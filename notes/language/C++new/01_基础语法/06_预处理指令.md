# 预处理指令

## 1. 核心概念

### 定义
- **预处理指令**：在编译前由预处理器处理的特殊指令
- **预处理器**：编译过程的第一阶段，处理以#开头的指令
- **宏定义**：文本替换机制，用于定义常量或简单函数
- **条件编译**：根据条件决定是否编译某段代码

### 关键特性
- **编译前处理**：在实际编译之前执行
- **文本替换**：宏展开是简单的文本替换
- **条件控制**：可以控制代码的编译与否
- **文件包含**：将其他文件内容插入当前文件

## 2. 语法规则

### 基本语法
```cpp
#include <文件名>      // 包含系统头文件
#include "文件名"      // 包含用户头文件

#define 宏名 替换文本  // 定义宏
#undef 宏名           // 取消宏定义

#ifdef 宏名           // 如果宏已定义
#ifndef 宏名          // 如果宏未定义
#if 条件表达式         // 条件编译
#elif 条件表达式       // 否则如果
#else                // 否则
#endif               // 结束条件编译

#pragma 指令         // 编译器特定指令
#error 错误消息       // 产生编译错误
```

### 代码示例
```cpp
#include <iostream>
using namespace std;

// 宏定义示例
#define PI 3.14159
#define MAX(a, b) ((a) > (b) ? (a) : (b))
#define SQUARE(x) ((x) * (x))

// 条件编译示例
#define DEBUG  // 定义DEBUG宏
#define VERSION 2

int main() {
    // 使用宏常量
    double radius = 5.0;
    double area = PI * SQUARE(radius);
    cout << "圆的面积: " << area << endl;
    
    // 使用带参数的宏
    int x = 10, y = 20;
    cout << "最大值: " << MAX(x, y) << endl;
    cout << "x的平方: " << SQUARE(x) << endl;
    
    // 条件编译的应用
#ifdef DEBUG
    cout << "调试模式: 正在计算..." << endl;
#endif
    
#if VERSION == 1
    cout << "版本1功能" << endl;
#elif VERSION == 2
    cout << "版本2功能" << endl;
#else
    cout << "未知版本" << endl;
#endif
    
    return 0;
}
```

### 注意事项
- 预处理指令不以分号结尾
- 宏定义是简单的文本替换
- 条件编译可以用于跨平台代码
- 使用括号避免宏展开的优先级问题

## 3. 常见用法

### 场景1：头文件保护
```cpp
// myheader.h 头文件内容
#ifndef MYHEADER_H     // 如果MYHEADER_H未定义
#define MYHEADER_H     // 定义MYHEADER_H

// 头文件内容
class MyClass {
public:
    void doSomething();
};

#endif // MYHEADER_H   // 结束条件编译
```

### 场景2：调试和日志
```cpp
#include <iostream>
using namespace std;

// 定义调试级别
#define DEBUG_LEVEL 2

// 条件调试输出
#if DEBUG_LEVEL >= 1
#define DEBUG_INFO(msg) cout << "[INFO] " << msg << endl
#else
#define DEBUG_INFO(msg)  // 空定义，不产生代码
#endif

#if DEBUG_LEVEL >= 2
#define DEBUG_DETAIL(msg) cout << "[DETAIL] " << msg << endl
#else
#define DEBUG_DETAIL(msg)
#endif

int main() {
    DEBUG_INFO("程序开始执行");
    
    int x = 10;
    DEBUG_DETAIL("x的值为: " << x);
    
    DEBUG_INFO("程序执行结束");
    return 0;
}
```

### 场景3：平台相关代码
```cpp
#include <iostream>
using namespace std;

// 检测操作系统（简化示例）
#ifdef _WIN32
    #define PLATFORM "Windows"
    #define PATH_SEPARATOR '\\'
#elif defined(__linux__)
    #define PLATFORM "Linux"
    #define PATH_SEPARATOR '/'
#elif defined(__APPLE__)
    #define PLATFORM "macOS"
    #define PATH_SEPARATOR '/'
#else
    #define PLATFORM "Unknown"
    #define PATH_SEPARATOR '/'
#endif

int main() {
    cout << "当前平台: " << PLATFORM << endl;
    cout << "路径分隔符: " << PATH_SEPARATOR << endl;
    
    // 平台特定代码
#ifdef _WIN32
    cout << "这是Windows特有功能" << endl;
#endif
    
    return 0;
}
```

## 4. 易错点/坑

### 错误示例1：宏参数未加括号
```cpp
#define SQUARE(x) x * x

int main() {
    int result = SQUARE(2 + 3);  // 期望25，实际得到11
    cout << result << endl;      // 输出11
    return 0;
}
```
**原因**：宏展开为 `2 + 3 * 2 + 3`，乘法优先级更高
**修正方案**：
```cpp
#define SQUARE(x) ((x) * (x))  // 为参数和整个表达式加括号

int main() {
    int result = SQUARE(2 + 3);  // 展开为 ((2 + 3) * (2 + 3))
    cout << result << endl;      // 输出25
    return 0;
}
```

### 错误示例2：宏副作用
```cpp
#define MAX(a, b) ((a) > (b) ? (a) : (b))

int main() {
    int x = 5, y = 10;
    int result = MAX(++x, y);  // 展开为 ((++x) > (y) ? (++x) : (y))
    cout << "结果: " << result << endl;  // 期望11，但可能得到12
    cout << "x的值: " << x << endl;      // x被增加了2次
    return 0;
}
```
**原因**：宏参数可能被多次求值
**修正方案**：
```cpp
// 使用内联函数代替宏
inline int max(int a, int b) {
    return (a > b) ? a : b;
}

int main() {
    int x = 5, y = 10;
    int result = max(++x, y);  // x只增加一次
    cout << "结果: " << result << endl;  // 输出11
    cout << "x的值: " << x << endl;      // 输出6
    return 0;
}
```

### 错误示例3：头文件重复包含
```cpp
// file1.cpp
#include "myheader.h"
#include "myheader.h"  // 重复包含

// 导致类重复定义错误
```
**原因**：同一个头文件被包含多次
**修正方案**：
```cpp
// myheader.h 中使用头文件保护
#ifndef MYHEADER_H
#define MYHEADER_H

class MyClass {
    // 类定义
};

#endif
```

## 5. 拓展补充

### 关联知识点
- **编译过程**：预处理→编译→汇编→链接
- **头文件**：声明和宏定义的集合
- **内联函数**：宏的替代方案
- **模板**：更强大的代码生成机制

### 进阶延伸
- **可变参数宏**：支持不定数量参数的宏
- **预定义宏**：编译器自动定义的宏（如__LINE__, __FILE__）
- **Pragma指令**：编译器特定的优化和控制
- **模块（C++20）**：现代的头文件替代方案