# 函数基础

## 1. 核心概念

### 定义
- **函数**：完成特定任务的独立代码块
- **参数**：函数接收的输入数据
- **返回值**：函数执行后返回的结果
- **函数原型**：函数声明，包括返回类型、函数名和参数列表

### 关键特性
- **代码复用**：同一函数可多次调用
- **模块化**：将复杂问题分解为小函数
- **信息隐藏**：函数内部实现对外部隐藏
- **作用域分离**：函数内部变量与外部隔离

## 2. 语法规则

### 基本语法
```cpp
返回类型 函数名(参数列表) {
    // 函数体
    语句;
    return 返回值;  // 如果返回类型不是void
}
```

### 代码示例
```cpp
#include <iostream>
using namespace std;

// 函数声明（函数原型）
int add(int a, int b);
void printMessage(string message);
double calculateAverage(double arr[], int size);

int main() {
    // 函数调用示例
    int result = add(5, 3);
    cout << "5 + 3 = " << result << endl;
    
    printMessage("Hello, Function!");
    
    double scores[] = {85.5, 90.0, 78.5, 92.0};
    double avg = calculateAverage(scores, 4);
    cout << "平均分: " << avg << endl;
    
    return 0;
}

// 函数定义：两个数相加
int add(int a, int b) {
    return a + b;
}

// 无返回值的函数
void printMessage(string message) {
    cout << "消息: " << message << endl;
}

// 处理数组的函数
double calculateAverage(double arr[], int size) {
    double sum = 0.0;
    for (int i = 0; i < size; i++) {
        sum += arr[i];
    }
    return sum / size;
}
```

### 注意事项
- 函数必须先声明或定义后才能调用
- 参数传递可以是值传递、引用传递或指针传递
- 函数可以有默认参数
- 函数可以重载（同名不同参数）

## 3. 常见用法

### 场景1：函数重载
```cpp
// 重载函数：同名但参数不同
int max(int a, int b) {
    return (a > b) ? a : b;
}

double max(double a, double b) {
    return (a > b) ? a : b;
}

int max(int a, int b, int c) {
    return max(max(a, b), c);
}

// 使用重载函数
cout << "max(3, 5): " << max(3, 5) << endl;           // 调用int版本
cout << "max(3.5, 2.8): " << max(3.5, 2.8) << endl;   // 调用double版本
cout << "max(1, 2, 3): " << max(1, 2, 3) << endl;     // 调用三参数版本
```

### 场景2：默认参数
```cpp
// 带有默认参数的函数
void printInfo(string name, int age = 18, string city = "北京") {
    cout << "姓名: " << name << endl;
    cout << "年龄: " << age << endl;
    cout << "城市: " << city << endl;
    cout << "---" << endl;
}

// 使用不同方式调用
printInfo("张三");                    // 使用所有默认参数
printInfo("李四", 25);               // 部分使用默认参数
printInfo("王五", 30, "上海");       // 不使用默认参数
```

### 场景3：递归函数
```cpp
// 计算阶乘的递归函数
int factorial(int n) {
    if (n <= 1) {
        return 1;  // 基本情况
    } else {
        return n * factorial(n - 1);  // 递归调用
    }
}

// 斐波那契数列递归实现
int fibonacci(int n) {
    if (n <= 0) return 0;
    if (n == 1) return 1;
    return fibonacci(n - 1) + fibonacci(n - 2);
}

// 使用递归函数
cout << "5的阶乘: " << factorial(5) << endl;
cout << "斐波那契数列第10项: " << fibonacci(10) << endl;
```

## 4. 易错点/坑

### 错误示例1：函数未声明
```cpp
int main() {
    int result = add(2, 3);  // 错误！add未声明
    return 0;
}

int add(int a, int b) {  // 定义在调用之后
    return a + b;
}
```
**原因**：C++需要先声明函数才能调用
**修正方案**：
```cpp
// 先声明函数
int add(int a, int b);

int main() {
    int result = add(2, 3);  // 正确
    return 0;
}

int add(int a, int b) {
    return a + b;
}
```

### 错误示例2：参数传递误解
```cpp
void swap(int a, int b) {  // 值传递
    int temp = a;
    a = b;
    b = temp;
}

int main() {
    int x = 5, y = 10;
    swap(x, y);
    cout << "x=" << x << ", y=" << y << endl;  // 仍然是5,10
    return 0;
}
```
**原因**：值传递只传递副本，不改变原变量
**修正方案**：
```cpp
// 使用引用传递
void swap(int &a, int &b) {  // 引用传递
    int temp = a;
    a = b;
    b = temp;
}

int main() {
    int x = 5, y = 10;
    swap(x, y);
    cout << "x=" << x << ", y=" << y << endl;  // 10,5
    return 0;
}
```

### 错误示例3：无限递归
```cpp
int badRecursion(int n) {
    return n + badRecursion(n - 1);  // 没有终止条件！
}
```
**原因**：递归函数缺少基本情况（终止条件）
**修正方案**：
```cpp
int goodRecursion(int n) {
    if (n <= 0) {  // 添加终止条件
        return 0;
    }
    return n + goodRecursion(n - 1);
}
```

## 5. 拓展补充

### 关联知识点
- **作用域**：局部变量、全局变量、静态变量
- **存储类别**：auto、register、static、extern
- **函数指针**：指向函数的指针变量
- **内联函数**：避免函数调用的开销

### 进阶延伸
- **函数模板**：泛型编程的基础
- **lambda表达式**：C++11引入的匿名函数
- **std::function**：通用的函数包装器
- **函数式编程**：C++中的函数式编程特性