# 常见错误与坑

## 1. 核心概念
- 定义：整理C++编程中常见的错误类型和容易踩的坑
- 关键特性：编译错误、运行时错误、逻辑错误、内存错误

## 2. 语法规则
- 基本语法：错误识别、调试技巧、预防措施
- 代码示例：

### 常见错误示例集合
```cpp
#include <iostream>
#include <vector>
#include <memory>
#include <cstring>

class CommonErrors {
public:
    // 错误1：未初始化变量
    static void uninitializedVariable() {
        int x;  // 未初始化
        std::cout << "x = " << x << std::endl;  // 未定义行为
        
        // 修正：总是初始化变量
        int y = 0;
        std::cout << "y = " << y << std::endl;
    }
    
    // 错误2：数组越界
    static void arrayOutOfBounds() {
        int arr[5] = {1, 2, 3, 4, 5};
        // std::cout << arr[5] << std::endl;  // 越界访问
        
        // 修正：使用边界检查或标准容器
        std::vector<int> vec = {1, 2, 3, 4, 5};
        if (vec.size() > 5) {
            std::cout << vec[5] << std::endl;
        } else {
            std::cout << "索引越界" << std::endl;
        }
    }
    
    // 错误3：内存泄漏
    static void memoryLeakExample() {
        int* ptr = new int[100];  // 分配内存
        // 使用ptr...
        // 忘记 delete[] ptr;  // 内存泄漏！
        
        // 修正：使用智能指针
        auto smartPtr = std::make_unique<int[]>(100);
        // 自动释放内存
    }
    
    // 错误4：悬空指针
    static void danglingPointer() {
        int* ptr = nullptr;
        {
            int x = 10;
            ptr = &x;  // ptr指向局部变量x
        }  // x的生命周期结束
        // std::cout << *ptr << std::endl;  // 悬空指针，未定义行为
        
        // 修正：确保指针有效性
        int y = 20;
        ptr = &y;  // ptr指向有效的变量
        std::cout << *ptr << std::endl;
    }
    
    // 错误5：除零错误
    static void divisionByZero() {
        int a = 10, b = 0;
        // int result = a / b;  // 除零错误
        
        // 修正：检查除数
        if (b != 0) {
            int result = a / b;
            std::cout << "结果: " << result << std::endl;
        } else {
            std::cout << "错误：除数不能为零" << std::endl;
        }
    }
    
    // 错误6：字符串操作错误
    static void stringErrors() {
        char str[10] = "hello";
        // strcpy(str, "这是一个很长的字符串");  // 缓冲区溢出
        
        // 修正：使用安全的字符串函数或std::string
        std::string safeStr = "hello";
        safeStr = "这是一个很长的字符串";  // 自动处理内存
        std::cout << safeStr << std::endl;
    }
    
    // 错误7：类型转换错误
    static void typeConversionErrors() {
        double d = 3.14;
        // int* p = (int*)&d;  // 危险的类型转换
        // std::cout << *p << std::endl;  // 未定义行为
        
        // 修正：使用安全的类型转换
        int i = static_cast<int>(d);  // 安全转换
        std::cout << i << std::endl;
    }
    
    // 错误8：忘记返回值
    static int forgetReturnValue() {
        int x = 10;
        // 忘记 return x;  // 编译警告，运行时未定义行为
        
        // 修正：确保所有路径都有返回值
        return x;
    }
};

// 错误9：循环中的错误
void loopErrors() {
    // 无限循环
    // while (true) {
    //     // 忘记退出条件
    // }
    
    // 修正：明确的退出条件
    int count = 0;
    while (count < 10) {
        std::cout << count++ << " ";
    }
    std::cout << std::endl;
}

// 错误10：多线程竞争条件
#include <thread>
#include <mutex>

class ThreadSafeCounter {
private:
    int count = 0;
    std::mutex mtx;
    
public:
    // 错误：非线程安全
    void unsafeIncrement() {
        count++;  // 竞争条件
    }
    
    // 修正：使用互斥锁
    void safeIncrement() {
        std::lock_guard<std::mutex> lock(mtx);
        count++;
    }
    
    int getCount() {
        std::lock_guard<std::mutex> lock(mtx);
        return count;
    }
};

int main() {
    std::cout << "=== 常见错误与修正示例 ===" << std::endl;
    
    CommonErrors::uninitializedVariable();
    CommonErrors::arrayOutOfBounds();
    CommonErrors::memoryLeakExample();
    CommonErrors::danglingPointer();
    CommonErrors::divisionByZero();
    CommonErrors::stringErrors();
    CommonErrors::typeConversionErrors();
    std::cout << "返回值: " << CommonErrors::forgetReturnValue() << std::endl;
    
    loopErrors();
    
    // 测试线程安全
    ThreadSafeCounter counter;
    std::thread t1([&counter]() {
        for (int i = 0; i < 1000; i++) {
            counter.safeIncrement();
        }
    });
    
    std::thread t2([&counter]() {
        for (int i = 0; i < 1000; i++) {
            counter.safeIncrement();
        }
    });
    
    t1.join();
    t2.join();
    
    std::cout << "最终计数: " << counter.getCount() << std::endl;
    
    return 0;
}
```
- 注意事项：错误识别、调试工具使用、预防性编程

## 3. 常见用法
- 场景1：使用编译器警告和静态分析
```bash
# 启用所有警告
g++ -Wall -Wextra -Wpedantic -o program main.cpp

# 将警告视为错误
g++ -Werror -o program main.cpp

# 使用Clang静态分析器
clang++ --analyze main.cpp

# 使用Cppcheck进行静态分析
cppcheck --enable=all main.cpp
```

- 场景2：运行时错误检测工具
```bash
# 使用Valgrind检测内存错误
valgrind --tool=memcheck ./program

# 检测内存泄漏
valgrind --leak-check=full ./program

# 检测未初始化内存
valgrind --track-origins=yes ./program

# 使用AddressSanitizer
g++ -fsanitize=address -g -o program main.cpp
./program
```

## 4. 易错点/坑
- 错误示例：
```cpp
// 错误：混淆=和==
if (x = 5) {  // 应该是 if (x == 5)
    // 总是执行，因为赋值表达式返回5（真）
}
```
- 原因：运算符优先级和类型混淆
- 修正方案：使用明确的比较，启用编译器警告

- 错误示例：
```cpp
// 错误：虚函数析构函数
class Base {
public:
    ~Base() { }  // 应该是 virtual ~Base() { }
};

class Derived : public Base {
    std::vector<int> data;
public:
    ~Derived() { }  // 可能不会调用
};

Base* ptr = new Derived();
delete ptr;  // 只调用Base的析构函数，内存泄漏
```
- 原因：多态基类缺少虚析构函数
- 修正方案：为多态基类声明虚析构函数

## 5. 拓展补充
- 关联知识点：异常处理、调试技巧、代码审查、测试驱动开发
- 进阶延伸：性能分析、安全编程、代码质量工具、持续集成