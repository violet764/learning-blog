# 模板（泛型编程）

## 1. 核心概念

### 定义
- **模板**：允许编写与数据类型无关的通用代码的C++特性
- **泛型编程**：编写可处理多种数据类型的通用算法和数据结构
- **模板实例化**：编译器根据具体类型生成特定版本的模板代码

### 关键特性
- **类型参数化**：将数据类型作为参数传递
- **编译时多态**：在编译时确定具体类型
- **代码复用**：同一模板可用于多种数据类型
- **性能优化**：避免运行时类型检查的开销

## 2. 语法规则

### 基本语法
```cpp
// 函数模板
template <typename T>
返回类型 函数名(参数列表);

// 类模板
template <typename T>
class 类名 {
    // 类定义
};
```

### 代码示例
```cpp
#include <iostream>
#include <string>
using namespace std;

// 函数模板：交换两个值
template <typename T>
void swapValues(T& a, T& b) {
    T temp = a;
    a = b;
    b = temp;
}

// 函数模板：查找最大值
template <typename T>
T findMax(const T arr[], int size) {
    T maxVal = arr[0];
    for (int i = 1; i < size; i++) {
        if (arr[i] > maxVal) {
            maxVal = arr[i];
        }
    }
    return maxVal;
}

// 类模板：简单的栈
template <typename T, int MAX_SIZE = 100>
class Stack {
private:
    T data[MAX_SIZE];
    int topIndex;
    
public:
    Stack() : topIndex(-1) {}
    
    // 入栈
    bool push(const T& value) {
        if (topIndex < MAX_SIZE - 1) {
            data[++topIndex] = value;
            return true;
        }
        return false;
    }
    
    // 出栈
    bool pop(T& value) {
        if (topIndex >= 0) {
            value = data[topIndex--];
            return true;
        }
        return false;
    }
    
    // 查看栈顶
    T top() const {
        if (topIndex >= 0) {
            return data[topIndex];
        }
        throw out_of_range("栈为空");
    }
    
    // 判断是否为空
    bool isEmpty() const {
        return topIndex == -1;
    }
    
    // 获取大小
    int size() const {
        return topIndex + 1;
    }
};

int main() {
    cout << "=== 函数模板演示 ===" << endl;
    
    // 使用模板函数交换整数
    int x = 10, y = 20;
    cout << "交换前: x=" << x << ", y=" << y << endl;
    swapValues(x, y);
    cout << "交换后: x=" << x << ", y=" << y << endl;
    
    // 使用模板函数交换字符串
    string s1 = "Hello", s2 = "World";
    cout << "交换前: s1=" << s1 << ", s2=" << s2 << endl;
    swapValues(s1, s2);
    cout << "交换后: s1=" << s1 << ", s2=" << s2 << endl;
    
    // 查找不同类型数组的最大值
    int intArr[] = {3, 7, 2, 9, 1};
    double doubleArr[] = {3.5, 7.2, 2.8, 9.1, 1.6};
    
    cout << "整数数组最大值: " << findMax(intArr, 5) << endl;
    cout << "浮点数数组最大值: " << findMax(doubleArr, 5) << endl;
    
    cout << "\\n=== 类模板演示 ===" << endl;
    
    // 使用整数栈
    Stack<int> intStack;
    intStack.push(10);
    intStack.push(20);
    intStack.push(30);
    
    cout << "整数栈大小: " << intStack.size() << endl;
    cout << "栈顶元素: " << intStack.top() << endl;
    
    // 使用字符串栈
    Stack<string> stringStack;
    stringStack.push("C++");
    stringStack.push("模板");
    stringStack.push("编程");
    
    cout << "字符串栈内容: ";
    while (!stringStack.isEmpty()) {
        string value;
        stringStack.pop(value);
        cout << value << " ";
    }
    cout << endl;
    
    // 使用自定义大小的栈
    Stack<double, 5> smallStack;
    for (int i = 0; i < 5; i++) {
        smallStack.push(i * 1.1);
    }
    cout << "小栈大小: " << smallStack.size() << endl;
    
    return 0;
}
```

### 注意事项
- 模板定义通常放在头文件中
- 模板参数可以是类型参数或非类型参数
- 模板在实例化时进行类型检查
- 可以使用多个模板参数

## 3. 常见用法

### 场景1：容器类模板
```cpp
// 简单的动态数组模板
template <typename T>
class DynamicArray {
private:
    T* data;
    int capacity;
    int size;
    
    void resize(int newCapacity) {
        T* newData = new T[newCapacity];
        for (int i = 0; i < size; i++) {
            newData[i] = data[i];
        }
        delete[] data;
        data = newData;
        capacity = newCapacity;
    }
    
public:
    DynamicArray() : data(nullptr), capacity(0), size(0) {}
    
    DynamicArray(int initialCapacity) : capacity(initialCapacity), size(0) {
        data = new T[capacity];
    }
    
    ~DynamicArray() {
        delete[] data;
    }
    
    // 禁止拷贝（简化实现）
    DynamicArray(const DynamicArray&) = delete;
    DynamicArray& operator=(const DynamicArray&) = delete;
    
    void pushBack(const T& value) {
        if (size >= capacity) {
            resize(capacity == 0 ? 1 : capacity * 2);
        }
        data[size++] = value;
    }
    
    T& operator[](int index) {
        if (index < 0 || index >= size) {
            throw out_of_range("索引越界");
        }
        return data[index];
    }
    
    const T& operator[](int index) const {
        if (index < 0 || index >= size) {
            throw out_of_range("索引越界");
        }
        return data[index];
    }
    
    int getSize() const { return size; }
    int getCapacity() const { return capacity; }
};
```

### 场景2：算法模板
```cpp
// 排序算法模板
template <typename T>
void bubbleSort(T arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
            }
        }
    }
}

// 查找算法模板
template <typename T>
int binarySearch(const T arr[], int n, const T& target) {
    int left = 0, right = n - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return -1;  // 未找到
}

// 对容器进行操作的模板函数
template <typename Container, typename Function>
void forEach(const Container& container, Function func) {
    for (const auto& element : container) {
        func(element);
    }
}
```

### 场景3：模板特化
```cpp
// 通用模板
template <typename T>
class TypeInfo {
public:
    static string getName() {
        return "未知类型";
    }
};

// 模板特化：整数类型
template <>
class TypeInfo<int> {
public:
    static string getName() {
        return "整数类型";
    }
};

// 模板特化：双精度浮点数
template <>
class TypeInfo<double> {
public:
    static string getName() {
        return "双精度浮点数";
    }
};

// 模板特化：字符串
template <>
class TypeInfo<string> {
public:
    static string getName() {
        return "字符串类型";
    }
};

// 使用示例
cout << TypeInfo<int>::getName() << endl;     // 输出：整数类型
cout << TypeInfo<double>::getName() << endl;  // 输出：双精度浮点数
cout << TypeInfo<string>::getName() << endl;  // 输出：字符串类型
```

## 4. 易错点/坑

### 错误示例1：模板定义在源文件中
```cpp
// mytemplate.h
template <typename T>
T add(T a, T b) {
    return a + b;
}

// main.cpp
#include "mytemplate.h"

int main() {
    int result = add(5, 3);  // 链接错误！
    return 0;
}
```
**原因**：模板定义必须对使用者可见，通常放在头文件中
**修正方案**：
```cpp
// 将模板定义放在头文件中
// mytemplate.h
template <typename T>
T add(T a, T b) {
    return a + b;
}
```

### 错误示例2：不支持的类型操作
```cpp
template <typename T>
T getAverage(const T arr[], int size) {
    T sum = T();  // 值初始化
    for (int i = 0; i < size; i++) {
        sum += arr[i];  // 要求T支持+=操作
    }
    return sum / size;  // 要求T支持/操作
}

class MyClass {
    // 没有定义+=和/运算符
};

int main() {
    MyClass arr[3];
    getAverage(arr, 3);  // 编译错误！
    return 0;
}
```
**原因**：模板要求类型支持特定操作
**修正方案**：
```cpp
// 使用概念约束（C++20）或静态断言
template <typename T>
T getAverage(const T arr[], int size) {
    static_assert(std::is_arithmetic_v<T>, "T必须是算术类型");
    T sum = T();
    for (int i = 0; i < size; i++) {
        sum += arr[i];
    }
    return sum / size;
}
```

### 错误示例3：模板参数推导失败
```cpp
template <typename T>
void process(T a, T b) {
    // 处理逻辑
}

int main() {
    process(5, 3.14);  // 错误：T无法推导（int vs double）
    return 0;
}
```
**原因**：编译器无法为T推导出唯一类型
**修正方案**：
```cpp
// 方案1：显式指定类型
process<double>(5, 3.14);

// 方案2：使用两个模板参数
template <typename T1, typename T2>
void process(T1 a, T2 b) {
    // 处理逻辑
}

// 方案3：使用通用引用（C++11）
template <typename T>
void process(T&& a, T&& b) {
    // 处理逻辑
}
```

## 5. 拓展补充

### 关联知识点
- **模板参数**：类型参数、非类型参数、模板模板参数
- **可变参数模板**：接受任意数量参数的模板
- **模板元编程**：在编译时进行计算的技术
- **SFINAE**：替换失败不是错误的原则

### 进阶延伸
- **概念（Concepts）**：C++20引入的模板约束机制
- **折叠表达式**：C++17简化可变参数模板的语法
- **CRTP**：奇特的递归模板模式
- **模板特化与偏特化**：为特定类型提供定制实现