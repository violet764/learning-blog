# 类与对象（封装）

## 1. 核心概念

### 定义
- **封装**：将数据和对数据的操作捆绑在一起，并隐藏实现细节
- **访问控制**：通过访问修饰符控制成员的可见性
- **数据隐藏**：保护数据不被外部直接访问和修改

### 关键特性
- **信息隐藏**：只暴露必要的接口，隐藏实现细节
- **数据保护**：防止意外修改数据，确保数据完整性
- **接口与实现分离**：使用者只关心接口，不关心实现
- **模块化设计**：提高代码的可维护性和可重用性

## 2. 语法规则

### 基本语法
```cpp
class 类名 {
private:    // 私有成员，只能在类内部访问
    数据类型 私有变量;
    
protected:  // 保护成员，类内部和派生类可以访问
    数据类型 保护变量;
    
public:     // 公有成员，任何地方都可以访问
    // 公有接口函数
    返回类型 函数名(参数列表);
};
```

### 代码示例
```cpp
#include <iostream>
#include <string>
using namespace std;

class BankAccount {
private:    // 私有数据成员，外部不能直接访问
    string accountNumber;
    string ownerName;
    double balance;
    
public:     // 公有接口，外部可以访问
    // 构造函数
    BankAccount(string accNum, string name, double initialBalance) {
        accountNumber = accNum;
        ownerName = name;
        if (initialBalance >= 0) {
            balance = initialBalance;
        } else {
            balance = 0;
        }
    }
    
    // 存款方法
    bool deposit(double amount) {
        if (amount > 0) {
            balance += amount;
            cout << "存款成功，当前余额: " << balance << endl;
            return true;
        }
        cout << "存款金额必须大于0" << endl;
        return false;
    }
    
    // 取款方法
    bool withdraw(double amount) {
        if (amount > 0 && amount <= balance) {
            balance -= amount;
            cout << "取款成功，当前余额: " << balance << endl;
            return true;
        }
        cout << "取款失败，余额不足或金额无效" << endl;
        return false;
    }
    
    // 获取余额（只读访问）
    double getBalance() const {
        return balance;
    }
    
    // 获取账户信息（只读）
    void displayInfo() const {
        cout << "账户号: " << accountNumber << endl;
        cout << "户主: " << ownerName << endl;
        cout << "余额: " << balance << endl;
    }
};

int main() {
    // 创建银行账户对象
    BankAccount myAccount("123456789", "张三", 1000.0);
    
    // 使用公有接口操作账户
    myAccount.displayInfo();
    myAccount.deposit(500.0);
    myAccount.withdraw(200.0);
    
    // 无法直接访问私有成员
    // myAccount.balance = 10000;  // 错误：私有成员不能访问
    
    cout << "当前余额: " << myAccount.getBalance() << endl;
    
    return 0;
}
```

### 注意事项
- 私有成员只能通过公有成员函数访问
- const成员函数不能修改对象状态
- 良好的封装应该提供完整的接口
- 构造函数用于对象初始化

## 3. 常见用法

### 场景1：完整的日期类封装
```cpp
class Date {
private:
    int year, month, day;
    
    // 私有辅助函数，检查日期有效性
    bool isValidDate(int y, int m, int d) {
        if (y < 1900 || y > 2100) return false;
        if (m < 1 || m > 12) return false;
        
        int daysInMonth;
        if (m == 2) {
            // 闰年判断
            bool isLeap = (y % 4 == 0 && y % 100 != 0) || (y % 400 == 0);
            daysInMonth = isLeap ? 29 : 28;
        } else if (m == 4 || m == 6 || m == 9 || m == 11) {
            daysInMonth = 30;
        } else {
            daysInMonth = 31;
        }
        
        return d >= 1 && d <= daysInMonth;
    }
    
public:
    // 构造函数
    Date(int y, int m, int d) {
        if (isValidDate(y, m, d)) {
            year = y;
            month = m;
            day = d;
        } else {
            year = 2000;
            month = 1;
            day = 1;  // 默认日期
        }
    }
    
    // 设置日期
    bool setDate(int y, int m, int d) {
        if (isValidDate(y, m, d)) {
            year = y;
            month = m;
            day = d;
            return true;
        }
        return false;
    }
    
    // 获取日期信息
    void getDate(int &y, int &m, int &d) const {
        y = year;
        m = month;
        d = day;
    }
    
    // 显示日期
    void display() const {
        cout << year << "年" << month << "月" << day << "日" << endl;
    }
    
    // 计算明天日期
    Date tomorrow() const {
        Date nextDay = *this;  // 复制当前对象
        nextDay.day++;
        
        // 处理月份和年份的进位
        if (!isValidDate(nextDay.year, nextDay.month, nextDay.day)) {
            nextDay.day = 1;
            nextDay.month++;
            if (nextDay.month > 12) {
                nextDay.month = 1;
                nextDay.year++;
            }
        }
        
        return nextDay;
    }
};
```

### 场景2：购物车系统封装
```cpp
class ShoppingCart {
private:
    static const int MAX_ITEMS = 100;
    string items[MAX_ITEMS];
    double prices[MAX_ITEMS];
    int quantities[MAX_ITEMS];
    int itemCount;
    
public:
    ShoppingCart() : itemCount(0) {}
    
    // 添加商品
    bool addItem(const string &itemName, double price, int quantity = 1) {
        if (itemCount >= MAX_ITEMS || price < 0 || quantity <= 0) {
            return false;
        }
        
        items[itemCount] = itemName;
        prices[itemCount] = price;
        quantities[itemCount] = quantity;
        itemCount++;
        return true;
    }
    
    // 移除商品
    bool removeItem(const string &itemName) {
        for (int i = 0; i < itemCount; i++) {
            if (items[i] == itemName) {
                // 将后面的元素前移
                for (int j = i; j < itemCount - 1; j++) {
                    items[j] = items[j + 1];
                    prices[j] = prices[j + 1];
                    quantities[j] = quantities[j + 1];
                }
                itemCount--;
                return true;
            }
        }
        return false;
    }
    
    // 计算总价
    double getTotalPrice() const {
        double total = 0.0;
        for (int i = 0; i < itemCount; i++) {
            total += prices[i] * quantities[i];
        }
        return total;
    }
    
    // 显示购物车内容
    void displayCart() const {
        cout << "购物车内容:" << endl;
        for (int i = 0; i < itemCount; i++) {
            cout << items[i] << " x" << quantities[i] 
                 << " - ￥" << prices[i] * quantities[i] << endl;
        }
        cout << "总计: ￥" << getTotalPrice() << endl;
    }
    
    // 清空购物车
    void clearCart() {
        itemCount = 0;
    }
};
```

## 4. 易错点/坑

### 错误示例1：违反封装原则
```cpp
class BadAccount {
public:  // 所有成员都是公有的
    double balance;
    
    void withdraw(double amount) {
        balance -= amount;  // 外部可以直接修改balance，导致数据不一致
    }
};

int main() {
    BadAccount acc;
    acc.balance = 1000;
    acc.balance = -500;  // 可以直接设置为负值，违反业务规则
    return 0;
}
```
**原因**：数据成员公有，外部可以直接修改，破坏了数据完整性
**修正方案**：
```cpp
class GoodAccount {
private:
    double balance;
    
public:
    void withdraw(double amount) {
        if (amount > 0 && amount <= balance) {
            balance -= amount;  // 通过方法控制修改
        }
    }
    
    double getBalance() const {
        return balance;  // 只提供只读访问
    }
};
```

### 错误示例2：不完整的接口
```cpp
class IncompleteAccount {
private:
    double balance;
    
public:
    // 只有存款方法，没有取款方法
    void deposit(double amount) {
        balance += amount;
    }
    
    // 缺少获取余额的方法
};

int main() {
    IncompleteAccount acc;
    acc.deposit(1000);
    // 无法获取余额，也无法取款
    return 0;
}
```
**原因**：接口不完整，无法完成基本操作
**修正方案**：
```cpp
class CompleteAccount {
private:
    double balance;
    
public:
    void deposit(double amount) {
        if (amount > 0) balance += amount;
    }
    
    bool withdraw(double amount) {
        if (amount > 0 && amount <= balance) {
            balance -= amount;
            return true;
        }
        return false;
    }
    
    double getBalance() const {
        return balance;
    }
};
```

### 错误示例3：const成员函数修改数据
```cpp
class ConstError {
private:
    int value;
    
public:
    int getValue() const {
        value = 10;  // 错误：const函数不能修改成员
        return value;
    }
};
```
**原因**：const成员函数承诺不修改对象状态
**修正方案**：
```cpp
class ConstCorrect {
private:
    int value;
    
public:
    int getValue() const {
        return value;  // 正确：只读访问
    }
    
    void setValue(int v) {
        value = v;     // 非const函数可以修改
    }
};
```

## 5. 拓展补充

### 关联知识点
- **this指针**：指向当前对象的指针
- **友元函数**：可以访问私有成员的非成员函数
- **静态成员**：属于类而不是对象的成员
- **const对象**：只能调用const成员函数的对象

### 进阶延伸
- **设计模式**：单例模式、工厂模式等封装技巧
- **RAII模式**：资源管理的封装技术
- **PIMPL模式**：实现接口与实现的完全分离
- **移动语义**：C++11引入的高效对象传递