# 智能指针（C++11+）

## 1. 核心概念

### 定义
- **智能指针**：C++11引入的自动管理动态内存的模板类
- **RAII模式**：资源获取即初始化，利用对象生命周期管理资源
- **所有权语义**：明确指针的所有权关系，防止内存泄漏

### 关键特性
- **自动内存管理**：对象销毁时自动释放内存
- **所有权转移**：明确指针所有权的转移语义
- **异常安全**：异常发生时确保资源正确释放
- **避免悬空指针**：防止访问已释放的内存

## 2. 语法规则

### 基本语法
```cpp
#include <memory>

// unique_ptr：独占所有权
std::unique_ptr<类型> ptr = std::make_unique<类型>(参数);

// shared_ptr：共享所有权  
std::shared_ptr<类型> ptr = std::make_shared<类型>(参数);

// weak_ptr：弱引用，不增加引用计数
std::weak_ptr<类型> weakPtr = sharedPtr;
```

### 代码示例
```cpp
#include <iostream>
#include <memory>
#include <vector>
using namespace std;

class MyClass {
private:
    string name;
    
public:
    MyClass(const string& n) : name(n) {
        cout << "MyClass构造: " << name << endl;
    }
    
    ~MyClass() {
        cout << "MyClass析构: " << name << endl;
    }
    
    void doSomething() {
        cout << "MyClass操作: " << name << endl;
    }
    
    string getName() const { return name; }
};

// 演示unique_ptr的独占所有权
void uniquePtrDemo() {
    cout << "=== unique_ptr演示 ===" << endl;
    
    // 创建unique_ptr
    unique_ptr<MyClass> ptr1 = make_unique<MyClass>("对象1");
    ptr1->doSomething();
    
    // 转移所有权
    unique_ptr<MyClass> ptr2 = move(ptr1);  // ptr1变为nullptr
    if (ptr1 == nullptr) {
        cout << "ptr1所有权已转移" << endl;
    }
    
    ptr2->doSomething();
    
    // 自动释放：当ptr2离开作用域时，对象自动销毁
}

// 演示shared_ptr的共享所有权
void sharedPtrDemo() {
    cout << "\\n=== shared_ptr演示 ===" << endl;
    
    // 创建shared_ptr
    shared_ptr<MyClass> ptr1 = make_shared<MyClass>("共享对象");
    cout << "引用计数: " << ptr1.use_count() << endl;  // 1
    
    {
        // 共享所有权
        shared_ptr<MyClass> ptr2 = ptr1;
        cout << "引用计数: " << ptr1.use_count() << endl;  // 2
        
        ptr2->doSomething();
        
        // ptr2离开作用域，引用计数减1
    }
    
    cout << "引用计数: " << ptr1.use_count() << endl;  // 1
    ptr1->doSomething();
    
    // 当ptr1离开作用域，引用计数为0时，对象自动销毁
}

// 演示weak_ptr解决循环引用
void weakPtrDemo() {
    cout << "\\n=== weak_ptr演示 ===" << endl;
    
    struct Node {
        string name;
        shared_ptr<Node> next;
        weak_ptr<Node> prev;  // 使用weak_ptr避免循环引用
        
        Node(const string& n) : name(n) {
            cout << "Node构造: " << name << endl;
        }
        
        ~Node() {
            cout << "Node析构: " << name << endl;
        }
    };
    
    // 创建双向链表节点
    shared_ptr<Node> node1 = make_shared<Node>("节点1");
    shared_ptr<Node> node2 = make_shared<Node>("节点2");
    
    // 建立连接
    node1->next = node2;
    node2->prev = node1;  // weak_ptr不增加引用计数
    
    cout << "node1引用计数: " << node1.use_count() << endl;  // 1
    cout << "node2引用计数: " << node2.use_count() << endl;  // 2（node1->next持有）
    
    // 检查weak_ptr是否有效
    if (auto sharedPrev = node2->prev.lock()) {
        cout << "通过weak_ptr访问: " << sharedPrev->name << endl;
    }
    
    // 节点自动释放，不会出现循环引用导致的内存泄漏
}

// 智能指针与STL容器
void smartPtrWithContainers() {
    cout << "\\n=== 智能指针与容器 ===" << endl;
    
    // vector存储unique_ptr（需要移动语义）
    vector<unique_ptr<MyClass>> objects;
    
    objects.push_back(make_unique<MyClass>("容器对象1"));
    objects.push_back(make_unique<MyClass>("容器对象2"));
    objects.emplace_back(new MyClass("容器对象3"));
    
    cout << "容器中有 " << objects.size() << " 个对象" << endl;
    
    // 遍历和访问
    for (const auto& obj : objects) {
        obj->doSomething();
    }
    
    // 容器析构时，所有unique_ptr会自动释放管理的对象
}

int main() {
    uniquePtrDemo();
    sharedPtrDemo();
    weakPtrDemo();
    smartPtrWithContainers();
    
    cout << "\\n=== 程序结束，所有资源自动释放 ===" << endl;
    return 0;
}
```

### 注意事项
- 优先使用`make_unique`和`make_shared`创建智能指针
- `unique_ptr`不支持拷贝，只能移动
- `shared_ptr`有引用计数开销
- `weak_ptr`需要先调用`lock()`转换为`shared_ptr`才能使用

## 3. 常见用法

### 场景1：工厂模式与智能指针
```cpp
#include <memory>
#include <iostream>

// 抽象产品类
class Product {
public:
    virtual ~Product() = default;
    virtual void use() = 0;
};

// 具体产品类
class ConcreteProductA : public Product {
public:
    void use() override {
        std::cout << "使用产品A" << std::endl;
    }
};

class ConcreteProductB : public Product {
public:
    void use() override {
        std::cout << "使用产品B" << std::endl;
    }
};

// 工厂类
class ProductFactory {
public:
    enum ProductType { TYPE_A, TYPE_B };
    
    static std::unique_ptr<Product> createProduct(ProductType type) {
        switch (type) {
            case TYPE_A:
                return std::make_unique<ConcreteProductA>();
            case TYPE_B:
                return std::make_unique<ConcreteProductB>();
            default:
                return nullptr;
        }
    }
};

// 使用工厂
void factoryDemo() {
    auto productA = ProductFactory::createProduct(ProductFactory::TYPE_A);
    auto productB = ProductFactory::createProduct(ProductFactory::TYPE_B);
    
    if (productA) productA->use();
    if (productB) productB->use();
    
    // 智能指针自动管理生命周期
}
```

### 场景2：资源管理类
```cpp
#include <memory>
#include <fstream>
#include <vector>

// 使用unique_ptr管理文件资源
class FileManager {
private:
    std::unique_ptr<std::fstream> file;
    
public:
    bool open(const std::string& filename) {
        file = std::make_unique<std::fstream>(filename, std::ios::in | std::ios::out);
        return file->is_open();
    }
    
    void write(const std::string& data) {
        if (file && file->is_open()) {
            *file << data << std::endl;
        }
    }
    
    // 不需要显式关闭文件，unique_ptr析构时会自动关闭
};

// 使用shared_ptr管理共享资源
class ResourcePool {
private:
    std::vector<std::shared_ptr<int>> resources;
    
public:
    std::shared_ptr<int> acquire() {
        auto resource = std::make_shared<int>(42);
        resources.push_back(resource);
        return resource;
    }
    
    void release(const std::shared_ptr<int>& resource) {
        // 从池中移除（简化实现）
        resources.erase(
            std::remove(resources.begin(), resources.end(), resource),
            resources.end()
        );
    }
    
    // 当ResourcePool销毁时，所有shared_ptr会自动释放
};
```

### 场景3：自定义删除器
```cpp
#include <memory>
#include <iostream>

// C风格资源
struct CFile {
    FILE* handle;
    
    CFile(const char* filename, const char* mode) {
        handle = fopen(filename, mode);
    }
    
    ~CFile() {
        if (handle) fclose(handle);
    }
};

// 自定义删除器
struct FileDeleter {
    void operator()(FILE* file) const {
        if (file) {
            fclose(file);
            std::cout << "文件已关闭（自定义删除器）" << std::endl;
        }
    }
};

// 数组删除器
struct ArrayDeleter {
    void operator()(int* arr) const {
        delete[] arr;
        std::cout << "数组已释放" << std::endl;
    }
};

void customDeleterDemo() {
    // 使用自定义删除器管理C风格文件
    std::unique_ptr<FILE, FileDeleter> file(fopen("test.txt", "w"));
    if (file) {
        fprintf(file.get(), "Hello, World!");
    }
    
    // 使用自定义删除器管理动态数组
    std::unique_ptr<int[], ArrayDeleter> arr(new int[10]);
    for (int i = 0; i < 10; i++) {
        arr[i] = i * i;
    }
    
    // 使用lambda表达式作为删除器
    auto lambdaDeleter = [](int* p) {
        delete p;
        std::cout << "Lambda删除器调用" << std::endl;
    };
    
    std::unique_ptr<int, decltype(lambdaDeleter)> ptr(new int(100), lambdaDeleter);
}
```

## 4. 易错点/坑

### 错误示例1：错误的所有权共享
```cpp
class BadDesign {
private:
    std::shared_ptr<BadDesign> self;  // 循环引用！
    
public:
    void setSelf() {
        self = std::shared_ptr<BadDesign>(this);  // 严重错误！
    }
    
    ~BadDesign() {
        std::cout << "BadDesign析构" << std::endl;
    }
};

void problematicUsage() {
    BadDesign* rawPtr = new BadDesign();
    rawPtr->setSelf();  // 创建多个控制块！
    
    // 内存泄漏：对象永远不会被释放
    // 因为self和外部指针创建了不同的控制块
}
```
**原因**：同一个对象被多个独立的shared_ptr管理
**修正方案**：
```cpp
class GoodDesign {
private:
    std::shared_ptr<GoodDesign> self;
    
public:
    static std::shared_ptr<GoodDesign> create() {
        // 使用工厂方法确保正确的shared_ptr管理
        auto ptr = std::shared_ptr<GoodDesign>(new GoodDesign());
        ptr->self = ptr;  // 正确的自引用
        return ptr;
    }
    
    ~GoodDesign() {
        std::cout << "GoodDesign正常析构" << std::endl;
    }
};
```

### 错误示例2：错误的unique_ptr使用
```cpp
void problematicUniquePtr() {
    std::unique_ptr<int> ptr1(new int(42));
    
    // std::unique_ptr<int> ptr2 = ptr1;  // 错误：不能拷贝
    
    // 正确的方式：转移所有权
    std::unique_ptr<int> ptr2 = std::move(ptr1);
    
    if (ptr1 == nullptr) {
        std::cout << "ptr1已失效" << std::endl;
    }
    
    // 访问已转移的指针
    // *ptr1 = 100;  // 未定义行为！
}
```
**原因**：unique_ptr不支持拷贝，只能移动
**修正方案**：
```cpp
void correctUniquePtrUsage() {
    auto ptr1 = std::make_unique<int>(42);
    
    // 转移所有权
    auto ptr2 = std::move(ptr1);
    
    // 检查指针有效性
    if (!ptr1) {
        std::cout << "ptr1已转移，使用ptr2" << std::endl;
        *ptr2 = 100;  // 安全访问
    }
}
```

### 错误示例3：悬空weak_ptr
```cpp
void danglingWeakPtr() {
    std::weak_ptr<int> weak;
    
    {
        auto shared = std::make_shared<int>(42);
        weak = shared;
        
        // shared离开作用域，对象被销毁
    }
    
    // weak指向的对象已销毁
    if (auto shared = weak.lock()) {
        // 这行代码不会执行
        *shared = 100;
    } else {
        std::cout << "weak_ptr已失效" << std::endl;
    }
}
```
**原因**：weak_ptr不保证对象的生命周期
**修正方案**：
```cpp
void safeWeakPtrUsage() {
    std::weak_ptr<int> weak;
    
    {
        auto shared = std::make_shared<int>(42);
        weak = shared;
        
        // 在使用前检查
        if (auto temp = weak.lock()) {
            *temp = 100;  // 安全使用
        }
    }
    
    // 对象已销毁，但这是预期的
    if (!weak.lock()) {
        std::cout << "对象已销毁，weak_ptr正确失效" << std::endl;
    }
}
```

## 5. 拓展补充

### 关联知识点
- **RAII模式**：资源管理的基本理念
- **移动语义**：unique_ptr所有权转移的基础
- **引用计数**：shared_ptr的实现机制
- **控制块**：shared_ptr管理的内存块

### 进阶延伸
- **enable_shared_from_this**：从this指针创建shared_ptr
- **allocate_shared**：自定义内存分配的shared_ptr
- **polymorphic_allocator**：C++17的多态分配器
- **out_ptr**：C++23的智能指针与C API互操作