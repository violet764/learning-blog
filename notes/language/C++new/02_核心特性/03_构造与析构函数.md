# 构造与析构函数

## 1. 核心概念

### 定义
- **构造函数**：在创建对象时自动调用的特殊成员函数，用于初始化对象
- **析构函数**：在对象销毁时自动调用的特殊成员函数，用于清理资源
- **对象生命周期**：从构造函数调用开始到析构函数调用结束

### 关键特性
- **自动调用**：构造函数和析构函数由编译器自动调用
- **同名规则**：构造函数与类同名，析构函数名前加~
- **无返回值**：构造函数和析构函数都没有返回类型
- **资源管理**：用于管理动态内存、文件句柄等资源

## 2. 语法规则

### 基本语法
```cpp
class 类名 {
public:
    // 构造函数
    类名(参数列表);
    
    // 析构函数
    ~类名();
};

// 构造函数定义
类名::类名(参数列表) {
    // 初始化代码
}

// 析构函数定义
类名::~类名() {
    // 清理代码
}
```

### 代码示例
```cpp
#include <iostream>
#include <cstring>
using namespace std;

class Student {
private:
    char* name;
    int age;
    double gpa;
    
public:
    // 默认构造函数
    Student() {
        name = new char[10];
        strcpy(name, "未知");
        age = 0;
        gpa = 0.0;
        cout << "默认构造函数被调用" << endl;
    }
    
    // 带参数的构造函数
    Student(const char* n, int a, double g) {
        name = new char[strlen(n) + 1];
        strcpy(name, n);
        age = a;
        gpa = g;
        cout << "带参构造函数被调用" << endl;
    }
    
    // 拷贝构造函数
    Student(const Student& other) {
        name = new char[strlen(other.name) + 1];
        strcpy(name, other.name);
        age = other.age;
        gpa = other.gpa;
        cout << "拷贝构造函数被调用" << endl;
    }
    
    // 析构函数
    ~Student() {
        delete[] name;
        cout << "析构函数被调用，释放资源" << endl;
    }
    
    // 显示信息
    void display() const {
        cout << "姓名: " << name << ", 年龄: " << age 
             << ", GPA: " << gpa << endl;
    }
    
    // 设置信息
    void setInfo(const char* n, int a, double g) {
        delete[] name;  // 释放原有内存
        name = new char[strlen(n) + 1];
        strcpy(name, n);
        age = a;
        gpa = g;
    }
};

int main() {
    cout << "=== 创建对象测试 ===" << endl;
    
    // 调用默认构造函数
    Student s1;
    s1.display();
    
    // 调用带参构造函数
    Student s2("张三", 20, 3.8);
    s2.display();
    
    // 调用拷贝构造函数
    Student s3 = s2;
    s3.display();
    
    cout << "=== 程序结束，对象将自动销毁 ===" << endl;
    return 0;
}
```

### 注意事项
- 构造函数可以有多个重载版本
- 析构函数只能有一个，且不能带参数
- 如果类中有动态分配的内存，必须自定义析构函数
- 拷贝构造函数在对象复制时自动调用

## 3. 常见用法

### 场景1：初始化列表语法
```cpp
class Point {
private:
    int x, y;
    const int id;  // 常量成员
    
public:
    // 使用初始化列表
    Point(int xVal, int yVal, int idVal) : x(xVal), y(yVal), id(idVal) {
        cout << "Point对象创建，ID: " << id << endl;
    }
    
    // 默认参数构造函数
    Point(int xVal = 0, int yVal = 0) : x(xVal), y(yVal), id(0) {}
    
    void display() const {
        cout << "Point(" << x << ", " << y << "), ID: " << id << endl;
    }
};
```

### 场景2：资源管理类（RAII）
```cpp
#include <fstream>
#include <string>

class FileHandler {
private:
    std::fstream file;
    std::string filename;
    
public:
    // 构造函数打开文件
    FileHandler(const std::string& fname) : filename(fname) {
        file.open(fname, std::ios::in | std::ios::out);
        if (!file.is_open()) {
            throw std::runtime_error("无法打开文件: " + fname);
        }
        cout << "文件 " << fname << " 已打开" << endl;
    }
    
    // 析构函数关闭文件
    ~FileHandler() {
        if (file.is_open()) {
            file.close();
            cout << "文件 " << filename << " 已关闭" << endl;
        }
    }
    
    // 写入数据
    void write(const std::string& data) {
        if (file.is_open()) {
            file << data << std::endl;
        }
    }
    
    // 读取一行
    std::string readLine() {
        std::string line;
        if (file.is_open() && std::getline(file, line)) {
            return line;
        }
        return "";
    }
    
    // 禁止拷贝（防止资源重复释放）
    FileHandler(const FileHandler&) = delete;
    FileHandler& operator=(const FileHandler&) = delete;
};
```

### 场景3：对象数组管理
```cpp
class StudentManager {
private:
    Student** students;  // 指针数组
    int capacity;
    int count;
    
public:
    // 构造函数分配内存
    StudentManager(int maxStudents) : capacity(maxStudents), count(0) {
        students = new Student*[capacity];
        cout << "StudentManager创建，容量: " << capacity << endl;
    }
    
    // 析构函数释放内存
    ~StudentManager() {
        for (int i = 0; i < count; i++) {
            delete students[i];  // 删除每个Student对象
        }
        delete[] students;       // 删除指针数组
        cout << "StudentManager销毁，释放所有资源" << endl;
    }
    
    // 添加学生
    bool addStudent(const char* name, int age, double gpa) {
        if (count < capacity) {
            students[count] = new Student(name, age, gpa);
            count++;
            return true;
        }
        return false;
    }
    
    // 显示所有学生
    void displayAll() const {
        for (int i = 0; i < count; i++) {
            cout << "学生" << i + 1 << ": ";
            students[i]->display();
        }
    }
};
```

## 4. 易错点/坑

### 错误示例1：浅拷贝问题
```cpp
class BadString {
private:
    char* data;
    
public:
    BadString(const char* str) {
        data = new char[strlen(str) + 1];
        strcpy(data, str);
    }
    
    ~BadString() {
        delete[] data;  // 问题：多个对象共享同一内存
    }
    
    // 缺少拷贝构造函数，使用默认的浅拷贝
};

int main() {
    BadString s1("Hello");
    BadString s2 = s1;  // 浅拷贝，两个对象指向同一内存
    
    // 程序结束时，同一内存被释放两次，导致未定义行为
    return 0;
}
```
**原因**：默认拷贝构造函数进行浅拷贝，多个对象共享动态内存
**修正方案**：
```cpp
class GoodString {
private:
    char* data;
    
public:
    GoodString(const char* str) {
        data = new char[strlen(str) + 1];
        strcpy(data, str);
    }
    
    // 自定义拷贝构造函数（深拷贝）
    GoodString(const GoodString& other) {
        data = new char[strlen(other.data) + 1];
        strcpy(data, other.data);
    }
    
    ~GoodString() {
        delete[] data;
    }
};
```

### 错误示例2：忘记释放资源
```cpp
class MemoryLeak {
private:
    int* array;
    
public:
    MemoryLeak(int size) {
        array = new int[size];  // 分配内存
    }
    
    // 缺少析构函数！内存泄漏
};

int main() {
    MemoryLeak obj(100);  // 分配的内存永远不会释放
    return 0;
}
```
**原因**：动态分配的内存没有在析构函数中释放
**修正方案**：
```cpp
class NoMemoryLeak {
private:
    int* array;
    
public:
    NoMemoryLeak(int size) {
        array = new int[size];
    }
    
    ~NoMemoryLeak() {
        delete[] array;  // 释放内存
    }
};
```

### 错误示例3：构造函数中的异常
```cpp
class DangerousConstructor {
private:
    int* resource1;
    int* resource2;
    
public:
    DangerousConstructor() {
        resource1 = new int[100];  // 分配第一个资源
        
        // 可能抛出异常的操作
        if (someCondition) {
            throw std::runtime_error("构造失败");
        }
        
        resource2 = new int[200];  // 分配第二个资源
    }
    
    ~DangerousConstructor() {
        delete[] resource1;
        delete[] resource2;
    }
};
```
**原因**：构造函数中抛出异常时，已分配的资源无法释放
**修正方案**：
```cpp
class SafeConstructor {
private:
    std::unique_ptr<int[]> resource1;  // 使用智能指针
    std::unique_ptr<int[]> resource2;
    
public:
    SafeConstructor() {
        resource1 = std::make_unique<int[]>(100);
        
        // 可能抛出异常的操作
        if (someCondition) {
            throw std::runtime_error("构造失败");
        }
        
        resource2 = std::make_unique<int[]>(200);
    }
    
    // 不需要自定义析构函数，智能指针自动管理
};
```

## 5. 拓展补充

### 关联知识点
- **初始化列表**：在构造函数体执行前初始化成员
- **委托构造函数**：一个构造函数调用另一个构造函数
- **移动构造函数**：C++11引入的高效对象转移
- **explicit关键字**：防止隐式构造函数调用

### 进阶延伸
- **RAII模式**：资源获取即初始化的编程习惯
- **Rule of Three/Five**：需要自定义拷贝控制函数的情况
- **placement new**：在指定内存位置构造对象
- **对象池模式**：复用对象以提高性能