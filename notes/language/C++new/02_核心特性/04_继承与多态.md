# 继承与多态

## 1. 核心概念

### 定义
- **继承**：允许一个类（派生类）基于另一个类（基类）创建，获得基类的属性和方法
- **多态**：同一接口在不同情况下表现出不同行为的能力
- **虚函数**：在基类中声明为virtual的函数，可以在派生类中重写

### 关键特性
- **代码复用**：通过继承重用基类代码
- **层次结构**：建立类之间的"is-a"关系
- **动态绑定**：运行时根据对象实际类型调用相应函数
- **接口抽象**：通过基类指针操作不同派生类对象

## 2. 语法规则

### 基本语法
```cpp
// 基类定义
class 基类名 {
访问修饰符:
    virtual 返回类型 函数名(参数);  // 虚函数
};

// 派生类定义
class 派生类名 : 访问修饰符 基类名 {
访问修饰符:
    返回类型 函数名(参数) override;  // 重写虚函数
};
```

### 代码示例
```cpp
#include <iostream>
#include <string>
using namespace std;

// 基类：形状
class Shape {
protected:
    string name;
    
public:
    Shape(const string& n) : name(n) {}
    
    // 虚函数：计算面积
    virtual double area() const {
        cout << "Shape area() called" << endl;
        return 0.0;
    }
    
    // 虚函数：显示信息
    virtual void display() const {
        cout << "形状: " << name << endl;
    }
    
    // 虚析构函数（重要！）
    virtual ~Shape() {
        cout << "Shape析构函数: " << name << endl;
    }
};

// 派生类：圆形
class Circle : public Shape {
private:
    double radius;
    
public:
    Circle(double r) : Shape("圆形"), radius(r) {}
    
    // 重写虚函数
    double area() const override {
        return 3.14159 * radius * radius;
    }
    
    void display() const override {
        Shape::display();  // 调用基类方法
        cout << "半径: " << radius << ", 面积: " << area() << endl;
    }
};

// 派生类：矩形
class Rectangle : public Shape {
private:
    double width, height;
    
public:
    Rectangle(double w, double h) : Shape("矩形"), width(w), height(h) {}
    
    // 重写虚函数
    double area() const override {
        return width * height;
    }
    
    void display() const override {
        Shape::display();
        cout << "宽度: " << width << ", 高度: " << height 
             << ", 面积: " << area() << endl;
    }
};

int main() {
    cout << "=== 继承与多态演示 ===" << endl;
    
    // 创建不同形状对象
    Circle circle(5.0);
    Rectangle rectangle(4.0, 6.0);
    
    // 直接调用
    cout << "\\n直接调用:" << endl;
    circle.display();
    rectangle.display();
    
    // 多态调用：通过基类指针
    cout << "\\n多态调用（基类指针）:" << endl;
    Shape* shapes[2];
    shapes[0] = &circle;
    shapes[1] = &rectangle;
    
    for (int i = 0; i < 2; i++) {
        shapes[i]->display();  // 动态绑定，调用实际对象的函数
        cout << "面积: " << shapes[i]->area() << endl;
        cout << "---" << endl;
    }
    
    // 多态调用：通过基类引用
    cout << "\\n多态调用（基类引用）:" << endl;
    Shape& shapeRef1 = circle;
    Shape& shapeRef2 = rectangle;
    
    shapeRef1.display();
    shapeRef2.display();
    
    cout << "=== 程序结束 ===" << endl;
    return 0;
}
```

### 注意事项
- 虚函数使用`virtual`关键字声明
- 重写虚函数时建议使用`override`关键字
- 包含虚函数的类应该有虚析构函数
- 纯虚函数使类成为抽象类，不能实例化

## 3. 常见用法

### 场景1：抽象基类和纯虚函数
```cpp
// 抽象基类：动物
class Animal {
protected:
    string name;
    
public:
    Animal(const string& n) : name(n) {}
    
    // 纯虚函数：使类成为抽象类
    virtual void speak() const = 0;
    
    // 纯虚函数：移动方式
    virtual void move() const = 0;
    
    virtual ~Animal() = default;
};

// 派生类：狗
class Dog : public Animal {
public:
    Dog(const string& n) : Animal(n) {}
    
    void speak() const override {
        cout << name << "说: 汪汪!" << endl;
    }
    
    void move() const override {
        cout << name << "用四条腿跑" << endl;
    }
};

// 派生类：鸟
class Bird : public Animal {
public:
    Bird(const string& n) : Animal(n) {}
    
    void speak() const override {
        cout << name << "说: 叽叽!" << endl;
    }
    
    void move() const override {
        cout << name << "用翅膀飞" << endl;
    }
};
```

### 场景2：多层次继承
```cpp
// 基类：雇员
class Employee {
protected:
    string name;
    double salary;
    
public:
    Employee(const string& n, double s) : name(n), salary(s) {}
    
    virtual void work() const {
        cout << name << "在工作" << endl;
    }
    
    virtual void displayInfo() const {
        cout << "雇员: " << name << ", 工资: " << salary << endl;
    }
    
    virtual ~Employee() {}
};

// 派生类：经理
class Manager : public Employee {
private:
    int teamSize;
    
public:
    Manager(const string& n, double s, int ts) 
        : Employee(n, s), teamSize(ts) {}
    
    void work() const override {
        cout << name << "在管理团队" << endl;
    }
    
    void displayInfo() const override {
        Employee::displayInfo();
        cout << "团队规模: " << teamSize << endl;
    }
    
    void conductMeeting() const {
        cout << name << "在主持会议" << endl;
    }
};

// 派生类：技术经理
class TechManager : public Manager {
private:
    string techSpecialty;
    
public:
    TechManager(const string& n, double s, int ts, const string& tech)
        : Manager(n, s, ts), techSpecialty(tech) {}
    
    void work() const override {
        cout << name << "在管理技术团队，擅长" << techSpecialty << endl;
    }
    
    void displayInfo() const override {
        Manager::displayInfo();
        cout << "技术专长: " << techSpecialty << endl;
    }
};
```

### 场景3：接口类（纯抽象类）
```cpp
// 接口类：可打印
class Printable {
public:
    virtual void print() const = 0;
    virtual ~Printable() = default;
};

// 接口类：可序列化
class Serializable {
public:
    virtual string serialize() const = 0;
    virtual void deserialize(const string& data) = 0;
    virtual ~Serializable() = default;
};

// 实现多个接口的类
class Document : public Printable, public Serializable {
private:
    string content;
    
public:
    Document(const string& c) : content(c) {}
    
    void print() const override {
        cout << "打印文档: " << content << endl;
    }
    
    string serialize() const override {
        return "DOCUMENT:" + content;
    }
    
    void deserialize(const string& data) override {
        if (data.find("DOCUMENT:") == 0) {
            content = data.substr(9);  // 跳过"DOCUMENT:"
        }
    }
    
    string getContent() const { return content; }
};
```

## 4. 易错点/坑

### 错误示例1：缺少虚析构函数
```cpp
class Base {
public:
    Base() { cout << "Base构造" << endl; }
    ~Base() { cout << "Base析构" << endl; }  // 非虚析构函数！
};

class Derived : public Base {
public:
    Derived() { cout << "Derived构造" << endl; }
    ~Derived() { cout << "Derived析构" << endl; }
};

int main() {
    Base* ptr = new Derived();
    delete ptr;  // 只调用Base的析构函数，Derived析构函数不被调用！
    return 0;
}
```
**原因**：非虚析构函数导致派生类部分资源泄漏
**修正方案**：
```cpp
class Base {
public:
    Base() { cout << "Base构造" << endl; }
    virtual ~Base() { cout << "Base析构" << endl; }  // 虚析构函数
};
```

### 错误示例2：对象切片（Object Slicing）
```cpp
class Base {
public:
    virtual void show() { cout << "Base" << endl; }
};

class Derived : public Base {
public:
    void show() override { cout << "Derived" << endl; }
};

int main() {
    Derived d;
    Base b = d;  // 对象切片！Derived特有部分被切掉
    b.show();    // 输出"Base"，不是"Derived"
    return 0;
}
```
**原因**：值拷贝导致派生类特有信息丢失
**修正方案**：
```cpp
int main() {
    Derived d;
    Base& b = d;  // 使用引用，避免切片
    b.show();     // 正确输出"Derived"
    
    Base* ptr = &d;  // 或使用指针
    ptr->show();     // 正确输出"Derived"
    return 0;
}
```

### 错误示例3：错误的访问控制
```cpp
class Base {
private:
    int secret;  // 私有成员
};

class Derived : public Base {
public:
    void tryAccess() {
        // secret = 10;  // 错误：不能访问基类私有成员
    }
};
```
**原因**：私有成员在派生类中不可访问
**修正方案**：
```cpp
class Base {
protected:  // 改为保护成员
    int secret;
};

class Derived : public Base {
public:
    void tryAccess() {
        secret = 10;  // 正确：可以访问保护成员
    }
};
```

## 5. 拓展补充

### 关联知识点
- **访问控制**：public、protected、private继承的区别
- **虚函数表**：实现多态的底层机制
- **final关键字**：禁止类被继承或函数被重写
- **动态类型转换**：dynamic_cast的安全类型转换

### 进阶延伸
- **多重继承**：一个类继承多个基类
- **虚继承**：解决菱形继承问题
- **CRTP模式**：奇特的递归模板模式
- **类型擦除**：运行时多态的另一种实现方式