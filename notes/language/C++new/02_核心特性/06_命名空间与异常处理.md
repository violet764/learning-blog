# 命名空间与异常处理

## 1. 核心概念

### 定义
- **命名空间**：将代码组织到逻辑组的机制，防止名称冲突
- **异常处理**：处理程序运行时错误的机制，提供错误恢复能力
- **异常安全**：代码在异常发生时仍能保持正确状态的特性

### 关键特性
- **名称隔离**：不同命名空间中的同名标识符不会冲突
- **错误传播**：异常可以从深层函数传播到外层处理程序
- **资源管理**：异常发生时确保资源正确释放
- **代码组织**：使用命名空间实现模块化设计

## 2. 语法规则

### 基本语法
```cpp
// 命名空间定义
namespace 命名空间名 {
    // 类、函数、变量等定义
}

// 异常处理
try {
    // 可能抛出异常的代码
} catch (异常类型1& e) {
    // 处理异常类型1
} catch (异常类型2& e) {
    // 处理异常类型2
} catch (...) {
    // 处理所有其他异常
}
```

### 代码示例
```cpp
#include <iostream>
#include <stdexcept>
#include <string>
using namespace std;

// 自定义命名空间
namespace MathUtils {
    const double PI = 3.14159;
    
    double calculateCircleArea(double radius) {
        if (radius < 0) {
            throw invalid_argument("半径不能为负数");
        }
        return PI * radius * radius;
    }
    
    double divide(double a, double b) {
        if (b == 0) {
            throw runtime_error("除数不能为零");
        }
        return a / b;
    }
}

namespace StringUtils {
    string toUpperCase(const string& str) {
        string result = str;
        for (char& c : result) {
            c = toupper(c);
        }
        return result;
    }
    
    string reverse(const string& str) {
        return string(str.rbegin(), str.rend());
    }
}

// 嵌套命名空间
namespace MyApp {
    namespace Database {
        class Connection {
        public:
            void connect() {
                cout << "数据库连接已建立" << endl;
            }
            
            void disconnect() {
                cout << "数据库连接已关闭" << endl;
            }
        };
    }
    
    namespace UI {
        void showMessage(const string& msg) {
            cout << "UI: " << msg << endl;
        }
    }
}

int main() {
    cout << "=== 命名空间使用演示 ===" << endl;
    
    // 使用命名空间中的函数
    cout << "圆面积: " << MathUtils::calculateCircleArea(5.0) << endl;
    cout << "字符串反转: " << StringUtils::reverse("Hello") << endl;
    
    // 使用嵌套命名空间
    MyApp::Database::Connection db;
    db.connect();
    MyApp::UI::showMessage("欢迎使用应用程序");
    
    cout << "\\n=== 异常处理演示 ===" << endl;
    
    // 异常处理示例
    try {
        double result1 = MathUtils::divide(10.0, 2.0);
        cout << "10.0 / 2.0 = " << result1 << endl;
        
        double result2 = MathUtils::divide(10.0, 0.0);  // 会抛出异常
        cout << "这行代码不会执行" << endl;
        
    } catch (const invalid_argument& e) {
        cout << "无效参数异常: " << e.what() << endl;
    } catch (const runtime_error& e) {
        cout << "运行时异常: " << e.what() << endl;
    } catch (...) {
        cout << "未知异常发生" << endl;
    }
    
    // 多级异常处理演示
    try {
        try {
            // 内部try块
            throw logic_error("逻辑错误示例");
        } catch (const logic_error& e) {
            cout << "内部捕获: " << e.what() << endl;
            throw;  // 重新抛出异常
        }
    } catch (const logic_error& e) {
        cout << "外部捕获: " << e.what() << endl;
    }
    
    cout << "=== 程序正常结束 ===" << endl;
    return 0;
}
```

### 注意事项
- 使用`using namespace`可以引入整个命名空间
- 使用`using 命名空间::成员`可以引入特定成员
- 异常应该按从具体到一般的顺序捕获
- 使用引用捕获异常以避免对象切片

## 3. 常见用法

### 场景1：自定义异常类
```cpp
#include <iostream>
#include <exception>
#include <string>

// 自定义异常基类
class MyException : public std::exception {
protected:
    std::string message;
    
public:
    MyException(const std::string& msg) : message(msg) {}
    
    const char* what() const noexcept override {
        return message.c_str();
    }
};

// 具体的异常类
class FileNotFoundException : public MyException {
public:
    FileNotFoundException(const std::string& filename) 
        : MyException("文件未找到: " + filename) {}
};

class DatabaseException : public MyException {
public:
    DatabaseException(const std::string& operation) 
        : MyException("数据库操作失败: " + operation) {}
};

class NetworkException : public MyException {
private:
    int errorCode;
    
public:
    NetworkException(const std::string& msg, int code) 
        : MyException(msg), errorCode(code) {}
    
    int getErrorCode() const { return errorCode; }
};

// 使用自定义异常
void readFile(const std::string& filename) {
    // 模拟文件不存在
    throw FileNotFoundException(filename);
}

void connectToDatabase() {
    // 模拟数据库连接失败
    throw DatabaseException("连接数据库");
}

int main() {
    try {
        readFile("data.txt");
        connectToDatabase();
    } catch (const FileNotFoundException& e) {
        std::cout << "文件异常: " << e.what() << std::endl;
    } catch (const DatabaseException& e) {
        std::cout << "数据库异常: " << e.what() << std::endl;
    } catch (const MyException& e) {
        std::cout << "我的异常: " << e.what() << std::endl;
    } catch (const std::exception& e) {
        std::cout << "标准异常: " << e.what() << std::endl;
    }
    
    return 0;
}
```

### 场景2：RAII与异常安全
```cpp
#include <iostream>
#include <memory>

// RAII资源管理类
class FileHandler {
private:
    FILE* file;
    
public:
    FileHandler(const char* filename, const char* mode) {
        file = fopen(filename, mode);
        if (!file) {
            throw std::runtime_error("无法打开文件");
        }
        std::cout << "文件已打开" << std::endl;
    }
    
    ~FileHandler() {
        if (file) {
            fclose(file);
            std::cout << "文件已关闭" << std::endl;
        }
    }
    
    // 禁止拷贝
    FileHandler(const FileHandler&) = delete;
    FileHandler& operator=(const FileHandler&) = delete;
    
    void write(const std::string& data) {
        if (fprintf(file, "%s\n", data.c_str()) < 0) {
            throw std::runtime_error("写入文件失败");
        }
    }
};

// 使用智能指针的RAII
class DatabaseConnection {
private:
    std::unique_ptr<void*> connection;  // 模拟数据库连接
    
public:
    DatabaseConnection() {
        // 模拟数据库连接（可能失败）
        connection = std::make_unique<void*>((void*)0x12345678);
        if (!connection) {
            throw std::runtime_error("数据库连接失败");
        }
        std::cout << "数据库已连接" << std::endl;
    }
    
    ~DatabaseConnection() {
        if (connection) {
            std::cout << "数据库连接已关闭" << std::endl;
        }
    }
    
    void executeQuery(const std::string& query) {
        // 模拟查询执行（可能失败）
        if (query.empty()) {
            throw std::runtime_error("查询不能为空");
        }
        std::cout << "执行查询: " << query << std::endl;
    }
};

// 异常安全的函数
void processData() {
    // 使用RAII对象，异常安全
    FileHandler file("data.txt", "w");
    DatabaseConnection db;
    
    file.write("开始处理数据");
    db.executeQuery("SELECT * FROM users");
    
    // 可能抛出异常的操作
    throw std::runtime_error("处理数据时发生错误");
    
    file.write("数据处理完成");  // 这行不会执行
    // 但file和db的析构函数会自动调用，确保资源释放
}

int main() {
    try {
        processData();
    } catch (const std::exception& e) {
        std::cout << "捕获异常: " << e.what() << std::endl;
    }
    
    return 0;
}
```

### 场景3：命名空间别名和using声明
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

// 很长的命名空间
namespace VeryLongNamespaceName {
    void function1() {
        std::cout << "函数1" << std::endl;
    }
    
    void function2() {
        std::cout << "函数2" << std::endl;
    }
    
    class MyClass {
    public:
        void method() {
            std::cout << "类方法" << std::endl;
        }
    };
}

// 使用命名空间别名
namespace VLN = VeryLongNamespaceName;

// 使用using声明
using std::cout;
using std::endl;
using std::vector;

// 使用using引入特定成员
using VeryLongNamespaceName::function1;
using VeryLongNamespaceName::MyClass;

int main() {
    // 使用别名
    VLN::function1();
    VLN::function2();
    
    // 使用using引入的成员
    function1();  // 可以直接使用，不需要命名空间前缀
    
    MyClass obj;
    obj.method();
    
    // 使用using引入的标准库成员
    vector<int> numbers = {3, 1, 4, 1, 5, 9};
    std::sort(numbers.begin(), numbers.end());
    
    for (int num : numbers) {
        cout << num << " ";  // 可以直接使用cout和endl
    }
    cout << endl;
    
    // 注意：避免在头文件中使用using namespace
    // 在实现文件中局部使用是可以的
    
    return 0;
}
```

## 4. 易错点/坑

### 错误示例1：异常对象切片
```cpp
class MyException : public std::exception {
    std::string msg;
public:
    MyException(const std::string& m) : msg(m) {}
    const char* what() const noexcept override {
        return msg.c_str();
    }
};

void problematicCatch() {
    try {
        throw MyException("我的异常");
    } catch (std::exception e) {  // 错误：按值捕获，发生切片
        std::cout << e.what() << std::endl;  // 可能丢失信息
    }
}
```
**原因**：按值捕获异常导致对象切片，派生类特有信息丢失
**修正方案**：
```cpp
void correctCatch() {
    try {
        throw MyException("我的异常");
    } catch (const std::exception& e) {  // 正确：按引用捕获
        std::cout << e.what() << std::endl;  // 保持完整信息
    }
}
```

### 错误示例2：异常吞噬
```cpp
void dangerousFunction() {
    FileHandler* file = new FileHandler("data.txt", "w");
    
    try {
        // 可能抛出异常的操作
        file->write("一些数据");
        throw std::runtime_error("操作失败");
        
    } catch (...) {
        // 捕获异常但不处理，导致内存泄漏
        std::cout << "发生异常" << std::endl;
        // 忘记delete file!
    }
    
    delete file;  // 这行不会执行
}
```
**原因**：异常处理中忘记释放资源
**修正方案**：
```cpp
void safeFunction() {
    // 使用RAII，自动管理资源
    FileHandler file("data.txt", "w");
    
    try {
        file.write("一些数据");
        throw std::runtime_error("操作失败");
        
    } catch (const std::exception& e) {
        std::cout << "异常: " << e.what() << std::endl;
        // file的析构函数会自动调用，确保资源释放
    }
}
```

### 错误示例3：命名空间污染
```cpp
// 头文件 myheader.h
using namespace std;  // 错误：在头文件中使用using namespace

class MyClass {
    // 类定义
};

// 其他文件包含此头文件时，会引入整个std命名空间
// 可能导致名称冲突
```
**原因**：头文件中的using namespace会污染包含该头文件的所有文件
**修正方案**：
```cpp
// 头文件 myheader.h
// 不使用using namespace

class MyClass {
    // 类定义
};

// 实现文件 myclass.cpp
#include "myheader.h"
#include <iostream>
#include <vector>

// 在实现文件中局部使用是可以的
using std::cout;
using std::endl;

void MyClass::someMethod() {
    cout << "Hello" << endl;  // 在实现文件中使用
}
```

## 5. 拓展补充

### 关联知识点
- **noexcept说明符**：声明函数不会抛出异常
- **异常规格**：C++98的异常规范机制（已弃用）
- **栈展开**：异常发生时调用栈的清理过程
- **terminate处理**：未捕获异常时的处理机制

### 进阶延伸
- **异常安全等级**：基本保证、强保证、不抛异常保证
- **移动语义与异常**：移动操作通常声明为noexcept
- **协程异常**：C++20协程中的异常处理
- **系统特定异常**：平台相关的异常类型