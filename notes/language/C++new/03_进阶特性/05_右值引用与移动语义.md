# 右值引用与移动语义

## 1. 核心概念

### 定义
- **右值引用**：C++11引入的引用类型，用于绑定到临时对象（右值）
- **移动语义**：将资源所有权从一个对象转移到另一个对象，避免不必要的拷贝
- **完美转发**：保持参数的值类别（左值/右值）进行转发

### 关键特性
- **性能优化**：避免深拷贝，提高大对象操作效率
- **资源管理**：明确资源所有权转移语义
- **标准库支持**：STL容器和算法全面支持移动语义
- **编译器优化**：自动识别可移动场景

## 2. 语法规则

### 基本语法
```cpp
// 右值引用声明
类型&& 引用名 = 右值表达式;

// 移动构造函数
类名(类名&& other);

// 移动赋值运算符
类名& operator=(类名&& other);

// 完美转发
template<typename T>
void func(T&& arg);  // 通用引用
```

### 代码示例
```cpp
#include <iostream>
#include <vector>
#include <string>
#include <utility>  // std::move, std::forward
using namespace std;

// 演示移动语义的字符串类
class MyString {
private:
    char* data;
    size_t length;
    
public:
    // 构造函数
    MyString(const char* str = "") : data(nullptr), length(0) {
        if (str) {
            length = strlen(str);
            data = new char[length + 1];
            strcpy(data, str);
            cout << "构造: " << data << endl;
        }
    }
    
    // 拷贝构造函数（深拷贝）
    MyString(const MyString& other) : data(nullptr), length(0) {
        length = other.length;
        if (length > 0) {
            data = new char[length + 1];
            strcpy(data, other.data);
        }
        cout << "拷贝构造: " << (data ? data : "空") << endl;
    }
    
    // 移动构造函数
    MyString(MyString&& other) noexcept : data(other.data), length(other.length) {
        other.data = nullptr;  // 置空原对象，防止双重释放
        other.length = 0;
        cout << "移动构造: " << (data ? data : "空") << endl;
    }
    
    // 拷贝赋值运算符
    MyString& operator=(const MyString& other) {
        if (this != &other) {
            delete[] data;  // 释放原有资源
            
            length = other.length;
            if (length > 0) {
                data = new char[length + 1];
                strcpy(data, other.data);
            } else {
                data = nullptr;
            }
        }
        cout << "拷贝赋值: " << (data ? data : "空") << endl;
        return *this;
    }
    
    // 移动赋值运算符
    MyString& operator=(MyString&& other) noexcept {
        if (this != &other) {
            delete[] data;  // 释放原有资源
            
            data = other.data;    // 接管资源
            length = other.length;
            
            other.data = nullptr;  // 置空原对象
            other.length = 0;
        }
        cout << "移动赋值: " << (data ? data : "空") << endl;
        return *this;
    }
    
    // 析构函数
    ~MyString() {
        delete[] data;
        cout << "析构" << endl;
    }
    
    const char* c_str() const { return data ? data : ""; }
    size_t size() const { return length; }
    
    friend ostream& operator<<(ostream& os, const MyString& str) {
        return os << (str.data ? str.data : "空");
    }
};

// 基本移动语义演示
void basicMoveSemantics() {
    cout << "=== 基本移动语义演示 ===" << endl;
    
    // 1. 普通构造
    MyString str1("Hello");
    
    // 2. 拷贝构造
    MyString str2 = str1;  // 调用拷贝构造函数
    
    // 3. 移动构造（使用std::move）
    MyString str3 = move(str1);  // 调用移动构造函数
    
    cout << "str1: " << str1 << endl;  // 空（资源已被移动）
    cout << "str2: " << str2 << endl;  // Hello
    cout << "str3: " << str3 << endl;  // Hello
    
    // 4. 移动赋值
    MyString str4("World");
    str4 = move(str3);  // 调用移动赋值运算符
    
    cout << "str3: " << str3 << endl;  // 空
    cout << "str4: " << str4 << endl;  // Hello
}

// 右值引用演示
void rvalueReferenceDemo() {
    cout << "\\n=== 右值引用演示 ===" << endl;
    
    MyString str("临时字符串");
    
    // 左值引用
    MyString& lref = str;  // 正确：绑定到左值
    // MyString& lref2 = MyString("临时");  // 错误：不能绑定右值到左值引用
    
    // 右值引用
    MyString&& rref = MyString("临时");  // 正确：绑定到右值
    // MyString&& rref2 = str;  // 错误：不能绑定左值到右值引用
    
    // 常量左值引用可以绑定右值
    const MyString& const_ref = MyString("临时");  // 正确
    
    cout << "右值引用内容: " << rref << endl;
}

// 移动语义在STL中的应用
void stlMoveSemantics() {
    cout << "\\n=== STL中的移动语义 ===" << endl;
    
    vector<MyString> strings;
    
    // 1. 插入临时对象（移动构造）
    cout << "插入临时对象:" << endl;
    strings.push_back(MyString("第一个"));  // 移动构造
    
    // 2. 插入具名对象（拷贝构造）
    cout << "插入具名对象:" << endl;
    MyString named("第二个");
    strings.push_back(named);  // 拷贝构造
    
    // 3. 显式移动具名对象
    cout << "移动具名对象:" << endl;
    strings.push_back(move(named));  // 移动构造
    
    cout << "named after move: " << named << endl;  // 空
    
    // 4. 向量扩容时的移动
    cout << "向量扩容:" << endl;
    strings.reserve(10);  // 触发重新分配，移动现有元素
    
    cout << "最终内容:" << endl;
    for (const auto& s : strings) {
        cout << s << endl;
    }
}

int main() {
    basicMoveSemantics();
    rvalueReferenceDemo();
    stlMoveSemantics();
    
    return 0;
}
```

### 注意事项
- 移动操作后，原对象处于有效但未定义状态
- 移动构造函数和赋值运算符应标记为noexcept
- std::move只是类型转换，不实际移动任何东西
- 完美转发需要模板和通用引用配合

## 3. 常见用法

### 场景1：完美转发实现
```cpp
#include <iostream>
#include <utility>

// 完美转发包装器
class Logger {
public:
    // 通用引用模板 - 完美转发的关键
    template<typename T>
    void log(T&& value) {
        // std::forward保持值类别
        process(std::forward<T>(value));
    }
    
private:
    // 处理左值版本
    void process(const string& value) {
        cout << "处理左值: " << value << endl;
    }
    
    // 处理右值版本
    void process(string&& value) {
        cout << "处理右值: " << value << endl;
        // 可以安全地移动value
    }
    
    // 处理整数版本
    void process(int value) {
        cout << "处理整数: " << value << endl;
    }
};

void perfectForwardingDemo() {
    cout << "=== 完美转发演示 ===" << endl;
    
    Logger logger;
    
    // 左值
    string lvalue = "左值字符串";
    logger.log(lvalue);  // 调用左值版本
    cout << "左值处理后: " << lvalue << endl;  // 仍然有效
    
    // 右值
    logger.log(string("右值字符串"));  // 调用右值版本
    
    // 字面量
    logger.log("字面量");  // 调用右值版本
    
    // 整数
    int x = 42;
    logger.log(x);       // 左值版本
    logger.log(123);     // 右值版本
}

// 工厂函数模板
template<typename T, typename... Args>
T create(Args&&... args) {
    // 完美转发所有参数
    return T(std::forward<Args>(args)...);
}

class Product {
    string name;
    int id;
public:
    Product(const string& n, int i) : name(n), id(i) {
        cout << "Product构造: " << name << "(" << id << ")" << endl;
    }
    
    Product(string&& n, int i) : name(std::move(n)), id(i) {
        cout << "Product移动构造: " << name << "(" << id << ")" << endl;
    }
};

void factoryDemo() {
    cout << "\\n工厂函数演示:" << endl;
    
    string name = "产品A";
    
    // 使用左值
    auto p1 = create<Product>(name, 1);  // 拷贝构造name
    
    // 使用右值
    auto p2 = create<Product>(string("产品B"), 2);  // 移动构造
    
    // 使用字面量
    auto p3 = create<Product>("产品C", 3);  // 移动构造
}
```

### 场景2：资源管理类
```cpp
#include <fstream>
#include <memory>

// RAII文件资源管理器
class FileResource {
private:
    unique_ptr<FILE, decltype(&fclose)> file;
    
public:
    FileResource(const char* filename, const char* mode)
        : file(fopen(filename, mode), &fclose) {
        if (!file) throw runtime_error("文件打开失败");
    }
    
    // 移动构造函数
    FileResource(FileResource&& other) noexcept
        : file(move(other.file)) {}
    
    // 移动赋值运算符
    FileResource& operator=(FileResource&& other) noexcept {
        if (this != &other) {
            file = move(other.file);
        }
        return *this;
    }
    
    void write(const string& content) {
        if (file) {
            fwrite(content.c_str(), 1, content.size(), file.get());
        }
    }
    
    // 禁用拷贝
    FileResource(const FileResource&) = delete;
    FileResource& operator=(const FileResource&) = delete;
};

void resourceManagementDemo() {
    cout << "\\n=== 资源管理类演示 ===" << endl;
    
    // 创建文件资源
    FileResource file1("test1.txt", "w");
    file1.write("Hello, World!");
    
    // 移动资源所有权
    FileResource file2 = move(file1);
    file2.write("\\nMoved resource");
    
    // file1不再拥有资源，但处于有效状态
}
```

### 场景3：STL容器优化
```cpp
void stlOptimizationDemo() {
    cout << "\\n=== STL容器优化 ===" << endl;
    
    vector<string> strings;
    
    // emplace_back直接构造（C++11）
    strings.emplace_back("直接构造");  // 避免临时对象
    
    // 移动语义优化
    string largeString(1000, 'x');
    strings.push_back(move(largeString));  // 移动而非拷贝
    
    // reserve预分配避免重新分配
    strings.reserve(100);
    
    // 移动语义在算法中的应用
    vector<string> source = {"a", "b", "c"};
    vector<string> destination;
    
    // 移动所有元素
    move(source.begin(), source.end(), back_inserter(destination));
    
    cout << "源容器大小: " << source.size() << endl;  // 3（但元素可能为空）
    cout << "目标容器大小: " << destination.size() << endl;  // 3
}
```

## 4. 易错点/坑

### 错误示例1：过度使用std::move
```cpp
void overuseMoveDemo() {
    string str = "hello";
    
    // 错误的过度使用
    string copy1 = move(str);  // 不必要，str还需要使用
    
    // 正确：仅在需要转移所有权时使用
    vector<string> vec;
    vec.push_back(move(str));  // 正确：str不再需要
    
    // 错误：对小对象使用move可能更慢
    int x = 42;
    int y = move(x);  // 对小整型使用move没有意义
}
```

### 错误示例2：移动后使用原对象
```cpp
void useAfterMoveDemo() {
    vector<int> data = {1, 2, 3};
    
    // 移动后使用原对象
    vector<int> newData = move(data);
    
    // 错误：data处于有效但未定义状态
    // cout << data.size() << endl;  // 未定义行为
    
    // 正确：重新赋值或避免使用
    data = {4, 5, 6};  // 重新赋值
    cout << data.size() << endl;  // 正确
}
```

### 错误示例3：错误的noexcept声明
```cpp
class BadMoveClass {
    vector<int> data;
public:
    // 错误：移动操作可能抛出异常
    BadMoveClass(BadMoveClass&& other) {
        data = move(other.data);  // vector移动可能抛出
    }
    
    // 正确：标记为noexcept
    BadMoveClass(BadMoveClass&& other) noexcept {
        data = move(other.data);
    }
};
```

### 错误示例4：忘记实现移动操作
```cpp
class NoMoveClass {
    int* data;
public:
    NoMoveClass() : data(new int(42)) {}
    ~NoMoveClass() { delete data; }
    
    // 只有拷贝操作，没有移动操作
    NoMoveClass(const NoMoveClass& other) : data(new int(*other.data)) {}
    
    // 错误：需要移动操作时仍使用拷贝
    // vector<NoMoveClass> vec;
    // vec.push_back(NoMoveClass());  // 调用拷贝构造函数
};
```

## 5. 拓展补充

### 关联知识点

#### 返回值优化（RVO）
```cpp
string createString() {
    return string("临时字符串");  // 可能触发RVO
}

void rvoDemo() {
    // RVO可能优化为直接构造
    string str = createString();
    
    // 强制移动（可能干扰RVO）
    string str2 = move(createString());  // 不推荐
}
```

#### 通用引用（Universal Reference）
```cpp
template<typename T>
void universalReferenceDemo(T&& param) {
    // T&& 可能是左值引用或右值引用
    if constexpr (is_lvalue_reference_v<T>) {
        cout << "左值引用" << endl;
    } else {
        cout << "右值引用" << endl;
    }
}
```

### 进阶延伸

#### 移动语义与异常安全
```cpp
class ExceptionSafeResource {
    unique_ptr<int> resource;
public:
    // 强异常安全保证
    void swap(ExceptionSafeResource& other) noexcept {
        using std::swap;
        swap(resource, other.resource);
    }
    
    ExceptionSafeResource& operator=(ExceptionSafeResource other) noexcept {
        swap(other);
        return *this;
    }
};
```

#### 自定义移动迭代器
```cpp
template<typename Iterator>
class move_iterator {
    Iterator current;
public:
    using value_type = typename iterator_traits<Iterator>::value_type;
    
    move_iterator(Iterator it) : current(it) {}
    
    auto operator*() -> decltype(move(*current)) {
        return move(*current);
    }
    
    // 其他迭代器操作...
};
```

#### 完美转发与可变参数模板
```cpp
template<typename... Args>
void perfectForwardingVariadic(Args&&... args) {
    // 完美转发所有参数
    someFunction(forward<Args>(args)...);
}

void variadicDemo() {
    string str = "hello";
    perfectForwardingVariadic(str, 42, "world");
}
```

### 性能测试与基准
```cpp
#include <chrono>

void performanceBenchmark() {
    const int SIZE = 1000000;
    
    auto start = chrono::high_resolution_clock::now();
    
    // 测试拷贝性能
    vector<vector<int>> copyVec;
    for (int i = 0; i < 100; ++i) {
        vector<int> temp(SIZE, i);
        copyVec.push_back(temp);  // 拷贝
    }
    
    auto copyTime = chrono::high_resolution_clock::now() - start;
    
    start = chrono::high_resolution_clock::now();
    
    // 测试移动性能
    vector<vector<int>> moveVec;
    for (int i = 0; i < 100; ++i) {
        vector<int> temp(SIZE, i);
        moveVec.push_back(move(temp));  // 移动
    }
    
    auto moveTime = chrono::high_resolution_clock::now() - start;
    
    cout << "拷贝时间: " 
         << chrono::duration_cast<chrono::milliseconds>(copyTime).count() 
         << "ms" << endl;
    cout << "移动时间: " 
         << chrono::duration_cast<chrono::milliseconds>(moveTime).count() 
         << "ms" << endl;
}
```

## 总结

右值引用与移动语义是现代C++性能优化的关键技术：

1. **理解值类别**：区分左值、右值、将亡值
2. **正确使用移动**：在适当场景使用std::move
3. **实现移动操作**：为资源管理类实现移动构造和赋值
4. **掌握完美转发**：保持参数值类别进行转发
5. **注意异常安全**：移动操作应标记为noexcept
6. **避免常见错误**：不要过度使用或移动后使用原对象

通过合理使用移动语义，可以显著提升大对象操作的性能，避免不必要的深拷贝，是现代C++高性能编程的必备技能。