# 内存管理

## 1. 核心概念

### 定义
- **内存管理**：程序运行时内存的分配、使用和释放
- **堆内存**：动态分配的内存区域，需要手动管理
- **栈内存**：自动分配和释放的内存区域
- **内存泄漏**：分配的内存未被正确释放

### 关键特性
- **RAII模式**：资源获取即初始化，自动管理资源生命周期
- **智能指针**：自动内存管理的指针类型
- **内存池**：预分配内存块提高分配效率
- **对齐要求**：数据在内存中的对齐规则

## 2. 语法规则

### 基本语法
```cpp
// 动态内存分配
类型* ptr = new 类型(参数);
类型* arr = new 类型[大小];

// 内存释放
delete ptr;
delete[] arr;

// 智能指针
unique_ptr<类型> ptr = make_unique<类型>(参数);
shared_ptr<类型> ptr = make_shared<类型>(参数);
```

### 代码示例
```cpp
#include <iostream>
#include <memory>
#include <vector>
using namespace std;

class Resource {
private:
    string name;
    
public:
    Resource(const string& n) : name(n) {
        cout << "分配资源: " << name << endl;
    }
    
    ~Resource() {
        cout << "释放资源: " << name << endl;
    }
    
    void use() {
        cout << "使用资源: " << name << endl;
    }
};

void rawMemoryDemo() {
    cout << "=== 原始内存管理 ===" << endl;
    
    // 单个对象
    Resource* res1 = new Resource("原始指针对象");
    res1->use();
    delete res1;  // 必须手动释放
    
    // 对象数组
    Resource* resArray = new Resource[3]{
        Resource("数组元素1"),
        Resource("数组元素2"), 
        Resource("数组元素3")
    };
    delete[] resArray;  // 数组释放
}

void smartPointerDemo() {
    cout << "\\n=== 智能指针管理 ===" << endl;
    
    // unique_ptr：独占所有权
    auto uniqueRes = make_unique<Resource>("unique_ptr对象");
    uniqueRes->use();
    // 自动释放，无需delete
    
    // shared_ptr：共享所有权
    auto sharedRes1 = make_shared<Resource>("shared_ptr对象");
    {
        auto sharedRes2 = sharedRes1;  // 共享所有权
        cout << "引用计数: " << sharedRes1.use_count() << endl;
    }
    cout << "引用计数: " << sharedRes1.use_count() << endl;
    // 最后一个shared_ptr离开作用域时自动释放
}

void memoryLayoutDemo() {
    cout << "\\n=== 内存布局演示 ===" << endl;
    
    struct Data {
        char c;     // 1字节
        int i;      // 4字节  
        double d;   // 8字节
        short s;    // 2字节
    };
    
    Data data;
    cout << "结构体大小: " << sizeof(Data) << " 字节" << endl;
    cout << "成员偏移: c=" << offsetof(Data, c)
         << ", i=" << offsetof(Data, i)
         << ", d=" << offsetof(Data, d)
         << ", s=" << offsetof(Data, s) << endl;
}

int main() {
    rawMemoryDemo();
    smartPointerDemo();
    memoryLayoutDemo();
    
    return 0;
}
```

### 注意事项
- 每个new必须对应一个delete
- 数组使用new[]和delete[]配对
- 智能指针自动管理内存生命周期
- 理解RAII模式确保资源正确释放

## 3. 常见用法

### 场景1：智能指针高级用法
```cpp
#include <memory>

void advancedSmartPointerDemo() {
    cout << "=== 智能指针高级用法 ===" << endl;
    
    // weak_ptr观察共享对象
    shared_ptr<Resource> shared = make_shared<Resource>("共享资源");
    weak_ptr<Resource> weak = shared;
    
    cout << "共享引用计数: " << shared.use_count() << endl;  // 1
    
    // 检查资源是否存在
    if (auto locked = weak.lock()) {
        cout << "资源存在: " << locked->use() << endl;
    }
    
    // 释放共享所有权
    shared.reset();
    
    if (auto locked = weak.lock()) {
        cout << "资源仍存在" << endl;
    } else {
        cout << "资源已被释放" << endl;
    }
    
    // 自定义删除器
    auto customDeleter = [](Resource* res) {
        cout << "自定义删除器释放资源" << endl;
        delete res;
    };
    
    unique_ptr<Resource, decltype(customDeleter)> 
        customPtr(new Resource("自定义删除"), customDeleter);
}
```

### 场景2：RAII资源管理
```cpp
#include <fstream>
#include <mutex>

// RAII文件资源管理
class FileHandler {
private:
    ofstream file;
    
public:
    FileHandler(const string& filename) : file(filename) {
        if (!file.is_open()) {
            throw runtime_error("文件打开失败");
        }
        cout << "文件打开: " << filename << endl;
    }
    
    ~FileHandler() {
        if (file.is_open()) {
            file.close();
            cout << "文件关闭" << endl;
        }
    }
    
    void write(const string& content) {
        file << content << endl;
    }
    
    // 禁用拷贝
    FileHandler(const FileHandler&) = delete;
    FileHandler& operator=(const FileHandler&) = delete;
    
    // 允许移动
    FileHandler(FileHandler&& other) noexcept : file(move(other.file)) {}
    FileHandler& operator=(FileHandler&& other) noexcept {
        if (this != &other) {
            file = move(other.file);
        }
        return *this;
    }
};

void raiiResourceDemo() {
    cout << "\\n=== RAII资源管理 ===" << endl;
    
    try {
        FileHandler file("test.txt");
        file.write("Hello, RAII!");
        
        // 即使发生异常，文件也会正确关闭
        throw runtime_error("测试异常");
        
    } catch (const exception& e) {
        cout << "异常捕获: " << e.what() << endl;
    }
    // 文件自动关闭
}
```

### 场景3：内存池优化
```cpp
template<typename T>
class SimpleMemoryPool {
private:
    struct Block {
        T* memory;
        Block* next;
    };
    
    Block* freeList = nullptr;
    size_t blockSize;
    
public:
    SimpleMemoryPool(size_t size = 100) : blockSize(size) {}
    
    T* allocate() {
        if (!freeList) {
            // 分配新块
            Block* newBlock = new Block;
            newBlock->memory = new T[blockSize];
            newBlock->next = nullptr;
            
            // 将新块加入空闲列表
            for (size_t i = 0; i < blockSize; ++i) {
                Block* item = new Block;
                item->memory = &newBlock->memory[i];
                item->next = freeList;
                freeList = item;
            }
        }
        
        Block* block = freeList;
        freeList = freeList->next;
        
        return block->memory;
    }
    
    void deallocate(T* ptr) {
        Block* block = new Block;
        block->memory = ptr;
        block->next = freeList;
        freeList = block;
    }
    
    ~SimpleMemoryPool() {
        while (freeList) {
            Block* next = freeList->next;
            delete freeList;
            freeList = next;
        }
    }
};

void memoryPoolDemo() {
    cout << "\\n=== 内存池优化 ===" << endl;
    
    SimpleMemoryPool<int> pool;
    
    vector<int*> allocated;
    for (int i = 0; i < 10; ++i) {
        int* ptr = pool.allocate();
        *ptr = i;
        allocated.push_back(ptr);
        cout << "分配: " << *ptr << endl;
    }
    
    // 释放部分内存
    for (int i = 0; i < 5; ++i) {
        pool.deallocate(allocated[i]);
        cout << "释放: " << i << endl;
    }
    
    // 重新分配
    for (int i = 0; i < 3; ++i) {
        int* ptr = pool.allocate();
        *ptr = i + 100;
        cout << "重新分配: " << *ptr << endl;
    }
}
```

## 4. 易错点/坑

### 错误示例1：内存泄漏
```cpp
void memoryLeakError() {
    // 忘记释放内存
    Resource* res = new Resource("泄漏对象");
    res->use();
    // 忘记delete res;
    
    // 修正：使用智能指针
    auto safeRes = make_shared<Resource>("安全对象");
    safeRes->use();
    // 自动释放
}
```

### 错误示例2：双重释放
```cpp
void doubleFreeError() {
    Resource* res = new Resource("测试对象");
    
    delete res;  // 第一次释放
    // delete res;  // 错误：双重释放
    
    res = nullptr;  // 安全做法
    
    // 修正：使用智能指针
    auto ptr = make_unique<Resource>("智能指针对象");
    // 自动管理，不会双重释放
}
```

### 错误示例3：错误的new/delete配对
```cpp
void wrongPairError() {
    // 单个对象使用new[]
    Resource* single = new Resource("单个");
    // delete[] single;  // 错误：应该用delete
    
    // 数组使用new
    Resource* array = new Resource[3];
    // delete array;     // 错误：应该用delete[]
    
    // 修正：正确配对
    delete single;      // 正确
    delete[] array;     // 正确
}
```

### 错误示例4：循环引用
```cpp
class Node {
public:
    shared_ptr<Node> next;
    shared_ptr<Node> prev;  // 循环引用！
    
    ~Node() { cout << "节点析构" << endl; }
};

void circularReferenceError() {
    auto node1 = make_shared<Node>();
    auto node2 = make_shared<Node>();
    
    node1->next = node2;
    node2->prev = node1;  // 循环引用，内存泄漏
    
    // 修正：使用weak_ptr
    // weak_ptr<Node> prev;  // 打破循环引用
}
```

## 5. 拓展补充

### 关联知识点

#### placement new
```cpp
void placementNewDemo() {
    cout << "\\n=== placement new ===" << endl;
    
    // 预分配内存
    alignas(Resource) char buffer[sizeof(Resource)];
    
    // 在指定内存位置构造对象
    Resource* res = new (buffer) Resource("placement构造");
    res->use();
    
    // 手动调用析构函数
    res->~Resource();
    
    cout << "placement new完成" << endl;
}
```

#### 内存对齐
```cpp
void memoryAlignmentDemo() {
    cout << "\\n=== 内存对齐 ===" << endl;
    
    struct AlignedData {
        alignas(16) char data[13];  // 16字节对齐
        int value;
    };
    
    AlignedData aligned;
    cout << "对齐后大小: " << sizeof(AlignedData) << endl;
    cout << "对齐要求: " << alignof(AlignedData) << endl;
}
```

### 进阶延伸

#### 自定义分配器
```cpp
template<typename T>
class CustomAllocator {
public:
    using value_type = T;
    
    CustomAllocator() = default;
    
    template<typename U>
    CustomAllocator(const CustomAllocator<U>&) {}
    
    T* allocate(size_t n) {
        cout << "分配 " << n << " 个 " << typeid(T).name() << " 对象" << endl;
        return static_cast<T*>(::operator new(n * sizeof(T)));
    }
    
    void deallocate(T* p, size_t n) {
        cout << "释放 " << n << " 个 " << typeid(T).name() << " 对象" << endl;
        ::operator delete(p);
    }
};

void customAllocatorDemo() {
    cout << "\\n=== 自定义分配器 ===" << endl;
    
    vector<int, CustomAllocator<int>> numbers;
    numbers.reserve(5);
    
    for (int i = 0; i < 5; ++i) {
        numbers.push_back(i);
    }
    
    // vector析构时自动调用分配器的deallocate
}
```

#### 垃圾收集概念
```cpp
// 引用计数垃圾收集（简化版）
class GCObject {
    int refCount = 0;
    
public:
    void addRef() { ++refCount; }
    void release() {
        if (--refCount == 0) {
            delete this;
        }
    }
    
protected:
    virtual ~GCObject() = default;
};

template<typename T>
class GCptr {
    T* ptr;
    
public:
    GCptr(T* p = nullptr) : ptr(p) {
        if (ptr) static_cast<GCObject*>(ptr)->addRef();
    }
    
    ~GCptr() {
        if (ptr) static_cast<GCObject*>(ptr)->release();
    }
    
    // 拷贝构造、赋值操作等...
};
```

### 性能优化建议

1. **优先使用栈内存**：自动管理，性能最优
2. **合理使用智能指针**：避免手动内存管理错误
3. **预分配内存**：减少动态分配开销
4. **考虑内存池**：对小对象提高分配效率
5. **注意缓存友好**：优化数据布局提高缓存命中率

## 总结

现代C++内存管理技术提供了强大的工具来避免常见的内存错误：

1. **理解内存模型**：栈、堆、静态存储区的区别
2. **掌握智能指针**：unique_ptr、shared_ptr、weak_ptr的适用场景
3. **应用RAII模式**：确保资源正确释放
4. **避免常见错误**：内存泄漏、双重释放、循环引用
5. **性能优化**：合理使用内存池和自定义分配器

通过正确使用这些技术，可以构建安全、高效、可维护的C++应用程序。

## 3. 常见用法

### 场景：自定义内存分配器
```cpp
template<typename T>
class SimpleAllocator {
public:
    using value_type = T;
    
    SimpleAllocator() = default;
    
    template<typename U>
    SimpleAllocator(const SimpleAllocator<U>&) {}
    
    T* allocate(size_t n) {
        cout << "分配 " << n << " 个 " << typeid(T).name() << " 对象" << endl;
        return static_cast<T*>(::operator new(n * sizeof(T)));
    }
    
    void deallocate(T* p, size_t n) {
        cout << "释放 " << n << " 个 " << typeid(T).name() << " 对象" << endl;
        ::operator delete(p);
    }
};

void customAllocatorDemo() {
    cout << "\\n=== 自定义分配器 ===" << endl;
    
    vector<int, SimpleAllocator<int>> numbers;
    numbers.reserve(5);
    
    for (int i = 0; i < 5; ++i) {
        numbers.push_back(i);
    }
    
    // vector析构时自动释放内存
    cout << "使用自定义分配器的vector大小: " << numbers.size() << endl;
}
```

### 场景2：对象池模式
```cpp
template<typename T>
class ObjectPool {
private:
    queue<unique_ptr<T>> pool;
    mutex mtx;
    
public:
    template<typename... Args>
    unique_ptr<T> acquire(Args&&... args) {
        lock_guard<mutex> lock(mtx);
        
        if (!pool.empty()) {
            auto obj = move(pool.front());
            pool.pop();
            return obj;
        }
        
        return make_unique<T>(forward<Args>(args)...);
    }
    
    void release(unique_ptr<T> obj) {
        lock_guard<mutex> lock(mtx);
        if (obj) {
            pool.push(move(obj));
        }
    }
    
    size_t size() const {
        lock_guard<mutex> lock(mtx);
        return pool.size();
    }
};

class DatabaseConnection {
    string connectionString;
public:
    DatabaseConnection(const string& connStr) : connectionString(connStr) {
        cout << "创建数据库连接: " << connStr << endl;
    }
    
    ~DatabaseConnection() {
        cout << "关闭数据库连接" << endl;
    }
    
    void execute(const string& query) {
        cout << "执行查询: " << query << endl;
    }
    
    void reset() {
        // 重置连接状态
        cout << "重置连接" << endl;
    }
};

void objectPoolDemo() {
    cout << "\\n=== 对象池模式 ===" << endl;
    
    ObjectPool<DatabaseConnection> pool;
    
    // 从池中获取连接
    auto conn1 = pool.acquire("server=db1;database=test");
    auto conn2 = pool.acquire("server=db2;database=test");
    
    conn1->execute("SELECT * FROM users");
    conn2->execute("UPDATE accounts SET balance = 100");
    
    // 使用后放回池中
    conn1->reset();
    pool.release(move(conn1));
    
    cout << "池中对象数量: " << pool.size() << endl;
}
```

### 场景3：循环引用解决方案
```cpp
class Node {
public:
    string name;
    shared_ptr<Node> next;
    weak_ptr<Node> prev;  // 使用weak_ptr避免循环引用
    
    Node(const string& n) : name(n) {
        cout << "创建节点: " << name << endl;
    }
    
    ~Node() {
        cout << "销毁节点: " << name << endl;
    }
    
    void setNext(shared_ptr<Node> node) {
        next = node;
        if (node) {
            node->prev = weak_ptr<Node>(shared_from_this());
        }
    }
};

void circularReferenceDemo() {
    cout << "\\n=== 循环引用解决方案 ===" << endl;
    
    auto node1 = make_shared<Node>("节点1");
    auto node2 = make_shared<Node>("节点2");
    auto node3 = make_shared<Node>("节点3");
    
    // 形成循环引用
    node1->setNext(node2);
    node2->setNext(node3);
    node3->setNext(node1);  // 循环引用，但使用weak_ptr不会泄漏
    
    cout << "节点1引用计数: " << node1.use_count() << endl;  // 1
    cout << "节点2引用计数: " << node2.use_count() << endl;  // 1
    cout << "节点3引用计数: " << node3.use_count() << endl;  // 1
    
    // 所有节点都能正确销毁
}
```

### 场景4：RAII资源管理器
```cpp
class FileResource {
private:
    unique_ptr<FILE, decltype(&fclose)> file;
    
public:
    FileResource(const char* filename, const char* mode)
        : file(fopen(filename, mode), &fclose) {
        if (!file) throw runtime_error("文件打开失败");
        cout << "打开文件: " << filename << endl;
    }
    
    // 移动构造函数
    FileResource(FileResource&& other) noexcept
        : file(move(other.file)) {}
    
    // 移动赋值运算符
    FileResource& operator=(FileResource&& other) noexcept {
        if (this != &other) {
            file = move(other.file);
        }
        return *this;
    }
    
    void write(const string& content) {
        if (file) {
            fwrite(content.c_str(), 1, content.size(), file.get());
        }
    }
    
    // 禁用拷贝
    FileResource(const FileResource&) = delete;
    FileResource& operator=(const FileResource&) = delete;
    
    ~FileResource() {
        if (file) {
            cout << "关闭文件" << endl;
        }
    }
};

void raiiResourceDemo() {
    cout << "\\n=== RAII资源管理器 ===" << endl;
    
    try {
        FileResource file("test.txt", "w");
        file.write("Hello, RAII!");
        
        // 即使抛出异常，文件也会正确关闭
        throw runtime_error("测试异常");
        
    } catch (const exception& e) {
        cout << "捕获异常: " << e.what() << endl;
    }
    
    // 文件资源已自动释放
}
```

## 4. 易错点/坑

### 错误示例1：内存泄漏
```cpp
void memoryLeakError() {
    // 错误：忘记释放内存
    int* data = new int[1000];
    // 使用data...
    // 忘记 delete[] data;  // 内存泄漏！
    
    // 修正：使用智能指针
    auto safeData = make_unique<int[]>(1000);
    // 自动释放
}
```

### 错误示例2：循环引用
```cpp
void circularReferenceError() {
    class BadNode {
    public:
        shared_ptr<BadNode> next;
        shared_ptr<BadNode> prev;  // 错误：循环引用！
        
        ~BadNode() { cout << "BadNode析构" << endl; }
    };
    
    auto node1 = make_shared<BadNode>();
    auto node2 = make_shared<BadNode>();
    
    node1->next = node2;
    node2->prev = node1;  // 循环引用，内存泄漏！
    
    // node1和node2永远不会被销毁
    cout << "节点1引用计数: " << node1.use_count() << endl;  // 2
    cout << "节点2引用计数: " << node2.use_count() << endl;  // 2
}
```

### 错误示例3：混合使用智能指针和裸指针
```cpp
void mixedPointerError() {
    // 错误：混合使用
    int* rawPtr = new int(42);
    shared_ptr<int> smartPtr1(rawPtr);
    // shared_ptr<int> smartPtr2(rawPtr);  // 错误！双重释放
    
    // 修正：统一使用智能指针
    auto smartPtr = make_shared<int>(42);
    auto anotherPtr = smartPtr;  // 正确：共享所有权
}
```

### 错误示例4：错误的析构顺序
```cpp
void destructionOrderError() {
    class ResourceA {
        shared_ptr<ResourceB> b;
    public:
        ~ResourceA() { cout << "ResourceA析构" << endl; }
    };
    
    class ResourceB {
        shared_ptr<ResourceA> a;  // 可能导致析构顺序问题
    public:
        ~ResourceB() { cout << "ResourceB析构" << endl; }
    };
    
    // 修正：使用weak_ptr或调整设计
    class FixedResourceB {
        weak_ptr<ResourceA> a;  // 使用weak_ptr
    public:
        ~FixedResourceB() { cout << "FixedResourceB析构" << endl; }
    };
}
```

### 错误示例5：过早释放资源
```cpp
void prematureReleaseError() {
    // 错误：过早释放
    auto ptr = make_unique<int>(42);
    int* rawPtr = ptr.get();
    ptr.reset();  // 过早释放
    
    // *rawPtr = 100;  // 未定义行为！
    
    // 修正：确保生命周期正确
    {
        auto safePtr = make_unique<int>(42);
        int* safeRawPtr = safePtr.get();
        *safeRawPtr = 100;  // 安全：ptr仍在作用域内
    }
    // safePtr自动释放
}
```

## 5. 拓展补充

### 关联知识点

#### placement new
```cpp
void placementNewDemo() {
    cout << "\\n=== placement new ===" << endl;
    
    // 预分配内存
    alignas(string) char buffer[sizeof(string) * 3];
    
    // 在指定位置构造对象
    string* str1 = new(buffer) string("第一个字符串");
    string* str2 = new(buffer + sizeof(string)) string("第二个字符串");
    string* str3 = new(buffer + 2 * sizeof(string)) string("第三个字符串");
    
    cout << *str1 << endl;
    cout << *str2 << endl;
    cout << *str3 << endl;
    
    // 手动调用析构函数
    str1->~string();
    str2->~string();
    str3->~string();
}
```

#### 内存对齐
```cpp
void memoryAlignmentDemo() {
    cout << "\\n=== 内存对齐 ===" << endl;
    
    struct UnalignedData {
        char c;     // 1字节
        int i;      // 4字节
        double d;   // 8字节
    };
    
    struct AlignedData {
        alignas(8) char c;   // 8字节对齐
        alignas(8) int i;    // 8字节对齐  
        double d;             // 8字节对齐
    };
    
    cout << "未对齐结构体大小: " << sizeof(UnalignedData) << endl;
    cout << "对齐结构体大小: " << sizeof(AlignedData) << endl;
    
    // 对齐要求
    cout << "double对齐要求: " << alignof(double) << endl;
    cout << "最大对齐要求: " << alignof(max_align_t) << endl;
}
```

#### 自定义删除器
```cpp
void customDeleterDemo() {
    cout << "\\n=== 自定义删除器 ===" << endl;
    
    // 文件删除器
    auto fileDeleter = [](FILE* file) {
        if (file) {
            fclose(file);
            cout << "文件已关闭" << endl;
        }
    };
    
    unique_ptr<FILE, decltype(fileDeleter)> 
        file(fopen("test.txt", "w"), fileDeleter);
    
    // 带日志的删除器
    auto loggingDeleter = [](int* ptr) {
        cout << "删除整数: " << *ptr << endl;
        delete ptr;
    };
    
    unique_ptr<int, decltype(loggingDeleter)> 
        num(new int(42), loggingDeleter);
}
```

### 进阶延伸

#### 内存池实现
```cpp
class SimpleMemoryPool {
private:
    struct Block {
        Block* next;
    };
    
    Block* freeList = nullptr;
    size_t blockSize;
    
public:
    SimpleMemoryPool(size_t size) : blockSize(size) {}
    
    void* allocate() {
        if (!freeList) {
            // 分配新块
            return ::operator new(blockSize);
        }
        
        Block* block = freeList;
        freeList = freeList->next;
        return block;
    }
    
    void deallocate(void* ptr) {
        if (!ptr) return;
        
        Block* block = static_cast<Block*>(ptr);
        block->next = freeList;
        freeList = block;
    }
    
    ~SimpleMemoryPool() {
        while (freeList) {
            Block* next = freeList->next;
            ::operator delete(freeList);
            freeList = next;
        }
    }
};
```

#### 智能指针性能优化
```cpp
void smartPointerOptimization() {
    cout << "\\n=== 智能指针性能优化 ===" << endl;
    
    // 使用make_shared优化（单次分配）
    auto shared1 = make_shared<vector<int>>(1000, 42);
    
    // 避免不必要的shared_ptr拷贝
    auto processVector = [](const shared_ptr<vector<int>>& vec) {
        // 使用const引用避免引用计数增加
        cout << "向量大小: " << vec->size() << endl;
    };
    
    processVector(shared1);
    
    // 使用unique_ptr移动语义
    auto uniqueVec = make_unique<vector<int>>(1000, 42);
    auto processUnique = [](unique_ptr<vector<int>> vec) {
        // 移动语义，无拷贝开销
        cout << "唯一向量大小: " << vec->size() << endl;
    };
    
    processUnique(move(uniqueVec));
}
```

### 最佳实践总结

1. **优先使用智能指针**：避免手动内存管理错误
2. **理解所有权语义**：明确资源生命周期管理
3. **避免循环引用**：合理使用weak_ptr
4. **异常安全设计**：确保资源在异常时正确释放
5. **性能优化考虑**：根据场景选择合适的内存管理策略
6. **使用现代特性**：充分利用C++11/14/17内存管理特性

## 总结

现代C++内存管理已经从手动管理演进到自动管理：

1. **RAII原则**：资源获取即初始化，自动管理生命周期
2. **智能指针**：unique_ptr、shared_ptr、weak_ptr各有用途
3. **移动语义**：优化大对象传递性能
4. **自定义管理**：分配器、对象池等高级技术
5. **工具支持**：内存分析、调试工具辅助

通过掌握这些技术，可以编写出安全、高效、易维护的C++代码。