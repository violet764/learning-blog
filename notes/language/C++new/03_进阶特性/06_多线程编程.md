# 多线程编程

## 1. 核心概念

### 定义
- **线程**：程序执行的最小单位，多个线程可以并发执行
- **并发**：多个任务在重叠的时间段内执行
- **同步**：协调多个线程对共享资源的访问
- **互斥**：防止多个线程同时访问共享资源

### 关键特性
- **性能提升**：利用多核处理器提高程序性能
- **响应性**：避免UI线程阻塞，提高用户体验
- **资源竞争**：需要处理数据竞争和死锁问题
- **内存模型**：理解内存可见性和执行顺序

## 2. 语法规则

### 基本语法
```cpp
#include <thread>
#include <mutex>
#include <atomic>

// 创建线程
std::thread t(函数, 参数...);

// 互斥锁
std::mutex mtx;
mtx.lock();   // 加锁
mtx.unlock(); // 解锁

// 原子操作
std::atomic<int> counter(0);
counter.fetch_add(1); // 原子加1
```

### 代码示例
```cpp
#include <iostream>
#include <thread>
#include <vector>
#include <mutex>
#include <atomic>
#include <chrono>
using namespace std;

// 基本线程创建和运行
void basicThreadDemo() {
    cout << "=== 基本线程演示 ===" << endl;
    
    // 线程函数
    auto threadFunc = [](int id) {
        cout << "线程 " << id << " 开始执行" << endl;
        this_thread::sleep_for(chrono::milliseconds(100));
        cout << "线程 " << id << " 结束执行" << endl;
    };
    
    // 创建多个线程
    vector<thread> threads;
    for (int i = 0; i < 3; ++i) {
        threads.emplace_back(threadFunc, i + 1);
    }
    
    // 等待所有线程完成
    for (auto& t : threads) {
        t.join();
    }
    
    cout << "所有线程执行完毕" << endl;
}

// 数据竞争问题演示
void dataRaceDemo() {
    cout << "\\n=== 数据竞争问题 ===" << endl;
    
    int unsafeCounter = 0;
    atomic<int> safeCounter(0);
    
    auto incrementUnsafe = [&unsafeCounter]() {
        for (int i = 0; i < 10000; ++i) {
            unsafeCounter++;  // 数据竞争！
        }
    };
    
    auto incrementSafe = [&safeCounter]() {
        for (int i = 0; i < 10000; ++i) {
            safeCounter++;  // 原子操作，安全
        }
    };
    
    vector<thread> unsafeThreads;
    vector<thread> safeThreads;
    
    // 不安全的计数器
    for (int i = 0; i < 10; ++i) {
        unsafeThreads.emplace_back(incrementUnsafe);
    }
    
    // 安全的计数器
    for (int i = 0; i < 10; ++i) {
        safeThreads.emplace_back(incrementSafe);
    }
    
    // 等待线程完成
    for (auto& t : unsafeThreads) t.join();
    for (auto& t : safeThreads) t.join();
    
    cout << "不安全计数器结果: " << unsafeCounter << " (应该为100000)" << endl;
    cout << "安全计数器结果: " << safeCounter << " (正确)" << endl;
}

// 互斥锁使用
void mutexDemo() {
    cout << "\\n=== 互斥锁演示 ===" << endl;
    
    mutex mtx;
    int sharedData = 0;
    
    auto lockedIncrement = [&sharedData, &mtx]() {
        for (int i = 0; i < 1000; ++i) {
            {
                lock_guard<mutex> lock(mtx);  // RAII锁
                sharedData++;
            }
            this_thread::sleep_for(chrono::microseconds(1));
        }
    };
    
    vector<thread> threads;
    for (int i = 0; i < 5; ++i) {
        threads.emplace_back(lockedIncrement);
    }
    
    for (auto& t : threads) {
        t.join();
    }
    
    cout << "使用互斥锁的共享数据: " << sharedData << " (正确)" << endl;
}

int main() {
    basicThreadDemo();
    dataRaceDemo();
    mutexDemo();
    
    return 0;
}
```

### 注意事项
- 线程创建后需要join或detach
- 避免数据竞争，使用同步机制
- 理解RAII在资源管理中的应用
- 注意死锁和活锁问题

## 3. 常见用法

### 场景1：生产者-消费者模式
```cpp
#include <queue>
#include <condition_variable>

template<typename T>
class ThreadSafeQueue {
private:
    queue<T> data;
    mutable mutex mtx;
    condition_variable cond;
    
public:
    void push(T value) {
        lock_guard<mutex> lock(mtx);
        data.push(move(value));
        cond.notify_one();  // 通知等待的消费者
    }
    
    T pop() {
        unique_lock<mutex> lock(mtx);
        
        // 等待队列不为空
        cond.wait(lock, [this] { return !data.empty(); });
        
        T value = move(data.front());
        data.pop();
        return value;
    }
    
    bool try_pop(T& value) {
        lock_guard<mutex> lock(mtx);
        if (data.empty()) return false;
        
        value = move(data.front());
        data.pop();
        return true;
    }
    
    size_t size() const {
        lock_guard<mutex> lock(mtx);
        return data.size();
    }
};

void producerConsumerDemo() {
    ThreadSafeQueue<int> queue;
    
    // 生产者线程
    thread producer([&queue]() {
        for (int i = 0; i < 10; ++i) {
            queue.push(i);
            this_thread::sleep_for(chrono::milliseconds(100));
            cout << "生产: " << i << endl;
        }
    });
    
    // 消费者线程
    thread consumer([&queue]() {
        for (int i = 0; i < 10; ++i) {
            int value = queue.pop();
            cout << "消费: " << value << endl;
        }
    });
    
    producer.join();
    consumer.join();
}
```

### 场景2：读写锁模式（C++17）
```cpp
#include <shared_mutex>

template<typename T>
class ThreadSafeData {
private:
    T data;
    mutable shared_mutex mtx;  // 读写锁
    
public:
    // 写操作（独占锁）
    void write(const T& newValue) {
        unique_lock<shared_mutex> lock(mtx);
        data = newValue;
    }
    
    // 读操作（共享锁）
    T read() const {
        shared_lock<shared_mutex> lock(mtx);
        return data;
    }
    
    // 原子更新
    void update(function<void(T&)> updater) {
        unique_lock<shared_mutex> lock(mtx);
        updater(data);
    }
};

void readWriteLockDemo() {
    ThreadSafeData<vector<int>> sharedData;
    
    // 初始化数据
    sharedData.write({1, 2, 3, 4, 5});
    
    vector<thread> readers;
    for (int i = 0; i < 3; ++i) {
        readers.emplace_back([&sharedData, i]() {
            for (int j = 0; j < 5; ++j) {
                auto data = sharedData.read();
                cout << "读者" << i << "读到: " << data.size() << "个元素" << endl;
                this_thread::sleep_for(chrono::milliseconds(50));
            }
        });
    }
    
    // 写线程
    thread writer([&sharedData]() {
        for (int i = 0; i < 3; ++i) {
            sharedData.update([](vector<int>& data) {
                data.push_back(data.size() + 1);
                cout << "写入新元素，总数: " << data.size() << endl;
            });
            this_thread::sleep_for(chrono::milliseconds(200));
        }
    });
    
    for (auto& t : readers) t.join();
    writer.join();
}
```

### 场景3：异步编程与Future
```cpp
#include <future>

int computeFactorial(int n) {
    if (n <= 1) return 1;
    
    int result = 1;
    for (int i = 2; i <= n; ++i) {
        result *= i;
        this_thread::sleep_for(chrono::milliseconds(10));  // 模拟计算时间
    }
    return result;
}

void asyncFutureDemo() {
    cout << "\\n=== 异步编程演示 ===" << endl;
    
    // 异步计算多个阶乘
    auto future1 = async(launch::async, computeFactorial, 10);
    auto future2 = async(launch::async, computeFactorial, 15);
    auto future3 = async(launch::async, computeFactorial, 20);
    
    // 主线程继续执行其他任务
    cout << "等待异步计算结果..." << endl;
    
    // 获取结果（阻塞等待）
    int result1 = future1.get();
    int result2 = future2.get();
    int result3 = future3.get();
    
    cout << "10! = " << result1 << endl;
    cout << "15! = " << result2 << endl;
    cout << "20! = " << result3 << endl;
}

// 使用packaged_task
void packagedTaskDemo() {
    cout << "\\n=== packaged_task演示 ===" << endl;
    
    // 创建任务包装器
    packaged_task<int(int)> task(computeFactorial);
    future<int> result = task.get_future();
    
    // 在单独线程中执行任务
    thread worker(move(task), 8);
    
    // 获取结果
    cout << "8! = " << result.get() << endl;
    
    worker.join();
}
```
```cpp
#include <queue>
#include <condition_variable>

template<typename T>
class ThreadSafeQueue {
private:
    queue<T> data;
    mutable mutex mtx;
    condition_variable cond;
    bool stopped = false;
    
public:
    void push(T value) {
        lock_guard<mutex> lock(mtx);
        data.push(move(value));
        cond.notify_one();
    }
    
    optional<T> pop() {
        unique_lock<mutex> lock(mtx);
        cond.wait(lock, [this] { 
            return !data.empty() || stopped; 
        });
        
        if (data.empty()) return nullopt;
        
        T value = move(data.front());
        data.pop();
        return value;
    }
    
    void stop() {
        lock_guard<mutex> lock(mtx);
        stopped = true;
        cond.notify_all();
    }
    
    bool empty() const {
        lock_guard<mutex> lock(mtx);
        return data.empty();
    }
};

void producerConsumerDemo() {
    cout << "\\n=== 生产者-消费者模式 ===" << endl;
    
    ThreadSafeQueue<int> queue;
    
    // 生产者线程
    thread producer([&queue]() {
        for (int i = 0; i < 10; ++i) {
            queue.push(i);
            this_thread::sleep_for(chrono::milliseconds(100));
            cout << "生产: " << i << endl;
        }
        queue.stop();
    });
    
    // 消费者线程
    thread consumer([&queue]() {
        while (auto value = queue.pop()) {
            cout << "消费: " << *value << endl;
        }
        cout << "消费者结束" << endl;
    });
    
    producer.join();
    consumer.join();
}
```

### 场景2：并行计算
```cpp
#include <future>
#include <numeric>

void parallelComputationDemo() {
    cout << "\\n=== 并行计算 ===" << endl;
    
    vector<int> data(1000000);
    iota(data.begin(), data.end(), 1);
    
    // 串行计算基准
    auto start = chrono::high_resolution_clock::now();
    long long serialSum = accumulate(data.begin(), data.end(), 0LL);
    auto serialTime = chrono::high_resolution_clock::now() - start;
    
    // 并行计算
    start = chrono::high_resolution_clock::now();
    
    const size_t numThreads = thread::hardware_concurrency();
    vector<future<long long>> futures;
    size_t chunkSize = data.size() / numThreads;
    
    for (size_t i = 0; i < numThreads; ++i) {
        auto begin = data.begin() + i * chunkSize;
        auto end = (i == numThreads - 1) ? data.end() : begin + chunkSize;
        
        futures.push_back(async(launch::async, [begin, end]() {
            return accumulate(begin, end, 0LL);
        }));
    }
    
    long long parallelSum = 0;
    for (auto& future : futures) {
        parallelSum += future.get();
    }
    
    auto parallelTime = chrono::high_resolution_clock::now() - start;
    
    cout << "串行结果: " << serialSum << ", 时间: " 
         << chrono::duration_cast<chrono::milliseconds>(serialTime).count() << "ms" << endl;
    cout << "并行结果: " << parallelSum << ", 时间: " 
         << chrono::duration_cast<chrono::milliseconds>(parallelTime).count() << "ms" << endl;
    cout << "加速比: " << static_cast<double>(serialTime.count()) / parallelTime.count() << endl;
}
```

### 场景3：读写锁（C++17）
```cpp
#include <shared_mutex>

template<typename T>
class ThreadSafeValue {
private:
    mutable shared_mutex mtx;
    T value;
    
public:
    ThreadSafeValue(T val = T{}) : value(move(val)) {}
    
    // 读操作（共享锁）
    T get() const {
        shared_lock<shared_mutex> lock(mtx);
        return value;
    }
    
    // 写操作（独占锁）
    void set(T newValue) {
        unique_lock<shared_mutex> lock(mtx);
        value = move(newValue);
    }
    
    // 原子更新
    template<typename Func>
    void update(Func&& func) {
        unique_lock<shared_mutex> lock(mtx);
        func(value);
    }
};

void readWriteLockDemo() {
    cout << "\\n=== 读写锁演示 ===" << endl;
    
    ThreadSafeValue<int> sharedValue(0);
    
    // 多个读者线程
    vector<thread> readers;
    for (int i = 0; i < 5; ++i) {
        readers.emplace_back([&sharedValue, i]() {
            for (int j = 0; j < 10; ++j) {
                int value = sharedValue.get();
                cout << "读者" << i << "读到: " << value << endl;
                this_thread::sleep_for(chrono::milliseconds(50));
            }
        });
    }
    
    // 写者线程
    thread writer([&sharedValue]() {
        for (int i = 1; i <= 5; ++i) {
            sharedValue.set(i * 10);
            cout << "写入: " << i * 10 << endl;
            this_thread::sleep_for(chrono::milliseconds(200));
        }
    });
    
    for (auto& t : readers) t.join();
    writer.join();
}
```

## 4. 易错点/坑

### 错误示例1：数据竞争
```cpp
void dataRaceError() {
    int counter = 0;
    
    thread t1([&counter]() {
        for (int i = 0; i < 10000; ++i) {
            counter++;  // 数据竞争！
        }
    });
    
    thread t2([&counter]() {
        for (int i = 0; i < 10000; ++i) {
            counter++;  // 数据竞争！
        }
    });
    
    t1.join();
    t2.join();
    
    cout << "计数器: " << counter << " (应该为20000)" << endl;
}
```

### 错误示例2：死锁
```cpp
void deadlockError() {
    mutex mtx1, mtx2;
    
    thread t1([&mtx1, &mtx2]() {
        lock_guard<mutex> lock1(mtx1);
        this_thread::sleep_for(chrono::milliseconds(100));
        lock_guard<mutex> lock2(mtx2);  // 可能死锁
    });
    
    thread t2([&mtx1, &mtx2]() {
        lock_guard<mutex> lock2(mtx2);
        this_thread::sleep_for(chrono::milliseconds(100));
        lock_guard<mutex> lock1(mtx1);  // 可能死锁
    });
    
    t1.join();
    t2.join();
}

// 修正：按固定顺序获取锁
void deadlockFixed() {
    mutex mtx1, mtx2;
    
    auto worker = [&mtx1, &mtx2](int id) {
        lock_guard<mutex> lock1(mtx1);  // 总是先获取mtx1
        lock_guard<mutex> lock2(mtx2);  // 然后获取mtx2
        cout << "线程" << id << "获得锁" << endl;
    };
    
    thread t1(worker, 1);
    thread t2(worker, 2);
    
    t1.join();
    t2.join();
}
```

### 错误示例3：忘记join
```cpp
void forgottenJoinError() {
    thread t([]() {
        cout << "线程运行中" << endl;
    });
    
    // 忘记t.join()，程序终止时未定义行为
    
    // 修正：使用RAII包装器
    class ScopedThread {
        thread t;
    public:
        template<typename... Args>
        ScopedThread(Args&&... args) : t(forward<Args>(args)...) {}
        
        ~ScopedThread() {
            if (t.joinable()) t.join();
        }
        
        // 禁用拷贝
        ScopedThread(const ScopedThread&) = delete;
        ScopedThread& operator=(const ScopedThread&) = delete;
    };
    
    ScopedThread safeThread([]() {
        cout << "安全线程运行" << endl;
    });
}
```

### 错误示例4：虚假唤醒
```cpp
void spuriousWakeupError() {
    mutex mtx;
    condition_variable cv;
    bool ready = false;
    
    thread consumer([&]() {
        unique_lock<mutex> lock(mtx);
        
        // 错误：可能虚假唤醒
        // cv.wait(lock);
        
        // 正确：使用条件检查
        cv.wait(lock, [&ready] { return ready; });
        
        cout << "条件满足" << endl;
    });
    
    this_thread::sleep_for(chrono::milliseconds(100));
    
    {
        lock_guard<mutex> lock(mtx);
        ready = true;
    }
    cv.notify_one();
    
    consumer.join();
}
```

## 5. 拓展补充

### 关联知识点

#### 线程局部存储
```cpp
thread_local int threadSpecificValue = 0;

void threadLocalDemo() {
    vector<thread> threads;
    
    for (int i = 0; i < 3; ++i) {
        threads.emplace_back([i]() {
            threadSpecificValue = i + 1;
            this_thread::sleep_for(chrono::milliseconds(100));
            cout << "线程" << i << "的值: " << threadSpecificValue << endl;
        });
    }
    
    for (auto& t : threads) t.join();
}
```

#### 原子操作内存顺序
```cpp
void memoryOrderDemo() {
    atomic<int> x(0), y(0);
    
    thread t1([&]() {
        x.store(1, memory_order_relaxed);
        y.store(1, memory_order_release);
    });
    
    thread t2([&]() {
        while (y.load(memory_order_acquire) != 1) {
            // 自旋等待
        }
        cout << "x = " << x.load(memory_order_relaxed) << endl;  // 保证看到x=1
    });
    
    t1.join();
    t2.join();
}
```

### 进阶延伸

#### 线程池实现
```cpp
class SimpleThreadPool {
    vector<thread> workers;
    queue<function<void()>> tasks;
    mutex queueMutex;
    condition_variable condition;
    bool stop = false;
    
public:
    SimpleThreadPool(size_t threads) {
        for (size_t i = 0; i < threads; ++i) {
            workers.emplace_back([this] {
                while (true) {
                    function<void()> task;
                    {
                        unique_lock<mutex> lock(queueMutex);
                        condition.wait(lock, [this] {
                            return stop || !tasks.empty();
                        });
                        
                        if (stop && tasks.empty()) return;
                        
                        task = move(tasks.front());
                        tasks.pop();
                    }
                    task();
                }
            });
        }
    }
    
    template<class F>
    void enqueue(F&& f) {
        {
            lock_guard<mutex> lock(queueMutex);
            tasks.emplace(forward<F>(f));
        }
        condition.notify_one();
    }
    
    ~SimpleThreadPool() {
        {
            lock_guard<mutex> lock(queueMutex);
            stop = true;
        }
        condition.notify_all();
        for (thread& worker : workers) {
            worker.join();
        }
    }
};
```

#### 并行算法（C++17）
```cpp
void parallelAlgorithmsDemo() {
    vector<int> data(1000000);
    generate(data.begin(), data.end(), []() {
        return rand() % 1000;
    });
    
    // 并行排序
    sort(execution::par, data.begin(), data.end());
    
    // 并行查找
    auto it = find(execution::par, data.begin(), data.end(), 42);
    
    // 并行累加
    int sum = reduce(execution::par, data.begin(), data.end());
    
    cout << "并行算法演示完成" << endl;
}
```

#### 协程（C++20）概念
```cpp
// C++20协程示例（概念性）
/*
generator<int> fibonacci() {
    int a = 0, b = 1;
    while (true) {
        co_yield a;
        tie(a, b) = make_pair(b, a + b);
    }
}

void coroutineDemo() {
    auto gen = fibonacci();
    for (int i = 0; i < 10; ++i) {
        cout << gen() << " ";
    }
    cout << endl;
}
*/
```

### 性能优化技巧

1. **减少锁竞争**：使用细粒度锁或无锁数据结构
2. **合理线程数量**：根据硬件并发数调整
3. **避免虚假共享**：对齐关键数据到缓存行
4. **使用线程局部存储**：减少同步开销
5. **批处理任务**：减少线程创建销毁开销

## 总结

多线程编程是现代C++高性能应用的关键技术：

1. **理解线程基础**：线程创建、同步、通信
2. **掌握同步机制**：互斥锁、条件变量、原子操作
3. **避免常见错误**：数据竞争、死锁、忘记join
4. **使用现代特性**：读写锁、并行算法、线程池
5. **注重性能优化**：减少锁竞争，合理利用硬件

通过合理的多线程设计，可以充分利用多核处理器性能，构建高并发、高性能的应用程序。