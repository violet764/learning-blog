# 迭代器与算法

## 1. 核心概念

### 定义
- **迭代器**：提供访问容器元素的方法，是容器和算法之间的桥梁
- **算法**：对数据序列执行特定操作的函数模板
- **迭代器类别**：根据功能划分的迭代器类型（输入、输出、前向、双向、随机访问）
- **算法泛型**：通过迭代器实现与容器类型的解耦

### 关键特性
- **统一接口**：所有STL容器提供相似的迭代器接口
- **范围操作**：算法通过迭代器范围操作数据
- **性能保证**：不同迭代器类别提供不同的性能特性
- **组合性**：算法可以组合使用形成数据处理管道

## 2. 语法规则

### 基本语法
```cpp
#include <algorithm>  // 算法头文件
#include <iterator>   // 迭代器头文件

// 迭代器声明和使用
容器类型::iterator it;        // 可修改的迭代器
容器类型::const_iterator cit; // 只读迭代器

// 算法调用格式
算法名(起始迭代器, 结束迭代器, 其他参数...);
```

### 代码示例
```cpp
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>
#include <iterator>
#include <numeric>
using namespace std;

// 迭代器类别演示
void iteratorCategoriesDemo() {
    cout << "=== 迭代器类别演示 ===" << endl;
    
    vector<int> vec = {1, 2, 3, 4, 5};
    list<int> lst = {5, 4, 3, 2, 1};
    
    // 1. 随机访问迭代器（vector）
    cout << "vector（随机访问迭代器）:" << endl;
    auto vecIt = vec.begin();
    cout << "第一个元素: " << *vecIt << endl;
    cout << "第三个元素: " << vecIt[2] << endl;  // 随机访问
    vecIt += 3;  // 随机跳跃
    cout << "跳跃后元素: " << *vecIt << endl;
    
    // 2. 双向迭代器（list）
    cout << "\\nlist（双向迭代器）:" << endl;
    auto lstIt = lst.begin();
    cout << "第一个元素: " << *lstIt << endl;
    ++lstIt;  // 前向移动
    cout << "第二个元素: " << *lstIt << endl;
    --lstIt;  // 反向移动
    cout << "回到第一个: " << *lstIt << endl;
    
    // 3. 输入/输出迭代器演示
    cout << "\\n输入输出迭代器:" << endl;
    vector<int> source = {1, 2, 3};
    vector<int> destination(3);
    
    // 使用输入迭代器读取，输出迭代器写入
    copy(source.begin(), source.end(), destination.begin());
    
    cout << "复制结果: ";
    for (int num : destination) {
        cout << num << " ";
    }
    cout << endl;
}

// 常用算法演示
void algorithmsDemo() {
    cout << "\\n=== 常用算法演示 ===" << endl;
    
    vector<int> numbers = {5, 2, 8, 1, 9, 3, 7, 4, 6};
    
    // 1. 非修改序列算法
    cout << "非修改算法:" << endl;
    
    // 查找
    auto it = find(numbers.begin(), numbers.end(), 3);
    if (it != numbers.end()) {
        cout << "找到3，位置: " << distance(numbers.begin(), it) << endl;
    }
    
    // 计数
    int countFives = count(numbers.begin(), numbers.end(), 5);
    cout << "5出现的次数: " << countFives << endl;
    
    // 条件计数
    int countEven = count_if(numbers.begin(), numbers.end(),
                            [](int x) { return x % 2 == 0; });
    cout << "偶数个数: " << countEven << endl;
    
    // 2. 修改序列算法
    cout << "\\n修改算法:" << endl;
    
    // 复制
    vector<int> copied(numbers.size());
    copy(numbers.begin(), numbers.end(), copied.begin());
    cout << "复制结果: ";
    for (int num : copied) cout << num << " ";
    cout << endl;
    
    // 变换
    vector<int> squared(numbers.size());
    transform(numbers.begin(), numbers.end(), squared.begin(),
             [](int x) { return x * x; });
    cout << "平方变换: ";
    for (int num : squared) cout << num << " ";
    cout << endl;
    
    // 填充
    vector<int> filled(5);
    fill(filled.begin(), filled.end(), 42);
    cout << "填充42: ";
    for (int num : filled) cout << num << " ";
    cout << endl;
    
    // 3. 排序和相关算法
    cout << "\\n排序算法:" << endl;
    
    // 排序
    sort(numbers.begin(), numbers.end());
    cout << "排序后: ";
    for (int num : numbers) cout << num << " ";
    cout << endl;
    
    // 二分查找（要求有序）
    bool found = binary_search(numbers.begin(), numbers.end(), 7);
    cout << "二分查找7: " << (found ? "找到" : "未找到") << endl;
    
    // 合并两个有序序列
    vector<int> nums1 = {1, 3, 5};
    vector<int> nums2 = {2, 4, 6};
    vector<int> merged(6);
    merge(nums1.begin(), nums1.end(), nums2.begin(), nums2.end(), merged.begin());
    cout << "合并有序序列: ";
    for (int num : merged) cout << num << " ";
    cout << endl;
}

// 数值算法演示
void numericAlgorithmsDemo() {
    cout << "\\n=== 数值算法演示 ===" << endl;
    
    vector<int> numbers = {1, 2, 3, 4, 5};
    
    // 累加
    int sum = accumulate(numbers.begin(), numbers.end(), 0);
    cout << "累加和: " << sum << endl;
    
    // 带操作的累加
    int product = accumulate(numbers.begin(), numbers.end(), 1,
                            [](int a, int b) { return a * b; });
    cout << "累乘积: " << product << endl;
    
    // 内积
    vector<int> v1 = {1, 2, 3};
    vector<int> v2 = {4, 5, 6};
    int dotProduct = inner_product(v1.begin(), v1.end(), v2.begin(), 0);
    cout << "内积: " << dotProduct << endl;
    
    // 相邻差
    vector<int> diffs(numbers.size());
    adjacent_difference(numbers.begin(), numbers.end(), diffs.begin());
    cout << "相邻差: ";
    for (int diff : diffs) cout << diff << " ";
    cout << endl;
    
    // 部分和
    vector<int> partialSums(numbers.size());
    partial_sum(numbers.begin(), numbers.end(), partialSums.begin());
    cout << "部分和: ";
    for (int sum : partialSums) cout << sum << " ";
    cout << endl;
}

int main() {
    iteratorCategoriesDemo();
    algorithmsDemo();
    numericAlgorithmsDemo();
    
    return 0;
}
```

### 注意事项
- 算法通过迭代器操作，不直接接触容器
- 确保迭代器范围有效（[first, last)）
- 修改算法可能使迭代器失效
- 排序算法要求随机访问迭代器

## 3. 常见用法

### 场景1：数据过滤和转换管道
```cpp
#include <vector>
#include <algorithm>
#include <iterator>
#include <string>

void dataProcessingPipeline() {
    cout << "=== 数据处理管道 ===" << endl;
    
    vector<int> data = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    // 管道：过滤偶数 → 转换为字符串 → 连接
    
    // 1. 过滤：保留大于5的偶数
    vector<int> filtered;
    copy_if(data.begin(), data.end(), back_inserter(filtered),
            [](int x) { return x > 5 && x % 2 == 0; });
    
    cout << "过滤后: ";
    for (int x : filtered) cout << x << " ";
    cout << endl;
    
    // 2. 转换：数字转为字符串
    vector<string> strings;
    transform(filtered.begin(), filtered.end(), back_inserter(strings),
             [](int x) { return "数字" + to_string(x); });
    
    cout << "转换后: ";
    for (const string& s : strings) cout << s << " ";
    cout << endl;
    
    // 3. 复杂转换：创建对象
    struct NumberInfo {
        int value;
        string description;
        bool isPrime;
        
        NumberInfo(int v) : value(v) {
            description = "数值: " + to_string(v);
            // 简单素数检测
            isPrime = (v > 1);
            for (int i = 2; i * i <= v; ++i) {
                if (v % i == 0) {
                    isPrime = false;
                    break;
                }
            }
        }
    };
    
    vector<NumberInfo> infos;
    transform(filtered.begin(), filtered.end(), back_inserter(infos),
             [](int x) { return NumberInfo(x); });
    
    cout << "对象信息:" << endl;
    for (const auto& info : infos) {
        cout << info.description << " (素数: " << (info.isPrime ? "是" : "否") << ")" << endl;
    }
}
```

### 场景2：自定义算法和迭代器适配器
```cpp
#include <iostream>
#include <vector>
#include <iterator>
#include <algorithm>

// 自定义算法：滑动窗口平均值
template<typename InputIt, typename OutputIt>
void slidingWindowAverage(InputIt first, InputIt last, OutputIt dest, size_t windowSize) {
    if (distance(first, last) < windowSize) {
        return;
    }
    
    auto windowStart = first;
    auto windowEnd = next(first, windowSize);
    
    while (windowEnd <= last) {
        double sum = accumulate(windowStart, windowEnd, 0.0);
        *dest = sum / windowSize;
        ++dest;
        ++windowStart;
        ++windowEnd;
    }
}

// 自定义迭代器：步长迭代器
template<typename Iterator>
class StrideIterator {
private:
    Iterator current;
    Iterator end;
    size_t stride;
    
public:
    using iterator_category = typename iterator_traits<Iterator>::iterator_category;
    using value_type = typename iterator_traits<Iterator>::value_type;
    using difference_type = typename iterator_traits<Iterator>::difference_type;
    using pointer = typename iterator_traits<Iterator>::pointer;
    using reference = typename iterator_traits<Iterator>::reference;
    
    StrideIterator(Iterator start, Iterator end, size_t s)
        : current(start), end(end), stride(s) {}
    
    reference operator*() const { return *current; }
    pointer operator->() const { return &(*current); }
    
    StrideIterator& operator++() {
        if (distance(current, end) >= stride) {
            advance(current, stride);
        } else {
            current = end;
        }
        return *this;
    }
    
    StrideIterator operator++(int) {
        StrideIterator temp = *this;
        ++(*this);
        return temp;
    }
    
    bool operator==(const StrideIterator& other) const {
        return current == other.current;
    }
    
    bool operator!=(const StrideIterator& other) const {
        return !(*this == other);
    }
};

void customAlgorithmsDemo() {
    cout << "\\n=== 自定义算法和迭代器 ===" << endl;
    
    vector<int> data = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    // 使用自定义滑动窗口算法
    vector<double> averages;
    slidingWindowAverage(data.begin(), data.end(), back_inserter(averages), 3);
    
    cout << "滑动窗口平均值(窗口大小3): ";
    for (double avg : averages) {
        cout << avg << " ";
    }
    cout << endl;
    
    // 使用自定义步长迭代器
    cout << "步长迭代器(步长2): ";
    StrideIterator<vector<int>::iterator> begin(data.begin(), data.end(), 2);
    StrideIterator<vector<int>::iterator> end(data.end(), data.end(), 2);
    
    for (auto it = begin; it != end; ++it) {
        cout << *it << " ";
    }
    cout << endl;
    
    // 结合STL算法使用自定义迭代器
    cout << "步长迭代器找最大值: ";
    auto maxIt = max_element(begin, end);
    if (maxIt != end) {
        cout << *maxIt << endl;
    }
}
```

### 场景3：复杂数据查询和操作
```cpp
#include <vector>
#include <algorithm>
#include <string>
#include <map>

struct Employee {
    int id;
    string name;
    string department;
    double salary;
    int yearsOfService;
    
    Employee(int i, string n, string d, double s, int y)
        : id(i), name(n), department(d), salary(s), yearsOfService(y) {}
    
    friend ostream& operator<<(ostream& os, const Employee& e) {
        os << e.name << " (ID: " << e.id << ", 部门: " << e.department
           << ", 薪资: " << e.salary << ", 工龄: " << e.yearsOfService << ")";
        return os;
    }
};

void complexQueriesDemo() {
    cout << "\\n=== 复杂数据查询 ===" << endl;
    
    vector<Employee> employees = {
        Employee(1, "Alice", "技术部", 80000, 3),
        Employee(2, "Bob", "销售部", 60000, 1),
        Employee(3, "Charlie", "技术部", 90000, 5),
        Employee(4, "Diana", "人事部", 75000, 2),
        Employee(5, "Eve", "技术部", 85000, 4),
        Employee(6, "Frank", "销售部", 65000, 2)
    };
    
    // 1. 部门分组统计
    map<string, vector<Employee>> byDepartment;
    for (const auto& emp : employees) {
        byDepartment[emp.department].push_back(emp);
    }
    
    cout << "按部门分组:" << endl;
    for (const auto& dept : byDepartment) {
        cout << dept.first << " (": << dept.second.size() << "人):" << endl;
        for (const auto& emp : dept.second) {
            cout << "  " << emp << endl;
        }
    }
    
    // 2. 复杂查询：高薪技术部员工
    cout << "\\n高薪技术部员工(薪资>80000):" << endl;
    vector<Employee> highPaidTech;
    copy_if(employees.begin(), employees.end(), back_inserter(highPaidTech),
            [](const Employee& e) {
                return e.department == "技术部" && e.salary > 80000;
            });
    
    for (const auto& emp : highPaidTech) {
        cout << emp << endl;
    }
    
    // 3. 排序：按薪资降序，工龄升序
    sort(employees.begin(), employees.end(),
         [](const Employee& a, const Employee& b) {
             if (a.salary != b.salary) {
                 return a.salary > b.salary;  // 薪资降序
             }
             return a.yearsOfService < b.yearsOfService;  // 工龄升序
         });
    
    cout << "\\n综合排序结果:" << endl;
    for (const auto& emp : employees) {
        cout << emp << endl;
    }
    
    // 4. 分区：将高薪员工移到前面
    auto highSalaryBoundary = partition(employees.begin(), employees.end(),
                                       [](const Employee& e) {
                                           return e.salary >= 80000;
                                       });
    
    cout << "\\n分区结果(高薪>=80000在前):" << endl;
    cout << "高薪员工:" << endl;
    for (auto it = employees.begin(); it != highSalaryBoundary; ++it) {
        cout << "  " << *it << endl;
    }
    
    cout << "其他员工:" << endl;
    for (auto it = highSalaryBoundary; it != employees.end(); ++it) {
        cout << "  " << *it << endl;
    }
    
    // 5. 数值计算：部门平均薪资
    cout << "\\n部门平均薪资:" << endl;
    for (const auto& dept : byDepartment) {
        double totalSalary = accumulate(dept.second.begin(), dept.second.end(), 0.0,
                                       [](double sum, const Employee& e) {
                                           return sum + e.salary;
                                       });
        double avgSalary = totalSalary / dept.second.size();
        cout << dept.first << ": " << avgSalary << endl;
    }
}
```

## 4. 易错点/坑

### 错误示例1：迭代器失效
```cpp
void iteratorInvalidationMistake() {
    vector<int> vec = {1, 2, 3, 4, 5};
    
    // 错误：在迭代过程中修改容器
    for (auto it = vec.begin(); it != vec.end(); ++it) {
        if (*it % 2 == 0) {
            vec.erase(it);  // 迭代器失效！
        }
    }
    
    // 错误：在算法执行期间修改容器
    auto it = remove_if(vec.begin(), vec.end(),
                       [](int x) { return x % 2 == 0; });
    
    // 在remove_if之后直接使用原迭代器
    cout << *vec.begin() << endl;  // 可能无效
}
```
**原因**：修改容器会使指向该容器的迭代器失效
**修正方案**：
```cpp
void safeIteratorUsage() {
    vector<int> vec = {1, 2, 3, 4, 5};
    
    // 正确方式1：使用erase的返回值
    for (auto it = vec.begin(); it != vec.end(); ) {
        if (*it % 2 == 0) {
            it = vec.erase(it);  // erase返回下一个有效迭代器
        } else {
            ++it;
        }
    }
    
    // 正确方式2：使用remove-erase惯用法
    vec.erase(remove_if(vec.begin(), vec.end(),
                       [](int x) { return x % 2 == 0; }),
             vec.end());
    
    // 正确方式3：使用算法返回值
    auto newEnd = remove_if(vec.begin(), vec.end(),
                           [](int x) { return x % 2 == 0; });
    
    // 只在有效范围内使用迭代器
    for (auto it = vec.begin(); it != newEnd; ++it) {
        cout << *it << " ";
    }
    cout << endl;
}
```

### 错误示例2：错误的算法前提条件
```cpp
void algorithmPreconditionMistake() {
    vector<int> unsorted = {5, 3, 1, 4, 2};
    
    // 错误：对未排序序列使用二分查找
    bool found = binary_search(unsorted.begin(), unsorted.end(), 3);
    cout << "二分查找结果: " << found << endl;  // 未定义行为
    
    list<int> lst = {1, 2, 3, 4, 5};
    
    // 错误：对双向迭代器使用需要随机访问的算法
    // sort(lst.begin(), lst.end());  // 编译错误
    
    // 错误：输出迭代器范围重叠
    vector<int> source = {1, 2, 3};
    vector<int> dest(3);
    
    // 如果源和目标范围重叠，结果未定义
    // copy(source.begin(), source.end(), source.begin() + 1);  // 危险！
}
```
**原因**：算法有特定的前提条件要求
**修正方案**：
```cpp
void correctAlgorithmUsage() {
    vector<int> unsorted = {5, 3, 1, 4, 2};
    
    // 正确：先排序再二分查找
    sort(unsorted.begin(), unsorted.end());
    bool found = binary_search(unsorted.begin(), unsorted.end(), 3);
    cout << "正确二分查找结果: " << found << endl;
    
    list<int> lst = {1, 2, 3, 4, 5};
    
    // 正确：使用容器特定的排序方法
    lst.sort();  // list有自己的sort成员函数
    
    // 正确：确保输出范围不重叠
    vector<int> source = {1, 2, 3};
    vector<int> dest(source.size());
    
    // 使用不重叠的范围
    copy(source.begin(), source.end(), dest.begin());
    
    // 或者使用安全的算法版本
    copy_backward(source.begin(), source.end(), dest.end());
}
```

### 错误示例3：性能陷阱
```cpp
void performancePitfall() {
    vector<int> largeVec(1000000);
    iota(largeVec.begin(), largeVec.end(), 1);  // 填充1-1000000
    
    // 低效：多次线性搜索
    for (int i = 1; i <= 1000; ++i) {
        auto it = find(largeVec.begin(), largeVec.end(), i);
        if (it != largeVec.end()) {
            // 处理找到的元素
        }
    }
    
    // 低效：不必要的数据复制
    vector<int> temp = largeVec;  // 不必要的大数据复制
    sort(temp.begin(), temp.end());
    
    // 低效：频繁的容器修改
    list<int> lst(largeVec.begin(), largeVec.end());
    for (int i = 0; i < 1000; ++i) {
        lst.push_front(i);  // 链表前端插入高效，但频繁修改仍可能影响性能
    }
}
```
**原因**：不了解算法复杂度和容器特性
**修正方案**：
```cpp
void performanceOptimized() {
    vector<int> largeVec(1000000);
    iota(largeVec.begin(), largeVec.end(), 1);
    
    // 高效：使用排序和二分查找
    sort(largeVec.begin(), largeVec.end());
    for (int i = 1; i <= 1000; ++i) {
        bool found = binary_search(largeVec.begin(), largeVec.end(), i);
        // O(log n) 而不是 O(n)
    }
    
    // 高效：避免不必要的数据复制
    // 如果不需要修改原数据，直接排序
    sort(largeVec.begin(), largeVec.end());
    
    // 或者使用引用/指针避免复制
    vector<int>& vecRef = largeVec;  // 使用引用
    
    // 高效：批量操作而不是频繁单次操作
    vector<int> toAdd(1000);
    iota(toAdd.begin(), toAdd.end(), 2000000);
    
    // 批量插入而不是循环插入
    largeVec.insert(largeVec.end(), toAdd.begin(), toAdd.end());
}
```

## 5. 拓展补充

### 关联知识点
- **迭代器特征（iterator_traits）**：获取迭代器类型信息
- **分配器（allocator）**：内存管理组件
- **执行策略（C++17）**：并行算法支持
- **范围（C++20）**：更简洁的算法接口

### 进阶延伸
- **自定义算法**：编写模板算法处理特定需求
- **迭代器适配器**：reverse_iterator、move_iterator等
- **并行算法**：利用多核处理器提高性能
- **概念约束（C++20）**：更严格的模板参数检查