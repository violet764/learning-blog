# 代码规范

## 1. 核心概念
- 定义：代码规范是保证代码可读性、可维护性和一致性的规则集合
- 关键特性：命名约定、格式标准、注释规范、架构原则

## 2. 语法规则
- 基本语法：遵循特定的编码风格和最佳实践
- 代码示例：

### 符合规范的C++代码示例
```cpp
// math_utils.h - 数学工具头文件
#ifndef MATH_UTILS_H
#define MATH_UTILS_H

#include <vector>
#include <stdexcept>

namespace math {

/// @brief 数学工具类，提供基本数学运算
class MathUtils {
public:
    /// @brief 计算数字列表的平均值
    /// @param numbers 数字列表
    /// @return 平均值
    /// @throws std::invalid_argument 如果列表为空
    static double calculateAverage(const std::vector<double>& numbers);
    
    /// @brief 计算阶乘
    /// @param n 非负整数
    /// @return n的阶乘
    /// @throws std::invalid_argument 如果n为负数
    static long long factorial(int n);
    
    /// @brief 判断数字是否为素数
    /// @param number 要检查的数字
    /// @return 如果是素数返回true，否则返回false
    static bool isPrime(int number);
};

} // namespace math

#endif // MATH_UTILS_H
```

```cpp
// math_utils.cpp - 数学工具实现
#include "math_utils.h"
#include <cmath>
#include <algorithm>

namespace math {

double MathUtils::calculateAverage(const std::vector<double>& numbers) {
    if (numbers.empty()) {
        throw std::invalid_argument("数字列表不能为空");
    }
    
    double sum = 0.0;
    for (double number : numbers) {
        sum += number;
    }
    
    return sum / numbers.size();
}

long long MathUtils::factorial(int n) {
    if (n < 0) {
        throw std::invalid_argument("阶乘只能计算非负整数");
    }
    
    if (n == 0 || n == 1) {
        return 1;
    }
    
    long long result = 1;
    for (int i = 2; i <= n; ++i) {
        result *= i;
    }
    
    return result;
}

bool MathUtils::isPrime(int number) {
    if (number < 2) {
        return false;
    }
    
    if (number == 2) {
        return true;
    }
    
    if (number % 2 == 0) {
        return false;
    }
    
    int sqrt_num = static_cast<int>(std::sqrt(number));
    for (int i = 3; i <= sqrt_num; i += 2) {
        if (number % i == 0) {
            return false;
        }
    }
    
    return true;
}

} // namespace math
```

```cpp
// main.cpp - 主程序文件，展示规范用法
#include <iostream>
#include <vector>
#include "math_utils.h"

// 使用命名空间别名提高可读性
namespace mu = math;

/// @brief 演示数学工具类的使用
void demonstrateMathUtils() {
    std::vector<double> test_numbers = {1.5, 2.5, 3.5, 4.5, 5.5};
    
    try {
        double average = mu::MathUtils::calculateAverage(test_numbers);
        std::cout << "平均值: " << average << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "计算平均值错误: " << e.what() << std::endl;
    }
    
    // 测试素数判断
    std::vector<int> test_primes = {2, 3, 17, 25, 29};
    for (int num : test_primes) {
        bool is_prime = mu::MathUtils::isPrime(num);
        std::cout << num << " 是" << (is_prime ? "" : "不") << "素数" << std::endl;
    }
}

/// @brief 演示智能指针和RAII的使用
void demonstrateSmartPointers() {
    // 使用智能指针自动管理资源
    auto numbers = std::make_unique<std::vector<int>>();
    numbers->push_back(1);
    numbers->push_back(2);
    numbers->push_back(3);
    
    // 使用范围for循环
    for (const auto& num : *numbers) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    
    // 智能指针自动释放内存
}

int main() {
    std::cout << "=== C++代码规范示例 ===" << std::endl;
    
    demonstrateMathUtils();
    demonstrateSmartPointers();
    
    return 0;
}
```
- 注意事项：一致性、可读性、可维护性、性能考虑

## 3. 常见用法
- 场景1：Google C++风格指南示例
```cpp
// 文件名：my_class.h
#ifndef MY_PROJECT_MY_CLASS_H_
#define MY_PROJECT_MY_CLASS_H_

#include <string>
#include <vector>

namespace my_project {

// 类名使用大驼峰命名法
class MyClass {
public:
    // 构造函数使用explicit避免隐式转换
    explicit MyClass(const std::string& name);
    
    // 方法名使用小驼峰命名法
    void doSomethingImportant();
    
    // 常量使用k前缀
    static constexpr int kDefaultSize = 100;
    
private:
    // 成员变量使用下划线后缀
    std::string name_;
    std::vector<int> data_;
};

} // namespace my_project

#endif // MY_PROJECT_MY_CLASS_H_
```

- 场景2：现代C++最佳实践
```cpp
#include <memory>
#include <algorithm>
#include <type_traits>

// 使用auto和类型推导
void modernCppExamples() {
    // 使用auto避免冗长的类型声明
    auto numbers = std::vector<int>{1, 2, 3, 4, 5};
    
    // 使用lambda表达式
    auto is_even = [](int n) { return n % 2 == 0; };
    
    // 使用算法和函数式编程
    auto even_numbers = std::vector<int>{};
    std::copy_if(numbers.begin(), numbers.end(), 
                std::back_inserter(even_numbers), is_even);
    
    // 使用结构化绑定（C++17）
    std::map<std::string, int> scores = {{"Alice", 90}, {"Bob", 85}};
    for (const auto& [name, score] : scores) {
        std::cout << name << ": " << score << std::endl;
    }
}

// 使用移动语义优化性能
class ResourceManager {
private:
    std::unique_ptr<int[]> data_;
    size_t size_;
    
public:
    // 移动构造函数
    ResourceManager(ResourceManager&& other) noexcept
        : data_(std::move(other.data_))
        , size_(other.size_) {
        other.size_ = 0;
    }
    
    // 移动赋值运算符
    ResourceManager& operator=(ResourceManager&& other) noexcept {
        if (this != &other) {
            data_ = std::move(other.data_);
            size_ = other.size_;
            other.size_ = 0;
        }
        return *this;
    }
};
```

## 4. 易错点/坑
- 错误示例：
```cpp
// 不符合规范的代码
class badclass{  // 缺少空格，类名不规范
    int x,y;     // 多个变量声明在一行
    void badmethod(){  // 括号位置不规范
    if(x==0){    // 缺少空格
    cout<<"error";  // 使用C风格输出
    }
    }
};
```
- 原因：格式混乱，命名不规范，使用过时特性
- 修正方案：遵循一致的代码风格

- 错误示例：
```cpp
// 内存管理错误
void memoryLeak() {
    int* ptr = new int[100];
    // 使用ptr...
    // 忘记delete[] ptr;  // 内存泄漏！
}
```
- 原因：手动内存管理容易出错
- 修正方案：使用智能指针
```cpp
void safeMemoryManagement() {
    auto ptr = std::make_unique<int[]>(100);
    // 自动管理内存
}
```

## 5. 拓展补充
- 关联知识点：设计模式、重构技术、代码审查、静态分析
- 进阶延伸：领域特定语言、代码生成工具、自动化代码格式化、代码质量度量