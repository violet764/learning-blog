# 设计模式应用

## 1. 核心概念
- 定义：实现常见的设计模式（单例、工厂、观察者等）在实际项目中的应用
- 关键特性：代码复用、解耦合、可维护性、可扩展性

## 2. 语法规则
- 基本语法：使用类继承、接口抽象、模板方法、智能指针
- 代码示例：

### 单例模式 (Singleton)
```cpp
#include <iostream>
#include <memory>
#include <mutex>

class Logger {
private:
    static std::unique_ptr<Logger> instance;
    static std::mutex mutex;
    
    Logger() { std::cout << "Logger实例创建" << std::endl; }
    
public:
    // 删除拷贝构造函数和赋值运算符
    Logger(const Logger&) = delete;
    Logger& operator=(const Logger&) = delete;
    
    // 获取单例实例（线程安全）
    static Logger& getInstance() {
        std::lock_guard<std::mutex> lock(mutex);
        if (!instance) {
            instance = std::unique_ptr<Logger>(new Logger());
        }
        return *instance;
    }
    
    void log(const std::string& message) {
        std::cout << "[LOG] " << message << std::endl;
    }
    
    void error(const std::string& message) {
        std::cout << "[ERROR] " << message << std::endl;
    }
};

// 静态成员初始化
std::unique_ptr<Logger> Logger::instance = nullptr;
std::mutex Logger::mutex;
```

### 工厂模式 (Factory)
```cpp
#include <memory>
#include <map>
#include <functional>

// 抽象产品类
class Shape {
public:
    virtual ~Shape() = default;
    virtual void draw() const = 0;
    virtual double area() const = 0;
};

// 具体产品类
class Circle : public Shape {
private:
    double radius;
    
public:
    Circle(double r) : radius(r) {}
    
    void draw() const override {
        std::cout << "绘制圆形，半径: " << radius << std::endl;
    }
    
    double area() const override {
        return 3.14159 * radius * radius;
    }
};

class Rectangle : public Shape {
private:
    double width, height;
    
public:
    Rectangle(double w, double h) : width(w), height(h) {}
    
    void draw() const override {
        std::cout << "绘制矩形，宽度: " << width << ", 高度: " << height << std::endl;
    }
    
    double area() const override {
        return width * height;
    }
};

// 工厂类
class ShapeFactory {
public:
    enum ShapeType { CIRCLE, RECTANGLE };
    
    static std::unique_ptr<Shape> createShape(ShapeType type, double param1 = 0, double param2 = 0) {
        switch (type) {
            case CIRCLE:
                return std::make_unique<Circle>(param1);
            case RECTANGLE:
                return std::make_unique<Rectangle>(param1, param2);
            default:
                throw std::invalid_argument("不支持的形状类型");
        }
    }
};
```

### 观察者模式 (Observer)
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <memory>

// 观察者接口
class Observer {
public:
    virtual ~Observer() = default;
    virtual void update(const std::string& message) = 0;
};

// 具体观察者
class User : public Observer {
private:
    std::string name;
    
public:
    User(const std::string& n) : name(n) {}
    
    void update(const std::string& message) override {
        std::cout << name << " 收到消息: " << message << std::endl;
    }
};

// 主题类（被观察者）
class Subject {
private:
    std::vector<Observer*> observers;
    std::string state;
    
public:
    void attach(Observer* observer) {
        observers.push_back(observer);
    }
    
    void detach(Observer* observer) {
        observers.erase(std::remove(observers.begin(), observers.end(), observer), 
                       observers.end());
    }
    
    void notify() {
        for (Observer* observer : observers) {
            observer->update(state);
        }
    }
    
    void setState(const std::string& newState) {
        state = newState;
        notify();
    }
    
    std::string getState() const {
        return state;
    }
};

// 测试代码
int main() {
    std::cout << "=== 单例模式测试 ===" << std::endl;
    Logger::getInstance().log("应用程序启动");
    Logger::getInstance().error("发生了一个错误");
    
    std::cout << "\n=== 工厂模式测试 ===" << std::endl;
    auto circle = ShapeFactory::createShape(ShapeFactory::CIRCLE, 5.0);
    auto rectangle = ShapeFactory::createShape(ShapeFactory::RECTANGLE, 4.0, 6.0);
    
    circle->draw();
    std::cout << "圆形面积: " << circle->area() << std::endl;
    
    rectangle->draw();
    std::cout << "矩形面积: " << rectangle->area() << std::endl;
    
    std::cout << "\n=== 观察者模式测试 ===" << std::endl;
    Subject newsPublisher;
    
    User user1("张三");
    User user2("李四");
    User user3("王五");
    
    newsPublisher.attach(&user1);
    newsPublisher.attach(&user2);
    
    newsPublisher.setState("最新消息：C++20标准发布！");
    
    newsPublisher.detach(&user1);
    newsPublisher.attach(&user3);
    
    newsPublisher.setState("更新：编译器支持情况公布");
    
    return 0;
}
```
- 注意事项：线程安全、资源管理、接口设计

## 3. 常见用法
- 场景1：策略模式实现支付系统
```cpp
#include <memory>

// 支付策略接口
class PaymentStrategy {
public:
    virtual ~PaymentStrategy() = default;
    virtual bool pay(double amount) = 0;
};

// 具体支付策略
class CreditCardPayment : public PaymentStrategy {
public:
    bool pay(double amount) override {
        std::cout << "使用信用卡支付: $" << amount << std::endl;
        // 实际的信用卡支付逻辑
        return true;
    }
};

class PayPalPayment : public PaymentStrategy {
public:
    bool pay(double amount) override {
        std::cout << "使用PayPal支付: $" << amount << std::endl;
        // 实际的PayPal支付逻辑
        return true;
    }
};

class AlipayPayment : public PaymentStrategy {
public:
    bool pay(double amount) override {
        std::cout << "使用支付宝支付: ¥" << amount << std::endl;
        // 实际的支付宝支付逻辑
        return true;
    }
};

// 支付上下文
class PaymentContext {
private:
    std::unique_ptr<PaymentStrategy> strategy;
    
public:
    void setStrategy(std::unique_ptr<PaymentStrategy> newStrategy) {
        strategy = std::move(newStrategy);
    }
    
    bool executePayment(double amount) {
        if (!strategy) {
            throw std::runtime_error("未设置支付策略");
        }
        return strategy->pay(amount);
    }
};
```

- 场景2：装饰器模式实现文本处理
```cpp
#include <string>

// 文本组件接口
class TextComponent {
public:
    virtual ~TextComponent() = default;
    virtual std::string getText() const = 0;
};

// 具体文本组件
class PlainText : public TextComponent {
private:
    std::string text;
    
public:
    PlainText(const std::string& t) : text(t) {}
    
    std::string getText() const override {
        return text;
    }
};

// 装饰器基类
class TextDecorator : public TextComponent {
protected:
    std::unique_ptr<TextComponent> component;
    
public:
    TextDecorator(std::unique_ptr<TextComponent> comp) : component(std::move(comp)) {}
    
    std::string getText() const override {
        return component->getText();
    }
};

// 具体装饰器
class BoldDecorator : public TextDecorator {
public:
    BoldDecorator(std::unique_ptr<TextComponent> comp) : TextDecorator(std::move(comp)) {}
    
    std::string getText() const override {
        return "<b>" + component->getText() + "</b>";
    }
};

class ItalicDecorator : public TextDecorator {
public:
    ItalicDecorator(std::unique_ptr<TextComponent> comp) : TextDecorator(std::move(comp)) {}
    
    std::string getText() const override {
        return "<i>" + component->getText() + "</i>";
    }
};

class ColorDecorator : public TextDecorator {
private:
    std::string color;
    
public:
    ColorDecorator(std::unique_ptr<TextComponent> comp, const std::string& c) 
        : TextDecorator(std::move(comp)), color(c) {}
    
    std::string getText() const override {
        return "<span style='color:" + color + "'>" + component->getText() + "</span>";
    }
};
```

## 4. 易错点/坑
- 错误示例：
```cpp
// 非线程安全的单例模式
class UnsafeSingleton {
    static UnsafeSingleton* instance;
    
public:
    static UnsafeSingleton* getInstance() {
        if (!instance) {
            instance = new UnsafeSingleton();  // 多线程下可能创建多个实例
        }
        return instance;
    }
};
```
- 原因：缺乏线程同步机制
- 修正方案：使用互斥锁或双重检查锁定

- 错误示例：
```cpp
// 工厂模式中忘记释放对象
Shape* createShape() {
    return new Circle();  // 调用者可能忘记delete
}
```
- 原因：手动内存管理容易出错
- 修正方案：返回智能指针或使用RAII模式

## 5. 拓展补充
- 关联知识点：面向对象设计、设计原则、UML图、重构技术
- 进阶延伸：MVC模式、依赖注入、微服务架构、领域驱动设计