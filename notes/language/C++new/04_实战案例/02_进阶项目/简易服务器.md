# 简易服务器

## 1. 核心概念
- 定义：实现一个基于TCP协议的简易网络服务器，支持多客户端连接
- 关键特性：套接字编程、多线程处理、网络通信协议

## 2. 语法规则
- 基本语法：使用socket API、多线程、网络字节序转换
- 代码示例：
```cpp
#include <iostream>
#include <thread>
#include <vector>
#include <mutex>
#include <winsock2.h>
#include <ws2tcpip.h>

#pragma comment(lib, "ws2_32.lib")

class SimpleServer {
private:
    SOCKET serverSocket;
    std::vector<std::thread> clientThreads;
    std::mutex consoleMutex;
    bool running;
    
public:
    SimpleServer() : serverSocket(INVALID_SOCKET), running(false) {
        WSADATA wsaData;
        if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
            throw std::runtime_error("WSAStartup失败");
        }
    }
    
    ~SimpleServer() {
        stop();
        WSACleanup();
    }
    
    bool start(int port) {
        // 创建服务器套接字
        serverSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (serverSocket == INVALID_SOCKET) {
            log("套接字创建失败");
            return false;
        }
        
        // 设置套接字选项（允许地址重用）
        int opt = 1;
        if (setsockopt(serverSocket, SOL_SOCKET, SO_REUSEADDR, 
                      (char*)&opt, sizeof(opt)) == SOCKET_ERROR) {
            log("设置套接字选项失败");
            return false;
        }
        
        // 绑定地址和端口
        sockaddr_in serverAddr{};
        serverAddr.sin_family = AF_INET;
        serverAddr.sin_addr.s_addr = INADDR_ANY;
        serverAddr.sin_port = htons(port);
        
        if (bind(serverSocket, (sockaddr*)&serverAddr, sizeof(serverAddr)) == SOCKET_ERROR) {
            log("绑定端口失败");
            closesocket(serverSocket);
            return false;
        }
        
        // 开始监听
        if (listen(serverSocket, SOMAXCONN) == SOCKET_ERROR) {
            log("监听失败");
            closesocket(serverSocket);
            return false;
        }
        
        running = true;
        log("服务器启动成功，端口: " + std::to_string(port));
        
        // 启动接受连接线程
        std::thread acceptThread(&SimpleServer::acceptConnections, this);
        acceptThread.detach();
        
        return true;
    }
    
    void stop() {
        running = false;
        if (serverSocket != INVALID_SOCKET) {
            closesocket(serverSocket);
            serverSocket = INVALID_SOCKET;
        }
        
        for (auto& thread : clientThreads) {
            if (thread.joinable()) {
                thread.join();
            }
        }
        clientThreads.clear();
        
        log("服务器已停止");
    }
    
private:
    void acceptConnections() {
        while (running) {
            sockaddr_in clientAddr{};
            int clientAddrSize = sizeof(clientAddr);
            
            SOCKET clientSocket = accept(serverSocket, 
                                        (sockaddr*)&clientAddr, &clientAddrSize);
            
            if (clientSocket == INVALID_SOCKET) {
                if (running) {
                    log("接受连接失败");
                }
                continue;
            }
            
            char clientIP[INET_ADDRSTRLEN];
            inet_ntop(AF_INET, &clientAddr.sin_addr, clientIP, INET_ADDRSTRLEN);
            
            log("客户端连接: " + std::string(clientIP) + ":" + 
                std::to_string(ntohs(clientAddr.sin_port)));
            
            // 为每个客户端创建处理线程
            clientThreads.emplace_back(&SimpleServer::handleClient, this, clientSocket);
        }
    }
    
    void handleClient(SOCKET clientSocket) {
        char buffer[1024];
        
        try {
            while (running) {
                // 接收数据
                int bytesReceived = recv(clientSocket, buffer, sizeof(buffer) - 1, 0);
                
                if (bytesReceived <= 0) {
                    break;  // 客户端断开连接
                }
                
                buffer[bytesReceived] = '\0';
                std::string message(buffer);
                
                log("收到消息: " + message);
                
                // 回显消息给客户端
                std::string response = "服务器收到: " + message;
                send(clientSocket, response.c_str(), response.length(), 0);
                
                // 如果收到"quit"，断开连接
                if (message == "quit") {
                    break;
                }
            }
        }
        catch (const std::exception& e) {
            log("处理客户端错误: " + std::string(e.what()));
        }
        
        closesocket(clientSocket);
        log("客户端断开连接");
    }
    
    void log(const std::string& message) {
        std::lock_guard<std::mutex> lock(consoleMutex);
        auto now = std::chrono::system_clock::now();
        auto time = std::chrono::system_clock::to_time_t(now);
        
        std::cout << std::put_time(std::localtime(&time), "[%H:%M:%S] ") 
                  << message << std::endl;
    }
};

int main() {
    SimpleServer server;
    
    try {
        if (!server.start(8080)) {
            std::cerr << "服务器启动失败" << std::endl;
            return 1;
        }
        
        std::cout << "服务器运行中，输入 'quit' 停止服务器..." << std::endl;
        
        std::string input;
        while (std::getline(std::cin, input)) {
            if (input == "quit") {
                break;
            }
        }
        
        server.stop();
    }
    catch (const std::exception& e) {
        std::cerr << "错误: " << e.what() << std::endl;
        return 1;
    }
    
    return 0;
}
```
- 注意事项：Windows下的Winsock初始化、资源释放、线程安全

## 3. 常见用法
- 场景1：基础回显服务器
  - 实现客户端连接接受和消息回显
  - 适合学习网络编程基础

- 场景2：HTTP简易服务器
```cpp
#include <sstream>
#include <map>

class HttpServer {
private:
    SimpleServer baseServer;
    
    void handleHttpRequest(SOCKET clientSocket, const std::string& request) {
        std::istringstream iss(request);
        std::string method, path, version;
        iss >> method >> path >> version;
        
        std::map<std::string, std::string> headers;
        std::string line;
        while (std::getline(iss, line) && line != "\r") {
            size_t pos = line.find(':');
            if (pos != std::string::npos) {
                std::string key = line.substr(0, pos);
                std::string value = line.substr(pos + 1);
                headers[key] = value;
            }
        }
        
        std::string response;
        if (method == "GET") {
            response = "HTTP/1.1 200 OK\r\n"
                      "Content-Type: text/html\r\n"
                      "\r\n"
                      "<html><body><h1>Hello from HTTP Server!</h1></body></html>";
        } else {
            response = "HTTP/1.1 405 Method Not Allowed\r\n"
                      "\r\n";
        }
        
        send(clientSocket, response.c_str(), response.length(), 0);
    }
    
public:
    bool start(int port) {
        // 可以基于SimpleServer扩展HTTP功能
        return baseServer.start(port);
    }
};
```

## 4. 易错点/坑
- 错误示例：
```cpp
// 不检查WSAStartup返回值
WSAStartup(MAKEWORD(2, 2), &wsaData);
// 如果初始化失败，后续socket调用会出错
```
- 原因：缺乏错误检查
- 修正方案：检查WSAStartup返回值

- 错误示例：
```cpp
// 多线程共享数据未加锁
void log(const std::string& message) {
    std::cout << message << std::endl;  // 多线程同时输出会混乱
}
```
- 原因：多线程竞争条件
- 修正方案：使用互斥锁保护共享资源

## 5. 拓展补充
- 关联知识点：网络协议、多线程编程、异常处理、资源管理
- 进阶延伸：HTTPS支持、负载均衡、WebSocket、RESTful API