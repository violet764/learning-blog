# 数据结构实现（链表/栈/队列）

## 1. 核心概念
- 定义：实现常见的数据结构（链表、栈、队列）及其基本操作
- 关键特性：动态内存管理、时间复杂度分析、模板编程

## 2. 语法规则
- 基本语法：使用模板类、智能指针、异常处理
- 代码示例：

### 链表实现
```cpp
#include <iostream>
#include <memory>

template<typename T>
class LinkedList {
private:
    struct Node {
        T data;
        std::unique_ptr<Node> next;
        
        Node(const T& value) : data(value), next(nullptr) {}
    };
    
    std::unique_ptr<Node> head;
    size_t size;
    
public:
    LinkedList() : head(nullptr), size(0) {}
    
    // 在链表头部插入
    void pushFront(const T& value) {
        auto newNode = std::make_unique<Node>(value);
        newNode->next = std::move(head);
        head = std::move(newNode);
        size++;
    }
    
    // 在链表尾部插入
    void pushBack(const T& value) {
        auto newNode = std::make_unique<Node>(value);
        
        if (!head) {
            head = std::move(newNode);
        } else {
            Node* current = head.get();
            while (current->next) {
                current = current->next.get();
            }
            current->next = std::move(newNode);
        }
        size++;
    }
    
    // 删除头部元素
    void popFront() {
        if (!head) {
            throw std::runtime_error("链表为空");
        }
        
        head = std::move(head->next);
        size--;
    }
    
    // 查找元素
    bool contains(const T& value) const {
        Node* current = head.get();
        while (current) {
            if (current->data == value) {
                return true;
            }
            current = current->next.get();
        }
        return false;
    }
    
    // 获取大小
    size_t getSize() const { return size; }
    
    // 判断是否为空
    bool isEmpty() const { return size == 0; }
    
    // 打印链表
    void print() const {
        Node* current = head.get();
        std::cout << "链表内容: ";
        while (current) {
            std::cout << current->data << " -> ";
            current = current->next.get();
        }
        std::cout << "NULL" << std::endl;
    }
};
```

### 栈实现
```cpp
template<typename T>
class Stack {
private:
    struct Node {
        T data;
        std::unique_ptr<Node> next;
        
        Node(const T& value) : data(value), next(nullptr) {}
    };
    
    std::unique_ptr<Node> top;
    size_t size;
    
public:
    Stack() : top(nullptr), size(0) {}
    
    // 入栈
    void push(const T& value) {
        auto newNode = std::make_unique<Node>(value);
        newNode->next = std::move(top);
        top = std::move(newNode);
        size++;
    }
    
    // 出栈
    T pop() {
        if (!top) {
            throw std::runtime_error("栈为空");
        }
        
        T value = top->data;
        top = std::move(top->next);
        size--;
        return value;
    }
    
    // 查看栈顶元素
    T peek() const {
        if (!top) {
            throw std::runtime_error("栈为空");
        }
        return top->data;
    }
    
    // 获取大小
    size_t getSize() const { return size; }
    
    // 判断是否为空
    bool isEmpty() const { return size == 0; }
};
```

### 队列实现
```cpp
template<typename T>
class Queue {
private:
    struct Node {
        T data;
        std::unique_ptr<Node> next;
        
        Node(const T& value) : data(value), next(nullptr) {}
    };
    
    std::unique_ptr<Node> front;
    Node* rear;
    size_t size;
    
public:
    Queue() : front(nullptr), rear(nullptr), size(0) {}
    
    // 入队
    void enqueue(const T& value) {
        auto newNode = std::make_unique<Node>(value);
        
        if (!rear) {
            front = std::move(newNode);
            rear = front.get();
        } else {
            rear->next = std::move(newNode);
            rear = rear->next.get();
        }
        size++;
    }
    
    // 出队
    T dequeue() {
        if (!front) {
            throw std::runtime_error("队列为空");
        }
        
        T value = front->data;
        front = std::move(front->next);
        
        if (!front) {
            rear = nullptr;
        }
        
        size--;
        return value;
    }
    
    // 查看队首元素
    T peek() const {
        if (!front) {
            throw std::runtime_error("队列为空");
        }
        return front->data;
    }
    
    // 获取大小
    size_t getSize() const { return size; }
    
    // 判断是否为空
    bool isEmpty() const { return size == 0; }
};

// 测试代码
int main() {
    std::cout << "=== 链表测试 ===" << std::endl;
    LinkedList<int> list;
    list.pushBack(1);
    list.pushBack(2);
    list.pushFront(0);
    list.print();
    std::cout << "链表大小: " << list.getSize() << std::endl;
    
    std::cout << "\n=== 栈测试 ===" << std::endl;
    Stack<int> stack;
    stack.push(10);
    stack.push(20);
    stack.push(30);
    std::cout << "栈顶元素: " << stack.peek() << std::endl;
    std::cout << "出栈: " << stack.pop() << std::endl;
    std::cout << "栈大小: " << stack.getSize() << std::endl;
    
    std::cout << "\n=== 队列测试 ===" << std::endl;
    Queue<int> queue;
    queue.enqueue(100);
    queue.enqueue(200);
    queue.enqueue(300);
    std::cout << "队首元素: " << queue.peek() << std::endl;
    std::cout << "出队: " << queue.dequeue() << std::endl;
    std::cout << "队列大小: " << queue.getSize() << std::endl;
    
    return 0;
}
```
- 注意事项：内存管理、异常安全、模板编程

## 3. 常见用法
- 场景1：链表实现LRU缓存
```cpp
template<typename K, typename V>
class LRUCache {
private:
    struct CacheNode {
        K key;
        V value;
        CacheNode* prev;
        CacheNode* next;
        
        CacheNode(K k, V v) : key(k), value(v), prev(nullptr), next(nullptr) {}
    };
    
    std::unordered_map<K, CacheNode*> cache;
    CacheNode* head;
    CacheNode* tail;
    size_t capacity;
    
    void moveToHead(CacheNode* node) {
        if (node == head) return;
        
        // 从当前位置移除
        if (node->prev) node->prev->next = node->next;
        if (node->next) node->next->prev = node->prev;
        if (node == tail) tail = node->prev;
        
        // 移动到头部
        node->next = head;
        node->prev = nullptr;
        if (head) head->prev = node;
        head = node;
        if (!tail) tail = head;
    }
    
public:
    LRUCache(size_t cap) : capacity(cap), head(nullptr), tail(nullptr) {}
    
    V get(K key) {
        if (cache.find(key) == cache.end()) {
            throw std::runtime_error("键不存在");
        }
        
        CacheNode* node = cache[key];
        moveToHead(node);
        return node->value;
    }
    
    void put(K key, V value) {
        if (cache.find(key) != cache.end()) {
            cache[key]->value = value;
            moveToHead(cache[key]);
            return;
        }
        
        if (cache.size() >= capacity) {
            // 移除尾部节点
            cache.erase(tail->key);
            CacheNode* toRemove = tail;
            tail = tail->prev;
            if (tail) tail->next = nullptr;
            delete toRemove;
        }
        
        CacheNode* newNode = new CacheNode(key, value);
        cache[key] = newNode;
        
        if (!head) {
            head = tail = newNode;
        } else {
            newNode->next = head;
            head->prev = newNode;
            head = newNode;
        }
    }
};
```

- 场景2：使用栈实现表达式求值
```cpp
#include <stack>
#include <sstream>
#include <cctype>

class ExpressionEvaluator {
private:
    static int precedence(char op) {
        if (op == '+' || op == '-') return 1;
        if (op == '*' || op == '/') return 2;
        return 0;
    }
    
    static int applyOp(int a, int b, char op) {
        switch(op) {
            case '+': return a + b;
            case '-': return a - b;
            case '*': return a * b;
            case '/': 
                if (b == 0) throw std::runtime_error("除零错误");
                return a / b;
        }
        return 0;
    }
    
public:
    static int evaluate(const std::string& expression) {
        std::stack<int> values;
        std::stack<char> ops;
        
        for (size_t i = 0; i < expression.length(); i++) {
            if (expression[i] == ' ') continue;
            
            if (isdigit(expression[i])) {
                int val = 0;
                while (i < expression.length() && isdigit(expression[i])) {
                    val = val * 10 + (expression[i] - '0');
                    i++;
                }
                values.push(val);
                i--;
            }
            else if (expression[i] == '(') {
                ops.push(expression[i]);
            }
            else if (expression[i] == ')') {
                while (!ops.empty() && ops.top() != '(') {
                    int val2 = values.top(); values.pop();
                    int val1 = values.top(); values.pop();
                    char op = ops.top(); ops.pop();
                    values.push(applyOp(val1, val2, op));
                }
                if (!ops.empty()) ops.pop();
            }
            else {
                while (!ops.empty() && precedence(ops.top()) >= precedence(expression[i])) {
                    int val2 = values.top(); values.pop();
                    int val1 = values.top(); values.pop();
                    char op = ops.top(); ops.pop();
                    values.push(applyOp(val1, val2, op));
                }
                ops.push(expression[i]);
            }
        }
        
        while (!ops.empty()) {
            int val2 = values.top(); values.pop();
            int val1 = values.top(); values.pop();
            char op = ops.top(); ops.pop();
            values.push(applyOp(val1, val2, op));
        }
        
        return values.top();
    }
};
```

## 4. 易错点/坑
- 错误示例：
```cpp
// 原始指针内存泄漏
class BadLinkedList {
    struct Node { int data; Node* next; };
    Node* head;
    
    ~BadLinkedList() {
        // 忘记释放内存！
    }
};
```
- 原因：手动内存管理容易出错
- 修正方案：使用智能指针自动管理内存

- 错误示例：
```cpp
// 队列实现中rear指针未正确更新
void enqueue(int value) {
    Node* newNode = new Node(value);
    rear->next = newNode;  // 如果队列为空，rear为nullptr
    rear = newNode;
}
```
- 原因：边界条件处理不当
- 修正方案：检查队列是否为空的情况

## 5. 拓展补充
- 关联知识点：模板编程、智能指针、算法复杂度、异常处理
- 进阶延伸：平衡二叉树、哈希表、图算法、并发数据结构