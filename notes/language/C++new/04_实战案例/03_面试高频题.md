# 面试高频题

## 1. 核心概念
- 定义：整理C++面试中常见的高频题目及其解决方案
- 关键特性：算法复杂度分析、代码优化、边界条件处理

## 2. 语法规则
- 基本语法：使用STL容器、算法、模板、智能指针
- 代码示例：

### 字符串反转
```cpp
#include <iostream>
#include <string>
#include <algorithm>

class StringProblems {
public:
    // 方法1：使用STL算法
    static std::string reverseStringSTL(const std::string& str) {
        std::string result = str;
        std::reverse(result.begin(), result.end());
        return result;
    }
    
    // 方法2：双指针法
    static std::string reverseStringTwoPointers(const std::string& str) {
        std::string result = str;
        int left = 0, right = result.length() - 1;
        
        while (left < right) {
            std::swap(result[left], result[right]);
            left++;
            right--;
        }
        return result;
    }
    
    // 方法3：递归法
    static std::string reverseStringRecursive(const std::string& str) {
        if (str.empty()) return "";
        return reverseStringRecursive(str.substr(1)) + str[0];
    }
};
```

### 链表相关题目
```cpp
#include <memory>

struct ListNode {
    int val;
    std::shared_ptr<ListNode> next;
    
    ListNode(int x) : val(x), next(nullptr) {}
};

class LinkedListProblems {
public:
    // 反转链表
    static std::shared_ptr<ListNode> reverseList(std::shared_ptr<ListNode> head) {
        std::shared_ptr<ListNode> prev = nullptr;
        auto current = head;
        
        while (current) {
            auto next = current->next;
            current->next = prev;
            prev = current;
            current = next;
        }
        
        return prev;
    }
    
    // 检测链表是否有环
    static bool hasCycle(std::shared_ptr<ListNode> head) {
        if (!head || !head->next) return false;
        
        auto slow = head;
        auto fast = head->next;
        
        while (fast && fast->next) {
            if (slow == fast) return true;
            slow = slow->next;
            fast = fast->next->next;
        }
        
        return false;
    }
    
    // 合并两个有序链表
    static std::shared_ptr<ListNode> mergeTwoLists(std::shared_ptr<ListNode> l1, 
                                                  std::shared_ptr<ListNode> l2) {
        auto dummy = std::make_shared<ListNode>(0);
        auto current = dummy;
        
        while (l1 && l2) {
            if (l1->val <= l2->val) {
                current->next = l1;
                l1 = l1->next;
            } else {
                current->next = l2;
                l2 = l2->next;
            }
            current = current->next;
        }
        
        current->next = l1 ? l1 : l2;
        return dummy->next;
    }
};
```

### 数组相关题目
```cpp
#include <vector>
#include <unordered_map>
#include <algorithm>

class ArrayProblems {
public:
    // 两数之和
    static std::vector<int> twoSum(const std::vector<int>& nums, int target) {
        std::unordered_map<int, int> numMap;
        
        for (int i = 0; i < nums.size(); i++) {
            int complement = target - nums[i];
            
            if (numMap.find(complement) != numMap.end()) {
                return {numMap[complement], i};
            }
            
            numMap[nums[i]] = i;
        }
        
        return {};  // 无解
    }
    
    // 最大子数组和（Kadane算法）
    static int maxSubArray(const std::vector<int>& nums) {
        if (nums.empty()) return 0;
        
        int maxSum = nums[0];
        int currentSum = nums[0];
        
        for (int i = 1; i < nums.size(); i++) {
            currentSum = std::max(nums[i], currentSum + nums[i]);
            maxSum = std::max(maxSum, currentSum);
        }
        
        return maxSum;
    }
    
    // 旋转数组
    static void rotateArray(std::vector<int>& nums, int k) {
        if (nums.empty() || k == 0) return;
        
        k = k % nums.size();  // 处理k大于数组长度的情况
        
        // 三次反转法
        std::reverse(nums.begin(), nums.end());
        std::reverse(nums.begin(), nums.begin() + k);
        std::reverse(nums.begin() + k, nums.end());
    }
};
```

### 测试代码
```cpp
int main() {
    std::cout << "=== 字符串反转测试 ===" << std::endl;
    std::string testStr = "Hello, World!";
    std::cout << "原字符串: " << testStr << std::endl;
    std::cout << "STL反转: " << StringProblems::reverseStringSTL(testStr) << std::endl;
    std::cout << "双指针反转: " << StringProblems::reverseStringTwoPointers(testStr) << std::endl;
    std::cout << "递归反转: " << StringProblems::reverseStringRecursive(testStr) << std::endl;
    
    std::cout << "\n=== 两数之和测试 ===" << std::endl;
    std::vector<int> nums = {2, 7, 11, 15};
    int target = 9;
    auto result = ArrayProblems::twoSum(nums, target);
    std::cout << "两数之和 " << target << ": [" << result[0] << ", " << result[1] << "]" << std::endl;
    
    std::cout << "\n=== 最大子数组和测试 ===" << std::endl;
    std::vector<int> nums2 = {-2, 1, -3, 4, -1, 2, 1, -5, 4};
    std::cout << "最大子数组和: " << ArrayProblems::maxSubArray(nums2) << std::endl;
    
    std::cout << "\n=== 数组旋转测试 ===" << std::endl;
    std::vector<int> nums3 = {1, 2, 3, 4, 5, 6, 7};
    std::cout << "旋转前: ";
    for (int num : nums3) std::cout << num << " ";
    std::cout << std::endl;
    
    ArrayProblems::rotateArray(nums3, 3);
    std::cout << "旋转后: ";
    for (int num : nums3) std::cout << num << " ";
    std::cout << std::endl;
    
    return 0;
}
```
- 注意事项：边界条件、时间复杂度、空间复杂度

## 3. 常见用法
- 场景1：二叉树相关题目
```cpp
#include <queue>
#include <stack>

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

class TreeProblems {
public:
    // 二叉树层次遍历
    static std::vector<std::vector<int>> levelOrder(TreeNode* root) {
        std::vector<std::vector<int>> result;
        if (!root) return result;
        
        std::queue<TreeNode*> q;
        q.push(root);
        
        while (!q.empty()) {
            int levelSize = q.size();
            std::vector<int> currentLevel;
            
            for (int i = 0; i < levelSize; i++) {
                TreeNode* node = q.front();
                q.pop();
                currentLevel.push_back(node->val);
                
                if (node->left) q.push(node->left);
                if (node->right) q.push(node->right);
            }
            
            result.push_back(currentLevel);
        }
        
        return result;
    }
    
    // 验证二叉搜索树
    static bool isValidBST(TreeNode* root) {
        return isValidBSTHelper(root, LONG_MIN, LONG_MAX);
    }
    
private:
    static bool isValidBSTHelper(TreeNode* node, long minVal, long maxVal) {
        if (!node) return true;
        
        if (node->val <= minVal || node->val >= maxVal) {
            return false;
        }
        
        return isValidBSTHelper(node->left, minVal, node->val) &&
               isValidBSTHelper(node->right, node->val, maxVal);
    }
};
```

- 场景2：排序和搜索算法
```cpp
class SortSearchProblems {
public:
    // 快速排序
    static void quickSort(std::vector<int>& arr, int low, int high) {
        if (low < high) {
            int pivotIndex = partition(arr, low, high);
            quickSort(arr, low, pivotIndex - 1);
            quickSort(arr, pivotIndex + 1, high);
        }
    }
    
    // 二分查找
    static int binarySearch(const std::vector<int>& arr, int target) {
        int left = 0, right = arr.size() - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (arr[mid] == target) {
                return mid;
            } else if (arr[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return -1;  // 未找到
    }
    
private:
    static int partition(std::vector<int>& arr, int low, int high) {
        int pivot = arr[high];
        int i = low - 1;
        
        for (int j = low; j < high; j++) {
            if (arr[j] <= pivot) {
                i++;
                std::swap(arr[i], arr[j]);
            }
        }
        
        std::swap(arr[i + 1], arr[high]);
        return i + 1;
    }
};
```

## 4. 易错点/坑
- 错误示例：
```cpp
// 二分查找中的整数溢出
int mid = (left + right) / 2;  // 当left和right很大时可能溢出
```
- 原因：整数相加可能超出int范围
- 修正方案：使用`left + (right - left) / 2`

- 错误示例：
```cpp
// 反转链表时忘记处理头节点
ListNode* reverseList(ListNode* head) {
    ListNode* prev = nullptr;
    ListNode* current = head;
    
    while (current) {
        ListNode* next = current->next;
        current->next = prev;  // 如果head是nullptr，这里会出错
        prev = current;
        current = next;
    }
    return prev;
}
```
- 原因：未处理空链表情况
- 修正方案：在函数开始检查head是否为nullptr

## 5. 拓展补充
- 关联知识点：算法复杂度分析、数据结构、动态规划、贪心算法
- 进阶延伸：系统设计题、并发编程题、数据库设计题、网络编程题