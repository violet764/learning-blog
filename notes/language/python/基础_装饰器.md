### 实用技巧

这些Python实用技巧可以帮助你编写更简洁、高效的代码，提高编程效率。

#### 解构赋值

```python
# 基本解构赋值
# 交换变量
a, b = 5, 10
print(f"交换前：a={a}, b={b}")
a, b = b, a
print(f"交换后：a={a}, b={b}")

# 函数返回多个值
def get_coordinates():
    """返回坐标"""
    return 10, 20, 30

x, y, z = get_coordinates()
print(f"坐标：x={x}, y={y}, z={z}")

# 列表/元组解构
numbers = [1, 2, 3, 4, 5]
first, second, third, fourth, fifth = numbers
print(f"列表解构：{first}, {second}, {third}, {fourth}, {fifth}")

# 使用*运算符解构
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
first, *middle, last = numbers
print(f"第一个：{first}")
print(f"中间部分：{middle}")
print(f"最后一个：{last}")

# 嵌套解构
nested_list = [1, [2, 3], 4]
a, [b, c], d = nested_list
print(f"嵌套解构：a={a}, b={b}, c={c}, d={d}")

# 解构字典
person = {"name": "张三", "age": 25, "city": "北京"}
name, age, city = person.values()
print(f"字典解构：姓名={name}, 年龄={age}, 城市={city}")

# 字典键值对解构
person = {"name": "张三", "age": 25}
for key, value in person.items():
    print(f"键：{key}, 值：{value}")

# 忽略某些值
a, b, *_, c = [1, 2, 3, 4, 5, 6, 7]
print(f"忽略中间值：a={a}, b={b}, c={c}")

# 使用下划线忽略单个值
a, _, b, _ = [1, 2, 3, 4]
print(f"忽略特定值：a={a}, b={b}")

# 循环中的解构
points = [(1, 2), (3, 4), (5, 6)]
for x, y in points:
    print(f"点：({x}, {y})")

# 函数参数解构
def process_person_info(name, age, city):
    """处理个人信息"""
    return f"姓名：{name}，年龄：{age}，城市：{city}"

person_data = ["李四", 30, "上海"]
result = process_person_info(*person_data)
print(result)

# 关键字参数解构
person_kwargs = {"name": "王五", "age": 35, "city": "广州"}
result = process_person_info(**person_kwargs)
print(result)

# 复杂解构示例
data = [
    ("张三", 25, {"math": 90, "english": 85}),
    ("李四", 30, {"math": 85, "english": 92}),
    ("王五", 28, {"math": 88, "english": 78})
]

for name, age, scores in data:
    math_score = scores["math"]
    english_score = scores["english"]
    average = (math_score + english_score) / 2
    print(f"{name}，{age}岁，平均成绩：{average:.1f}")

# 使用zip和解构
names = ["张三", "李四", "王五"]
ages = [25, 30, 28]
cities = ["北京", "上海", "广州"]

for name, age, city in zip(names, ages, cities):
    print(f"{name}，{age}岁，住在{city}")

# 条件解构
values = [1, 2, 3]
if len(values) >= 3:
    a, b, c = values[:3]
    print(f"条件解构：a={a}, b={b}, c={c}")
```

#### 装饰器

```python
# 基本装饰器
def simple_decorator(func):
    """简单装饰器"""
    def wrapper():
        print("函数调用前的操作")
        func()
        print("函数调用后的操作")
    return wrapper

@simple_decorator
def greet():
    """问候函数"""
    print("Hello, World!")

greet()

# 带参数的装饰器
def timing_decorator(func):
    """计时装饰器"""
    import time
    import functools
    
    @functools.wraps(func)  # 保留原函数的元数据
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"{func.__name__} 执行时间: {end - start:.4f}秒")
        return result
    return wrapper

@timing_decorator
def slow_function(n):
    """慢函数"""
    total = 0
    for i in range(n):
        total += i
        time.sleep(0.01)  # 模拟耗时操作
    return total

result = slow_function(100)
print(f"计算结果：{result}")

# 带参数的装饰器工厂
def repeat(n):
    """重复执行函数n次的装饰器工厂"""
    def decorator(func):
        import functools
        
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            results = []
            for i in range(n):
                print(f"第 {i+1} 次执行:")
                result = func(*args, **kwargs)
                results.append(result)
            return results
        return wrapper
    return decorator

@repeat(3)
def multiply(a, b):
    """乘法函数"""
    result = a * b
    print(f"{a} × {b} = {result}")
    return result

results = multiply(5, 3)
print(f"所有结果：{results}")

# 类装饰器
class CountCalls:
    """计数调用装饰器类"""
    def __init__(self, func):
        import functools
        functools.update_wrapper(self, func)
        self.func = func
        self.call_count = 0
    
    def __call__(self, *args, **kwargs):
        self.call_count += 1
        print(f"调用 {self.func.__name__} 第 {self.call_count} 次")
        return self.func(*args, **kwargs)

@CountCalls
def fibonacci(n):
    """斐波那契数列"""
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

# 注意：递归函数使用装饰器时，每个递归调用都会被装饰
# 这里只演示前几个斐波那契数
for i in range(6):
    print(f"fibonacci({i}) = {fibonacci(i)}")

# 属性装饰器
class Person:
    """人类"""
    
    def __init__(self, name):
        self._name = name
    
    @property
    def name(self):
        """获取姓名"""
        return self._name
    
    @name.setter
    def name(self, value):
        """设置姓名"""
        if not value:
            raise ValueError("姓名不能为空")
        self._name = value
    
    @name.deleter
    def name(self):
        """删除姓名"""
        print("删除姓名")
        self._name = None

person = Person("张三")
print(person.name)
person.name = "李四"
print(person.name)
del person.name

# 堆叠装饰器
def bold(func):
    """加粗装饰器"""
    import functools
    
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        return f"<b>{func(*args, **kwargs)}</b>"
    return wrapper

def italic(func):
    """斜体装饰器"""
    import functools
    
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        return f"<i>{func(*args, **kwargs)}</i>"
    return wrapper

@bold
@italic
def format_text(text):
    """格式化文本"""
    return text

result = format_text("Hello, World!")
print(f"格式化结果：{result}")

# 缓存装饰器
def memoize(func):
    """记忆化装饰器"""
    import functools
    
    cache = {}
    
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        # 创建可哈希的键
        key = str(args) + str(sorted(kwargs.items()))
        
        if key not in cache:
            cache[key] = func(*args, **kwargs)
            print(f"计算并缓存结果：{key}")
        else:
            print(f"使用缓存结果：{key}")
        
        return cache[key]
    
    return wrapper

@memoize
def expensive_function(n):
    """耗时函数"""
    print(f"计算 {n} 的平方...")
    return n * n

print(f"结果：{expensive_function(5)}")
print(f"结果：{expensive_function(5)}")  # 使用缓存
print(f"结果：{expensive_function(10)}")
print(f"结果：{expensive_function(10)}")  # 使用缓存
```

#### 上下文管理器

```python
# 自定义上下文管理器
class Timer:
    """计时器上下文管理器"""
    def __init__(self, description="代码块"):
        self.description = description
        self.start = None
        self.end = None
    
    def __enter__(self):
        import time
        self.start = time.time()
        print(f"开始计时：{self.description}")
        return self  # 返回自身，可以在with块中使用
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        import time
        self.end = time.time()
        elapsed = self.end - self.start
        print(f"{self.description} 执行时间: {elapsed:.4f}秒")
        
        # 返回False表示不抑制异常，True表示抑制异常
        return False

# 使用自定义上下文管理器
with Timer("睡眠测试"):
    import time
    time.sleep(0.5)

# 带返回值的上下文管理器
class FileHandler:
    """文件处理上下文管理器"""
    def __init__(self, filename, mode="r"):
        self.filename = filename
        self.mode = mode
        self.file = None
    
    def __enter__(self):
        try:
            self.file = open(self.filename, self.mode, encoding="utf-8")
            return self.file  # 返回文件对象
        except Exception as e:
            print(f"打开文件失败: {e}")
            raise
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.file:
            self.file.close()
            print(f"文件 {self.filename} 已关闭")
        
        # 如果发生文件异常，返回True抑制异常
        if exc_type is IOError:
            print(f"文件操作异常: {exc_val}")
            return True
        return False

# 使用文件处理上下文管理器
try:
    with FileHandler("test_file.txt", "w") as f:
        f.write("这是测试内容\n")
        f.write("第二行内容\n")
        # 故意引发错误以测试异常处理
        # raise IOError("模拟文件错误")
except Exception as e:
    print(f"捕获异常: {e}")

# 使用contextlib模块
from contextlib import contextmanager, closing

# 使用contextmanager装饰器创建上下文管理器
@contextmanager
def database_connection(db_name):
    """数据库连接上下文管理器"""
    print(f"连接到数据库: {db_name}")
    connection = {"db": db_name, "connected": True}
    
    try:
        yield connection  # 返回连接对象
    finally:
        connection["connected"] = False
        print(f"断开与数据库 {db_name} 的连接")

# 使用数据库连接上下文管理器
with database_connection("test_db") as conn:
    print(f"数据库状态: {conn}")
    # 执行数据库操作...

# 使用closing上下文管理器
from urllib.request import urlopen

with closing(urlopen("https://www.python.org")) as page:
    content = page.read(1024)  # 读取前1024字节
    print(f"读取内容长度: {len(content)} 字节")

# 嵌套上下文管理器
class Resource:
    """资源管理器"""
    def __init__(self, name):
        self.name = name
    
    def __enter__(self):
        print(f"获取资源: {self.name}")
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        print(f"释放资源: {self.name}")
        return False

# 嵌套使用多个上下文管理器
with Resource("资源A") as a, Resource("资源B") as b:
    print(f"同时使用 {a.name} 和 {b.name}")

# 动态上下文管理器
class DynamicContextManager:
    """动态上下文管理器"""
    def __init__(self):
        self.stack = []
    
    def add_context(self, context_manager):
        """添加上下文管理器"""
        self.stack.append(context_manager)
    
    def __enter__(self):
        """进入所有上下文"""
        for cm in self.stack:
            cm.__enter__()
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """退出所有上下文（与进入相反的顺序）"""
        for cm in reversed(self.stack):
            cm.__exit__(exc_type, exc_val, exc_tb)
        return False

# 使用动态上下文管理器
dynamic = DynamicContextManager()
dynamic.add_context(Resource("动态资源1"))
dynamic.add_context(Resource("动态资源2"))
dynamic.add_context(Timer("动态资源管理"))

with dynamic:
    print("使用动态管理的多个资源")

# 上下文管理器在异常处理中的应用
class ExceptionLogger:
    """异常日志上下文管理器"""
    def __init__(self, log_file="errors.log"):
        self.log_file = log_file
        self.errors = []
    
    def __enter__(self):
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        if exc_type:
            error_info = {
                "type": exc_type.__name__,
                "message": str(exc_val),
                "traceback": exc_tb
            }
            self.errors.append(error_info)
            self.log_errors()
        return False  # 不抑制异常
    
    def log_errors(self):
        """记录错误到文件"""
        with open(self.log_file, "a", encoding="utf-8") as f:
            import datetime
            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            f.write(f"\n[{timestamp}] 错误发生:\n")
            for error in self.errors:
                f.write(f"  类型: {error['type']}\n")
                f.write(f"  消息: {error['message']}\n")

# 使用异常日志上下文管理器
with ExceptionLogger("my_errors.log"):
    print("执行可能出错的代码...")
    # 故意引发错误
    # raise ValueError("这是一个测试错误")

# 上下文管理器在资源清理中的应用
@contextmanager
def temporary_file(content, mode="w+"):
    """临时文件上下文管理器"""
    import os
    import tempfile
    
    # 创建临时文件
    temp_file = tempfile.NamedTemporaryFile(mode=mode, delete=False)
    try:
        if content:
            temp_file.write(content)
        temp_file.flush()  # 确保内容写入磁盘
        temp_file.seek(0)  # 回到文件开头
        yield temp_file
    finally:
        temp_file.close()
        os.unlink(temp_file.name)  # 删除临时文件

# 使用临时文件上下文管理器
with temporary_file("这是临时文件内容") as temp:
    content = temp.read()
    print(f"临时文件内容: {content}")
    print(f"临时文件路径: {temp.name}")

# 上下文管理器在事务管理中的应用
class Transaction:
    """事务管理器"""
    def __init__(self):
        self.operations = []
        self.committed = False
    
    def add_operation(self, operation, undo_operation):
        """添加操作和撤销操作"""
        self.operations.append((operation, undo_operation))
    
    def commit(self):
        """提交事务"""
        try:
            for operation, _ in self.operations:
                operation()
            self.committed = True
            print("事务提交成功")
        except Exception as e:
            print(f"事务提交失败: {e}")
            self.rollback()
    
    def rollback(self):
        """回滚事务"""
        print("回滚事务")
        for _, undo_operation in reversed(self.operations):
            try:
                undo_operation()
            except Exception as e:
                print(f"回滚操作失败: {e}")
    
    def __enter__(self):
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        if exc_type:
            print(f"事务中发生异常: {exc_val}")
            self.rollback()
            return True  # 抑制异常
        else:
            self.commit()
            return False

# 使用事务管理器
class BankAccount:
    """银行账户"""
    def __init__(self, balance):
        self.balance = balance
    
    def deposit(self, amount):
        """存款"""
        self.balance += amount
        print(f"存款 {amount}，余额：{self.balance}")
    
    def withdraw(self, amount):
        """取款"""
        if amount > self.balance:
            raise ValueError("余额不足")
        self.balance -= amount
        print(f"取款 {amount}，余额：{self.balance}")

# 账户转账事务
account1 = BankAccount(1000)
account2 = BankAccount(500)

with Transaction() as tx:
    # 账户1取款100
    tx.add_operation(
        lambda: account1.withdraw(100),
        lambda: account1.deposit(100)  # 撤销操作：存款100
    )
    
    # 账户2存款100
    tx.add_operation(
        lambda: account2.deposit(100),
        lambda: account2.withdraw(100)  # 撤销操作：取款100
    )
    
    # 模拟可能的错误
    # raise Exception("银行系统故障")

print(f"账户1余额: {account1.balance}")
print(f"账户2余额: {account2.balance}")
```
