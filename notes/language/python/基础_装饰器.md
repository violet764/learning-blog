# Python 基础：实用技巧与高级特性

本文档介绍Python中的一些实用技巧和高级特性，包括解构赋值、装饰器和上下文管理器等，这些特性能够帮助你编写更简洁、高效的代码。

## 一、解构赋值
解构赋值是Python中一种强大的特性，它允许我们将序列或可迭代对象中的元素分配给多个变量，使代码更加简洁和易读。

### 基本解构赋值

```python
# 基本解构赋值
# 交换变量
a, b = 5, 10
print(f"交换前：a={a}, b={b}")
a, b = b, a  # 利用元组解构实现变量交换
print(f"交换后：a={a}, b={b}")

# 函数返回多个值
def get_coordinates():
    """返回三维坐标
    Returns:
        tuple: 包含x, y, z坐标的元组
    """
    return 10, 20, 30

x, y, z = get_coordinates()  # 函数返回的元组被解构到三个变量
print(f"坐标：x={x}, y={y}, z={z}")

# 列表/元组解构
numbers = [1, 2, 3, 4, 5]
first, second, third, fourth, fifth = numbers  # 将列表元素解构到变量
print(f"列表解构：{first}, {second}, {third}, {fourth}, {fifth}")
```

### 复杂解构模式

```python
# 使用*运算符解构
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
first, *middle, last = numbers  # *middle收集中间的所有元素
print(f"第一个：{first}")
print(f"中间部分：{middle}")
print(f"最后一个：{last}")

# 嵌套解构
nested_list = [1, [2, 3], 4]
a, [b, c], d = nested_list  # 嵌套解构，第二个元素本身是一个列表
print(f"嵌套解构：a={a}, b={b}, c={c}, d={d}")

# 解构字典
person = {"name": "张三", "age": 25, "city": "北京"}
# 使用values()方法获取字典的所有值并解构
name, age, city = person.values()
print(f"字典解构：姓名={name}, 年龄={age}, 城市={city}")

# 字典键值对解构
person = {"name": "张三", "age": 25}
# 使用items()方法遍历字典的键值对并解构
for key, value in person.items():
    print(f"键：{key}, 值：{value}")

# 忽略某些值
a, b, *_, c = [1, 2, 3, 4, 5, 6, 7]  # *_忽略中间不需要的值
print(f"忽略中间值：a={a}, b={b}, c={c}")

# 使用下划线忽略单个值
a, _, b, _ = [1, 2, 3, 4]  # _是Python中表示"不关心的变量"的约定
print(f"忽略特定值：a={a}, b={b}")

# 循环中的解构
points = [(1, 2), (3, 4), (5, 6)]
# 在循环中解构元组
for x, y in points:
    print(f"点：({x}, {y})")
```


### 函数参数解构

```python
# 函数参数解构
def process_person_info(name, age, city):
    """处理个人信息
    Args:
        name (str): 姓名
        age (int): 年龄
        city (str): 城市
    Returns:
        str: 格式化的个人信息字符串
    """
    return f"姓名：{name}，年龄：{age}，城市：{city}"

person_data = ["李四", 30, "上海"]
# 使用*运算符将列表解构为函数参数
result = process_person_info(*person_data)
print(result)

# 关键字参数解构
person_kwargs = {"name": "王五", "age": 35, "city": "广州"}
# 使用**运算符将字典解构为关键字参数
result = process_person_info(**person_kwargs)
print(result)

# 复杂解构示例
data = [
    ("张三", 25, {"math": 90, "english": 85}),
    ("李四", 30, {"math": 85, "english": 92}),
    ("王五", 28, {"math": 88, "english": 78})
]

# 嵌套解构处理复杂数据结构
for name, age, scores in data:
    math_score = scores["math"]
    english_score = scores["english"]
    average = (math_score + english_score) / 2
    print(f"{name}，{age}岁，平均成绩：{average:.1f}")

# 使用zip和解构
names = ["张三", "李四", "王五"]
ages = [25, 30, 28]
cities = ["北京", "上海", "广州"]

# zip函数将多个序列打包，然后解构到循环变量
for name, age, city in zip(names, ages, cities):
    print(f"{name}，{age}岁，住在{city}")

# 条件解构
values = [1, 2, 3]
if len(values) >= 3:
    a, b, c = values[:3]  # 只解构前3个元素
    print(f"条件解构：a={a}, b={b}, c={c}")
```

## 二、装饰器 

装饰器是Python中一种强大的特性，它允许我们在不修改原函数代码的情况下，为函数添加额外的功能，如日志记录、性能监控、权限检查等。

### 基本装饰器

```python
# 基本装饰器
def simple_decorator(func):
    """简单装饰器 - 在函数调用前后添加额外操作
    Args:
        func (function): 被装饰的函数
    Returns:
        function: 包装后的函数
    """
    def wrapper():
        print("函数调用前的操作")
        func()  # 调用原函数
        print("函数调用后的操作")
    return wrapper

@simple_decorator  # 使用@语法糖应用装饰器
def greet():
    """问候函数"""
    print("Hello, World!")

greet()  # 调用被装饰的函数
```


### 带参数装饰器

```python
# 带参数的装饰器
def timing_decorator(func):
    """计时装饰器 - 测量函数执行时间
    Args:
        func (function): 被装饰的函数
    Returns:
        function: 包装后的函数
    """
    import time
    import functools

    @functools.wraps(func)  # 保留原函数的元数据（如__name__, __doc__等）
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)  # 调用原函数并传递参数
        end = time.time()
        print(f"{func.__name__} 执行时间: {end - start:.4f}秒")
        return result
    return wrapper

@timing_decorator
def slow_function(n):
    """慢函数 - 模拟耗时操作
    Args:
        n (int): 循环次数
    Returns:
        int: 计算结果
    """
    total = 0
    for i in range(n):
        total += i
        time.sleep(0.01)  # 模拟耗时操作
    return total

result = slow_function(100)
print(f"计算结果：{result}")

# 带参数的装饰器工厂
def repeat(n):
    """重复执行函数n次的装饰器工厂
    Args:
        n (int): 重复执行次数
    Returns:
        function: 装饰器函数
    """
    def decorator(func):
        import functools

        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            results = []
            for i in range(n):
                print(f"第 {i+1} 次执行:")
                result = func(*args, **kwargs)
                results.append(result)
            return results
        return wrapper
    return decorator

@repeat(3)  # repeat(3)返回真正的装饰器
def multiply(a, b):
    """乘法函数
    Args:
        a (int/float): 第一个操作数
        b (int/float): 第二个操作数
    Returns:
        int/float: 两数之积
    """
    result = a * b
    print(f"{a} × {b} = {result}")
    return result

results = multiply(5, 3)
print(f"所有结果：{results}")
```


### 类装饰器

```python
# 类装饰器
class CountCalls:
    """计数调用装饰器类 - 统计函数被调用的次数"""

    def __init__(self, func):
        """初始化装饰器
        Args:
            func (function): 被装饰的函数
        """
        import functools
        functools.update_wrapper(self, func)  # 复制原函数的元数据
        self.func = func
        self.call_count = 0  # 调用计数器

    def __call__(self, *args, **kwargs):
        """使装饰器实例像函数一样可调用
        Args:
            *args: 位置参数
            **kwargs: 关键字参数
        Returns:
            any: 原函数的返回值
        """
        self.call_count += 1
        print(f"调用 {self.func.__name__} 第 {self.call_count} 次")
        return self.func(*args, **kwargs)

@CountCalls
def fibonacci(n):
    """斐波那契数列
    Args:
        n (int): 序列位置
    Returns:
        int: 第n个斐波那契数
    """
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)  # 递归实现

# 注意：递归函数使用装饰器时，每个递归调用都会被装饰
# 这里只演示前几个斐波那契数
for i in range(6):
    print(f"fibonacci({i}) = {fibonacci(i)}")
```

### 属性装饰器

```python
# 属性装饰器
class Person:
    """人类"""

    def __init__(self, name):
        """初始化人员
        Args:
            name (str): 姓名
        """
        self._name = name  # 使用下划线表示私有属性

    @property
    def name(self):
        """获取姓名 - getter方法
        Returns:
            str: 人员姓名
        """
        return self._name

    @name.setter
    def name(self, value):
        """设置姓名 - setter方法
        Args:
            value (str): 新的姓名
        Raises:
            ValueError: 当姓名为空时抛出异常
        """
        if not value:
            raise ValueError("姓名不能为空")
        self._name = value

    @name.deleter
    def name(self):
        """删除姓名 - deleter方法"""
        print("删除姓名")
        self._name = None

person = Person("张三")
print(person.name)  # 通过属性访问器获取姓名
person.name = "李四"  # 通过属性访问器设置姓名
print(person.name)
del person.name  # 通过属性访问器删除姓名
```

### 堆叠装饰器

```python
# 堆叠装饰器
def bold(func):
    """加粗装饰器 - 为文本添加HTML加粗标签
    Args:
        func (function): 被装饰的函数
    Returns:
        function: 包装后的函数
    """
    import functools

    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        return f"<b>{func(*args, **kwargs)}</b>"
    return wrapper

def italic(func):
    """斜体装饰器 - 为文本添加HTML斜体标签
    Args:
        func (function): 被装饰的函数
    Returns:
        function: 包装后的函数
    """
    import functools

    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        return f"<i>{func(*args, **kwargs)}</i>"
    return wrapper

@bold  # 先应用bold装饰器
@italic  # 后应用italic装饰器（实际执行顺序是从下往上）
def format_text(text):
    """格式化文本
    Args:
        text (str): 要格式化的文本
    Returns:
        str: 格式化后的文本
    """
    return text

result = format_text("Hello, World!")
print(f"格式化结果：{result}")
```

### 缓存装饰器

```python
# 缓存装饰器
def memoize(func):
    """记忆化装饰器 - 缓存函数调用结果以提高性能
    Args:
        func (function): 被装饰的函数
    Returns:
        function: 包装后的函数
    """
    import functools

    cache = {}  # 缓存字典

    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        # 创建可哈希的键
        key = str(args) + str(sorted(kwargs.items()))

        if key not in cache:
            cache[key] = func(*args, **kwargs)
            print(f"计算并缓存结果：{key}")
        else:
            print(f"使用缓存结果：{key}")

        return cache[key]

    return wrapper

@memoize
def expensive_function(n):
    """耗时函数 - 模拟计算密集型操作
    Args:
        n (int): 计算参数
    Returns:
        int: 计算结果
    """
    print(f"计算 {n} 的平方...")
    return n * n

print(f"结果：{expensive_function(5)}")
print(f"结果：{expensive_function(5)}")  # 使用缓存
print(f"结果：{expensive_function(10)}")
print(f"结果：{expensive_function(10)}")  # 使用缓存
```

## 三、上下文管理器 
上下文管理器是Python中用于资源管理和异常处理的重要特性，通过with语句确保资源的正确获取和释放。

### 自定义上下文管理器

```python
# 自定义上下文管理器
class Timer:
    """计时器上下文管理器 - 测量代码块执行时间"""

    def __init__(self, description="代码块"):
        """初始化计时器
        Args:
            description (str): 被计时代码块的描述
        """
        self.description = description
        self.start = None
        self.end = None

    def __enter__(self):
        """进入上下文管理器
        Returns:
            Timer: 返回自身，可在with块中使用
        """
        import time
        self.start = time.time()
        print(f"开始计时：{self.description}")
        return self  # 返回自身，可以在with块中使用

    def __exit__(self, exc_type, exc_val, exc_tb):
        """退出上下文管理器
        Args:
            exc_type: 异常类型
            exc_val: 异常值
            exc_tb: 异常追踪信息
        Returns:
            bool: False表示不抑制异常，True表示抑制异常
        """
        import time
        self.end = time.time()
        elapsed = self.end - self.start
        print(f"{self.description} 执行时间: {elapsed:.4f}秒")

        # 返回False表示不抑制异常，True表示抑制异常
        return False

# 使用自定义上下文管理器
with Timer("睡眠测试"):
    import time
    time.sleep(0.5)
```

### contextlib模块

```python
# 带返回值的上下文管理器
class FileHandler:
    """文件处理上下文管理器 - 安全处理文件操作"""

    def __init__(self, filename, mode="r"):
        """初始化文件处理器
        Args:
            filename (str): 文件名
            mode (str): 文件打开模式，默认为"r"
        """
        self.filename = filename
        self.mode = mode
        self.file = None

    def __enter__(self):
        """进入上下文管理器"""
        try:
            self.file = open(self.filename, self.mode, encoding="utf-8")
            return self.file  # 返回文件对象
        except Exception as e:
            print(f"打开文件失败: {e}")
            raise

    def __exit__(self, exc_type, exc_val, exc_tb):
        """退出上下文管理器"""
        if self.file:
            self.file.close()
            print(f"文件 {self.filename} 已关闭")

        # 如果发生文件异常，返回True抑制异常
        if exc_type is IOError:
            print(f"文件操作异常: {exc_val}")
            return True
        return False

# 使用文件处理上下文管理器
try:
    with FileHandler("test_file.txt", "w") as f:
        f.write("这是测试内容\n")
        f.write("第二行内容\n")
        # 故意引发错误以测试异常处理
        # raise IOError("模拟文件错误")
except Exception as e:
    print(f"捕获异常: {e}")

# 使用contextlib模块
from contextlib import contextmanager, closing

# 使用contextmanager装饰器创建上下文管理器
@contextmanager
def database_connection(db_name):
    """数据库连接上下文管理器
    Args:
        db_name (str): 数据库名称
    Yields:
        dict: 数据库连接对象
    """
    print(f"连接到数据库: {db_name}")
    connection = {"db": db_name, "connected": True}

    try:
        yield connection  # 返回连接对象
    finally:
        connection["connected"] = False
        print(f"断开与数据库 {db_name} 的连接")

# 使用数据库连接上下文管理器
with database_connection("test_db") as conn:
    print(f"数据库状态: {conn}")
    # 执行数据库操作...

# 使用closing上下文管理器
from urllib.request import urlopen

with closing(urlopen("https://www.python.org")) as page:
    content = page.read(1024)  # 读取前1024字节
    print(f"读取内容长度: {len(content)} 字节")
```

### 嵌套上下文管理器

```python
# 嵌套上下文管理器
class Resource:
    """资源管理器 - 管理资源的获取和释放"""

    def __init__(self, name):
        """初始化资源
        Args:
            name (str): 资源名称
        """
        self.name = name

    def __enter__(self):
        """获取资源"""
        print(f"获取资源: {self.name}")
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """释放资源"""
        print(f"释放资源: {self.name}")
        return False

# 嵌套使用多个上下文管理器
with Resource("资源A") as a, Resource("资源B") as b:
    print(f"同时使用 {a.name} 和 {b.name}")

# 动态上下文管理器
class DynamicContextManager:
    """动态上下文管理器 - 动态管理多个上下文"""

    def __init__(self):
        """初始化动态上下文管理器"""
        self.stack = []

    def add_context(self, context_manager):
        """添加上下文管理器
        Args:
            context_manager: 要添加的上下文管理器
        """
        self.stack.append(context_manager)

    def __enter__(self):
        """进入所有上下文"""
        for cm in self.stack:
            cm.__enter__()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """退出所有上下文（与进入相反的顺序）"""
        for cm in reversed(self.stack):
            cm.__exit__(exc_type, exc_val, exc_tb)
        return False

# 使用动态上下文管理器
dynamic = DynamicContextManager()
dynamic.add_context(Resource("动态资源1"))
dynamic.add_context(Resource("动态资源2"))
dynamic.add_context(Timer("动态资源管理"))

with dynamic:
    print("使用动态管理的多个资源")
```

### 异常处理应用

```python
# 上下文管理器在异常处理中的应用
class ExceptionLogger:
    """异常日志上下文管理器 - 记录和处理异常"""

    def __init__(self, log_file="errors.log"):
        """初始化异常日志器
        Args:
            log_file (str): 日志文件名
        """
        self.log_file = log_file
        self.errors = []

    def __enter__(self):
        """进入上下文管理器"""
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """退出上下文管理器"""
        if exc_type:
            error_info = {
                "type": exc_type.__name__,
                "message": str(exc_val),
                "traceback": exc_tb
            }
            self.errors.append(error_info)
            self.log_errors()
        return False  # 不抑制异常

    def log_errors(self):
        """记录错误到文件"""
        with open(self.log_file, "a", encoding="utf-8") as f:
            import datetime
            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            f.write(f"\n[{timestamp}] 错误发生:\n")
            for error in self.errors:
                f.write(f"  类型: {error['type']}\n")
                f.write(f"  消息: {error['message']}\n")

# 使用异常日志上下文管理器
with ExceptionLogger("my_errors.log"):
    print("执行可能出错的代码...")
    # 故意引发错误
    # raise ValueError("这是一个测试错误")
```

### 资源清理应用

```python
# 上下文管理器在资源清理中的应用
@contextmanager
def temporary_file(content, mode="w+"):
    """临时文件上下文管理器 - 自动创建和清理临时文件
    Args:
        content (str): 文件内容
        mode (str): 文件打开模式
    Yields:
        file: 临时文件对象
    """
    import os
    import tempfile

    # 创建临时文件
    temp_file = tempfile.NamedTemporaryFile(mode=mode, delete=False)
    try:
        if content:
            temp_file.write(content)
        temp_file.flush()  # 确保内容写入磁盘
        temp_file.seek(0)  # 回到文件开头
        yield temp_file
    finally:
        temp_file.close()
        os.unlink(temp_file.name)  # 删除临时文件

# 使用临时文件上下文管理器
with temporary_file("这是临时文件内容") as temp:
    content = temp.read()
    print(f"临时文件内容: {content}")
    print(f"临时文件路径: {temp.name}")
```

### 事务管理应用

```python
# 上下文管理器在事务管理中的应用
class Transaction:
    """事务管理器 - 管理一系列操作的提交或回滚"""

    def __init__(self):
        """初始化事务管理器"""
        self.operations = []
        self.committed = False

    def add_operation(self, operation, undo_operation):
        """添加操作和撤销操作
        Args:
            operation (function): 要执行的操作
            undo_operation (function): 撤销操作
        """
        self.operations.append((operation, undo_operation))

    def commit(self):
        """提交事务"""
        try:
            for operation, _ in self.operations:
                operation()
            self.committed = True
            print("事务提交成功")
        except Exception as e:
            print(f"事务提交失败: {e}")
            self.rollback()

    def rollback(self):
        """回滚事务"""
        print("回滚事务")
        for _, undo_operation in reversed(self.operations):
            try:
                undo_operation()
            except Exception as e:
                print(f"回滚操作失败: {e}")

    def __enter__(self):
        """进入事务上下文"""
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """退出事务上下文"""
        if exc_type:
            print(f"事务中发生异常: {exc_val}")
            self.rollback()
            return True  # 抑制异常
        else:
            self.commit()
            return False

# 使用事务管理器
class BankAccount:
    """银行账户"""

    def __init__(self, balance):
        """初始化账户
        Args:
            balance (float): 初始余额
        """
        self.balance = balance

    def deposit(self, amount):
        """存款
        Args:
            amount (float): 存款金额
        """
        self.balance += amount
        print(f"存款 {amount}，余额：{self.balance}")

    def withdraw(self, amount):
        """取款
        Args:
            amount (float): 取款金额
        Raises:
            ValueError: 当余额不足时抛出异常
        """
        if amount > self.balance:
            raise ValueError("余额不足")
        self.balance -= amount
        print(f"取款 {amount}，余额：{self.balance}")

# 账户转账事务
account1 = BankAccount(1000)
account2 = BankAccount(500)

with Transaction() as tx:
    # 账户1取款100
    tx.add_operation(
        lambda: account1.withdraw(100),
        lambda: account1.deposit(100)  # 撤销操作：存款100
    )

    # 账户2存款100
    tx.add_operation(
        lambda: account2.deposit(100),
        lambda: account2.withdraw(100)  # 撤销操作：取款100
    )

    # 模拟可能的错误
    # raise Exception("银行系统故障")

print(f"账户1余额: {account1.balance}")
print(f"账户2余额: {account2.balance}")
```
