## 标准库模块详解

Python标准库提供了丰富的模块，这些模块无需安装即可直接使用。下面介绍几个最常用的标准库模块及其功能：

### math模块 - 数学运算

math模块提供了大量的数学函数和常数，适用于科学计算和工程应用。下面展示了math模块的常用功能：

```python
# math模块 - 数学运算
# math模块提供了大量的数学函数和常数，适用于科学计算和工程应用
import math

# 基本数学常数
print(f"π: {math.pi}")          # 圆周率π，约等于3.14159
print(f"e: {math.e}")            # 自然常数e，约等于2.71828
print(f"τ: {math.tau}")          # τ = 2π，约等于6.28318
print(f"无穷大: {math.inf}")     # 正无穷大
print(f"非数字: {math.nan}")     # NaN (Not a Number)，表示无效的数值运算结果

> **注意**: NaN是一个特殊值，表示"不是数字"的结果。需要注意：
> 1. NaN与任何值（包括它自己）比较都返回False：`math.nan != math.nan` 为True
> 2. 检查一个值是否为NaN应使用`math.isnan(x)`函数
> 3. NaN通常由无效数学运算产生，如0/0、sqrt(-1)等

# 基本数学函数
print(f"向上取整: {math.ceil(3.14)}")       # ceil(x) 返回不小于x的最小整数
print(f"向下取整: {math.floor(3.14)}")      # floor(x) 返回不大于x的最大整数
print(f"截断: {math.trunc(3.14)}")          # trunc(x) 返回x的整数部分
print(f"绝对值: {math.fabs(-3.14)}")         # fabs(x) 返回x的绝对值，返回浮点数
print(f"阶乘: {math.factorial(5)}")          # factorial(n) 返回n的阶乘
print(f"最大公约数: {math.gcd(24, 36)}")    # gcd(a,b) 返回a和b的最大公约数

# 幂和对数函数
print(f"2的3次方: {math.pow(2, 3)}")        # pow(x,y) 返回x的y次幂
print(f"平方根: {math.sqrt(16)}")            # sqrt(x) 返回x的平方根
print(f"自然对数: {math.log(10)}")           # log(x) 返回x的自然对数（以e为底）
print(f"以2为底的对数: {math.log2(10)}")     # log2(x) 返回以2为底x的对数
print(f"以10为底的对数: {math.log10(10)}")   # log10(x) 返回以10为底x的对数

# 三角函数
# 注意：三角函数的参数单位是弧度，不是角度
angle = math.pi / 4  # 45度转换为弧度

> **角度与弧度转换**:
> - 弧度 = 角度 × π/180
> - 角度 = 弧度 × 180/π
> - math.degrees(x) 将弧度转换为角度
> - math.radians(x) 将角度转换为弧度
print(f"正弦: {math.sin(angle)}")            # sin(x) 返回x的正弦值
print(f"余弦: {math.cos(angle)}")            # cos(x) 返回x的余弦值
print(f"正切: {math.tan(angle)}")            # tan(x) 返回x的正切值
print(f"反正弦: {math.asin(0.5)}")           # asin(x) 返回x的反正弦值
```

**math模块常用函数总结**

| 函数类别 | 函数名 | 功能说明 | 示例 |
|---------|--------|----------|------|
| 常数 | `math.pi` | 圆周率π | `math.pi ≈ 3.14159` |
| 常数 | `math.e` | 自然常数e | `math.e ≈ 2.71828` |
| 取整 | `math.ceil(x)` | 向上取整 | `math.ceil(3.14) = 4` |
| 取整 | `math.floor(x)` | 向下取整 | `math.floor(3.14) = 3` |
| 取整 | `math.trunc(x)` | 截断小数部分 | `math.trunc(3.14) = 3` |
| 幂运算 | `math.pow(x,y)` | x的y次幂 | `math.pow(2,3) = 8.0` |
| 幂运算 | `math.sqrt(x)` | 平方根 | `math.sqrt(16) = 4.0` |
| 对数 | `math.log(x)` | 自然对数 | `math.log(10) ≈ 2.302` |
| 对数 | `math.log2(x)` | 以2为底的对数 | `math.log2(8) = 3.0` |
| 对数 | `math.log10(x)` | 以10为底的对数 | `math.log10(100) = 2.0` |
| 三角函数 | `math.sin(x)` | 正弦函数 | `math.sin(0) = 0.0` |
| 三角函数 | `math.cos(x)` | 余弦函数 | `math.cos(0) = 1.0` |
| 三角函数 | `math.tan(x)` | 正切函数 | `math.tan(0) = 0.0` |
| 反三角函数 | `math.asin(x)` | 反正弦函数 | `math.asin(0) = 0.0` |
| 反三角函数 | `math.acos(x)` | 反余弦函数 | `math.acos(1) = 0.0` |
| 反三角函数 | `math.atan(x)` | 反正切函数 | `math.atan(0) = 0.0` |

### random模块 - 随机数生成

random模块提供了各种随机数生成函数，常用于模拟、游戏开发和数据抽样。以下代码展示了random模块的常用功能：

```python
# random模块 - 随机数生成
# random模块提供了各种随机数生成函数，常用于模拟、游戏开发和数据抽样
import random

# 基本随机数
print(f"随机浮点数[0,1): {random.random()}")         # random() 返回[0.0, 1.0)之间的随机浮点数
print(f"随机整数[1,10]: {random.randint(1, 10)}")   # randint(a,b) 返回[a,b]之间的随机整数（包含b）
print(f"随机整数[1,10): {random.randrange(1, 10)}")  # randrange(start,stop) 返回[start,stop)之间的随机整数
print(f"随机浮点数[0,10]: {random.uniform(0, 10)}") # uniform(a,b) 返回[a,b]之间的随机浮点数

# 从序列中随机选择
items = ['apple', 'banana', 'cherry', 'date']
print(f"随机选择: {random.choice(items)}")                  # choice(seq) 从序列中随机选择一个元素
print(f"随机选择多个(不重复): {random.sample(items, 2)}")     # sample(seq,k) 从序列中随机选择k个不重复的元素
print(f"随机选择多个(可能重复): {random.choices(items, k=2)}") # choices(seq,k) 从序列中随机选择k个元素（可能重复）

# 打乱序列
# shuffle() 方法会直接修改原序列，将其中元素随机重排
numbers = list(range(1, 11))
print(f"原序列: {numbers}")
random.shuffle(numbers)      # 就地打乱列表顺序
print(f"打乱后: {numbers}")

> **注意**:
> 1. `shuffle()` 方法会直接修改原列表，不返回新列表
> 2. 如果不想修改原列表，可以先复制：`random.shuffle(numbers.copy())`
> 3. 对于不可变序列（如元组），不能使用shuffle()，可以先转换为列表

# 设置随机种子（保证可重复性）
# seed(n) 设置随机种子，使得每次运行程序时生成的随机数序列相同，便于调试和测试
random.seed(42)
print(f"种子42的随机数: {random.random()}")
random.seed(42)              # 重置相同的种子
print(f"重置种子的随机数: {random.random()}")  # 相同种子产生相同的随机数

> **随机种子应用场景**:
> 1. 调试程序时确保每次运行有相同的行为
> 2. 机器学习中划分训练集和测试集时确保可复现
> 3. 游戏中生成相同的地图或关卡
> 4. 密码学应用中应使用`secrets`模块而非random模块
> 5. 多线程环境下每个线程有自己的随机状态，需要分别设置种子
```

**random模块常用函数总结**

| 函数名 | 功能说明 | 参数说明 | 示例 |
|--------|----------|----------|------|
| `random()` | 返回[0.0, 1.0)之间的随机浮点数 | 无参数 | `random.random()` |
| `randint(a,b)` | 返回[a,b]之间的随机整数（包含b） | a:起始值, b:结束值 | `random.randint(1,10)` |
| `randrange(start,stop)` | 返回[start,stop)之间的随机整数 | start:起始值, stop:结束值 | `random.randrange(1,10)` |
| `uniform(a,b)` | 返回[a,b]之间的随机浮点数 | a:起始值, b:结束值 | `random.uniform(0,10)` |
| `choice(seq)` | 从序列中随机选择一个元素 | seq:序列对象 | `random.choice(['a','b','c'])` |
| `sample(seq,k)` | 从序列中随机选择k个不重复的元素 | seq:序列对象, k:选择数量 | `random.sample([1,2,3],2)` |
| `choices(seq,k)` | 从序列中随机选择k个元素（可能重复） | seq:序列对象, k:选择数量 | `random.choices([1,2,3],k=2)` |
| `shuffle(lst)` | 就地打乱列表顺序 | lst:列表对象 | `random.shuffle([1,2,3])` |
| `seed(n)` | 设置随机种子 | n:种子值 | `random.seed(42)` |

### datetime模块 - 日期和时间

datetime模块提供了处理日期和时间的类和函数，支持日期时间的创建、格式化、解析和计算。以下代码展示了datetime模块的基本用法：

```python
# datetime模块 - 日期和时间
# datetime模块提供了处理日期和时间的类和函数，支持日期时间的创建、格式化、解析和计算
from datetime import datetime, date, time, timedelta

# 获取当前日期和时间
# datetime.now() 返回当前本地日期和时间
now = datetime.now()
print(f"当前日期时间: {now}")
# strftime() 方法将datetime对象格式化为字符串
print(f"格式化日期时间: {now.strftime('%Y-%m-%d %H:%M:%S')}")

# 创建特定日期时间
# date(year,month,day) 创建日期对象
specific_date = date(2023, 12, 6)
# time(hour,minute,second) 创建时间对象
specific_time = time(14, 30, 45)
# datetime(year,month,day,hour,minute,second) 创建日期时间对象
specific_datetime = datetime(2023, 12, 6, 14, 30, 45)

print(f"特定日期: {specific_date}")
print(f"特定时间: {specific_time}")
print(f"特定日期时间: {specific_datetime}")

# 日期计算
# timedelta 表示两个日期或时间之间的差值
delta = timedelta(days=10, hours=5)  # 创建10天5小时的时间间隔
future_date = now + delta           # 当前时间加上时间间隔
print(f"10天5小时后: {future_date}")

# 日期差值
# 两个date对象相减得到timedelta对象
date1 = date(2023, 12, 6)
date2 = date(2024, 1, 1)
difference = date2 - date1
print(f"日期差: {difference.days}天")  # .days属性获取天数差
```

**datetime模块常用类和方法**

| 类名 | 功能说明 | 主要方法/属性 |
|------|----------|---------------|
| `datetime` | 日期时间对象 | `now()`, `strftime()`, `strptime()` |
| `date` | 日期对象 | `today()`, year, month, day |
| `time` | 时间对象 | hour, minute, second, microsecond |
| `timedelta` | 时间间隔对象 | days, seconds, microseconds |

**日期格式化符号说明**

| 符号 | 含义 | 示例 |
|------|------|------|
| `%Y` | 四位年份 | 2023 |
| `%m` | 月份（01-12） | 12 |
| `%d` | 日期（01-31） | 06 |
| `%H` | 小时（00-23） | 14 |
| `%M` | 分钟（00-59） | 30 |
| `%S` | 秒（00-59） | 45 |

**字符串日期解析**

以下代码展示如何将字符串解析为日期对象：

```python
# 字符串解析日期
# strptime(string,format) 将格式化的字符串解析为datetime对象
date_str = "2023-12-06 14:30:45"
parsed_date = datetime.strptime(date_str, "%Y-%m-%d %H:%M:%S")
print(f"解析的日期: {parsed_date}")
```

### os模块 - 操作系统接口

os模块提供了与操作系统交互的功能，包括文件系统操作、环境变量管理等：

```python
# os模块 - 操作系统接口
# os模块提供了与操作系统交互的功能，包括文件系统操作、环境变量管理等
import os

# 获取当前工作目录
# getcwd() 返回当前进程的工作目录
print(f"当前目录: {os.getcwd()}")

# 创建目录
# makedirs(path) 创建目录，exist_ok=True表示目录已存在时不报错
if not os.path.exists("test_dir"):
    os.makedirs("test_dir")
    print("目录创建成功")

# 列出目录内容
# listdir(path) 返回指定目录下的所有文件和目录名列表
print("当前目录内容:")
for item in os.listdir("."):
    item_type = "目录" if os.path.isdir(item) else "文件"  # isdir() 判断是否为目录
    print(f"  {item} ({item_type})")

# 路径操作
# dirname(path) 返回路径的目录部分；basename(path) 返回路径的文件名部分
file_path = "test_dir/example.txt"
dir_name = os.path.dirname(file_path)
base_name = os.path.basename(file_path)
print(f"目录名: {dir_name}")
print(f"文件名: {base_name}")

# 环境变量
# environ.get() 获取环境变量，第二个参数为默认值；os.environ[key] = value 设置环境变量
print(f"PATH环境变量: {os.environ.get('PATH', '未设置')}")
os.environ["MY_VAR"] = "我的变量"
print(f"自定义变量: {os.environ['MY_VAR']}")
```

**os模块常用函数总结**
| 函数名 | 功能说明 | 参数说明 | 示例 |
|--------|----------|----------|------|
| `getcwd()` | 获取当前工作目录 | 无参数 | `os.getcwd()` |
| `makedirs(path)` | 创建目录（可递归） | path:路径 | `os.makedirs("a/b/c")` |
| `listdir(path)` | 列出目录内容 | path:目录路径 | `os.listdir(".")` |
| `path.exists(path)` | 检查路径是否存在 | path:路径 | `os.path.exists("file.txt")` |
| `path.isfile(path)` | 检查是否为文件 | path:路径 | `os.path.isfile("file.txt")` |
| `path.isdir(path)` | 检查是否为目录 | path:路径 | `os.path.isdir("folder")` |
| `path.dirname(path)` | 获取路径的目录部分 | path:路径 | `os.path.dirname("/a/b/c.txt")` |
| `path.basename(path)` | 获取路径的文件名部分 | path:路径 | `os.path.basename("/a/b/c.txt")` |
| `environ.get(key)` | 获取环境变量 | key:变量名 | `os.environ.get("PATH")` |

### sys模块 - 系统相关参数和函数

sys模块提供了一系列与Python解释器及其环境相关的函数和变量。以下代码展示了sys模块的常用功能：

```python
# sys模块 - 系统相关参数和函数
# sys模块提供了一系列与Python解释器及其环境相关的函数和变量
import sys

# Python版本信息
# sys.version 返回Python版本字符串；sys.version_info 返回版本信息的元组
print(f"Python版本: {sys.version}")
print(f"版本信息: {sys.version_info}")

# 系统平台
# sys.platform 返回操作系统平台标识符
print(f"系统平台: {sys.platform}")

# 命令行参数
# sys.argv 是一个列表，包含命令行传递给脚本的参数，第一个元素是脚本名
print(f"脚本名称: {sys.argv[0]}")
print(f"命令行参数: {sys.argv[1:]}")

# Python路径
# sys.path 是一个列表，包含Python解释器搜索模块的目录路径
print(f"模块搜索路径: {sys.path[:3]}...")  # 显示前3个路径

# 递归深度限制
# getrecursionlimit() 返回递归深度限制；setrecursionlimit(limit) 设置新的递归深度限制
print(f"递归深度限制: {sys.getrecursionlimit()}")
sys.setrecursionlimit(2000)
print(f"新的递归深度限制: {sys.getrecursionlimit()}")
```

**sys模块重要属性和函数**
| 属性/函数名 | 功能说明 | 类型 |
|-------------|----------|------|
| `sys.version` | Python版本字符串 | str |
| `sys.version_info` | 版本信息元组 | tuple |
| `sys.platform` | 系统平台标识符 | str |
| `sys.argv` | 命令行参数列表 | list |
| `sys.path` | 模块搜索路径列表 | list |
| `sys.getrecursionlimit()` | 获取递归深度限制 | function |
| `sys.setrecursionlimit(limit)` | 设置递归深度限制 | function |

### collections模块 - 特殊容器数据类型

collections模块提供了Python标准内建容器dict、list、set和tuple的替代选择。以下代码展示了collections模块的主要功能：

```python
# collections模块 - 特殊容器数据类型
# collections模块提供了Python标准内建容器dict、list、set和tuple的替代选择
from collections import namedtuple, Counter, defaultdict, deque, OrderedDict

# namedtuple - 命名元组
# namedtuple创建一个继承自tuple的子类，可以通过属性名访问元素
Point = namedtuple('Point', ['x', 'y'])  # 创建Point类，有两个字段x和y
p1 = Point(1, 2)
print(f"点坐标: {p1}")
print(f"x坐标: {p1.x}, y坐标: {p1.y}")  # 通过属性名访问元素

# Counter - 计数器
# Counter是一个字典子类，用于可哈希对象的计数
words = ['apple', 'banana', 'apple', 'cherry', 'banana', 'apple']
word_counts = Counter(words)  # 统计每个单词出现的次数
print(f"词频统计: {word_counts}")
print(f"最常见的词: {word_counts.most_common(2)}")  # most_common(n)返回出现次数最多的n个元素

# defaultdict - 带默认值的字典
# defaultdict创建字典时指定默认值类型，访问不存在的键时自动创建默认值
d = defaultdict(list)  # 指定默认值为空列表
d['a'].append(1)       # d['a']自动创建为[]，然后append(1)
d['a'].append(2)
d['b'].append(3)
print(f"defaultdict: {dict(d)}")  # 转换为普通字典便于查看
```

**collections模块常用类总结**

| 类名 | 功能说明 | 特点 |
|------|----------|------|
| `namedtuple` | 命名元组 | 通过属性名访问元素，节省内存 |
| `Counter` | 计数器 | 统计元素出现次数，支持most_common() |
| `defaultdict` | 默认字典 | 访问不存在的键时自动创建默认值 |
| `deque` | 双端队列 | 支持两端高效添加和删除元素 |
| `OrderedDict` | 有序字典 | 保持键的插入顺序 |

**deque双端队列与OrderedDict有序字典**

```python
# deque - 双端队列
# deque是双向队列，支持从两端高效地添加和删除元素
dq = deque([1, 2, 3])
dq.append(4)     # append() 在右端添加元素
dq.appendleft(0) # appendleft() 在左端添加元素
dq.pop()         # pop() 从右端删除元素
dq.popleft()     # popleft() 从左端删除元素
print(f"deque: {dq}")

# OrderedDict - 有序字典（Python 3.7+dict默认有序）
# OrderedDict是一个字典子类，保持键的插入顺序（Python 3.7+中普通dict也是有序的）
od = OrderedDict()
od['first'] = 1
od['second'] = 2
od['third'] = 3
print(f"OrderedDict: {od}")
```

### itertools模块 - 迭代器工具

itertools模块包含了一系列用于高效迭代的函数，提供了许多创建和使用迭代器的工具：

```python
# itertools模块 - 迭代器工具
# itertools模块包含了一系列用于高效迭代的函数，提供了许多创建和使用迭代器的工具
import itertools

# count() - 无限计数器
# count(start,step) 创建一个从start开始，每次增加step的无限迭代器
for i in itertools.count(5):
    if i > 10:
        break
    print(i)

# cycle() - 无限循环
# cycle(iterable) 创建一个无限循环遍历iterable元素的迭代器
colors = ['red', 'green', 'blue']
for i, color in zip(range(6), itertools.cycle(colors)):
    print(f"{i}: {color}")

# product() - 笛卡尔积
# product(*iterables) 计算输入序列的笛卡尔积，相当于嵌套循环
colors = ['red', 'blue']
sizes = ['S', 'M', 'L']
combinations = list(itertools.product(colors, sizes))
print(f"组合: {combinations}")

# permutations() - 排列
# permutations(iterable,r) 返回长度为r的所有排列，r默认为len(iterable)
items = ['a', 'b', 'c']
perms = list(itertools.permutations(items, 2))
print(f"排列: {perms}")

# chain() - 连接迭代器
# chain(*iterables) 创建一个迭代器，将多个迭代器连接起来
chained = itertools.chain([1, 2], [3, 4], [5, 6])
print(f"连接: {list(chained)}")


# accumulate() - 累计
# accumulate(iterable,func) 创建一个迭代器，返回iterable的累计结果，func默认为加法
numbers = [1, 2, 3, 4, 5]
accumulated = list(itertools.accumulate(numbers))
print(f"累计: {accumulated}")

from itertools import pairwise
a = [1,2,3,4]
for x ,y in pairwise(a):
    print(x,y)
```

**itertools模块常用函数总结**

| 函数名 | 功能说明 | 参数说明 | 示例 |
|--------|----------|----------|------|
| `count(start,step)` | 无限计数器 | start:起始值, step:步长 | `itertools.count(0,2)` |
| `cycle(iterable)` | 无限循环 | iterable:可迭代对象 | `itertools.cycle([1,2,3])` |
| `product(*iterables)` | 笛卡尔积 | iterables:多个可迭代对象 | `itertools.product('AB','CD')` |
| `permutations(iterable,r)` | 排列 | iterable:可迭代对象, r:排列长度 | `itertools.permutations('ABC',2)` |
| `combinations(iterable,r)` | 组合 | iterable:可迭代对象, r:组合长度 | `itertools.combinations('ABC',2)` |
| `groupby(iterable,key)` | 分组 | iterable:可迭代对象, key:分组函数 | `itertools.groupby(data,key)` |
| `chain(*iterables)` | 连接迭代器 | iterables:多个可迭代对象 | `itertools.chain([1,2,3],[4,5,6])` |
| `accumulate(iterable,func)` | 累积 | iterable:可迭代对象, func:累积函数 | `itertools.accumulate([1,2,3,4,5])` |
| `pairwise(iterable)` | 迭代相邻元素 | iterable:可迭代对象 | `itertools.pairwise([1,2,3,4])` |
**itertools组合与分组**

```python
# itertools模块 - 迭代器工具
import itertools

# combinations() - 组合
# combinations(iterable,r) 返回长度为r的所有组合，元素顺序不重要且不重复
items = ['a', 'b', 'c']
combs = list(itertools.combinations(items, 2))
print(f"组合: {combs}")

# groupby() - 分组
# groupby(iterable,key) 对iterable中连续相同元素进行分组，key函数指定分组依据
s = '222333555'
for ch, group in groupby(s):
    print(ch,list(group))
"""
2 ['2', '2', '2']
3 ['3', '3', '3']
5 ['5', '5', '5']
"""
```
