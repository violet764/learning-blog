# Python 基础：面向对象

> 面向对象编程（OOP）是 Python 中一种重要的编程范式，它允许我们通过类来组织代码，通过对象表示现实世界中的实体。面向对象编程的核心思想是将数据和操作数据的方法封装在一起。

---

##  类与对象基础


类是对一类事物的抽象描述，是创建对象的模板或蓝图。类定义了事物的属性（特征）和行为（方法）。

对象是类的具体实例，是根据类的定义创建的具体实体。每个对象都有自己的属性值，但共享类定义的方法。

**类的组成**

```python
class Person:
    """人类 - 代表一个人的基本信息和行为"""

    # 类属性（所有实例共享）
    species = "Homo sapiens"

    # 构造方法（实例化时自动调用）
    def __init__(self, name, age, gender):
        """初始化方法，创建对象时自动调用

        Args:
            name: 姓名
            age: 年龄
            gender: 性别
        """
        # 实例属性（每个实例独有）
        self.name = name
        self.age = age
        self.gender = gender

    # 实例方法（第一个参数是 self）
    def introduce(self):
        """自我介绍"""
        return f"我叫{self.name}，今年{self.age}岁"

    # 类方法（第一个参数是 cls）
    @classmethod
    def from_birth_year(cls, name, birth_year, gender):
        """从出生年份创建对象"""
        current_year = 2023
        age = current_year - birth_year
        return cls(name, age, gender)

    # 静态方法（不需要特殊参数）
    @staticmethod
    def is_adult(age):
        """判断是否成年"""
        return age >= 18
```

**类属性 vs 实例属性**

- **类属性**：定义在类内部、方法外部的属性，所有实例共享
- **实例属性**：在 `__init__` 方法中通过 `self.xxx` 定义的属性，每个实例独有

```python
person1 = Person("张三", 25, "男")
person2 = Person("李四", 30, "女")

# 访问实例属性
print(person1.name)  # 张三

# 访问类属性
print(person1.species)  # Homo sapiens
print(Person.species)   # Homo sapiens

# 修改类属性（影响所有实例）
Person.species = "智人"
print(person1.species)  # 智人
print(person2.species)  # 智人
```

**方法类型**

1. **实例方法**：第一个参数是 `self`，操作实例属性
2. **类方法**：第一个参数是 `cls`，操作类属性
3. **静态方法**：没有特殊参数，只是普通的函数

---

## 属性访问器（Property）

Property 允许我们以属性的方式访问方法，同时可以在访问时添加验证逻辑。

```python
class Person:
    def __init__(self, name):
        self._name = name  # 私有属性

    # getter
    @property
    def name(self):
        return self._name

    # setter
    @name.setter
    def name(self, value):
        if not value:
            raise ValueError("姓名不能为空")
        self._name = value

    # deleter
    @name.deleter
    def name(self):
        print("删除姓名")
        self._name = None


person = Person("张三")
print(person.name)     # 获取 - 张三
person.name = "李四"   # 设置 - 李四
del person.name       # 删除
```

**Property 的作用**

1. **数据封装**：隐藏内部实现细节
2. **验证**：在设置值时进行验证
3. **计算属性**：动态计算属性值
4. **只读属性**：只提供 getter，不提供 setter

---

## 魔术方法（特殊方法）


魔术方法（也称为 Dunder Methods 或特殊方法）是 Python 类中以双下划线开头和结尾的方法，它们在特定情况下会自动被调用。

**字符串表示**

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    # 面向用户 - print()、str() 调用
    def __str__(self):
        return f"{self.name}，{self.age}岁"

    # 面向开发者 - repr()、调试调用
    def __repr__(self):
        return f"Person('{self.name}', {self.age})"


person = Person("张三", 25)
print(str(person))    # 张三，25岁
print(repr(person))  # Person('张三', 25)
```

**运算符魔术方法**

```python
class Vector:
    """二维向量类"""

    def __init__(self, x, y):
        self.x = x
        self.y = y

    # 一元运算符
    def __neg__(self):
        return Vector(-self.x, -self.y)

    def __abs__(self):
        return (self.x ** 2 + self.y ** 2) ** 0.5

    # 二元运算符
    def __add__(self, other):
        return Vector(self.x + other.x, self.y + other.y)

    def __sub__(self, other):
        return Vector(self.x - other.x, self.y - other.y)

    def __mul__(self, scalar):
        return Vector(self.x * scalar, self.y * scalar)

    def __rmul__(self, scalar):  # 支持 scalar * vector
        return self.__mul__(scalar)

    def __truediv__(self, scalar):
        return Vector(self.x / scalar, self.y / scalar)

    # 比较运算符
    def __eq__(self, other):
        return self.x == other.x and self.y == other.y

    def __lt__(self, other):
        return abs(self) < abs(other)

    # 字符串表示
    def __str__(self):
        return f"Vector({self.x}, {self.y})"

    def __repr__(self):
        return f"Vector(x={self.x}, y={self.y})"


v1 = Vector(3, 4)
v2 = Vector(1, 2)

print(v1 + v2)        # Vector(4, 6)
print(v1 - v2)        # Vector(2, 2)
print(v1 * 3)         # Vector(9, 12)
print(3 * v1)         # Vector(9, 12)
print(-v1)            # Vector(-3, -4)
print(abs(v1))        # 5.0
```

**容器协议**

```python
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __len__(self):
        """len() 函数"""
        return 2

    def __getitem__(self, index):
        """索引访问 []"""
        if index == 0: return self.x
        if index == 1: return self.y
        raise IndexError("索引超出范围")

    def __setitem__(self, index, value):
        """索引赋值 [] ="""
        if index == 0: self.x = value
        elif index == 1: self.y = value
        else: raise IndexError()

    def __contains__(self, value):
        """in 运算符"""
        return value == self.x or value == self.y


v = Vector(3, 4)
print(len(v))         # 2
print(v[0], v[1])   # 3 4
print(3 in v)        # True
```

**可调用对象**

```python
class Callable:
    def __call__(self, *args, **kwargs):
        return f"被调用，参数: {args}, {kwargs}"

obj = Callable()
print(obj())           # 被调用，参数: (), {}
print(obj(1, 2, x=3)) # 被调用，参数: (1, 2), {'x': 3}
```

---

##  继承与多态


继承是面向对象的核心特性之一，允许创建新类（子类）来继承现有类（父类）的属性和方法。子类可以重用父类的代码，也可以重写或扩展父类的行为。

**单继承**

```python
# 父类
class Animal:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def eat(self):
        return f"{self.name}正在吃东西"

    def sleep(self):
        return f"{self.name}正在睡觉"

    def make_sound(self):
        raise NotImplementedError("子类必须实现")


# 子类
class Dog(Animal):
    def __init__(self, name, age, breed):
        super().__init__(name, age)  # 调用父类构造方法
        self.breed = breed

    def make_sound(self):
        return f"{self.name}汪汪叫"

    def fetch(self):
        return f"{self.name}跑去捡球"


class Cat(Animal):
    def __init__(self, name, age, color):
        super().__init__(name, age)
        self.color = color

    def make_sound(self):
        return f"{self.name}喵喵叫"

    def climb(self):
        return f"{self.name}爬到树上"


# 使用
dog = Dog("旺财", 3, "金毛")
print(dog.eat())       # 继承自父类
print(dog.make_sound()) # 重写父类方法
print(dog.fetch())      # 子类特有方法
```

**多重继承**

Python 支持一个类继承多个父类：

```python
class Pet:
    def __init__(self, owner):
        self.owner = owner

    def show_affection(self):
        return f"{self.owner}的宠物表达爱意"


class PetDog(Dog, Pet):  # 同时继承 Dog 和 Pet
    def __init__(self, name, age, breed, owner):
        Dog.__init__(self, name, age, breed)
        Pet.__init__(self, owner)


pet_dog = PetDog("小白", 4, "贵宾犬", "张三")
print(pet_dog.make_sound())  # 继承自 Dog
print(pet_dog.show_affection())  # 继承自 Pet
```

**方法解析顺序（MRO）**

当存在多重继承时，Python 使用 MRO 来确定方法调用的顺序：

```python
print(PetDog.__mro__)
# 输出类似: (<class 'PetDog'>, <class 'Dog'>, <class 'Pet'>, <class 'Animal'>, <class 'object'>)
```

多态允许不同类的对象对同一方法调用做出不同的响应：

```python
def animal_sound(animal):
    """接收任何 Animal 或其子类的对象"""
    print(f"{animal.name}: {animal.make_sound()}")


dog = Dog("旺财", 3, "金毛")
cat = Cat("咪咪", 2, "白色")

animal_sound(dog)  # 旺财: 旺财汪汪叫
animal_sound(cat)  # 咪咪: 咪咪喵喵叫
```

多态的优势：
- 代码复用：可以使用父类类型引用子类对象
- 接口统一：不同对象可以用相同方式操作
- 扩展性：添加新子类无需修改已有代码

---

## 特殊类

### 抽象基类（ABC）

抽象基类定义了一个类的接口，子类必须实现抽象方法：

```python
from abc import ABC, abstractmethod

class Shape(ABC):
    """形状抽象基类"""

    @abstractmethod
    def area(self):
        """计算面积"""
        pass

    @abstractmethod
    def perimeter(self):
        """计算周长"""
        pass

    def description(self):
        """具体方法 - 子类可以直接使用"""
        return f"面积={self.area()}，周长={self.perimeter()}"


class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

    def perimeter(self):
        return 2 * (self.width + self.height)


rect = Rectangle(5, 3)
print(rect.description())  # 面积=15，周长=16
```

### 数据类（dataclass）

数据类用于存储数据，自动生成 `__init__`、`__repr__`、`__eq__` 等方法：

```python
from dataclasses import dataclass, field

@dataclass
class Student:
    name: str
    age: int
    grades: list = field(default_factory=list)  # 默认工厂
    id: int = field(default=0, init=False)       # 不参与 init

    def __post_init__(self):
        """初始化后处理"""
        if self.id == 0:
            self.id = hash(self.name) % 10000

    def average_grade(self):
        if not self.grades:
            return 0
        return sum(self.grades) / len(self.grades)


student = Student("张三", 18, [85, 90, 78])
print(student)              # Student(name='张三', age=18, ...)
print(student.average_grade())  # 84.33...
```

### 枚举类（Enum）

枚举类用于定义一组相关的常量：

```python
from enum import Enum, auto, unique

@unique  # 确保值唯一
class Color(Enum):
    RED = auto()
    GREEN = auto()
    BLUE = auto()


class Status(Enum):
    PENDING = 1
    APPROVED = 2
    REJECTED = 3

    @property
    def description(self):
        return {self.PENDING: "待处理",
                self.APPROVED: "已批准",
                self.REJECTED: "已拒绝"}[self]


print(Color.RED.name)   # RED
print(Color.RED.value)   # 1
print(Status.APPROVED.description)  # 已批准
```

---

##  描述符协议

描述符是 Python 中属性访问的底层协议，用于自定义属性查找、设置和删除行为。

```python
class Integer:
    """整数属性描述符 - 验证并转换整数属性"""

    def __init__(self, min_value=None, max_value=None):
        self.min_value = min_value
        self.max_value = max_value

    def __set_name__(self, owner, name):
        self.name = name

    def __get__(self, obj, objtype=None):
        return getattr(obj, f"_value_{self.name}", None)

    def __set__(self, obj, value):
        if not isinstance(value, int):
            raise TypeError(f"{self.name} 必须是整数")
        if self.min_value and value < self.min_value:
            raise ValueError(f"{self.name} 必须 >= {self.min_value}")
        if self.max_value and value > self.max_value:
            raise ValueError(f"{self.name} 必须 <= {self.max_value}")
        obj.__dict__[f"_value_{self.name}"] = value


class Student:
    """使用描述符验证属性"""
    age = Integer(min_value=0, max_value=150)
    score = Integer(min_value=0, max_value=100)

    def __init__(self, name, age, score):
        self.name = name
        self.age = age
        self.score = score


student = Student("张三", 18, 85)
print(student.age)   # 18

# student.age = -1   # ValueError: age 必须 >= 0
# student.score = 101  # ValueError: score 必须 <= 100
```

**描述符优先级**

1. 数据描述符（同时有 `__get__` 和 `__set__`）
2. 实例字典中的值
3. 非数据描述符（只有 `__get__`）
4. 类属性

---

## 迭代器与可迭代对象

**迭代器协议**

迭代器需要实现两个方法：
- `__iter__()`：返回迭代器本身
- `__next__()`：返回下一个元素

```python
class RangeIterator:
    """范围迭代器"""

    def __init__(self, start, stop, step=1):
        self.current = start
        self.stop = stop
        self.step = step

    def __iter__(self):
        return self

    def __next__(self):
        if self.step > 0 and self.current >= self.stop:
            raise StopIteration
        if self.step < 0 and self.current <= self.stop:
            raise StopIteration
        result = self.current
        self.current += self.step
        return result


for i in RangeIterator(0, 5):
    print(i, end=" ")  # 0 1 2 3 4
```

**可迭代对象**

可迭代对象实现了 `__iter__` 方法，返回迭代器：

```python
class ReverseList:
    """反向列表"""

    def __init__(self, data):
        self.data = list(data)

    def __iter__(self):
        return iter(reversed(self.data))

    def __reversed__(self):
        return reversed(self.data)


numbers = [1, 2, 3, 4, 5]
for num in ReverseList(numbers):
    print(num, end=" ")  # 5 4 3 2 1
```

---

##  设计模式

### 单例模式

确保一个类只有一个实例：

```python
class Singleton:
    _instance = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance


s1 = Singleton()
s2 = Singleton()
print(s1 is s2)  # True
```

### 工厂模式

封装对象的创建逻辑：

```python
class AnimalFactory:
    @staticmethod
    def create_animal(animal_type, name, age, **kwargs):
        if animal_type.lower() == "dog":
            return Dog(name, age, kwargs.get("breed", "未知"))
        elif animal_type.lower() == "cat":
            return Cat(name, age, kwargs.get("color", "未知"))
        raise ValueError(f"不支持的类型：{animal_type}")


dog = AnimalFactory.create_animal("dog", "旺财", 3)
cat = AnimalFactory.create_animal("cat", "咪咪", 2)
```

### 观察者模式

定义对象间的一对多依赖关系：

```python
class Observable:
    def __init__(self):
        self._observers = []

    def add_observer(self, observer):
        if observer not in self._observers:
            self._observers.append(observer)

    def notify_observers(self, message):
        for observer in self._observers:
            observer.update(message)


class Observer:
    def update(self, message):
        print(f"收到通知：{message}")


# 使用
observable = Observable()
observable.add_Observer(Observer())
observable.notify_observers("Hello")
```

---

## 类的高级特性

### 元类编程

元类是创建类的类：

```python
class SingletonMeta(type):
    _instances = {}

    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super().__call__(*args, **kwargs)
        return cls._instances[cls]


class Database(metaclass=SingletonMeta):
    def __init__(self):
        self.id = id(self)


db1 = Database()
db2 = Database()
print(db1 is db2)  # True
```

### Mixin（混入）

Mixin 是一种代码复用模式，通过多重继承来添加功能：

```python
class LoggableMixin:
    def log(self, message):
        print(f"[{self.__class__.__name__}] {message}")


class TimestampMixin:
    def get_timestamp(self):
        from datetime import datetime
        return datetime.now().isoformat()


class User(LoggableMixin, TimestampMixin):
    def __init__(self, name):
        self.name = name

    def login(self):
        self.log(f"用户 {self.name} 登录")
        print(f"登录时间: {self.get_timestamp()}")


user = User("张三")
user.login()
```

### __slots__ 优化

限制实例属性，节省内存：

```python
class OptimizedPoint:
    __slots__ = ['x', 'y']

    def __init__(self, x, y):
        self.x = x
        self.y = y


class NormalPoint:
    def __init__(self, x, y):
        self.x = x
        self.y = y


import sys
print(sys.getsizeof(OptimizedPoint(1, 2)))  # 更小
print(sys.getsizeof(NormalPoint(1, 2)))    # 更大
```

---

