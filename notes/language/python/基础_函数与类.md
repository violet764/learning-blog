#### 函数定义

```python
# 基本函数定义
def greet(name):
    return f"你好, {name}!"

# 带默认参数的函数
def introduce(name, age=25):
    return f"我叫{name}，今年{age}岁"

# 可变参数
def sum_all(*numbers):
    return sum(numbers)

def create_profile(**kwargs):
    return kwargs

# 调用函数
print(greet("小明"))
print(introduce("小红"))
print(introduce("小李", 28))
print(sum_all(1, 2, 3, 4, 5))
print(create_profile(name="小王", age=22, city="上海"))
```


#### 类与对象

面向对象编程（OOP）是Python中一种重要的编程范式，它允许我们通过类来组织代码，通过对象来表示现实世界中的实体。

##### 类的基本概念

```python
# 类的定义
class Person:
    """人类"""
    
    # 类属性（所有实例共享）
    species = "Homo sapiens"
    
    # 构造方法（实例化时自动调用）
    def __init__(self, name, age, gender):
        """初始化方法"""
        # 实例属性（每个实例独有）
        self.name = name
        self.age = age
        self.gender = gender
        self.__secret = "这是隐私信息"  # 私有属性（双下划线开头）
    
    # 实例方法（第一个参数必须是self）
    def introduce(self):
        """自我介绍"""
        return f"我叫{self.name}，今年{self.age}岁"
    
    def celebrate_birthday(self):
        """过生日"""
        self.age += 1
        print(f"{self.name}现在{self.age}岁了！")
    
    # 类方法（第一个参数是cls）
    @classmethod
    def from_birth_year(cls, name, birth_year, gender):
        """从出生年份创建Person对象"""
        current_year = 2023  # 简化处理
        age = current_year - birth_year
        return cls(name, age, gender)
    
    # 静态方法（不需要特殊参数）
    @staticmethod
    def is_adult(age):
        """判断是否成年"""
        return age >= 18
    
    # 属性访问器
    @property
    def secret(self):
        """获取私有属性"""
        return self.__secret
    
    @secret.setter
    def secret(self, new_secret):
        """设置私有属性"""
        if len(new_secret) > 0:
            self.__secret = new_secret
    
    # 删除器
    @secret.deleter
    def secret(self):
        """删除私有属性"""
        print("删除隐私信息")
        self.__secret = None
    
    # 魔术方法（特殊方法）
    def __str__(self):
        """字符串表示（面向用户）"""
        return f"{self.name}，{self.age}岁"
    
    def __repr__(self):
        """官方字符串表示（面向开发者）"""
        return f"Person('{self.name}', {self.age}, '{self.gender}')"
    
    def __eq__(self, other):
        """相等性比较"""
        if isinstance(other, Person):
            return (self.name == other.name and 
                   self.age == other.age and 
                   self.gender == other.gender)
        return False
    
    def __lt__(self, other):
        """小于比较（基于年龄）"""
        if isinstance(other, Person):
            return self.age < other.age
        return NotImplemented

# 创建实例（对象）
person1 = Person("张三", 25, "男")
person2 = Person("李四", 30, "女")

# 访问实例属性
print(f"姓名：{person1.name}")
print(f"年龄：{person1.age}")

# 调用实例方法
print(person1.introduce())
person1.celebrate_birthday()

# 访问类属性
print(f"物种：{person1.species}")
print(f"物种：{Person.species}")

# 修改类属性（影响所有实例）
Person.species = "智人"
print(f"修改后的物种：{person1.species}")

# 调用类方法
person3 = Person.from_birth_year("王五", 1995, "男")
print(f"王五：{person3}")

# 调用静态方法
print(f"25岁是否成年：{Person.is_adult(25)}")
print(f"16岁是否成年：{Person.is_adult(16)}")

# 使用属性访问器
print(f"隐私信息：{person1.secret}")
person1.secret = "新的隐私信息"
print(f"更新后的隐私信息：{person1.secret}")

# 使用魔术方法
print(f"字符串表示：{str(person1)}")
print(f"官方表示：{repr(person1)}")

# 对象比较
person4 = Person("张三", 25, "男")
print(f"person1 == person4：{person1 == person4}")
print(f"person1 < person2：{person1 < person2}")

# 删除属性
del person1.secret
```

##### 继承与多态

```python
# 基类（父类）
class Animal:
    """动物基类"""
    
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def make_sound(self):
        """发出声音"""
        raise NotImplementedError("子类必须实现此方法")
    
    def eat(self):
        """吃东西"""
        return f"{self.name}正在吃东西"
    
    def sleep(self):
        """睡觉"""
        return f"{self.name}正在睡觉"

# 派生类（子类）
class Dog(Animal):
    """狗类"""
    
    def __init__(self, name, age, breed):
        # 调用父类的构造方法
        super().__init__(name, age)
        self.breed = breed
    
    def make_sound(self):
        """狗叫"""
        return f"{self.name}汪汪叫"
    
    def fetch(self):
        """捡东西"""
        return f"{self.name}跑去捡球"
    
    def __str__(self):
        return f"狗：{self.name}，{self.age}岁，品种：{self.breed}"

class Cat(Animal):
    """猫类"""
    
    def __init__(self, name, age, color):
        super().__init__(name, age)
        self.color = color
    
    def make_sound(self):
        """猫叫"""
        return f"{self.name}喵喵叫"
    
    def climb(self):
        """爬树"""
        return f"{self.name}爬到树上"
    
    def __str__(self):
        return f"猫：{self.name}，{self.age}岁，颜色：{self.color}"

# 多重继承
class Pet:
    """宠物特征"""
    
    def __init__(self, owner):
        self.owner = owner
    
    def show_affection(self):
        """显示感情"""
        return f"{self.owner}的宠物表达爱意"

class PetDog(Dog, Pet):
    """宠物狗（多重继承）"""
    
    def __init__(self, name, age, breed, owner):
        # 调用多个父类的构造方法
        Dog.__init__(self, name, age, breed)
        Pet.__init__(self, owner)
    
    def __str__(self):
        return f"宠物狗：{self.name}，主人：{self.owner}"

# 使用继承
dog = Dog("旺财", 3, "金毛")
cat = Cat("咪咪", 2, "白色")

print(dog)
print(cat)
print(dog.make_sound())
print(cat.make_sound())
print(dog.eat())
print(cat.sleep())
print(dog.fetch())
print(cat.climb())

# 多态示例
def animal_sound(animal):
    """让动物发出声音"""
    print(f"声音：{animal.make_sound()}")

# 不同类型的对象调用相同的方法
animal_sound(dog)  # 狗叫
animal_sound(cat)  # 猫叫

# 多重继承
pet_dog = PetDog("小白", 4, "贵宾犬", "张三")
print(pet_dog)
print(pet_dog.make_sound())
print(pet_dog.show_affection())

# 方法解析顺序（MRO）
print(f"PetDog的方法解析顺序：{PetDog.__mro__}")
```

##### 特殊类与高级特性

```python
# 抽象基类
from abc import ABC, abstractmethod

class Shape(ABC):
    """形状抽象基类"""
    
    @abstractmethod
    def area(self):
        """计算面积"""
        pass
    
    @abstractmethod
    def perimeter(self):
        """计算周长"""
        pass
    
    def description(self):
        """描述（具体方法）"""
        return f"这是一个形状，面积为{self.area()}，周长为{self.perimeter()}"

class Rectangle(Shape):
    """矩形类"""
    
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def area(self):
        return self.width * self.height
    
    def perimeter(self):
        return 2 * (self.width + self.height)

class Circle(Shape):
    """圆形类"""
    
    def __init__(self, radius):
        self.radius = radius
    
    def area(self):
        import math
        return math.pi * self.radius ** 2
    
    def perimeter(self):
        import math
        return 2 * math.pi * self.radius

# 使用抽象基类
rect = Rectangle(5, 3)
circle = Circle(2)

print(f"矩形：{rect.description()}")
print(f"圆形：{circle.description()}")

# 数据类
from dataclasses import dataclass, field

@dataclass
class Student:
    """学生数据类"""
    name: str
    age: int
    grades: list = field(default_factory=list)
    id: int = field(default=0, init=False)
    
    def __post_init__(self):
        """初始化后处理"""
        # 简单的ID生成
        self.id = hash(self.name) % 10000
    
    def add_grade(self, grade):
        """添加成绩"""
        self.grades.append(grade)
    
    def average_grade(self):
        """计算平均成绩"""
        if not self.grades:
            return 0
        return sum(self.grades) / len(self.grades)

# 使用数据类
student = Student("张三", 18, [85, 90, 78])
print(student)
student.add_grade(92)
print(f"平均成绩：{student.average_grade():.1f}")

# 枚举类
from enum import Enum, auto, unique

@unique
class Color(Enum):
    """颜色枚举"""
    RED = auto()
    GREEN = auto()
    BLUE = auto()
    
    def __str__(self):
        return self.name.capitalize()

class Status(Enum):
    """状态枚举（手动赋值）"""
    PENDING = 1
    APPROVED = 2
    REJECTED = 3
    
    @property
    def description(self):
        descriptions = {
            Status.PENDING: "待处理",
            Status.APPROVED: "已批准",
            Status.REJECTED: "已拒绝"
        }
        return descriptions[self]

# 使用枚举
favorite_color = Color.RED
print(f"喜欢的颜色：{favorite_color}")
print(f"颜色值：{favorite_color.value}")
print(f"颜色名：{favorite_color.name}")

current_status = Status.APPROVED
print(f"当前状态：{current_status.description}")

# 类型提示
from typing import List, Dict, Optional, Union, Any, Tuple

class Calculator:
    """带类型提示的计算器"""
    
    def __init__(self):
        self.history: List[str] = []
    
    def add(self, a: Union[int, float], b: Union[int, float]) -> Union[int, float]:
        """加法"""
        result = a + b
        self._add_to_history(f"{a} + {b} = {result}")
        return result
    
    def subtract(self, a: Union[int, float], b: Union[int, float]) -> Union[int, float]:
        """减法"""
        result = a - b
        self._add_to_history(f"{a} - {b} = {result}")
        return result
    
    def multiply(self, a: Union[int, float], b: Union[int, float]) -> Union[int, float]:
        """乘法"""
        result = a * b
        self._add_to_history(f"{a} * {b} = {result}")
        return result
    
    def divide(self, a: Union[int, float], b: Union[int, float]) -> Optional[float]:
        """除法"""
        if b == 0:
            return None
        result = a / b
        self._add_to_history(f"{a} / {b} = {result}")
        return result
    
    def get_history(self) -> List[str]:
        """获取历史记录"""
        return self.history.copy()
    
    def clear_history(self) -> None:
        """清空历史记录"""
        self.history.clear()
    
    def _add_to_history(self, operation: str) -> None:
        """添加操作到历史记录（私有方法）"""
        self.history.append(operation)

# 使用类型提示
calc = Calculator()
print(f"加法：{calc.add(5, 3)}")
print(f"减法：{calc.subtract(10, 4)}")
print(f"乘法：{calc.multiply(6, 7)}")
print(f"除法：{calc.divide(20, 5)}")
print(f"除零：{calc.divide(10, 0)}")
print(f"历史记录：{calc.get_history()}")
```

##### 设计模式与高级OOP概念

```python
# 单例模式
class Singleton:
    """单例模式实现"""
    _instance = None
    _initialized = False
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self):
        if not Singleton._initialized:
            self.value = 0
            Singleton._initialized = True
    
    def increment(self):
        self.value += 1
        return self.value

# 测试单例
s1 = Singleton()
s2 = Singleton()
print(f"s1 == s2: {s1 == s2}")
print(f"s1.value: {s1.value}")
s1.increment()
print(f"s2.value: {s2.value}")

# 工厂模式
class AnimalFactory:
    """动物工厂"""
    
    @staticmethod
    def create_animal(animal_type, name, age, **kwargs):
        """创建动物"""
        if animal_type.lower() == "dog":
            breed = kwargs.get("breed", "未知品种")
            return Dog(name, age, breed)
        elif animal_type.lower() == "cat":
            color = kwargs.get("color", "未知颜色")
            return Cat(name, age, color)
        else:
            raise ValueError(f"不支持的动物类型：{animal_type}")

# 使用工厂
dog = AnimalFactory.create_animal("dog", "大黄", 2, breed="土狗")
cat = AnimalFactory.create_animal("cat", "小花", 1, color="三花")
print(f"工厂创建的狗：{dog}")
print(f"工厂创建的猫：{cat}")

# 观察者模式
class Observable:
    """被观察者"""
    
    def __init__(self):
        self._observers = []
    
    def add_observer(self, observer):
        """添加观察者"""
        if observer not in self._observers:
            self._observers.append(observer)
    
    def remove_observer(self, observer):
        """移除观察者"""
        if observer in self._observers:
            self._observers.remove(observer)
    
    def notify_observers(self, message):
        """通知所有观察者"""
        for observer in self._observers:
            observer.update(message)

class NewsAgency(Observable):
    """新闻社"""
    
    def publish_news(self, news):
        """发布新闻"""
        print(f"新闻社发布：{news}")
        self.notify_observers(news)

class NewsSubscriber:
    """新闻订阅者"""
    
    def __init__(self, name):
        self.name = name
    
    def update(self, news):
        """接收新闻更新"""
        print(f"{self.name}收到新闻：{news}")

# 使用观察者模式
agency = NewsAgency()
subscriber1 = NewsSubscriber("订阅者A")
subscriber2 = NewsSubscriber("订阅者B")

agency.add_observer(subscriber1)
agency.add_observer(subscriber2)

agency.publish_news("Python发布了新版本")

# 装饰器模式
class Coffee:
    """咖啡基类"""
    
    def cost(self):
        return 5.0
    
    def description(self):
        return "基础咖啡"

class CoffeeDecorator:
    """咖啡装饰器基类"""
    
    def __init__(self, coffee):
        self._coffee = coffee
    
    def cost(self):
        return self._coffee.cost()
    
    def description(self):
        return self._coffee.description()

class MilkDecorator(CoffeeDecorator):
    """牛奶装饰器"""
    
    def cost(self):
        return self._coffee.cost() + 1.0
    
    def description(self):
        return f"{self._coffee.description()}+牛奶"

class SugarDecorator(CoffeeDecorator):
    """糖装饰器"""
    
    def cost(self):
        return self._coffee.cost() + 0.5
    
    def description(self):
        return f"{self._coffee.description()}+糖"

# 使用装饰器模式
coffee = Coffee()
coffee_with_milk = MilkDecorator(coffee)
coffee_with_milk_sugar = SugarDecorator(coffee_with_milk)

print(f"咖啡描述：{coffee.description()}，价格：{coffee.cost()}")
print(f"加奶咖啡：{coffee_with_milk.description()}，价格：{coffee_with_milk.cost()}")
print(f"加奶加糖咖啡：{coffee_with_milk_sugar.description()}，价格：{coffee_with_milk_sugar.cost()}")

# 元类编程
class SingletonMeta(type):
    """单例元类"""
    
    _instances = {}
    
    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super().__call__(*args, **kwargs)
        return cls._instances[cls]

class DatabaseConnection(metaclass=SingletonMeta):
    """使用元类实现单例的数据库连接"""
    
    def __init__(self):
        self.connection_id = id(self)
        print(f"创建数据库连接：{self.connection_id}")

# 测试元类单例
db1 = DatabaseConnection()
db2 = DatabaseConnection()
print(f"db1.connection_id: {db1.connection_id}")
print(f"db2.connection_id: {db2.connection_id}")
print(f"db1 is db2: {db1 is db2}")

# 反射和动态属性
class DynamicObject:
    """支持动态属性的对象"""
    
    def __init__(self):
        self._data = {}
    
    def __getattr__(self, name):
        """动态获取属性"""
        if name in self._data:
            return self._data[name]
        raise AttributeError(f"'{type(self).__name__}' object has no attribute '{name}'")
    
    def __setattr__(self, name, value):
        """动态设置属性"""
        if name.startswith('_'):
            # 内部属性正常设置
            super().__setattr__(name, value)
        else:
            # 动态属性存储在_data中
            if not hasattr(self, '_data'):
                super().__setattr__('_data', {})
            self._data[name] = value
    
    def __delattr__(self, name):
        """动态删除属性"""
        if name in self._data:
            del self._data[name]
        else:
            raise AttributeError(f"'{type(self).__name__}' object has no attribute '{name}'")

# 使用动态属性
obj = DynamicObject()
obj.dynamic_attr = "动态属性"
obj.another_attr = 42

print(f"动态属性：{obj.dynamic_attr}")
print(f"另一个属性：{obj.another_attr}")

del obj.another_attr
try:
    print(obj.another_attr)
except AttributeError as e:
    print(f"删除属性后：{e}")

# 混入（Mixin）
class LoggableMixin:
    """日志混入"""
    
    def log(self, message):
        print(f"[{self.__class__.__name__}] {message}")

class TimestampMixin:
    """时间戳混入"""
    
    def get_timestamp(self):
        import time
        return time.strftime("%Y-%m-%d %H:%M:%S")

class User(LoggableMixin, TimestampMixin):
    """用户类（使用混入）"""
    
    def __init__(self, username):
        self.username = username
    
    def login(self):
        """登录"""
        self.log(f"用户 {self.username} 在 {self.get_timestamp()} 登录")
    
    def logout(self):
        """登出"""
        self.log(f"用户 {self.username} 在 {self.get_timestamp()} 登出")

# 使用混入
user = User("张三")
user.login()
user.logout()
```


#### 列表推导式与生成器

Python提供了简洁而强大的推导式和生成器语法，它们可以用于创建各种序列类型，提高代码的可读性和效率。

##### 列表推导式详解

```python
# 基本列表推导式
numbers = [x for x in range(10)]
print(f"基本推导式：{numbers}")

# 带条件的列表推导式
even_numbers = [x for x in range(20) if x % 2 == 0]
print(f"偶数：{even_numbers}")

# 带表达式的列表推导式
squares = [x**2 for x in range(10)]
print(f"平方数：{squares}")

# 条件表达式（三元运算符）在推导式中的应用
conditional_numbers = [x if x % 2 == 0 else x*2 for x in range(10)]
print(f"偶数保留，奇数翻倍：{conditional_numbers}")

# 嵌套列表推导式
matrix = [[i*j for j in range(1, 4)] for i in range(1, 4)]
print(f"乘法表矩阵：{matrix}")

# 扁平化嵌套列表
nested_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
flattened = [x for sublist in nested_list for x in sublist]
print(f"扁平化：{flattened}")

# 复杂嵌套推导式
combinations = [(x, y) for x in range(3) for y in range(3) if x != y]
print(f"不同坐标对：{combinations}")

# 处理字符串
words = ["hello", "world", "python"]
word_lengths = [len(word) for word in words]
print(f"单词长度：{word_lengths}")

# 字符串转换
uppercase_words = [word.upper() for word in words]
print(f"大写单词：{uppercase_words}")

# 过滤和处理结合
filtered_words = [word.upper() for word in words if len(word) > 5]
print(f"长度>5的单词（转为大写）：{filtered_words}")

# 处理文件内容示例（模拟）
lines = ["line 1\n", "line 2\n", "line 3\n"]
cleaned_lines = [line.strip() for line in lines]
print(f"清理后的行：{cleaned_lines}")

# 数学计算应用
from math import pi, sin, cos

angles = [i * pi / 6 for i in range(13)]  # 0到2π，步长π/6
sin_values = [round(sin(angle), 3) for angle in angles]
cos_values = [round(cos(angle), 3) for angle in angles]
print(f"正弦值：{sin_values}")
print(f"余弦值：{cos_values}")

# 列表推导式性能对比
import time

# 传统方式
def traditional_approach():
    result = []
    for i in range(1000000):
        if i % 2 == 0:
            result.append(i**2)
    return result

# 列表推导式方式
def comprehension_approach():
    return [i**2 for i in range(1000000) if i % 2 == 0]

# 性能测试
start = time.time()
traditional_result = traditional_approach()
traditional_time = time.time() - start

start = time.time()
comprehension_result = comprehension_approach()
comprehension_time = time.time() - start

print(f"传统方法耗时：{traditional_time:.4f}秒")
print(f"推导式方法耗时：{comprehension_time:.4f}秒")
print(f"性能提升：{traditional_time/comprehension_time:.2f}倍")
```

##### 字典推导式

```python
# 基本字典推导式
word_lengths = {word: len(word) for word in ["apple", "banana", "cherry"]}
print(f"单词长度字典：{word_lengths}")

# 从现有字典创建新字典
original = {"a": 1, "b": 2, "c": 3}
squared = {key: value**2 for key, value in original.items()}
print(f"平方值字典：{squared}")

# 过滤字典
filtered = {key: value for key, value in original.items() if value % 2 == 1}
print(f"奇数值字典：{filtered}")

# 键值转换
swapped = {value: key for key, value in original.items()}
print(f"键值互换：{swapped}")

# 复杂表达式
people = {"Alice": 25, "Bob": 30, "Charlie": 35}
categories = {name: "Young" if age < 30 else "Adult" 
             for name, age in people.items()}
print(f"年龄分类：{categories}")

# 从两个列表创建字典
keys = ["name", "age", "city"]
values = ["张三", 25, "北京"]
person_dict = {key: value for key, value in zip(keys, values)}
print(f"从列表创建：{person_dict}")

# 嵌套字典推导式
matrix_data = {
    i: {j: i*j for j in range(1, 4)} 
    for i in range(1, 4)
}
print(f"乘法表字典：{matrix_data}")

# 处理文本数据
text = "hello world python programming"
word_count = {word: text.count(word) for word in set(text.split())}
print(f"单词计数：{word_count}")

# 字典推导式应用：统计字符频率
sentence = "Python is awesome and Python is powerful"
char_frequency = {char: sentence.count(char) 
                 for char in set(sentence) if not char.isspace()}
print(f"字符频率：{char_frequency}")

# 创建默认值字典
keys = ["a", "b", "c", "d"]
default_values = {key: 0 for key in keys}
print(f"默认值字典：{default_values}")
```

##### 集合推导式

```python
# 基本集合推导式
numbers = {x for x in range(10)}
print(f"数字集合：{numbers}")

# 去重和转换
words = ["apple", "banana", "apple", "cherry", "banana"]
unique_lengths = {len(word) for word in words}
print(f"唯一长度：{unique_lengths}")

# 条件过滤
prime_squares = {x**2 for x in range(2, 20) if all(x % i != 0 for i in range(2, int(x**0.5) + 1))}
print(f"质数平方：{prime_squares}")

# 字符串处理
sentence = "The quick brown fox jumps over the lazy dog"
unique_letters = {char for char in sentence.lower() if char.isalpha()}
print(f"唯一字母：{sorted(unique_letters)}")

# 复杂条件
number_set = {x for x in range(1, 100) 
              if x % 3 == 0 or x % 5 == 0}
print(f"3或5的倍数：{sorted(number_set)}")

# 从其他数据结构创建集合
matrix = [[1, 2, 3], [2, 3, 4], [3, 4, 5]]
unique_elements = {element for row in matrix for element in row}
print(f"矩阵中的唯一元素：{unique_elements}")

# 集合运算
set1 = {x**2 for x in range(10)}
set2 = {x**2 for x in range(5, 15)}
intersection = set1 & set2
union = set1 | set2
difference = set2 - set1

print(f"集合1：{sorted(set1)}")
print(f"集合2：{sorted(set2)}")
print(f"交集：{sorted(intersection)}")
print(f"并集：{sorted(union)}")
print(f"差集：{sorted(difference)}")
```

##### 生成器表达式

```python
# 基本生成器表达式
squares_gen = (x**2 for x in range(10))
print(f"生成器对象：{squares_gen}")

# 遍历生成器
print("生成器元素：")
for square in squares_gen:
    print(square, end=" ")
print()

# 转换为列表
squares_list = list(x**2 for x in range(10))
print(f"转换为列表：{squares_list}")

# 条件生成器表达式
even_squares_gen = (x**2 for x in range(20) if x % 2 == 0)
print(f"前5个偶数平方：{[next(even_squares_gen) for _ in range(5)]")

# 使用生成器表达式计算统计量
import math

numbers = [x**2 for x in range(1, 101)]  # 1-100的平方
# 计算平均数
average = sum(numbers) / len(numbers)
# 计算标准差
variance = sum((x - average)**2 for x in numbers) / len(numbers)
std_dev = math.sqrt(variance)

print(f"平均数：{average:.2f}")
print(f"标准差：{std_dev:.2f}")

# 内存效率对比
import sys

# 列表（占用更多内存）
list_data = [x**2 for x in range(100000)]
list_memory = sys.getsizeof(list_data) + sum(sys.getsizeof(x) for x in list_data)

# 生成器（占用更少内存）
gen_data = (x**2 for x in range(100000))
gen_memory = sys.getsizeof(gen_data)  # 生成器本身占用内存很少

print(f"列表内存占用：{list_memory}字节")
print(f"生成器内存占用：{gen_memory}字节")

# 生成器表达式与函数式编程
# 查找前10个满足条件的数
numbers = range(1, 1000)
result = next((x for x in numbers 
                if all(x % i != 0 for i in range(2, int(x**0.5) + 1)) 
                and sum(int(digit) for digit in str(x)) % 2 == 0), None)
print(f"第一个质数且数字之和为偶数的数：{result}")

# 生成器链式操作
data = range(1, 21)

# 链式处理：过滤 -> 转换 -> 过滤
processed = (x**2 for x in data if x % 2 == 0)  # 偶数平方
processed = (x//4 for x in processed if x > 20)  # 大于20的数除以4

result_list = list(processed)
print(f"链式处理结果：{result_list}")

# 生成器表达式在文件处理中的应用（模拟）
lines = ["line 1", "line 2", "error: something", "line 3", "error: another", "line 4"]
# 只处理非错误行
non_error_lines = (line for line in lines if not line.startswith("error:"))
print(f"非错误行：{list(non_error_lines)}")
```

##### 生成器函数

```python
# 基本生成器函数
def count_up_to(n):
    """从1数到n的生成器"""
    current = 1
    while current <= n:
        yield current
        current += 1

# 使用生成器函数
counter = count_up_to(5)
print("生成器函数输出：")
for number in counter:
    print(number, end=" ")
print()

# 斐波那契数列生成器
def fibonacci():
    """斐波那契数列生成器"""
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b

# 获取前10个斐波那契数
fib_gen = fibonacci()
fib_numbers = [next(fib_gen) for _ in range(10)]
print(f"前10个斐波那契数：{fib_numbers}")

# 质数生成器
def prime_generator():
    """质数生成器"""
    def is_prime(n):
        if n <= 1:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True
    
    num = 2
    while True:
        if is_prime(num):
            yield num
        num += 1

# 获取前10个质数
prime_gen = prime_generator()
primes = [next(prime_gen) for _ in range(10)]
print(f"前10个质数：{primes}")

# 生成器的send()和close()方法
def interactive_generator():
    """交互式生成器"""
    try:
        received = yield "开始"
        while True:
            if received is None:
                received = yield "没有收到值"
            else:
                received = yield f"收到：{received}"
    except GeneratorExit:
        print("生成器被关闭")

# 使用交互式生成器
interactive = interactive_generator()
print(f"启动：{next(interactive)}")
print(f"发送'hello'：{interactive.send('hello')}")
print(f"发送'world'：{interactive.send('world')}")
interactive.close()

# yield from语法（委托生成器）
def sub_generator():
    """子生成器"""
    yield "子生成器1"
    yield "子生成器2"
    yield "子生成器3"

def delegating_generator():
    """委托生成器"""
    yield "委托开始"
    yield from sub_generator()
    yield "委托结束"

# 使用委托生成器
delegating = delegating_generator()
print("委托生成器输出：")
for item in delegating:
    print(item)

# 文件逐行读取生成器
def read_file_lines(filename):
    """逐行读取文件的生成器"""
    try:
        with open(filename, "r", encoding="utf-8") as file:
            for line in file:
                yield line.strip()
    except FileNotFoundError:
        yield f"文件 {filename} 不存在"

# 使用文件读取生成器（示例）
# file_lines = read_file_lines("example.txt")
# for line in file_lines:
#     print(line)

# 数据流处理生成器
def data_pipeline():
    """数据流水线生成器"""
    # 阶段1：生成原始数据
    data = range(1, 21)
    
    # 阶段2：过滤奇数
    even_data = (x for x in data if x % 2 == 0)
    
    # 阶段3：平方
    squared_data = (x**2 for x in even_data)
    
    # 阶段4：过滤小于50的数
    filtered_data = (x for x in squared_data if x > 50)
    
    # 阶段5：开方取整
    final_data = (int(x**0.5) for x in filtered_data)
    
    yield from final_data

# 使用数据流水线
pipeline_result = list(data_pipeline())
print(f"数据流水线结果：{pipeline_result}")

# 协程示例（双向通信）
def coroutine():
    """协程示例"""
    print("协程启动")
    try:
        while True:
            x = yield
            print(f"收到值：{x}")
    except GeneratorExit:
        print("协程结束")

# 使用协程
co = coroutine()
next(co)  # 启动协程
co.send(10)
co.send(20)
co.send(30)
co.close()  # 关闭协程
```

##### 高级生成器应用

```python
# 生成器组合器
def chain(*iterables):
    """连接多个可迭代对象"""
    for iterable in iterables:
        yield from iterable

# 使用组合器
result1 = list(chain([1, 2, 3], [4, 5, 6], [7, 8, 9]))
print(f"链式组合：{result1}")

def cycle(iterable):
    """无限循环可迭代对象"""
    saved = []
    for element in iterable:
        yield element
        saved.append(element)
    while saved:
        for element in saved:
            yield element

# 使用循环生成器（注意：这是无限循环）
# cycle_gen = cycle([1, 2, 3])
# print("循环生成器（前10个）：")
# for i, x in zip(range(10), cycle_gen):
#     print(x, end=" ")
# print()

def tee(iterable, n=2):
    """将一个可迭代对象分成n个独立的迭代器"""
    # 简化版的tee实现
    data = list(iterable)
    return [iter(data) for _ in range(n)]

# 使用tee
original = [1, 2, 3, 4, 5]
iter1, iter2 = tee(original, 2)
print(f"迭代器1：{list(iter1)}")
print(f"迭代器2：{list(iter2)}")

# 生成器在数据分析中的应用
def moving_average(sequence, window_size):
    """移动平均数生成器"""
    if window_size <= 0:
        raise ValueError("窗口大小必须为正数")
    
    window = []
    sum_window = 0
    
    for item in sequence:
        window.append(item)
        sum_window += item
        
        if len(window) > window_size:
            sum_window -= window.pop(0)
        
        if len(window) == window_size:
            yield sum_window / window_size

# 使用移动平均数
data = [1, 3, 5, 7, 9, 11, 13, 15]
ma3 = list(moving_average(data, 3))
print(f"3点移动平均数：{ma3}")

# 无限序列生成器
def arithmetic_sequence(start, step=1):
    """等差数列生成器"""
    current = start
    while True:
        yield current
        current += step

def geometric_sequence(start, ratio=2):
    """等比数列生成器"""
    current = start
    while True:
        yield current
        current *= ratio

# 使用无限序列生成器
arith_seq = arithmetic_sequence(1, 2)
arith_10 = [next(arith_seq) for _ in range(10)]
print(f"等差数列前10项：{arith_10}")

geom_seq = geometric_sequence(1, 2)
geom_10 = [next(geom_seq) for _ in range(10)]
print(f"等比数列前10项：{geom_10}")

# 生成器性能测试
import timeit

# 传统函数方式
def traditional_fibonacci(n):
    result = []
    a, b = 0, 1
    for _ in range(n):
        result.append(a)
        a, b = b, a + b
    return result

# 生成器方式
def generator_fibonacci(n):
    a, b = 0, 1
    for _ in range(n):
        yield a
        a, b = b, a + b

# 性能测试
n = 100000

traditional_time = timeit.timeit(
    "traditional_fibonacci(n)", 
    setup="from __main__ import traditional_fibonacci, n", 
    number=10
)

generator_time = timeit.timeit(
    "list(generator_fibonacci(n))", 
    setup="from __main__ import generator_fibonacci, n", 
    number=10
)

print(f"传统方法耗时：{traditional_time:.4f}秒")
print(f"生成器方法耗时：{generator_time:.4f}秒")

# 内存使用测试
import tracemalloc

# 启动内存跟踪
tracemalloc.start()

# 使用传统方法
large_list = traditional_fibonacci(100000)
current, peak = tracemalloc.get_traced_memory()
tracemalloc.stop()

print(f"传统方法内存使用：当前 {current/1024:.2f}KB，峰值 {peak/1024:.2f}KB")

# 重新启动跟踪
tracemalloc.start()

# 使用生成器
large_generator = generator_fibonacci(100000)
large_list_from_gen = list(large_generator)
current, peak = tracemalloc.get_traced_memory()
tracemalloc.stop()

print(f"生成器方法内存使用：当前 {current/1024:.2f}KB，峰值 {peak/1024:.2f}KB")

# 生成器在爬虫中的应用（模拟）
def crawl_pages(start_url, max_pages):
    """模拟网页爬虫生成器"""
    visited = set()
    to_visit = [start_url]
    
    while to_visit and len(visited) < max_pages:
        url = to_visit.pop(0)
        if url not in visited:
            visited.add(url)
            
            # 模拟页面内容和链接
            page_content = f"内容来自：{url}"
            yield page_content
            
            # 模拟发现新链接
            new_links = [f"{url}/link{i}" for i in range(1, 4)]
            to_visit.extend(new_links)

# 使用爬虫生成器
# crawler = crawl_pages("http://example.com", 5)
# for page in crawler:
#     print(page)
```

