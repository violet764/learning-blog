# Python 基础：函数与类

本文档详细介绍 Python 中函数和类的核心概念，这些是 Python 面向对象编程和函数式编程的基础，掌握这些概念对于编写高质量的 Python 代码至关重要。

## 函数

函数是Python中组织代码的基本单元，它允许我们将相关的代码组织在一起，提高代码的可重用性和可维护性。

### 函数定义与调用

```python
# 基本函数定义
def greet(name):
    """问候函数
    Args:
        name (str): 要问候的人名
    Returns:
        str: 包含问候语的字符串
    """
    return f"你好, {name}!"

# 带默认参数的函数
def introduce(name, age=25):
    """介绍个人信息
    Args:
        name (str): 姓名
        age (int, optional): 年龄，默认为25
    Returns:
        str: 包含个人信息的字符串
    """
    return f"我叫{name}，今年{age}岁"

# 可变位置参数
def sum_all(*numbers):
    """计算所有数字的和
    Args:
        *numbers: 可变数量的位置参数，接受任意数量的数字
    Returns:
        int/float: 所有数字的和
    """
    return sum(numbers)

# 可变关键字参数
def create_profile(**kwargs):
    """创建个人档案
    Args:
        **kwargs: 可变数量的关键字参数，接受任意数量的键值对
    Returns:
        dict: 包含所有传入信息的字典
    """
    return kwargs

# 调用函数
print(greet("小明"))
print(introduce("小红"))
print(introduce("小李", 28))
print(sum_all(1, 2, 3, 4, 5))
print(create_profile(name="小王", age=22, city="上海"))
```


## 类与对象

面向对象编程（OOP）是Python中一种重要的编程范式，它允许我们通过类来组织代码，通过对象来表示现实世界中的实体。

### 类的基本概念

类是创建对象的模板或蓝图，它定义了对象的属性和方法。对象是类的具体实例。

```python
# 类的定义
class Person:
    """人类 - 代表一个人的基本信息和行为"""
    
    # 类属性（所有实例共享）
    species = "Homo sapiens"
    
    # 构造方法（实例化时自动调用）
    def __init__(self, name, age, gender):
        """初始化方法，创建Person对象时自动调用
        Args:
            name (str): 姓名
            age (int): 年龄
            gender (str): 性别
        """
        # 实例属性（每个实例独有）
        self.name = name
        self.age = age
        self.gender = gender
        self.__secret = "这是隐私信息"  # 私有属性（双下划线开头）
    
    # 实例方法（第一个参数必须是self）
    def introduce(self):
        """自我介绍
        Returns:
            str: 包含个人信息的介绍字符串
        """
        return f"我叫{self.name}，今年{self.age}岁"

    def celebrate_birthday(self):
        """过生日，增加一岁"""
        self.age += 1
        print(f"{self.name}现在{self.age}岁了！")
    
    # 类方法（第一个参数是cls）
    @classmethod
    def from_birth_year(cls, name, birth_year, gender):
        """从出生年份创建Person对象的类方法
        Args:
            name (str): 姓名
            birth_year (int): 出生年份
            gender (str): 性别
        Returns:
            Person: 新创建的Person对象
        """
        current_year = 2023  # 简化处理
        age = current_year - birth_year
        return cls(name, age, gender)

    # 静态方法（不需要特殊参数）
    @staticmethod
    def is_adult(age):
        """判断是否成年的静态方法
        Args:
            age (int): 年龄
        Returns:
            bool: 成年返回True，否则返回False
        """
        return age >= 18
    
    # 属性访问器
    @property
    def secret(self):
        """获取私有属性的访问器
        Returns:
            str: 隐私信息
        """
        return self.__secret

    @secret.setter
    def secret(self, new_secret):
        """设置私有属性的修改器
        Args:
            new_secret (str): 新的隐私信息
        """
        if len(new_secret) > 0:
            self.__secret = new_secret

    # 删除器
    @secret.deleter
    def secret(self):
        """删除私有属性的删除器"""
        print("删除隐私信息")
        self.__secret = None
    
    # 魔术方法（特殊方法）
    def __str__(self):
        """字符串表示（面向用户）
        Returns:
            str: 用户友好的对象描述
        """
        return f"{self.name}，{self.age}岁"

    def __repr__(self):
        """官方字符串表示（面向开发者）
        Returns:
            str: 开发者友好的对象描述
        """
        return f"Person('{self.name}', {self.age}, '{self.gender}')"

    def __eq__(self, other):
        """相等性比较
        Args:
            other (Person): 要比较的另一个Person对象
        Returns:
            bool: 相等返回True，否则返回False
        """
        if isinstance(other, Person):
            return (self.name == other.name and
                   self.age == other.age and
                   self.gender == other.gender)
        return False

    def __lt__(self, other):
        """小于比较（基于年龄）
        Args:
            other (Person): 要比较的另一个Person对象
        Returns:
            bool: 当前对象年龄小于另一个对象年龄时返回True
        """
        if isinstance(other, Person):
            return self.age < other.age
        return NotImplemented

# 创建实例（对象）
person1 = Person("张三", 25, "男")
person2 = Person("李四", 30, "女")

# 访问实例属性
print(f"姓名：{person1.name}")
print(f"年龄：{person1.age}")

# 调用实例方法
print(person1.introduce())
person1.celebrate_birthday()

# 访问类属性
print(f"物种：{person1.species}")
print(f"物种：{Person.species}")

# 修改类属性（影响所有实例）
Person.species = "智人"
print(f"修改后的物种：{person1.species}")

# 调用类方法
person3 = Person.from_birth_year("王五", 1995, "男")
print(f"王五：{person3}")

# 调用静态方法
print(f"25岁是否成年：{Person.is_adult(25)}")
print(f"16岁是否成年：{Person.is_adult(16)}")

# 使用属性访问器
print(f"隐私信息：{person1.secret}")
person1.secret = "新的隐私信息"
print(f"更新后的隐私信息：{person1.secret}")

# 使用魔术方法
print(f"字符串表示：{str(person1)}")
print(f"官方表示：{repr(person1)}")

# 对象比较
person4 = Person("张三", 25, "男")
print(f"person1 == person4：{person1 == person4}")
print(f"person1 < person2：{person1 < person2}")

# 删除属性
del person1.secret
```

### 继承与多态

继承是面向对象编程的核心概念之一，它允许我们创建一个新的类（子类）来扩展现有类（父类）的功能。多态则允许不同类的对象对同一消息做出不同的响应。

```python
# 基类（父类）
class Animal:
    """动物基类 - 所有动物的基类"""

    def __init__(self, name, age):
        """初始化动物对象
        Args:
            name (str): 动物名字
            age (int): 动物年龄
        """
        self.name = name
        self.age = age

    def make_sound(self):
        """发出声音 - 抽象方法，子类必须实现
        Raises:
            NotImplementedError: 子类必须重写此方法
        """
        raise NotImplementedError("子类必须实现此方法")

    def eat(self):
        """吃东西
        Returns:
            str: 描述动物进食的字符串
        """
        return f"{self.name}正在吃东西"

    def sleep(self):
        """睡觉
        Returns:
            str: 描述动物睡眠的字符串
        """
        return f"{self.name}正在睡觉"

# 派生类（子类）
class Dog(Animal):
    """狗类 - 继承自Animal类"""

    def __init__(self, name, age, breed):
        """初始化狗对象
        Args:
            name (str): 狗的名字
            age (int): 狗的年龄
            breed (str): 狗的品种
        """
        # 调用父类的构造方法
        super().__init__(name, age)
        self.breed = breed

    def make_sound(self):
        """狗叫 - 重写父类方法
        Returns:
            str: 描述狗叫声的字符串
        """
        return f"{self.name}汪汪叫"

    def fetch(self):
        """捡东西 - 狗特有的方法
        Returns:
            str: 描述狗捡东西的字符串
        """
        return f"{self.name}跑去捡球"

    def __str__(self):
        """字符串表示
        Returns:
            str: 狗的信息描述
        """
        return f"狗：{self.name}，{self.age}岁，品种：{self.breed}"

class Cat(Animal):
    """猫类 - 继承自Animal类"""

    def __init__(self, name, age, color):
        """初始化猫对象
        Args:
            name (str): 猫的名字
            age (int): 猫的年龄
            color (str): 猫的颜色
        """
        super().__init__(name, age)
        self.color = color

    def make_sound(self):
        """猫叫 - 重写父类方法
        Returns:
            str: 描述猫叫声的字符串
        """
        return f"{self.name}喵喵叫"

    def climb(self):
        """爬树 - 猫特有的方法
        Returns:
            str: 描述猫爬树的字符串
        """
        return f"{self.name}爬到树上"

    def __str__(self):
        """字符串表示
        Returns:
            str: 猫的信息描述
        """
        return f"猫：{self.name}，{self.age}岁，颜色：{self.color}"

# 多重继承
class Pet:
    """宠物特征类"""

    def __init__(self, owner):
        """初始化宠物特征
        Args:
            owner (str): 宠物的主人
        """
        self.owner = owner

    def show_affection(self):
        """显示感情
        Returns:
            str: 描述宠物表达爱意的字符串
        """
        return f"{self.owner}的宠物表达爱意"

class PetDog(Dog, Pet):
    """宠物狗类 - 多重继承自Dog和Pet"""

    def __init__(self, name, age, breed, owner):
        """初始化宠物狗对象
        Args:
            name (str): 狗的名字
            age (int): 狗的年龄
            breed (str): 狗的品种
            owner (str): 狗的主人
        """
        # 调用多个父类的构造方法
        Dog.__init__(self, name, age, breed)
        Pet.__init__(self, owner)

    def __str__(self):
        """字符串表示
        Returns:
            str: 宠物狗的信息描述
        """
        return f"宠物狗：{self.name}，主人：{self.owner}"

# 使用继承
dog = Dog("旺财", 3, "金毛")
cat = Cat("咪咪", 2, "白色")

print(dog)
print(cat)
print(dog.make_sound())
print(cat.make_sound())
print(dog.eat())
print(cat.sleep())
print(dog.fetch())
print(cat.climb())

# 多态示例
def animal_sound(animal):
    """让动物发出声音 - 演示多态
    Args:
        animal (Animal): 动物对象
    """
    print(f"声音：{animal.make_sound()}")

# 不同类型的对象调用相同的方法
animal_sound(dog)  # 狗叫
animal_sound(cat)  # 猫叫

# 多重继承
pet_dog = PetDog("小白", 4, "贵宾犬", "张三")
print(pet_dog)
print(pet_dog.make_sound())
print(pet_dog.show_affection())

# 方法解析顺序（MRO）
print(f"PetDog的方法解析顺序：{PetDog.__mro__}")
```

### 特殊类与高级特性

Python提供了许多高级特性和特殊类，可以帮助我们编写更简洁、更强大的代码。这些特性包括抽象基类、数据类、枚举类和类型提示等。  

**抽象基类**
```python

from abc import ABC, abstractmethod

class Shape(ABC):
    """形状抽象基类 - 定义所有形状的通用接口"""

    @abstractmethod
    def area(self):
        """计算面积 - 抽象方法，子类必须实现
        Returns:
            float: 形状的面积
        """
        pass

    @abstractmethod
    def perimeter(self):
        """计算周长 - 抽象方法，子类必须实现
        Returns:
            float: 形状的周长
        """
        pass

    def description(self):
        """描述形状信息 - 具体方法，子类可以继承使用
        Returns:
            str: 包含形状面积和周长的描述字符串
        """
        return f"这是一个形状，面积为{self.area()}，周长为{self.perimeter()}"

class Rectangle(Shape):
    """矩形类 - 继承自Shape抽象基类"""

    def __init__(self, width, height):
        """初始化矩形
        Args:
            width (float): 矩形宽度
            height (float): 矩形高度
        """
        self.width = width
        self.height = height

    def area(self):
        """计算矩形面积
        Returns:
            float: 矩形面积
        """
        return self.width * self.height

    def perimeter(self):
        """计算矩形周长
        Returns:
            float: 矩形周长
        """
        return 2 * (self.width + self.height)

class Circle(Shape):
    """圆形类 - 继承自Shape抽象基类"""

    def __init__(self, radius):
        """初始化圆形
        Args:
            radius (float): 圆形半径
        """
        self.radius = radius

    def area(self):
        """计算圆形面积
        Returns:
            float: 圆形面积
        """
        import math
        return math.pi * self.radius ** 2

    def perimeter(self):
        """计算圆形周长
        Returns:
            float: 圆形周长
        """
        import math
        return 2 * math.pi * self.radius

# 使用抽象基类
rect = Rectangle(5, 3)
circle = Circle(2)

print(f"矩形：{rect.description()}")
print(f"圆形：{circle.description()}")
```

**数据类**
```python
from dataclasses import dataclass, field

@dataclass
class Student:
    """学生数据类 - 使用dataclass简化数据类的定义"""
    name: str
    age: int
    grades: list = field(default_factory=list)
    id: int = field(default=0, init=False)

    def __post_init__(self):
        """初始化后处理 - 在__init__方法执行后自动调用
        用于执行额外的初始化逻辑
        """
        # 简单的ID生成
        self.id = hash(self.name) % 10000

    def add_grade(self, grade):
        """添加成绩
        Args:
            grade (float): 要添加的成绩
        """
        self.grades.append(grade)

    def average_grade(self):
        """计算平均成绩
        Returns:
            float: 平均成绩，如果没有成绩则返回0
        """
        if not self.grades:
            return 0
        return sum(self.grades) / len(self.grades)

# 使用数据类
student = Student("张三", 18, [85, 90, 78])
print(student)
student.add_grade(92)
print(f"平均成绩：{student.average_grade():.1f}")
```

**枚举类**
```python
from enum import Enum, auto, unique

@unique
class Color(Enum):
    """颜色枚举 - 使用枚举定义一组相关的常量"""
    RED = auto()
    GREEN = auto()
    BLUE = auto()

    def __str__(self):
        """字符串表示
        Returns:
            str: 颜色名称（首字母大写）
        """
        return self.name.capitalize()

class Status(Enum):
    """状态枚举（手动赋值） - 手动指定枚举值"""
    PENDING = 1
    APPROVED = 2
    REJECTED = 3

    @property
    def description(self):
        """获取状态描述
        Returns:
            str: 状态的中文描述
        """
        descriptions = {
            Status.PENDING: "待处理",
            Status.APPROVED: "已批准",
            Status.REJECTED: "已拒绝"
        }
        return descriptions[self]

# 使用枚举
favorite_color = Color.RED
print(f"喜欢的颜色：{favorite_color}")
print(f"颜色值：{favorite_color.value}")
print(f"颜色名：{favorite_color.name}")

current_status = Status.APPROVED
print(f"当前状态：{current_status.description}")
```

**类型提示**
```python

from typing import List, Dict, Optional, Union, Any, Tuple

class Calculator:
    """带类型提示的计算器 - 使用类型提示增强代码可读性和IDE支持"""

    def __init__(self):
        """初始化计算器，创建空的历史记录列表"""
        self.history: List[str] = []

    def add(self, a: Union[int, float], b: Union[int, float]) -> Union[int, float]:
        """加法运算
        Args:
            a (Union[int, float]): 第一个操作数
            b (Union[int, float]): 第二个操作数
        Returns:
            Union[int, float]: 两数之和
        """
        result = a + b
        self._add_to_history(f"{a} + {b} = {result}")
        return result

    def subtract(self, a: Union[int, float], b: Union[int, float]) -> Union[int, float]:
        """减法运算
        Args:
            a (Union[int, float]): 被减数
            b (Union[int, float]): 减数
        Returns:
            Union[int, float]: 两数之差
        """
        result = a - b
        self._add_to_history(f"{a} - {b} = {result}")
        return result

    def multiply(self, a: Union[int, float], b: Union[int, float]) -> Union[int, float]:
        """乘法运算
        Args:
            a (Union[int, float]): 第一个操作数
            b (Union[int, float]): 第二个操作数
        Returns:
            Union[int, float]: 两数之积
        """
        result = a * b
        self._add_to_history(f"{a} * {b} = {result}")
        return result

    def divide(self, a: Union[int, float], b: Union[int, float]) -> Optional[float]:
        """除法运算
        Args:
            a (Union[int, float]): 被除数
            b (Union[int, float]): 除数
        Returns:
            Optional[float]: 两数之商，除数为0时返回None
        """
        if b == 0:
            return None
        result = a / b
        self._add_to_history(f"{a} / {b} = {result}")
        return result

    def get_history(self) -> List[str]:
        """获取历史记录的副本
        Returns:
            List[str]: 历史记录列表的副本
        """
        return self.history.copy()

    def clear_history(self) -> None:
        """清空历史记录"""
        self.history.clear()

    def _add_to_history(self, operation: str) -> None:
        """添加操作到历史记录（私有方法）
        Args:
            operation (str): 操作描述字符串
        """
        self.history.append(operation)

# 使用类型提示
calc = Calculator()
print(f"加法：{calc.add(5, 3)}")
print(f"减法：{calc.subtract(10, 4)}")
print(f"乘法：{calc.multiply(6, 7)}")
print(f"除法：{calc.divide(20, 5)}")
print(f"除零：{calc.divide(10, 0)}")
print(f"历史记录：{calc.get_history()}")
```

## 设计模式与高级OOP概念

设计模式是解决软件设计问题的经典解决方案。Python作为一种动态语言，可以灵活地实现各种设计模式。
### 单例模式
```python

class Singleton:
    """单例模式实现 - 确保一个类只有一个实例"""
    _instance = None
    _initialized = False

    def __new__(cls):
        """控制对象的创建过程
        Returns:
            Singleton: Singleton类的唯一实例
        """
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

    def __init__(self):
        """初始化单例对象"""
        if not Singleton._initialized:
            self.value = 0
            Singleton._initialized = True

    def increment(self):
        """增加值
        Returns:
            int: 增加后的值
        """
        self.value += 1
        return self.value

# 测试单例
s1 = Singleton()
s2 = Singleton()
print(f"s1 == s2: {s1 == s2}")
print(f"s1.value: {s1.value}")
s1.increment()
print(f"s2.value: {s2.value}")
```


### 工厂模式
```python
class AnimalFactory:
    """动物工厂 - 创建不同类型动物对象的工厂类"""

    @staticmethod
    def create_animal(animal_type, name, age, **kwargs):
        """创建动物对象的静态方法
        Args:
            animal_type (str): 动物类型（"dog"或"cat"）
            name (str): 动物名字
            age (int): 动物年龄
            **kwargs: 其他参数
        Returns:
            Animal: 创建的动物对象
        Raises:
            ValueError: 当不支持的动物类型时抛出异常
        """
        if animal_type.lower() == "dog":
            breed = kwargs.get("breed", "未知品种")
            return Dog(name, age, breed)
        elif animal_type.lower() == "cat":
            color = kwargs.get("color", "未知颜色")
            return Cat(name, age, color)
        else:
            raise ValueError(f"不支持的动物类型：{animal_type}")

# 使用工厂
dog = AnimalFactory.create_animal("dog", "大黄", 2, breed="土狗")
cat = AnimalFactory.create_animal("cat", "小花", 1, color="三花")
print(f"工厂创建的狗：{dog}")
print(f"工厂创建的猫：{cat}")
```
### 观察者模式
```python
class Observable:
    """被观察者 - 实现观察者模式的核心类"""

    def __init__(self):
        """初始化被观察者"""
        self._observers = []

    def add_observer(self, observer):
        """添加观察者
        Args:
            observer: 要添加的观察者对象
        """
        if observer not in self._observers:
            self._observers.append(observer)

    def remove_observer(self, observer):
        """移除观察者
        Args:
            observer: 要移除的观察者对象
        """
        if observer in self._observers:
            self._observers.remove(observer)

    def notify_observers(self, message):
        """通知所有观察者
        Args:
            message: 要通知的消息
        """
        for observer in self._observers:
            observer.update(message)

class NewsAgency(Observable):
    """新闻社 - 被观察者的具体实现"""

    def publish_news(self, news):
        """发布新闻并通知所有订阅者
        Args:
            news (str): 要发布的新闻内容
        """
        print(f"新闻社发布：{news}")
        self.notify_observers(news)

class NewsSubscriber:
    """新闻订阅者 - 观察者的具体实现"""

    def __init__(self, name):
        """初始化订阅者
        Args:
            name (str): 订阅者名称
        """
        self.name = name

    def update(self, news):
        """接收新闻更新
        Args:
            news (str): 接收到的新闻内容
        """
        print(f"{self.name}收到新闻：{news}")
```
### 使用观察者模式
```python
agency = NewsAgency()
subscriber1 = NewsSubscriber("订阅者A")
subscriber2 = NewsSubscriber("订阅者B")

agency.add_observer(subscriber1)
agency.add_observer(subscriber2)

agency.publish_news("Python发布了新版本")

agency.add_observer(subscriber1)
agency.add_observer(subscriber2)

agency.publish_news("Python发布了新版本")

# 装饰器模式
class Coffee:
    """咖啡基类 - 被装饰的对象"""

    def cost(self):
        """计算咖啡成本
        Returns:
            float: 咖啡的成本
        """
        return 5.0

    def description(self):
        """咖啡描述
        Returns:
            str: 咖啡的描述
        """
        return "基础咖啡"

class CoffeeDecorator:
    """咖啡装饰器基类 - 装饰器的抽象基类"""

    def __init__(self, coffee):
        """初始化装饰器
        Args:
            coffee (Coffee): 要装饰的咖啡对象
        """
        self._coffee = coffee

    def cost(self):
        """计算装饰后的咖啡成本
        Returns:
            float: 装饰后的咖啡成本
        """
        return self._coffee.cost()

    def description(self):
        """装饰后的咖啡描述
        Returns:
            str: 装饰后的咖啡描述
        """
        return self._coffee.description()

class MilkDecorator(CoffeeDecorator):
    """牛奶装饰器 - 具体的装饰器实现"""

    def cost(self):
        """添加牛奶后的成本
        Returns:
            float: 添加牛奶后的总成本
        """
        return self._coffee.cost() + 1.0

    def description(self):
        """添加牛奶后的描述
        Returns:
            str: 添加牛奶后的描述
        """
        return f"{self._coffee.description()}+牛奶"

class SugarDecorator(CoffeeDecorator):
    """糖装饰器 - 具体的装饰器实现"""

    def cost(self):
        """添加糖后的成本
        Returns:
            float: 添加糖后的总成本
        """
        return self._coffee.cost() + 0.5

    def description(self):
        """添加糖后的描述
        Returns:
            str: 添加糖后的描述
        """
        return f"{self._coffee.description()}+糖"

# 使用装饰器模式
coffee = Coffee()
coffee_with_milk = MilkDecorator(coffee)
coffee_with_milk_sugar = SugarDecorator(coffee_with_milk)

print(f"咖啡描述：{coffee.description()}，价格：{coffee.cost()}")
print(f"加奶咖啡：{coffee_with_milk.description()}，价格：{coffee_with_milk.cost()}")
print(f"加奶加糖咖啡：{coffee_with_milk_sugar.description()}，价格：{coffee_with_milk_sugar.cost()}")
```
### 元类编程

```python
class SingletonMeta(type):
    """单例元类 - 使用元类实现单例模式"""

    _instances = {}

    def __call__(cls, *args, **kwargs):
        """控制类的实例化过程
        Args:
            *args: 位置参数
            **kwargs: 关键字参数
        Returns:
            object: 类的唯一实例
        """
        if cls not in cls._instances:
            cls._instances[cls] = super().__call__(*args, **kwargs)
        return cls._instances[cls]

class DatabaseConnection(metaclass=SingletonMeta):
    """使用元类实现单例的数据库连接类"""

    def __init__(self):
        """初始化数据库连接"""
        self.connection_id = id(self)
        print(f"创建数据库连接：{self.connection_id}")

# 测试元类单例
db1 = DatabaseConnection()
db2 = DatabaseConnection()
print(f"db1.connection_id: {db1.connection_id}")
print(f"db2.connection_id: {db2.connection_id}")
print(f"db1 is db2: {db1 is db2}")

# 反射和动态属性
class DynamicObject:
    """支持动态属性的对象 - 演示Python的反射机制"""

    def __init__(self):
        """初始化动态对象"""
        self._data = {}

    def __getattr__(self, name):
        """动态获取属性 - 当访问不存在的属性时调用
        Args:
            name (str): 属性名称
        Returns:
            any: 属性值
        Raises:
            AttributeError: 当属性不存在时抛出异常
        """
        if name in self._data:
            return self._data[name]
        raise AttributeError(f"'{type(self).__name__}' object has no attribute '{name}'")

    def __setattr__(self, name, value):
        """动态设置属性 - 当设置属性时调用
        Args:
            name (str): 属性名称
            value (any): 属性值
        """
        if name.startswith('_'):
            # 内部属性正常设置
            super().__setattr__(name, value)
        else:
            # 动态属性存储在_data中
            if not hasattr(self, '_data'):
                super().__setattr__('_data', {})
            self._data[name] = value

    def __delattr__(self, name):
        """动态删除属性 - 当删除属性时调用
        Args:
            name (str): 属性名称
        Raises:
            AttributeError: 当属性不存在时抛出异常
        """
        if name in self._data:
            del self._data[name]
        else:
            raise AttributeError(f"'{type(self).__name__}' object has no attribute '{name}'")

# 使用动态属性
obj = DynamicObject()
obj.dynamic_attr = "动态属性"
obj.another_attr = 42

print(f"动态属性：{obj.dynamic_attr}")
print(f"另一个属性：{obj.another_attr}")

del obj.another_attr
try:
    print(obj.another_attr)
except AttributeError as e:
    print(f"删除属性后：{e}")

# 混入（Mixin）
class LoggableMixin:
    """日志混入 - 提供日志功能"""

    def log(self, message):
        """记录日志
        Args:
            message (str): 日志消息
        """
        print(f"[{self.__class__.__name__}] {message}")

class TimestampMixin:
    """时间戳混入 - 提供时间戳功能"""

    def get_timestamp(self):
        """获取当前时间戳
        Returns:
            str: 格式化的时间字符串
        """
        import time
        return time.strftime("%Y-%m-%d %H:%M:%S")

class User(LoggableMixin, TimestampMixin):
    """用户类（使用混入） - 继承多个混入类以获得额外功能"""

    def __init__(self, username):
        """初始化用户
        Args:
            username (str): 用户名
        """
        self.username = username

    def login(self):
        """用户登录"""
        self.log(f"用户 {self.username} 在 {self.get_timestamp()} 登录")

    def logout(self):
        """用户登出"""
        self.log(f"用户 {self.username} 在 {self.get_timestamp()} 登出")

# 使用混入
user = User("张三")
user.login()
user.logout()
```


## 列表推导式与生成器

列表推导式和生成器是Python中强大而高效的特性，它们提供了一种简洁的方式来创建和处理序列数据。相比传统的循环方式，它们不仅代码更简洁，而且通常性能更好。

### 列表推导式

列表推导式是一种创建列表的简洁方式，它将循环和条件逻辑整合在一个表达式中。

```python
# 基本列表推导式
numbers = [x for x in range(10)]
print(f"基本推导式：{numbers}")

# 带条件的列表推导式
even_numbers = [x for x in range(20) if x % 2 == 0]
print(f"偶数：{even_numbers}")

# 带表达式的列表推导式
squares = [x**2 for x in range(10)]
print(f"平方数：{squares}")

# 条件表达式（三元运算符）在推导式中的应用
conditional_numbers = [x if x % 2 == 0 else x*2 for x in range(10)]
print(f"偶数保留，奇数翻倍：{conditional_numbers}")

# 嵌套列表推导式
matrix = [[i*j for j in range(1, 4)] for i in range(1, 4)]
print(f"乘法表矩阵：{matrix}")

# 扁平化嵌套列表
nested_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
flattened = [x for sublist in nested_list for x in sublist]
print(f"扁平化：{flattened}")

# 复杂嵌套推导式
combinations = [(x, y) for x in range(3) for y in range(3) if x != y]
print(f"不同坐标对：{combinations}")

# 处理字符串
words = ["hello", "world", "python"]
word_lengths = [len(word) for word in words]
print(f"单词长度：{word_lengths}")

# 字符串转换
uppercase_words = [word.upper() for word in words]
print(f"大写单词：{uppercase_words}")

# 过滤和处理结合
filtered_words = [word.upper() for word in words if len(word) > 5]
print(f"长度>5的单词（转为大写）：{filtered_words}")

# 处理文件内容示例（模拟）
lines = ["line 1\n", "line 2\n", "line 3\n"]
cleaned_lines = [line.strip() for line in lines]
print(f"清理后的行：{cleaned_lines}")

# 数学计算应用
from math import pi, sin, cos

angles = [i * pi / 6 for i in range(13)]  # 0到2π，步长π/6
sin_values = [round(sin(angle), 3) for angle in angles]
cos_values = [round(cos(angle), 3) for angle in angles]
print(f"正弦值：{sin_values}")
print(f"余弦值：{cos_values}")

# 列表推导式性能对比
import time

# 传统方式
def traditional_approach():
    """传统循环方式创建列表"""
    result = []
    for i in range(1000000):
        if i % 2 == 0:
            result.append(i**2)
    return result

# 列表推导式方式
def comprehension_approach():
    """使用列表推导式创建列表"""
    return [i**2 for i in range(1000000) if i % 2 == 0]

# 性能测试
start = time.time()
traditional_result = traditional_approach()
traditional_time = time.time() - start

start = time.time()
comprehension_result = comprehension_approach()
comprehension_time = time.time() - start

print(f"传统方法耗时：{traditional_time:.4f}秒")
print(f"推导式方法耗时：{comprehension_time:.4f}秒")
print(f"性能提升：{traditional_time/comprehension_time:.2f}倍")
```

### 字典推导式

字典推导式提供了一种创建字典的简洁方式，类似于列表推导式，但用于创建字典对象。

```python
# 基本字典推导式
word_lengths = {word: len(word) for word in ["apple", "banana", "cherry"]}
print(f"单词长度字典：{word_lengths}")

# 从现有字典创建新字典
original = {"a": 1, "b": 2, "c": 3}
squared = {key: value**2 for key, value in original.items()}
print(f"平方值字典：{squared}")

# 过滤字典
filtered = {key: value for key, value in original.items() if value % 2 == 1}
print(f"奇数值字典：{filtered}")

# 键值转换
swapped = {value: key for key, value in original.items()}
print(f"键值互换：{swapped}")

# 复杂表达式
people = {"Alice": 25, "Bob": 30, "Charlie": 35}
categories = {name: "Young" if age < 30 else "Adult"
             for name, age in people.items()}
print(f"年龄分类：{categories}")

# 从两个列表创建字典
keys = ["name", "age", "city"]
values = ["张三", 25, "北京"]
person_dict = {key: value for key, value in zip(keys, values)}
print(f"从列表创建：{person_dict}")

# 嵌套字典推导式
matrix_data = {
    i: {j: i*j for j in range(1, 4)}
    for i in range(1, 4)
}
print(f"乘法表字典：{matrix_data}")

# 处理文本数据
text = "hello world python programming"
word_count = {word: text.count(word) for word in set(text.split())}
print(f"单词计数：{word_count}")

# 字典推导式应用：统计字符频率
sentence = "Python is awesome and Python is powerful"
char_frequency = {char: sentence.count(char)
                 for char in set(sentence) if not char.isspace()}
print(f"字符频率：{char_frequency}")

# 创建默认值字典
keys = ["a", "b", "c", "d"]
default_values = {key: 0 for key in keys}
print(f"默认值字典：{default_values}")
```

### 集合推导式

集合推导式用于创建集合对象，它与列表推导式类似，但创建的是无序且不重复的集合。

```python
# 基本集合推导式
numbers = {x for x in range(10)}
print(f"数字集合：{numbers}")

# 去重和转换
words = ["apple", "banana", "apple", "cherry", "banana"]
unique_lengths = {len(word) for word in words}
print(f"唯一长度：{unique_lengths}")

# 条件过滤
prime_squares = {x**2 for x in range(2, 20) if all(x % i != 0 for i in range(2, int(x**0.5) + 1))}
print(f"质数平方：{prime_squares}")

# 字符串处理
sentence = "The quick brown fox jumps over the lazy dog"
unique_letters = {char for char in sentence.lower() if char.isalpha()}
print(f"唯一字母：{sorted(unique_letters)}")

# 复杂条件
number_set = {x for x in range(1, 100)
              if x % 3 == 0 or x % 5 == 0}
print(f"3或5的倍数：{sorted(number_set)}")

# 从其他数据结构创建集合
matrix = [[1, 2, 3], [2, 3, 4], [3, 4, 5]]
unique_elements = {element for row in matrix for element in row}
print(f"矩阵中的唯一元素：{unique_elements}")

# 集合运算
set1 = {x**2 for x in range(10)}
set2 = {x**2 for x in range(5, 15)}
intersection = set1 & set2
union = set1 | set2
difference = set2 - set1

print(f"集合1：{sorted(set1)}")
print(f"集合2：{sorted(set2)}")
print(f"交集：{sorted(intersection)}")
print(f"并集：{sorted(union)}")
print(f"差集：{sorted(difference)}")
```

## 生成器表达式

生成器表达式是创建生成器对象的一种简洁方式，它与列表推导式语法相似，但使用圆括号而不是方括号。生成器表达式具有内存效率高的优势，特别适合处理大量数据。

```python
# 基本生成器表达式
squares_gen = (x**2 for x in range(10))
print(f"生成器对象：{squares_gen}")

# 遍历生成器
print("生成器元素：")
for square in squares_gen:
    print(square, end=" ")
print()

# 转换为列表
squares_list = list(x**2 for x in range(10))
print(f"转换为列表：{squares_list}")

# 条件生成器表达式
even_squares_gen = (x**2 for x in range(20) if x % 2 == 0)
print(f"前5个偶数平方：{[next(even_squares_gen) for _ in range(5)]")

# 使用生成器表达式计算统计量
import math

numbers = [x**2 for x in range(1, 101)]  # 1-100的平方
# 计算平均数
average = sum(numbers) / len(numbers)
# 计算标准差
variance = sum((x - average)**2 for x in numbers) / len(numbers)
std_dev = math.sqrt(variance)

print(f"平均数：{average:.2f}")
print(f"标准差：{std_dev:.2f}")

# 内存效率对比
import sys

# 列表（占用更多内存）
list_data = [x**2 for x in range(100000)]
list_memory = sys.getsizeof(list_data) + sum(sys.getsizeof(x) for x in list_data)

# 生成器（占用更少内存）
gen_data = (x**2 for x in range(100000))
gen_memory = sys.getsizeof(gen_data)  # 生成器本身占用内存很少

print(f"列表内存占用：{list_memory}字节")
print(f"生成器内存占用：{gen_memory}字节")

# 生成器表达式与函数式编程
# 查找前10个满足条件的数
numbers = range(1, 1000)
result = next((x for x in numbers
                if all(x % i != 0 for i in range(2, int(x**0.5) + 1))
                and sum(int(digit) for digit in str(x)) % 2 == 0), None)
print(f"第一个质数且数字之和为偶数的数：{result}")

# 生成器链式操作
data = range(1, 21)

# 链式处理：过滤 -> 转换 -> 过滤
processed = (x**2 for x in data if x % 2 == 0)  # 偶数平方
processed = (x//4 for x in processed if x > 20)  # 大于20的数除以4

result_list = list(processed)
print(f"链式处理结果：{result_list}")

# 生成器表达式在文件处理中的应用（模拟）
lines = ["line 1", "line 2", "error: something", "line 3", "error: another", "line 4"]
# 只处理非错误行
non_error_lines = (line for line in lines if not line.startswith("error:"))
print(f"非错误行：{list(non_error_lines)}")
```

### 生成器函数

生成器函数是使用`yield`关键字定义的特殊函数，它们可以暂停执行并在后续调用中恢复，非常适合处理大量数据或创建无限序列。

```python
# 基本生成器函数
def count_up_to(n):
    """从1数到n的生成器
    Args:
        n (int): 计数上限
    Yields:
        int: 从1到n的整数
    """
    current = 1
    while current <= n:
        yield current
        current += 1

# 使用生成器函数
counter = count_up_to(5)
print("生成器函数输出：")
for number in counter:
    print(number, end=" ")
print()

# 斐波那契数列生成器
def fibonacci():
    """斐波那契数列生成器
    Yields:
        int: 斐波那契数列中的下一个数
    """
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b

# 获取前10个斐波那契数
fib_gen = fibonacci()
fib_numbers = [next(fib_gen) for _ in range(10)]
print(f"前10个斐波那契数：{fib_numbers}")

# 质数生成器
def prime_generator():
    """质数生成器
    Yields:
        int: 下一个质数
    """
    def is_prime(n):
        """判断是否为质数
        Args:
            n (int): 要判断的数
        Returns:
            bool: 是质数返回True，否则返回False
        """
        if n <= 1:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True

    num = 2
    while True:
        if is_prime(num):
            yield num
        num += 1

# 获取前10个质数
prime_gen = prime_generator()
primes = [next(prime_gen) for _ in range(10)]
print(f"前10个质数：{primes}")

# 生成器的send()和close()方法
def interactive_generator():
    """交互式生成器 - 演示send()方法的使用
    Yields:
        str: 生成器的状态信息
    """
    try:
        received = yield "开始"
        while True:
            if received is None:
                received = yield "没有收到值"
            else:
                received = yield f"收到：{received}"
    except GeneratorExit:
        print("生成器被关闭")

# 使用交互式生成器
interactive = interactive_generator()
print(f"启动：{next(interactive)}")
print(f"发送'hello'：{interactive.send('hello')}")
print(f"发送'world'：{interactive.send('world')}")
interactive.close()

# yield from语法（委托生成器）
def sub_generator():
    """子生成器
    Yields:
        str: 子生成器的输出
    """
    yield "子生成器1"
    yield "子生成器2"
    yield "子生成器3"

def delegating_generator():
    """委托生成器 - 使用yield from委托给其他生成器
    Yields:
        str: 委托生成器的输出
    """
    yield "委托开始"
    yield from sub_generator()
    yield "委托结束"

# 使用委托生成器
delegating = delegating_generator()
print("委托生成器输出：")
for item in delegating:
    print(item)

# 文件逐行读取生成器
def read_file_lines(filename):
    """逐行读取文件的生成器
    Args:
        filename (str): 文件名
    Yields:
        str: 文件的每一行（去除换行符）
    """
    try:
        with open(filename, "r", encoding="utf-8") as file:
            for line in file:
                yield line.strip()
    except FileNotFoundError:
        yield f"文件 {filename} 不存在"

# 使用文件读取生成器（示例）
# file_lines = read_file_lines("example.txt")
# for line in file_lines:
#     print(line)

# 数据流处理生成器
def data_pipeline():
    """数据流水线生成器 - 演示生成器链式处理
    Yields:
        int: 处理后的数据
    """
    # 阶段1：生成原始数据
    data = range(1, 21)

    # 阶段2：过滤奇数
    even_data = (x for x in data if x % 2 == 0)

    # 阶段3：平方
    squared_data = (x**2 for x in even_data)

    # 阶段4：过滤小于50的数
    filtered_data = (x for x in squared_data if x > 50)

    # 阶段5：开方取整
    final_data = (int(x**0.5) for x in filtered_data)

    yield from final_data

# 使用数据流水线
pipeline_result = list(data_pipeline())
print(f"数据流水线结果：{pipeline_result}")

# 协程示例（双向通信）
def coroutine():
    """协程示例 - 演示生成器的双向通信
    Yields:
        None: 协程不产生输出，主要用于接收输入
    """
    print("协程启动")
    try:
        while True:
            x = yield
            print(f"收到值：{x}")
    except GeneratorExit:
        print("协程结束")

# 使用协程
co = coroutine()
next(co)  # 启动协程
co.send(10)
co.send(20)
co.send(30)
co.close()  # 关闭协程
```

### 高级生成器应用

生成器在实际应用中有很多高级用法，包括组合器、无限序列生成、性能优化等。这些应用展示了生成器的强大功能和灵活性。

```python
# 生成器组合器
def chain(*iterables):
    """连接多个可迭代对象
    Args:
        *iterables: 可变数量的可迭代对象
    Yields:
        any: 来自各个可迭代对象的元素
    """
    for iterable in iterables:
        yield from iterable

# 使用组合器
result1 = list(chain([1, 2, 3], [4, 5, 6], [7, 8, 9]))
print(f"链式组合：{result1}")

def cycle(iterable):
    """无限循环可迭代对象
    Args:
        iterable: 要循环的可迭代对象
    Yields:
        any: 无限循环产生的元素
    """
    saved = []
    for element in iterable:
        yield element
        saved.append(element)
    while saved:
        for element in saved:
            yield element

# 使用循环生成器（注意：这是无限循环）
# cycle_gen = cycle([1, 2, 3])
# print("循环生成器（前10个）：")
# for i, x in zip(range(10), cycle_gen):
#     print(x, end=" ")
# print()

def tee(iterable, n=2):
    """将一个可迭代对象分成n个独立的迭代器
    Args:
        iterable: 要分割的可迭代对象
        n (int): 分割成的迭代器数量，默认为2
    Returns:
        list: 包含n个独立迭代器的列表
    """
    # 简化版的tee实现
    data = list(iterable)
    return [iter(data) for _ in range(n)]

# 使用tee
original = [1, 2, 3, 4, 5]
iter1, iter2 = tee(original, 2)
print(f"迭代器1：{list(iter1)}")
print(f"迭代器2：{list(iter2)}")

# 生成器在数据分析中的应用
def moving_average(sequence, window_size):
    """移动平均数生成器
    Args:
        sequence: 输入序列
        window_size (int): 移动窗口大小
    Yields:
        float: 移动平均值
    Raises:
        ValueError: 当窗口大小不是正数时抛出异常
    """
    if window_size <= 0:
        raise ValueError("窗口大小必须为正数")

    window = []
    sum_window = 0

    for item in sequence:
        window.append(item)
        sum_window += item

        if len(window) > window_size:
            sum_window -= window.pop(0)

        if len(window) == window_size:
            yield sum_window / window_size

# 使用移动平均数
data = [1, 3, 5, 7, 9, 11, 13, 15]
ma3 = list(moving_average(data, 3))
print(f"3点移动平均数：{ma3}")

# 无限序列生成器
def arithmetic_sequence(start, step=1):
    """等差数列生成器
    Args:
        start (int/float): 起始值
        step (int/float): 步长，默认为1
    Yields:
        int/float: 等差数列中的下一个数
    """
    current = start
    while True:
        yield current
        current += step

def geometric_sequence(start, ratio=2):
    """等比数列生成器
    Args:
        start (int/float): 起始值
        ratio (int/float): 比例因子，默认为2
    Yields:
        int/float: 等比数列中的下一个数
    """
    current = start
    while True:
        yield current
        current *= ratio

# 使用无限序列生成器
arith_seq = arithmetic_sequence(1, 2)
arith_10 = [next(arith_seq) for _ in range(10)]
print(f"等差数列前10项：{arith_10}")

geom_seq = geometric_sequence(1, 2)
geom_10 = [next(geom_seq) for _ in range(10)]
print(f"等比数列前10项：{geom_10}")

# 生成器性能测试
import timeit

# 传统函数方式
def traditional_fibonacci(n):
    """传统方式生成斐波那契数列
    Args:
        n (int): 生成的数列长度
    Returns:
        list: 包含n个斐波那契数的列表
    """
    result = []
    a, b = 0, 1
    for _ in range(n):
        result.append(a)
        a, b = b, a + b
    return result

# 生成器方式
def generator_fibonacci(n):
    """生成器方式生成斐波那契数列
    Args:
        n (int): 生成的数列长度
    Yields:
        int: 斐波那契数列中的下一个数
    """
    a, b = 0, 1
    for _ in range(n):
        yield a
        a, b = b, a + b

# 性能测试
n = 100000

traditional_time = timeit.timeit(
    "traditional_fibonacci(n)",
    setup="from __main__ import traditional_fibonacci, n",
    number=10
)

generator_time = timeit.timeit(
    "list(generator_fibonacci(n))",
    setup="from __main__ import generator_fibonacci, n",
    number=10
)

print(f"传统方法耗时：{traditional_time:.4f}秒")
print(f"生成器方法耗时：{generator_time:.4f}秒")

# 内存使用测试
import tracemalloc

# 启动内存跟踪
tracemalloc.start()

# 使用传统方法
large_list = traditional_fibonacci(100000)
current, peak = tracemalloc.get_traced_memory()
tracemalloc.stop()

print(f"传统方法内存使用：当前 {current/1024:.2f}KB，峰值 {peak/1024:.2f}KB")

# 重新启动跟踪
tracemalloc.start()

# 使用生成器
large_generator = generator_fibonacci(100000)
large_list_from_gen = list(large_generator)
current, peak = tracemalloc.get_traced_memory()
tracemalloc.stop()

print(f"生成器方法内存使用：当前 {current/1024:.2f}KB，峰值 {peak/1024:.2f}KB")

# 生成器在爬虫中的应用（模拟）
def crawl_pages(start_url, max_pages):
    """模拟网页爬虫生成器
    Args:
        start_url (str): 起始URL
        max_pages (int): 最大爬取页面数
    Yields:
        str: 爬取到的页面内容
    """
    visited = set()
    to_visit = [start_url]

    while to_visit and len(visited) < max_pages:
        url = to_visit.pop(0)
        if url not in visited:
            visited.add(url)

            # 模拟页面内容和链接
            page_content = f"内容来自：{url}"
            yield page_content

            # 模拟发现新链接
            new_links = [f"{url}/link{i}" for i in range(1, 4)]
            to_visit.extend(new_links)

# 使用爬虫生成器
# crawler = crawl_pages("http://example.com", 5)
# for page in crawler:
#     print(page)
```

