## 字典（Dictionary）

字典是Python中另一种重要的数据结构，是一个无序的键值对集合（Python 3.7+保持插入顺序），键必须是不可变类型，值可以是任意类型。

### 字典的创建与查询

```python
# 基本创建方式
empty_dict = {}  # 空字典
person = {
    "name": "张三",
    "age": 30,
    "city": "北京"
}

# 使用dict()构造函数
dict1 = dict(name="李四", age=25, city="上海")
print(dict1)  # {'name': '李四', 'age': 25, 'city': '上海'}

# 从列表创建字典
key_value_pairs = [("name", "王五"), ("age", 35), ("city", "广州")]
dict2 = dict(key_value_pairs)
print(dict2)  # {'name': '王五', 'age': 35, 'city': '广州'}

# 从两个列表创建键和值
keys = ["name", "age", "city"]
values = ["赵六", 40, "深圳"]
dict3 = dict(zip(keys, values))
print(dict3)  # {'name': '赵六', 'age': 40, 'city': '深圳'}

# 字典推导式
squares = {x: x**2 for x in range(6)}
print(squares)  # {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25}

# 条件字典推导式
even_squares = {x: x**2 for x in range(10) if x % 2 == 0}
print(even_squares)  # {0: 0, 2: 4, 4: 16, 6: 36, 8: 64}

# 复杂字典推导式
word_info = {word: {"length": len(word), "first": word[0]} 
             for word in ["apple", "banana", "cherry"]}
print(word_info)
# {'apple': {'length': 5, 'first': 'a'}, 
#  'banana': {'length': 6, 'first': 'b'}, 
#  'cherry': {'length': 6, 'first': 'c'}}

# 嵌套字典
employees = {
    "部门1": {
        "经理": {"姓名": "张经理", "年龄": 45},
        "员工": {"姓名": "小李", "年龄": 28}
    },
    "部门2": {
        "经理": {"姓名": "王经理", "年龄": 50},
        "员工": {"姓名": "小赵", "年龄": 32}
    }
}
```

**字典的访问与查询**

```python
person = {
    "name": "张三",
    "age": 30,
    "city": "北京",
    "email": "zhangsan@example.com"
}

# 使用方括号访问（键不存在会抛出KeyError）
print(person["name"])  # 张三
print(person["age"])    # 30

# 使用get()方法访问（键不存在返回None或默认值）
print(person.get("name"))           # 张三
print(person.get("salary"))         # None
print(person.get("salary", 0))      # 0（提供默认值）

# 检查键是否存在
print("name" in person)     # True
print("salary" in person)   # False
print("name" not in person) # False

# 获取所有键、值、键值对
keys = person.keys()        # dict_keys(['name', 'age', 'city', 'email'])
values = person.values()    # dict_values(['张三', 30, '北京', 'zhangsan@example.com'])
items = person.items()      # dict_items([('name', '张三'), ('age', 30), ('city', '北京'), ('email', 'zhangsan@example.com')])

# 转换为列表
print(list(keys))     # ['name', 'age', 'city', 'email']
print(list(values))   # ['张三', 30, '北京', 'zhangsan@example.com']
print(list(items))    # [('name', '张三'), ('age', 30), ('city', '北京'), ('email', 'zhangsan@example.com')]

# 遍历字典
print("遍历键：")
for key in person:
    print(key)

print("\n遍历值：")
for value in person.values():
    print(value)

print("\n遍历键值对：")
for key, value in person.items():
    print(f"{key}: {value}")

# 使用setdefault()方法获取或设置默认值
education = person.setdefault("education", "本科")
print(education)  # 本科
print(person)     # 包含新增的education键

# 使用collections.defaultdict
from collections import defaultdict

# 为不存在的键提供默认值
word_count = defaultdict(int)
words = ["apple", "banana", "apple", "cherry", "banana", "apple"]
for word in words:
    word_count[word] += 1

print(dict(word_count))  # {'apple': 3, 'banana': 2, 'cherry': 1}
```

### 字典的增删改

**列表的添加与修改**
```python
person = {
    "name": "张三",
    "age": 30,
    "city": "北京"
}

# 直接赋值添加或修改
person["email"] = "zhangsan@example.com"  # 添加新键
person["age"] = 31                         # 修改现有键
print(person)

# 使用update()方法更新字典
new_info = {
    "age": 32,              # 更新现有键
    "salary": 50000,         # 添加新键
    "department": "技术部"    # 添加新键
}
person.update(new_info)
print(person)

# update()也可以接受列表或元组
person.update([("hobby", "读书"), ("married", True)])
print(person)

# 使用setdefault()添加键（仅当键不存在时）
result1 = person.setdefault("name", "默认姓名")  # 键已存在，返回原值
result2 = person.setdefault("phone", "13800138000")  # 键不存在，设置并返回新值

print(result1)  # 张三
print(result2)  # 13800138000
print(person)

# 使用|操作符合并字典（Python 3.9+）
dict1 = {"a": 1, "b": 2}
dict2 = {"b": 3, "c": 4}
merged = dict1 | dict2
print(merged)  # {'a': 1, 'b': 3, 'c': 4}

# 使用|=操作符更新字典（Python 3.9+）
dict1 |= dict2
print(dict1)  # {'a': 1, 'b': 3, 'c': 4}

# 嵌套字典的修改
company = {
    "employees": [
        {"name": "张三", "salary": 5000},
        {"name": "李四", "salary": 6000}
    ],
    "info": {
        "name": "科技公司",
        "location": "北京"
    }
}

# 修改嵌套字典中的值
company["employees"][0]["salary"] = 5500
company["info"]["location"] = "上海"

print(company)

# 批量修改字典
def update_person(person, updates):
    for key, value in updates.items():
        person[key] = value
    return person

person = {"name": "王五", "age": 30}
updates = {"age": 31, "city": "深圳", "married": True}
person = update_person(person, updates)
print(person)
```

**字典的删除操作**

```python
person = {
    "name": "张三",
    "age": 30,
    "city": "北京",
    "email": "zhangsan@example.com",
    "salary": 50000
}

# 使用del语句删除键值对
del person["city"]
print(person)  # 城市被删除

# 尝试删除不存在的键（会抛出KeyError）
try:
    del person["nonexistent"]
except KeyError:
    print("键不存在，无法删除")

# 使用pop()方法删除并返回值
age = person.pop("age")
print(f"删除的年龄：{age}")  # 30
print(person)              # 年龄键被删除

# pop()方法提供默认值
phone = person.pop("phone", "未提供")
print(f"电话：{phone}")  # 未提供

# popitem()方法删除并返回最后一个键值对（Python 3.7+）
last_item = person.popitem()
print(f"删除的最后一个键值对：{last_item}")
print(person)

# 使用clear()清空整个字典
person_copy = person.copy()
person_copy.clear()
print(f"清空后的字典：{person_copy}")  # {}

# 批量删除字典中的键
def remove_keys(dictionary, keys_to_remove):
    for key in keys_to_remove:
        dictionary.pop(key, None)  # 使用None作为默认值避免KeyError
    return dictionary

person = {
    "name": "张三",
    "age": 30,
    "city": "北京",
    "email": "zhangsan@example.com",
    "temp_field1": "临时数据1",
    "temp_field2": "临时数据2"
}

temp_keys = [key for key in person.keys() if key.startswith("temp_")]
person = remove_keys(person, temp_keys)
print(f"删除临时字段后：{person}")

# 字典推导式过滤（创建新字典）
person = {
    "name": "张三",
    "age": 30,
    "city": "北京",
    "email": "zhangsan@example.com",
    "salary": 50000
}

# 只保留字符串类型的值
string_values = {key: value for key, value in person.items() 
                 if isinstance(value, str)}
print(f"只保留字符串值：{string_values}")

# 根据键名过滤
basic_info = {key: value for key, value in person.items() 
             if key in ["name", "age", "city"]}
print(f"基本信息：{basic_info}")
```

### 字典的高级方法

```python
person = {
    "name": "张三",
    "age": 30,
    "city": "北京",
    "email": "zhangsan@example.com",
    "salary": 50000
}

# copy()方法创建字典副本
shallow_copy = person.copy()
print(f"浅拷贝：{shallow_copy}")

# 修改副本不影响原字典
shallow_copy["age"] = 31
print(f"原字典：{person['age']}")      # 30
print(f"拷贝字典：{shallow_copy['age']}")  # 31

# 深拷贝处理嵌套字典
import copy

nested_dict = {
    "personal": {"name": "张三", "age": 30},
    "work": {"company": "ABC公司", "position": "工程师"}
}

shallow = nested_dict.copy()
deep = copy.deepcopy(nested_dict)

# 修改浅拷贝影响原字典
shallow["personal"]["age"] = 31
print(f"原字典：{nested_dict['personal']['age']}")  # 31（受影响）

# 修改深拷贝不影响原字典
deep["personal"]["age"] = 32
print(f"原字典：{nested_dict['personal']['age']}")  # 31（不受影响）

# fromkeys()类方法创建新字典
keys = ["name", "age", "city"]
default_dict = dict.fromkeys(keys, "未知")
print(f"默认字典：{default_dict}")  # {'name': '未知', 'age': '未知', 'city': '未知'}

# fromkeys()的默认值是None
none_dict = dict.fromkeys(keys)
print(f"None字典：{none_dict}")  # {'name': None, 'age': None, 'city': None}

# 字典的集合操作（Python 3.9+）
dict1 = {"a": 1, "b": 2, "c": 3}
dict2 = {"b": 2, "c": 4, "d": 5}

# 获取共同键
common_keys = dict1.keys() & dict2.keys()
print(f"共同键：{common_keys}")  # {'b', 'c'}

# 获取所有键
all_keys = dict1.keys() | dict2.keys()
print(f"所有键：{all_keys}")  # {'d', 'b', 'a', 'c'}

# 获取独有键
unique_to_dict1 = dict1.keys() - dict2.keys()
print(f"dict1独有键：{unique_to_dict1}")  # {'a'}

# 合并字典中的相同键值对
common_items = dict1.items() & dict2.items()
print(f"相同键值对：{common_items}")  # {('b', 2)}

# 字典视图的动态性
person = {"name": "张三", "age": 30}
keys_view = person.keys()

print(f"修改前：{keys_view}")
person["city"] = "北京"
print(f"修改后：{keys_view}")  # 视图会反映字典的实时变化
```

### 字典的排序与比较

```python
students = {
    "张三": 85,
    "李四": 92,
    "王五": 78,
    "赵六": 88,
    "钱七": 95
}

# 按键排序
sorted_by_key = dict(sorted(students.items()))
print(f"按键排序：{sorted_by_key}")
# {'张三': 85, '李四': 92, '王五': 78, '赵六': 88, '钱七': 95}

# 按值排序
sorted_by_value = dict(sorted(students.items(), key=lambda item: item[1]))
print(f"按值升序排序：{sorted_by_value}")
# {'王五': 78, '张三': 85, '赵六': 88, '李四': 92, '钱七': 95}

sorted_by_value_desc = dict(sorted(students.items(), 
                                   key=lambda item: item[1], reverse=True))
print(f"按值降序排序：{sorted_by_value_desc}")
# {'钱七': 95, '李四': 92, '赵六': 88, '张三': 85, '王五': 78}

# 多级排序
students_info = {
    "张三": {"score": 85, "age": 20},
    "李四": {"score": 92, "age": 21},
    "王五": {"score": 78, "age": 20},
    "赵六": {"score": 85, "age": 19},
    "钱七": {"score": 92, "age": 22}
}

# 先按分数降序，再按年龄升序
sorted_students = dict(sorted(students_info.items(), 
                             key=lambda item: (item[1]["score"], -item[1]["age"])))
print(f"多级排序：{sorted_students}")

# 使用operator模块进行排序
import operator

# 按值排序（更高效）
sorted_by_value_op = dict(sorted(students.items(), 
                                key=operator.itemgetter(1)))
print(f"使用operator排序：{sorted_by_value_op}")

# 获取字典的n个最大/最小键值对
import heapq

# 获取分数最高的3个学生
top_3 = dict(heapq.nlargest(3, students.items(), key=lambda item: item[1]))
print(f"分数最高的3人：{top_3}")

# 获取分数最低的2个学生
bottom_2 = dict(heapq.nsmallest(2, students.items(), key=lambda item: item[1]))
print(f"分数最低的2人：{bottom_2}")
```

### 字典的高级应用

```python
# 字典作为缓存（备忘录模式）
def fibonacci(n, cache={}):
    if n in cache:
        return cache[n]
    if n <= 1:
        result = n
    else:
        result = fibonacci(n-1, cache) + fibonacci(n-2, cache)
    cache[n] = result
    return result

print(f"fibonacci(10)：{fibonacci(10)}")  # 55
print(f"缓存内容：{cache}")

# 字典作为函数参数的默认值陷阱
def add_to_list(item, my_dict={}):
    if "items" not in my_dict:
        my_dict["items"] = []
    my_dict["items"].append(item)
    return my_dict

# 多次调用会共享同一个字典
print(add_to_list(1))  # {'items': [1]}
print(add_to_list(2))  # {'items': [1, 2]}（不是期望的 {'items': [2]}）

# 正确的默认字典用法
def add_to_list_fixed(item, my_dict=None):
    if my_dict is None:
        my_dict = {}
    if "items" not in my_dict:
        my_dict["items"] = []
    my_dict["items"].append(item)
    return my_dict

print(add_to_list_fixed(1))  # {'items': [1]}
print(add_to_list_fixed(2))  # {'items': [2]}（符合期望）

# 使用字典实现多态
class Animal:
    def __init__(self, name, sound):
        self.name = name
        self.sound = sound
    
    def make_sound(self):
        return f"{self.name}发出{self.sound}声"

# 使用字典存储不同的发声函数
sound_functions = {
    "dog": lambda name: f"{name}汪汪叫",
    "cat": lambda name: f"{name}喵喵叫",
    "bird": lambda name: f"{name}唧唧叫"
}

def animal_sound(animal_type, name):
    sound_func = sound_functions.get(animal_type, lambda n: f"{name}未知动物")
    return sound_func(name)

print(animal_sound("dog", "旺财"))  # 旺财汪汪叫
print(animal_sound("cat", "咪咪"))  # 咪咪喵喵叫
print(animal_sound("fish", "小丑"))  # 小丑未知动物

# 字典的链式操作（使用dict()构造函数）
result = dict(
    (key, value * 2) 
    for key, value in {"a": 1, "b": 2, "c": 3}.items() 
    if value % 2 == 0
)
print(result)  # {'b': 4}

# 使用字典构建配置系统
class Config:
    def __init__(self):
        self._config = {}
    
    def set(self, key, value):
        self._config[key] = value
        return self  # 支持链式调用
    
    def get(self, key, default=None):
        return self._config.get(key, default)
    
    def update(self, **kwargs):
        self._config.update(kwargs)
        return self
    
    def to_dict(self):
        return self._config.copy()

# 使用配置系统
config = (Config()
          .set("host", "localhost")
          .set("port", 8080)
          .update(debug=True, timeout=30))

print(config.to_dict())  # {'host': 'localhost', 'port': 8080, 'debug': True, 'timeout': 30}

# 字典的性能优化
import time

# 比较字典查找的效率
large_dict = {i: f"value_{i}" for i in range(1000000)}
test_keys = [500000, 200000, 800000, 999999]

# 测试字典查找速度
start = time.time()
for key in test_keys:
    value = large_dict.get(key)
end = time.time()
print(f"字典查找耗时：{end - start:.6f}秒")

# 测试列表查找速度（用于对比）
large_list = list(range(1000000))
test_indices = [500000, 200000, 800000, 999999]

start = time.time()
for index in test_indices:
    value = large_list[index] if index < len(large_list) else None
end = time.time()
print(f"列表查找耗时：{end - start:.6f}秒")
```

### 字典的实用技巧

```python
# 字典合并的多种方法
dict1 = {"a": 1, "b": 2}
dict2 = {"b": 3, "c": 4}

# 方法1：使用update()
merged = dict1.copy()
merged.update(dict2)

# 方法2：使用字典推导式
merged = {**dict1, **dict2}

# 方法3：使用|操作符（Python 3.9+）
merged = dict1 | dict2

print(f"合并结果：{merged}")  # {'a': 1, 'b': 3, 'c': 4}

# 字典的扁平化
nested_dict = {
    "level1": {
        "level2": {
            "level3": "deep_value"
        },
        "other": "value"
    }
}

def flatten_dict(d, parent_key='', sep='_'):
    items = []
    for k, v in d.items():
        new_key = f"{parent_key}{sep}{k}" if parent_key else k
        if isinstance(v, dict):
            items.extend(flatten_dict(v, new_key, sep=sep).items())
        else:
            items.append((new_key, v))
    return dict(items)

flat_dict = flatten_dict(nested_dict)
print(f"扁平化字典：{flat_dict}")  # {'level1_level2_level3': 'deep_value', 'level1_other': 'value'}

# 反转字典（值变为键，键变为值）
def reverse_dict(d):
    return {v: k for k, v in d.items()}

original = {"a": 1, "b": 2, "c": 3}
reversed_dict = reverse_dict(original)
print(f"反转字典：{reversed_dict}")  # {1: 'a', 2: 'b', 3: 'c'}

# 处理重复值的反转
original_with_duplicates = {"a": 1, "b": 2, "c": 1}
reversed_with_lists = {}
for k, v in original_with_duplicates.items():
    reversed_with_lists.setdefault(v, []).append(k)

print(f"处理重复值的反转：{reversed_with_lists}")  # {1: ['a', 'c'], 2: ['b']}

# 字典统计
def dict_stats(d):
    return {
        "键的数量": len(d),
        "所有键类型统计": {type(k).__name__: sum(1 for k in d.keys() if isinstance(k, type(k))) 
                          for k in set(d.keys())},
        "所有值类型统计": {type(v).__name__: sum(1 for v in d.values() if isinstance(v, type(v))) 
                          for v in set(d.values())},
        "嵌套字典数量": sum(1 for v in d.values() if isinstance(v, dict))
    }

test_dict = {
    "name": "张三",
    "age": 30,
    "scores": {"math": 90, "english": 85},
    "active": True,
    123: "数字键",
    (1, 2): "元组键"
}

print(f"字典统计：{dict_stats(test_dict)}")

# 使用字典实现switch-case模式
def switch_case(value, cases):
    return cases.get(value, "默认情况")

# 使用字典替代if-elif-else
operation_dict = {
    "add": lambda a, b: a + b,
    "subtract": lambda a, b: a - b,
    "multiply": lambda a, b: a * b,
    "divide": lambda a, b: a / b if b != 0 else "除数不能为零"
}

def calculate(operation, a, b):
    func = operation_dict.get(operation)
    if func:
        return func(a, b)
    else:
        return "不支持的操作"

print(calculate("add", 5, 3))       # 8
print(calculate("divide", 10, 2))   # 5.0
print(calculate("power", 2, 3))     # 不支持的操作
```




## 字符串（String）

字符串是Python中最常用的数据类型之一，提供了丰富的操作方法和功能。

### 字符串的创建与基本操作

```python
# 多种创建方式
single_quote = 'Hello World'
double_quote = "Hello World"
triple_single = '''多行字符串
第二行
第三行'''
triple_double = """多行字符串
第二行
第三行"""
raw_string = r'C:\Windows\System32'  # 原始字符串，不转义
unicode_string = u'Unicode字符串'     # Unicode字符串

# 字节字符串
byte_string = b'Hello World'
print(byte_string)  # b'Hello World'

# 字符串长度
text = "Python编程"
print(f"字符串长度：{len(text)}")  # 7（中文字符在Python 3中算1个字符）

# 字符串拼接
first = "Hello"
second = "World"
concatenated = first + " " + second
print(concatenated)  # Hello World

# 字符串重复
pattern = "AB" * 3
print(pattern)  # ABABAB

# 字符串比较
str1 = "apple"
str2 = "Apple"
str3 = "apple"

print(str1 == str2)  # False（区分大小写）
print(str1.lower() == str2.lower())  # True（不区分大小写）
print(str1 == str3)   # True

# 字符串排序
words = ["banana", "apple", "cherry", "date"]
sorted_words = sorted(words)
print(f"排序后：{sorted_words}")  # ['apple', 'banana', 'cherry', 'date']

# 大小写不敏感排序
case_insensitive = sorted(words, key=str.lower)
print(f"不区分大小写排序：{case_insensitive}")  # ['apple', 'banana', 'cherry', 'date']
```


### 字符串的索引与切片

```python
text = "Python Programming"

# 正向索引（从0开始）
print(text[0])      # P
print(text[6])      # （空格）
print(text[7])      # P

# 负向索引（从-1开始）
print(text[-1])     # g
print(text[-3])     # i
print(text[-len(text)])  # P

# 切片操作
print(text[0:6])        # Python
print(text[7:18])       # Programming
print(text[7:])         # Programming
print(text[:6])         # Python
print(text[::2])        # Pto rgamn（步长为2）
print(text[::3])        # Ph agmn（步长为3）

# 负步长切片
print(text[::-1])        # gnimmargorP nohtyP（反转）
print(text[11:2:-2])     # girP（从索引11到2，步长-2）
print(text[-1:-6:-1])    # gnimm（从后向前5个字符）

# 切片赋值（字符串不可变，但可以创建新字符串）
text = "Python Programming"
new_text = text[:6] + " 3.9" + text[6:]
print(new_text)  # Python 3.9 Programming

# 切片与步长结合
print(text[::2][::-1])  # nmarg otP（每隔一个字符取，然后反转）
```

### 字符串的查询方法

```python
text = "Python is easy to learn. Python is powerful."

# find()方法：查找子串位置（首次出现）
position = text.find("Python")
print(f"Python首次出现位置：{position}")  # 0

# 指定搜索范围
second_occurrence = text.find("Python", 1)
print(f"Python第二次出现位置：{second_occurrence}")  # 26

# rfind()方法：从右边查找
last_occurrence = text.rfind("Python")
print(f"Python最后一次出现位置：{last_occurrence}")  # 26

# index()方法：类似find()，但找不到会抛出ValueError
try:
    position = text.index("Java")
except ValueError:
    print("Java不在字符串中")

# count()方法：统计子串出现次数
python_count = text.count("Python")
print(f"Python出现次数：{python_count}")  # 2

# startswith()方法：检查是否以指定字符串开头
print(text.startswith("Python"))  # True
print(text.startswith("is"))      # False

# 元组参数检查多个可能的开头
print(text.startswith(("Python", "Java", "C++")))  # True

# endswith()方法：检查是否以指定字符串结尾
print(text.endswith("powerful."))  # True
print(text.endswith("learn."))     # False

# 检查多个可能的结尾
print(text.endswith(("powerful.", "learn.", "Python.")))  # True

# is系列方法
print("12345".isdigit())      # True（只包含数字）
print("123a".isdigit())       # False
print("12.5".isdigit())       # False

print("abc".isalpha())        # True（只包含字母）
print("abc123".isalpha())     # False

print("abc123".isalnum())     # True（只包含字母和数字）
print("abc@123".isalnum())    # False

print("hello world".islower())    # True（全是小写）
print("Hello World".islower())    # False

print("HELLO WORLD".isupper())    # True（全是大写）
print("Hello World".isupper())    # False

print("Hello World".istitle())    # True（标题格式）
print("hello world".istitle())    # False

print("   ".isspace())            # True（只包含空白字符）
print(" hello ".isspace())        # False

print("_hello_".isidentifier())   # True（有效的Python标识符）
print("123hello".isidentifier())  # False
```

### 字符串的转换方法

```python
text = "Hello World Python Programming"

# 大小写转换
print(text.lower())        # hello world python programming
print(text.upper())        # HELLO WORLD PYTHON PROGRAMMING
print(text.title())        # Hello World Python Programming（每个单词首字母大写）
print(text.capitalize())   # Hello world python programming（只有句首字母大写）
print(text.swapcase())     # hELLO wORLD pYTHON pROGRAMMING（大小写互换）

# casefold()方法：更激进的lower()，用于大小写不敏感比较
german_text = "Straße"
print(german_text.lower())      # straße
print(german_text.casefold())   # strasse（更好的国际化支持）

# 转换为首字母大写
words = ["apple", "banana", "cherry"]
capitalized_words = [word.capitalize() for word in words]
print(capitalized_words)  # ['Apple', 'Banana', 'Cherry']

# 每个单词首字母大写
title_words = [word.title() for word in words]
print(title_words)  # ['Apple', 'Banana', 'Cherry']
```

### 字符串的清理方法

```python
# strip()方法：去除两端空白
text = "   Hello World   "
print(f"原字符串：'{text}'")
print(f"去除两端空白：'{text.strip()}'")  # 'Hello World'

# lstrip()和rstrip()
print(f"去除左端空白：'{text.lstrip()}'")   # 'Hello World   '
print(f"去除右端空白：'{text.rstrip()}'")   # '   Hello World'

# 指定去除字符
text2 = "///Hello World///"
print(f"去除斜杠：'{text2.strip('/')}'")  # 'Hello World'

text3 = "xxHello Worldxx"
print(f"去除x：'{text3.strip('x')}'")    # 'Hello World'

# 去除多个字符
text4 = "=!*Hello World*!="
print(f"去除多个字符：'{text4.strip('=!*')}'")  # 'Hello World'

# 使用translate()方法进行字符清理
import string

text5 = "Hello! World, 123!"
# 创建转换表：删除标点符号和数字
translator = str.maketrans('', '', string.punctuation + string.digits)
clean_text = text5.translate(translator)
print(f"清理后：'{clean_text}'")  # 'Hello World'

# 只保留字母和空格
text6 = "Hello, 世界! 123 World."
clean_alpha = ''.join(c for c in text6 if c.isalpha() or c.isspace())
print(f"只保留字母和空格：'{clean_alpha}'")  # 'Hello 世界 World'
```

### 字符串的分割与连接

```python
# split()方法：分割字符串
text = "Python,Java,C++,JavaScript"

# 基本分割
languages = text.split(",")
print(languages)  # ['Python', 'Java', 'C++', 'JavaScript']

# 指定最大分割次数
languages_limited = text.split(",", 2)
print(languages_limited)  # ['Python', 'Java', 'C++,JavaScript']

# 默认按空白字符分割（多个空格视为一个分隔符）
text2 = "Python   Java\tC++\nJavaScript"
words = text2.split()
print(words)  # ['Python', 'Java', 'C++', 'JavaScript']

# rsplit()方法：从右边分割
text3 = "2023-12-06"
date_parts = text3.rsplit("-", 1)  # 只分割最后一个-
print(date_parts)  # ['2023-12', '06']

# partition()和rpartition()方法：分割成3部分
text4 = "user@example.com"
username, separator, domain = text4.partition("@")
print(f"用户名：{username}, 分隔符：{separator}, 域名：{domain}")

# 分割但保留分隔符
import re
text5 = "Python, Java, C++, JavaScript"
languages_with_sep = re.split(r'(\s*,\s*)', text5)
print(languages_with_sep)  # ['Python', ', ', 'Java', ', ', 'C++', ', ', 'JavaScript']

# splitlines()方法：按行分割
multiline_text = """第一行
第二行
第三行"""
lines = multiline_text.splitlines()
print(lines)  # ['第一行', '第二行', '第三行']

# join()方法：连接字符串
words = ["Python", "is", "awesome"]
sentence = " ".join(words)
print(sentence)  # Python is awesome

# 使用不同的分隔符
sentence_comma = ", ".join(words)
print(sentence_comma)  # Python, is, awesome

# 连接列表中的数字（需要先转换为字符串）
numbers = [1, 2, 3, 4, 5]
numbers_str = "-".join(map(str, numbers))
print(numbers_str)  # 1-2-3-4-5

# 使用os.path.join连接路径（跨平台）
import os
path_parts = ["home", "user", "documents", "file.txt"]
full_path = os.path.join(*path_parts)
print(f"系统路径：{full_path}")
```

### 字符串的替换与查找替换

```python
text = "Python is popular. Python is versatile. Python is powerful."

# replace()方法：替换字符串
new_text = text.replace("Python", "Java")
print(new_text)  # Java is popular. Java is versatile. Java is powerful.

# 指定替换次数
limited_replace = text.replace("Python", "Java", 2)
print(limited_replace)  # Java is popular. Java is versatile. Python is powerful.

# 多次替换
text2 = "Hello World, Hello Python"
text2 = text2.replace("Hello", "Hi").replace("World", "Universe")
print(text2)  # Hi Universe, Hi Python

# 使用字典进行多次替换
def multiple_replace(text, replacements):
    for old, new in replacements.items():
        text = text.replace(old, new)
    return text

text3 = "Python is easy to learn, Python is powerful."
replacements = {
    "Python": "Java",
    "easy": "simple",
    "powerful": "versatile"
}
result = multiple_replace(text3, replacements)
print(result)  # Java is simple to learn, Java is versatile.

# 使用正则表达式进行高级替换
import re

# 保留数字，其他字符替换为#
text4 = "Python 3.9 is released in 2020"
pattern = r'[A-Za-z.]+'  # 匹配字母和点
masked = re.sub(pattern, '#', text4)
print(masked)  # ### 3.9 # #### ## ####

# 保留字母，数字替换为*
letters_only = re.sub(r'\d+', '*', text4)
print(letters_only)  # Python *.* is released in *

# 回调函数替换
def replace_with_length(match):
    return str(len(match.group()))  # 返回匹配字符串的长度

text5 = "Python Java C++"
result = re.sub(r'\w+', replace_with_length, text5)
print(result)  # 6 4 3
```

### 字符串的格式化

```python
name = "Alice"
age = 25
height = 165.5

# f-string格式化（Python 3.6+，推荐）
basic_fstring = f"{name}今年{age}岁，身高{height}cm"
print(basic_fstring)  # Alice今年25岁，身高165.5cm

# 格式化选项
formatted_fstring = f"姓名：{name:>8}，年龄：{age:<3}，身高：{height:6.1f}"
print(formatted_fstring)  # 姓名：    Alice，年龄：25 ，身高： 165.5

# 复杂表达式
print(f"{age * 2}")           # 50
print(f"{name.upper()}")       # ALICE
print(f"{name.replace('e', '3')}")  # Alic3

# 多行f-string
multi_line_fstring = f"""
个人信息：
姓名：{name}
年龄：{age}
身高：{height}cm
"""
print(multi_line_fstring)

# format()方法格式化
basic_format = "{}今年{}岁，身高{}cm".format(name, age, height)
print(basic_format)  # Alice今年25岁，身高165.5cm

# 位置参数
positional_format = "姓名：{0}，年龄：{1}，姓名再次：{0}".format(name, age)
print(positional_format)  # 姓名：Alice，年龄：25，姓名再次：Alice

# 关键字参数
keyword_format = "姓名：{name}，年龄：{age}，姓名再次：{name}".format(
    name=name, age=age)
print(keyword_format)  # 姓名：Alice，年龄：25，姓名再次：Alice

# 混合位置和关键字参数
mixed_format = "{0}的年龄是{age}岁".format(name, age=age)
print(mixed_format)  # Alice的年龄是25岁

# 格式化选项
format_options = "姓名：{name:>8}，年龄：{age:<3}，身高：{height:6.1f}".format(
    name=name, age=age, height=height)
print(format_options)  # 姓名：    Alice，年龄：25 ，身高： 165.5

# %格式化（老式方法）
percent_format = "%s今年%d岁，身高%.1fcm" % (name, age, height)
print(percent_format)  # Alice今年25岁，身高165.5cm

# %格式化的变体
percent_variants = [
    "整数：%d" % 42,
    "浮点数：%.2f" % 3.14159,
    "字符串：%s" % "Hello",
    "八进制：%o" % 255,
    "十六进制：%x" % 255,
    "科学计数法：%e" % 12345.6
]
for variant in percent_variants:
    print(variant)

# 使用format_map()与字典
person_dict = {"name": "Bob", "age": 30, "city": "Beijing"}
format_map_result = "姓名：{name}，年龄：{age}，城市：{city}".format_map(person_dict)
print(format_map_result)  # 姓名：Bob，年龄：30，城市：Beijing

# 使用Template类（string模块）
from string import Template

template = Template("姓名：$name，年龄：$age")
template_result = template.substitute(name="Charlie", age=35)
print(template_result)  # 姓名：Charlie，年龄：35

# 使用safe_substitute避免KeyError
template_unsafe = Template("姓名：$name，年龄：$age，城市：$city")
safe_result = template_unsafe.safe_substitute(name="David", age=40)
print(safe_result)  # 姓名：David，年龄：40，城市：$city
```

### 正则表达式处理字符串

```python
import re

# 基本匹配
text = "Python 3.9, Java 8, C++ 14"

# 查找所有匹配项
versions = re.findall(r'\d+\.\d+', text)
print(f"找到所有版本：{versions}")  # ['3.9', '8', '14']

# 查找第一个匹配项
first_version = re.search(r'\d+\.\d+', text)
if first_version:
    print(f"第一个版本：{first_version.group()}")  # 3.9

# 分割字符串
languages = re.split(r'\s*,\s*', text)
print(f"分割结果：{languages}")  # ['Python 3.9', 'Java 8', 'C++ 14']

# 替换字符串
new_text = re.sub(r'(\w+)\s+(\d+\.\d+)', r'\1版本\2', text)
print(f"替换后：{new_text}")  # Python版本3.9, Java版本8, C++版本14

# 编译正则表达式（提高性能）
pattern = re.compile(r'\b[A-Z][a-z]+\b')  # 匹配首字母大写的单词
text2 = "Python is a programming Language created by Guido van Rossum."
capitalized_words = pattern.findall(text2)
print(f"首字母大写的单词：{capitalized_words}")  # ['Python', 'Language', 'Guido']

# 使用捕获组
email_pattern = re.compile(r'([a-zA-Z0-9._%+-]+)@([a-zA-Z0-9.-]+\.[a-zA-Z]{2,})')
email = "user@example.com"
match = email_pattern.match(email)
if match:
    print(f"用户名：{match.group(1)}，域名：{match.group(2)}")

# 使用命名捕获组
date_pattern = re.compile(r'(?P<year>\d{4})-(?P<month>\d{2})-(?P<day>\d{2})')
date = "2023-12-06"
date_match = date_pattern.match(date)
if date_match:
    print(f"年：{date_match.group('year')}")
    print(f"月：{date_match.group('month')}")
    print(f"日：{date_match.group('day')}")

# 查找所有匹配项并获取详细信息
text3 = "联系电话：123-456-7890，备用电话：987-654-3210"
phone_pattern = re.compile(r'(?P<area>\d{3})-(?P<prefix>\d{3})-(?P<line>\d{4})')
for match in phone_pattern.finditer(text3):
    print(f"区号：{match.group('area')}，前缀：{match.group('prefix')}" +
          f"，线路：{match.group('line')}")

# 使用标志
text4 = "Python python PYTHON"
# re.IGNORECASE：忽略大小写
case_insensitive = re.findall(r'python', text4, re.IGNORECASE)
print(f"忽略大小写匹配：{case_insensitive}")  # ['Python', 'python', 'PYTHON']

# re.MULTILINE：多行模式
multiline_text = """First line
Second line
Third line"""
line_start = re.findall(r'^\w+', multiline_text, re.MULTILINE)
print(f"每行开头的单词：{line_start}")  # ['First', 'Second', 'Third']

# re.DOTALL：使点号匹配换行符
text_with_newlines = "Hello\nWorld"
dot_matches_all = re.findall(r'Hello.*World', text_with_newlines, re.DOTALL)
print(f"跨越换行符匹配：{dot_matches_all}")  # ['Hello\nWorld']
```

### 字符串的性能优化

```python
import time
import sys

# 字符串拼接的性能比较
def string_concat_performance(n):
    # 方法1：使用+操作符
    start = time.time()
    result_plus = ""
    for i in range(n):
        result_plus += str(i)
    time_plus = time.time() - start
    
    # 方法2：使用join()
    start = time.time()
    result_join = "".join(str(i) for i in range(n))
    time_join = time.time() - start
    
    # 方法3：使用列表join()
    start = time.time()
    str_list = [str(i) for i in range(n)]
    result_list_join = "".join(str_list)
    time_list_join = time.time() - start
    
    print(f"方法1（+操作符）：{time_plus:.6f}秒，长度：{len(result_plus)}")
    print(f"方法2（join生成器）：{time_join:.6f}秒，长度：{len(result_join)}")
    print(f"方法3（列表join）：{time_list_join:.6f}秒，长度：{len(result_list_join)}")

# 运行性能测试
print("小规模测试（1000次）：")
string_concat_performance(1000)

print("\n大规模测试（10000次）：")
string_concat_performance(10000)

# 字符串interning（字符串驻留）
a = "hello"
b = "hello"
c = "".join(["h", "e", "l", "l", "o"])

print(f"a与b是否相同对象：{a is b}")  # True（短字符串会自动驻留）
print(f"a与c是否相同对象：{a is c}")  # False

# 手动intern
import sys
d = sys.intern("hello")
e = sys.intern("hello")
print(f"d与e是否相同对象：{d is e}")  # True

# 字符串的内存使用
str_short = "hello"
str_long = "a" * 1000
print(f"短字符串内存占用：{sys.getsizeof(str_short)}字节")
print(f"长字符串内存占用：{sys.getsizeof(str_long)}字节")

# 使用生成器处理大字符串，避免内存问题
def process_large_string_chunkwise(text, chunk_size=1000):
    for i in range(0, len(text), chunk_size):
        chunk = text[i:i+chunk_size]
        # 处理每个块
        yield chunk.upper()

large_text = "this is a very long string that we want to process in chunks " * 100
processed_chunks = list(process_large_string_chunkwise(large_text))
print(f"处理后块数：{len(processed_chunks)}")
print(f"第一个块：{processed_chunks[0][:50]}...")  # 只显示部分内容

# 使用字符串缓冲区提高性能
from io import StringIO

# 方法1：常规拼接
def regular_concat(words):
    result = ""
    for word in words:
        result += word + " "
    return result

# 方法2：使用StringIO
def stringio_concat(words):
    buffer = StringIO()
    for word in words:
        buffer.write(word + " ")
    return buffer.getvalue()

words = ["hello"] * 10000
start = time.time()
regular_result = regular_concat(words)
regular_time = time.time() - start

start = time.time()
stringio_result = stringio_concat(words)
stringio_time = time.time() - start

print(f"常规拼接耗时：{regular_time:.6f}秒")
print(f"StringIO拼接耗时：{stringio_time:.6f}秒")
```

