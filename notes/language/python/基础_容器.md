# 基础语法


## 列表（List）

列表是Python中最常用的数据结构之一，是一个有序的可变集合，可以包含任意类型的元素。

### 列表的创建

```python
# 基本创建方式
empty_list = []                    # 空列表
numbers = [1, 2, 3, 4, 5]         # 数字列表
fruits = ["apple", "banana", "orange"]  # 字符串列表
mixed = [1, "hello", 3.14, True]   # 混合类型列表

# 使用list()构造函数
string_list = list("Python")       # ['P', 'y', 't', 'h', 'o', 'n']
range_list = list(range(10))       # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
tuple_list = list((1, 2, 3))       # [1, 2, 3]
dict_list = list({"a": 1, "b": 2}) # ['a', 'b']

# 列表推导式
squares = [x**2 for x in range(10)]  # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
evens = [x for x in range(20) if x % 2 == 0]  # [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]

# 重复创建
zeros = [0] * 10  # [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
pattern = [1, 2] * 3  # [1, 2, 1, 2, 1, 2]

# 嵌套列表
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
three_d = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
```

### 列表的索引与切片

```python
numbers = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]

# 正向索引（从0开始）
print(numbers[0])   # 第一个元素：10
print(numbers[4])   # 第五个元素：50
print(numbers[9])   # 最后一个元素：100

# 负向索引（从-1开始）
print(numbers[-1])  # 最后一个元素：100
print(numbers[-3])  # 倒数第三个元素：80
print(numbers[-10]) # 第一个元素：10

# 切片操作
print(numbers[2:7])     # [30, 40, 50, 60, 70]
print(numbers[:5])      # [10, 20, 30, 40, 50]
print(numbers[5:])      # [60, 70, 80, 90, 100]
print(numbers[::2])     # [10, 30, 50, 70, 90] 步长为2
print(numbers[1::3])    # [20, 50, 80] 从索引1开始，步长为3
print(numbers[::-1])    # [100, 90, 80, 70, 60, 50, 40, 30, 20, 10] 反向
print(numbers[7:2:-1])  # [80, 70, 60, 50, 40] 反向切片

# 切片赋值
numbers[2:5] = [300, 400, 500]  # 替换切片
print(numbers)  # [10, 20, 300, 400, 500, 60, 70, 80, 90, 100]

numbers[1:6:2] = [200, 401, 501]  # 带步长的切片赋值
print(numbers)  # [10, 200, 300, 401, 500, 501, 70, 80, 90, 100]

# 删除切片
del numbers[2:7]
print(numbers)  # [10, 200, 70, 80, 90, 100]
```


### 列表的查询操作

```python
fruits = ["apple", "banana", "cherry", "apple", "orange"]

# index() - 查找元素的位置
first_apple = fruits.index("apple")
print(f"第一个apple的位置：{first_apple}")  # 0

# 指定搜索范围
second_apple = fruits.index("apple", 1)  # 从索引1开始查找
print(f"第二个apple的位置：{second_apple}")  # 3

# 查找不存在的元素
try:
    position = fruits.index("grape")
except ValueError:
    print("grape不在列表中")

# count() - 统计元素出现的次数
apple_count = fruits.count("apple")
print(f"apple出现的次数：{apple_count}")  # 2

# in运算符 - 检查元素是否存在
print("apple" in fruits)  # True
print("grape" in fruits)  # False
print("grape" not in fruits)  # True

# 获取最大值和最小值
numbers = [3, 1, 4, 1, 5, 9, 2, 6]
print(f"最大值：{max(numbers)}")  # 9
print(f"最小值：{min(numbers)}")  # 1

# 获取列表长度
print(f"列表长度：{len(fruits)}")  # 5

# 获取元素总和
print(f"数字总和：{sum(numbers)}")  # 31

# all()和any()函数
bool_list = [True, True, False]
print(f"所有元素为True：{all(bool_list)}")  # False
print(f"存在元素为True：{any(bool_list)}")  # True
```

### 列表的增删改操作


**列表的一些增删改方法：**

| 方法/操作 | 描述 | 参数 | 返回值 | 是否修改原列表 |
|-----------|------|------|--------|---------------|
| `append(item)` | 在列表末尾添加一个元素 | `item`: 要添加的任意对象 | None | 是 |
| `extend(iterable)` | 将可迭代对象的所有元素添加到末尾 | `iterable`: 可迭代对象（列表、字符串等） | None | 是 |
| `insert(index, item)` | 在指定位置插入元素 | `index`: 插入位置<br>`item`: 要插入的对象 | None | 是 |
| `+` 操作符 | 通过组合两个列表创建新列表 | 两个列表对象 | 新列表 | 否 |
| `remove(item)` | 删除第一次出现的指定元素 | `item`: 要删除的元素 | None | 是 |
| `pop([index])` | 删除并返回指定索引处的元素（无索引则删除最后一个） | `index`: 可选位置（默认为-1） | 被删除的元素 | 是 |
| `del` 语句 | 删除指定位置的元素或切片 | 索引或切片 | None | 是 |
| `clear()` | 删除列表中的所有元素 | 无 | None | 是 |
| `index(item[, start[, end]])` | 查找元素第一次出现的索引 | `item`: 要查找的元素<br>`start`: 可选起始索引<br>`end`: 可选结束索引 | 第一次出现的索引 | 否 |
| `count(item)` | 统计元素出现的次数 | `item`: 要统计的元素 | 出现次数 | 否 |
| `in` 操作符 | 检查元素是否存在于列表中 o(n) | 要搜索的元素 | 布尔值 | 否 |
| `not in` 操作符 | 检查元素是否不存在于列表中 | 要搜索的元素 | 布尔值 | 否 |
| `max()` | 返回最大的元素 | 可迭代对象 | 最大元素 | 否 |
| `min()` | 返回最小的元素 | 可迭代对象 | 最小元素 | 否 |
| `len()` | 返回元素数量 | 可迭代对象 | 元素数量 | 否 |
| `sum()` | 返回所有元素的和 | 数字可迭代对象 | 元素之和 | 否 |
| `all()` | 如果所有元素都为真则返回True | 可迭代对象 | 布尔值 | 否 |
| `any()` | 如果任一元素为真则返回True | 可迭代对象 | 布尔值 | 否 |  



**列表的添加操作**
```python
numbers = [1, 2, 3]

# append() - 在末尾添加单个元素
numbers.append(4)
print(numbers)  # [1, 2, 3, 4]

numbers.append([5, 6])  # 添加整个列表作为单个元素
print(numbers)  # [1, 2, 3, 4, [5, 6]]

# extend() - 扩展列表（添加可迭代对象的所有元素）
numbers.extend([7, 8, 9])
print(numbers)  # [1, 2, 3, 4, [5, 6], 7, 8, 9]

numbers.extend("abc")  # 添加字符串的每个字符
print(numbers)  # [1, 2, 3, 4, [5, 6], 7, 8, 9, 'a', 'b', 'c']

# insert() - 在指定位置插入元素
numbers.insert(0, 0)  # 在开头插入
print(numbers)  # [0, 1, 2, 3, 4, [5, 6], 7, 8, 9, 'a', 'b', 'c']

numbers.insert(3, "middle")  # 在索引3处插入
print(numbers)  # [0, 1, 2, 'middle', 3, 4, [5, 6], 7, 8, 9, 'a', 'b', 'c']

numbers.insert(len(numbers), "end")  # 在末尾插入（等同于append）
print(numbers[-3:])  # ['b', 'c', 'end']

# 使用+操作符创建新列表
list1 = [1, 2, 3]
list2 = [4, 5, 6]
combined = list1 + list2
print(combined)  # [1, 2, 3, 4, 5, 6]

# 注意：+操作符创建新列表，不修改原列表
print(list1)    # [1, 2, 3] 原列表不变
print(list2)    # [4, 5, 6] 原列表不变
```



**列表的删除操作**

```python
numbers = [10, 20, 30, 40, 50, 30, 60, 30]

# remove() - 删除第一个匹配的元素
numbers.remove(30)
print(numbers)  # [10, 20, 40, 50, 30, 60, 30]

# 尝试删除不存在的元素
try:
    numbers.remove(999)
except ValueError:
    print("元素不存在，无法删除")

# pop() - 删除并返回指定位置的元素
last = numbers.pop()  # 删除最后一个元素
print(f"删除的元素：{last}")  # 30
print(numbers)  # [10, 20, 40, 50, 30, 60]

first = numbers.pop(0)  # 删除第一个元素
print(f"删除的元素：{first}")  # 10
print(numbers)  # [20, 40, 50, 30, 60]

middle = numbers.pop(2)  # 删除索引2的元素
print(f"删除的元素：{middle}")  # 50
print(numbers)  # [20, 40, 30, 60]

# del语句 - 删除指定元素或切片
del numbers[1]  # 删除索引1的元素
print(numbers)  # [20, 30, 60]

del numbers[1:]  # 删除从索引1到末尾的所有元素
print(numbers)  # [20]

# clear() - 清空整个列表
numbers.clear()
print(numbers)  # []

# 列表推导式删除（创建新列表）
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
evens = [x for x in numbers if x % 2 == 0]  # 只保留偶数
print(evens)  # [2, 4, 6, 8, 10]
```


**列表的修改操作**

```python
fruits = ["apple", "banana", "cherry"]

# 直接赋值修改
fruits[1] = "blueberry"
print(fruits)  # ['apple', 'blueberry', 'cherry']

# 批量修改
fruits[1:2] = ["banana", "orange", "pear"]
print(fruits)  # ['apple', 'banana', 'orange', 'pear', 'cherry']

# 使用+=操作符
fruits += ["grape", "mango"]
print(fruits)  # ['apple', 'banana', 'orange', 'pear', 'cherry', 'grape', 'mango']

# 使用*=操作符重复
fruits *= 2
print(fruits)  # 列表内容重复一次
```


### 列表的排序操作

`sort()` 方法用于对列表进行原地排序，直接修改原列表而不创建新列表。
```python
list.sort(key=None, reverse=False)
"""
key（可选）：指定一个函数，用于从每个列表元素中提取比较键。默认值为 None，表示直接比较元素本身。  
reverse（可选）：布尔值，默认为 False。如果设置为 True，则按降序排序；否则按升序排序。  
无返回值（返回 None） 
"""
```

`sorted()` 函数返回一个新的已排序列表，不修改原始列表。

```python
sorted(iterable, key=None, reverse=False)
"""
iterable：可迭代对象（如列表、元组、字符串等）  
key（可选）：指定一个函数，用于从每个元素中提取比较键  
reverse（可选）：布尔值，控制排序方向（False为升序，True为降序）  
key（可选）：指定一个函数，用于从每个列表元素中提取比较键。默认值为 None，表示直接比较元素本身。  
reverse（可选）：布尔值，默认为 False。如果设置为 True，则按降序排序；否则按升序排序。  
返回一个新的已排序列表
"""
```
 
代码示例：  

```python
numbers = [3, 1, 4, 1, 5, 9, 2, 6, 5]

# sort()方法 - 原地排序
numbers.sort()
print(f"升序排序：{numbers}")  # [1, 1, 2, 3, 4, 5, 5, 6, 9]

# 降序排序
numbers.sort(reverse=True)
print(f"降序排序：{numbers}")  # [9, 6, 5, 5, 4, 3, 2, 1, 1]

# 使用key参数自定义排序
fruits = ["apple", "banana", "cherry", "orange", "grape"]
fruits.sort(key=len)  # 按长度排序
print(f"按长度排序：{fruits}")  # ['apple', 'grape', 'banana', 'orange', 'cherry']

fruits.sort(key=len, reverse=True)  # 按长度降序
print(f"按长度降序：{fruits}")  # ['banana', 'orange', 'cherry', 'apple', 'grape']

# 复杂对象排序
students = [
    {"name": "Alice", "age": 25, "score": 85},
    {"name": "Bob", "age": 23, "score": 92},
    {"name": "Charlie", "age": 26, "score": 78}
]

students.sort(key=lambda x: x["age"])  # 按年龄排序
print(f"按年龄排序：{students}")

students.sort(key=lambda x: x["score"], reverse=True)  # 按分数降序
print(f"按分数降序：{students}")

# sorted()函数 - 返回新列表
numbers = [3, 1, 4, 1, 5, 9, 2, 6, 5]
sorted_numbers = sorted(numbers)
print(f"原列表：{numbers}")
print(f"新排序列表：{sorted_numbers}")

# 多级排序
students = [
    {"name": "Alice", "age": 25, "score": 85},
    {"name": "Bob", "age": 23, "score": 92},
    {"name": "Charlie", "age": 23, "score": 78},
    {"name": "David", "age": 25, "score": 92}
]

# 先按年龄升序，再按分数降序
students.sort(key=lambda x: (x["age"], -x["score"]))
print(f"多级排序：{students}")
```

### 列表的其余方法

```python
numbers = [1, 2, 3, 4, 5]

# reverse() - 反转列表
numbers.reverse()
print(f"反转后的列表：{numbers}")  # [5, 4, 3, 2, 1]

# copy() - 创建列表的浅拷贝
numbers_copy = numbers.copy()
print(f"拷贝的列表：{numbers_copy}")

# 修改拷贝不影响原列表
numbers_copy.append(6)
print(f"原列表：{numbers}")  # [5, 4, 3, 2, 1]
print(f"拷贝列表：{numbers_copy}")  # [5, 4, 3, 2, 1, 6]

# 深拷贝（处理嵌套列表）
import copy
nested_list = [[1, 2], [3, 4]]
shallow_copy = nested_list.copy()
deep_copy = copy.deepcopy(nested_list)

# 修改浅拷贝影响原列表
shallow_copy[0].append(5)
print(f"原嵌套列表：{nested_list}")  # [[1, 2, 5], [3, 4]]

# 修改深拷贝不影响原列表
deep_copy[1].append(6)
print(f"原嵌套列表：{nested_list}")  # [[1, 2, 5], [3, 4]]

# 列表的数学操作
list1 = [1, 2, 3]
list2 = [4, 5, 6]

# 拼接
concatenated = list1 + list2
print(f"拼接：{concatenated}")  # [1, 2, 3, 4, 5, 6]

# 重复
repeated = list1 * 3
print(f"重复：{repeated}")  # [1, 2, 3, 1, 2, 3, 1, 2, 3]

# 列表推导式的高级用法
# 条件表达式
result = [x if x % 2 == 0 else x*2 for x in range(10)]
print(f"偶数保留，奇数翻倍：{result}")  # [0, 2, 2, 6, 4, 10, 6, 14, 8, 18]

# 嵌套循环
matrix = [[i*j for j in range(3)] for i in range(3)]
print(f"3x3矩阵：{matrix}")  # [[0, 0, 0], [0, 1, 2], [0, 2, 4]]

# 带条件的嵌套循环
result = [(i, j) for i in range(3) for j in range(3) if i != j]
print(f"不同坐标对：{result}")  # [(0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1)]
```

**列表的高级应用**

```python
# 列表作为栈使用（LIFO）
stack = []

# push操作
stack.append(1)
stack.append(2)
stack.append(3)
print(f"栈内容：{stack}")  # [1, 2, 3]

# pop操作
top = stack.pop()
print(f"弹出元素：{top}")  # 3
print(f"栈内容：{stack}")  # [1, 2]

# 列表作为队列使用（FIFO，效率较低）
from collections import deque

queue = deque([1, 2, 3])
queue.append(4)  # enqueue
print(f"队列：{queue}")  # deque([1, 2, 3, 4])

front = queue.popleft()  # dequeue
print(f"出队元素：{front}")  # 1
print(f"队列：{queue}")  # deque([2, 3, 4])

# 列表推导式的高级技巧
# 提取字典列表中的特定字段
people = [
    {"name": "Alice", "age": 25, "city": "Beijing"},
    {"name": "Bob", "age": 30, "city": "Shanghai"},
    {"name": "Charlie", "age": 35, "city": "Guangzhou"}
]

names = [person["name"] for person in people]
print(f"所有姓名：{names}")  # ['Alice', 'Bob', 'Charlie']

# 过滤和转换
adults = [person["name"] for person in people if person["age"] >= 30]
print(f"成年人姓名：{adults}")  # ['Bob', 'Charlie']

# 复杂的数据处理
data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# 列表的函数式编程
from functools import reduce

# map函数 - 对每个元素应用函数
squares = list(map(lambda x: x**2, data))
print(f"平方数：{squares}")  # [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

# filter函数 - 过滤元素
evens = list(filter(lambda x: x % 2 == 0, data))
print(f"偶数：{evens}")  # [2, 4, 6, 8, 10]

# reduce函数 - 累积操作
product = reduce(lambda x, y: x * y, data)
print(f"所有数的乘积：{product}")  # 3628800

# 列表性能优化
import time

# 方法1：循环追加
start = time.time()
result = []
for i in range(1000000):
    result.append(i * 2)
end = time.time()
print(f"循环追加耗时：{end - start:.4f}秒")

# 方法2：列表推导式
start = time.time()
result = [i * 2 for i in range(1000000)]
end = time.time()
print(f"列表推导式耗时：{end - start:.4f}秒")

# 列表与内存
import sys

small_list = list(range(100))
large_list = list(range(1000000))
print(f"小列表内存：{sys.getsizeof(small_list)}字节")
print(f"大列表内存：{sys.getsizeof(large_list)}字节")
```

## 元组（Tuple）

元组是Python中的一种不可变序列类型，一旦创建就不能修改。元组使用圆括号 () 定义，也可以省略圆括号。

### 元组的创建与查询

```python
# 基本创建方式
empty_tuple = ()                # 空元组
single_element = (42,)          # 单元素元组（注意逗号）
numbers = (1, 2, 3, 4, 5)       # 基本元组
mixed = (1, "hello", 3.14, True)  # 混合类型元组

# 省略圆括号创建元组
coordinates = 10, 20, 30
print(coordinates)  # (10, 20, 30)

# 使用tuple()构造函数
tuple_from_list = tuple([1, 2, 3, 4, 5])
print(tuple_from_list)  # (1, 2, 3, 4, 5)

tuple_from_string = tuple("Python")
print(tuple_from_string)  # ('P', 'y', 't', 'h', 'o', 'n')

# 嵌套元组
nested_tuple = ((1, 2), (3, 4), (5, 6))
print(nested_tuple)  # ((1, 2), (3, 4), (5, 6))

# 多重赋值创建元组
a, b, c = 1, 2, 3
print(f"a={a}, b={b}, c={c}")  # a=1, b=2, c=3

# 函数返回多个值
def get_coordinates():
    return 10, 20, 30  # 返回元组

x, y, z = get_coordinates()  # 自动解包
print(f"坐标：x={x}, y={y}, z={z}")  # 坐标：x=10, y=20, z=30
```

### 元组的索引与切片

```python
coordinates = (10, 20, 30, 40, 50)

# 正向索引（从0开始）
print(coordinates[0])   # 10
print(coordinates[2])   # 30
print(coordinates[4])   # 50

# 负向索引（从-1开始）
print(coordinates[-1])  # 50
print(coordinates[-3])  # 30

# 切片操作
print(coordinates[1:4])     # (20, 30, 40)
print(coordinates[:3])     # (10, 20, 30)
print(coordinates[2:])      # (30, 40, 50)
print(coordinates[::2])    # (10, 30, 50) 步长为2
print(coordinates[::-1])   # (50, 40, 30, 20, 10) 反向

# 元组的嵌套索引
nested = ((1, 2), (3, 4), (5, 6))
print(nested[1])        # (3, 4)
print(nested[1][0])     # 3
print(nested[2][1])     # 6
```

### 元组的不可变性

```python
# 元组创建后不能修改
coordinates = (10, 20, 30)

# 以下操作会引发TypeError
try:
    coordinates[0] = 100  # TypeError: 'tuple' object does not support item assignment
except TypeError as e:
    print(f"错误：{e}")

# 但是可以引用可变对象
mutable_tuple = ([1, 2], [3, 4])
mutable_tuple[0].append(3)  # 修改列表元素是可以的
print(mutable_tuple)  # ([1, 2, 3], [3, 4])

# 删除元组
del coordinates
# print(coordinates)  # NameError: name 'coordinates' is not defined
```

### 元组的方法

```python
fruits = ("apple", "banana", "cherry", "apple", "orange")

# count() - 统计元素出现的次数
apple_count = fruits.count("apple")
print(f"apple出现的次数：{apple_count}")  # 2

# index() - 查找元素第一次出现的索引
first_apple_index = fruits.index("apple")
print(f"第一个apple的索引：{first_apple_index}")  # 0

# 指定搜索范围
second_apple_index = fruits.index("apple", 1)
print(f"第二个apple的索引：{second_apple_index}")  # 3

# in和not in操作符
print("apple" in fruits)    # True
print("grape" in fruits)    # False
print("grape" not in fruits) # True

# 获取长度
print(f"元组长度：{len(fruits)}")  # 5

# 最大值和最小值
numbers = (3, 1, 4, 1, 5, 9, 2, 6)
print(f"最大值：{max(numbers)}")  # 9
print(f"最小值：{min(numbers)}")  # 1

# 总和
print(f"总和：{sum(numbers)}")  # 31
```

### 元组的解包

```python
# 基本解包
coordinates = (10, 20, 30)
x, y, z = coordinates
print(f"x={x}, y={y}, z={z}")  # x=10, y=20, z=30

# 使用星号(*)收集多余元素
a, *middle, b = (1, 2, 3, 4, 5)
print(f"a={a}, middle={middle}, b={b}")  # a=1, middle=[2, 3, 4], b=5

# 忽略某些值
first, _, third, *_ = (1, 2, 3, 4, 5)
print(f"first={first}, third={third}")  # first=1, third=3

# 嵌套解包
person = ("Alice", 25, ("北京", "朝阳区"))
name, age, (city, district) = person
print(f"姓名：{name}，年龄：{age}，城市：{city}，区域：{district}")

# 函数参数解包
def process_student(name, age, score):
    return f"{name}（{age}岁）得分：{score}"

student_data = ("张三", 18, 95)
result = process_student(*student_data)
print(result)  # 张三（18岁）得分：95

# 函数返回值解包
def get_name_age():
    return "李四", 20

name, age = get_name_age()
print(f"姓名：{name}，年龄：{age}")  # 姓名：李四，年龄：20
```

### 元组的用途

```python
# 1. 作为字典的键（因为元组是不可变的）
locations = {
    (0, 0): "起点",
    (10, 20): "商店",
    (30, 40): "终点"
}

print(locations[(10, 20)])  # 商店

# 2. 返回多个值
def divide_with_remainder(dividend, divisor):
    quotient = dividend // divisor
    remainder = dividend % divisor
    return quotient, remainder

quotient, remainder = divide_with_remainder(17, 5)
print(f"17 ÷ 5 = {quotient} 余 {remainder}")  # 17 ÷ 5 = 3 余 2

# 3. 交换变量值
a, b = 10, 20
print(f"交换前：a={a}, b={b}")  # 交换前：a=10, b=20
a, b = b, a
print(f"交换后：a={a}, b={b}")  # 交换后：a=20, b=10

# 4. 遍历字典的键值对
person = {"name": "Alice", "age": 25, "city": "Beijing"}
for key, value in person.items():
    print(f"{key}: {value}")

# 5. 作为不可变数据结构
student_record = ("张三", 18, 95, "2023-12-06")
print(f"学生记录：{student_record}")

# 6. 元组推导式（实际上是生成器表达式）
squares_tuple = tuple(x**2 for x in range(5))
print(f"平方元组：{squares_tuple}")  # (0, 1, 4, 9, 16)

# 7. 元组的命名访问（使用namedtuple）
from collections import namedtuple

# 创建命名元组类
Point = namedtuple('Point', ['x', 'y'])
Student = namedtuple('Student', ['name', 'age', 'score'])

# 创建命名元组实例
point = Point(10, 20)
student = Student("王五", 19, 88)

print(f"点坐标：({point.x}, {point.y})")  # 点坐标：(10, 20)
print(f"学生信息：{student.name}，{student.age}岁，{student.score}分")

# 命名元组也支持索引访问
print(f"点坐标：({point[0]}, {point[1]})")  # 点坐标：(10, 20)

# 命名元组是不可变的
try:
    point.x = 30  # TypeError: can't set attribute
except AttributeError as e:
    print(f"错误：{e}")

# 命名元组支持解包
x, y = point
print(f"x={x}, y={y}")  # x=10, y=20

# 命名元组的其他方法
print(point._fields)  # ('x', 'y')  # 字段名
new_point = point._replace(x=30)  # 创建替换某些字段的新实例
print(f"新点：{new_point}")  # 新点：Point(x=30, y=20)

# 从字典创建命名元组
point_dict = {"x": 15, "y": 25}
point_from_dict = Point(**point_dict)
print(f"从字典创建的点：{point_from_dict}")  # 从字典创建的点：Point(x=15, y=25)
```

### 元组与列表的比较

```python
# 创建相同的序列数据
list_data = [1, 2, 3, 4, 5]
tuple_data = (1, 2, 3, 4, 5)

# 性能对比
import time
import sys

# 1. 内存使用对比
print(f"列表内存：{sys.getsizeof(list_data)}字节")
print(f"元组内存：{sys.getsizeof(tuple_data)}字节")

# 2. 创建性能对比
start = time.time()
for _ in range(1000000):
    list_temp = [1, 2, 3, 4, 5]
list_creation_time = time.time() - start

start = time.time()
for _ in range(1000000):
    tuple_temp = (1, 2, 3, 4, 5)
tuple_creation_time = time.time() - start

print(f"列表创建耗时：{list_creation_time:.6f}秒")
print(f"元组创建耗时：{tuple_creation_time:.6f}秒")

# 3. 迭代性能对比
start = time.time()
for _ in range(1000000):
    for item in list_data:
        pass
list_iteration_time = time.time() - start

start = time.time()
for _ in range(1000000):
    for item in tuple_data:
        pass
tuple_iteration_time = time.time() - start

print(f"列表迭代耗时：{list_iteration_time:.6f}秒")
print(f"元组迭代耗时：{tuple_iteration_time:.6f}秒")

# 4. 作为字典键的能力
try:
    dict_with_list_key = {[1, 2, 3]: "value"}  # TypeError
except TypeError as e:
    print(f"列表不能作为字典键：{e}")

# 元组可以作为字典键
dict_with_tuple_key = {(1, 2, 3): "value"}
print(f"元组作为字典键：{dict_with_tuple_key}")

# 5. 可变性对比
list_data[0] = 100
print(f"修改后的列表：{list_data}")  # [100, 2, 3, 4, 5]

try:
    tuple_data[0] = 100  # TypeError
except TypeError as e:
    print(f"元组不能修改：{e}")

# 6. 方法对比
list_methods = [method for method in dir(list) if not method.startswith('_')]
tuple_methods = [method for method in dir(tuple) if not method.startswith('_')]

print(f"列表方法数：{len(list_methods)}")
print(f"元组方法数：{len(tuple_methods)}")
print(f"列表特有方法：{set(list_methods) - set(tuple_methods)}")
print(f"元组特有方法：{set(tuple_methods) - set(list_methods)}")
```

### 元组的应用场景

```python
# 1. 函数返回多个值
def get_user_info(user_id):
    # 模拟数据库查询
    return ("张三", 25, "北京", "zhangsan@example.com")

name, age, city, email = get_user_info(123)
print(f"用户信息：{name}，{age}岁，{city}，{email}")

# 2. 配置信息
DATABASE_CONFIG = ("localhost", 5432, "mydb", "user", "password")
HOST, PORT, DATABASE, USER, PASSWORD = DATABASE_CONFIG
print(f"数据库配置：主机={HOST}，端口={PORT}，数据库={DATABASE}")

# 3. 坐标和几何数据
points = [(0, 0), (1, 1), (2, 4), (3, 9)]
for x, y in points:
    print(f"点({x}, {y})")

# 4. 不可变的数据记录
EMPLOYEE_RECORDS = [
    ("张三", "开发部", 50000),
    ("李四", "测试部", 45000),
    ("王五", "设计部", 48000)
]

for name, department, salary in EMPLOYEE_RECORDS:
    print(f"{name}在{department}，薪资{salary}")

# 5. 元组作为哈希表的键
matrix = {}
for i in range(3):
    for j in range(3):
        matrix[(i, j)] = i * 3 + j + 1

print("3x3矩阵：")
for i in range(3):
    row = [matrix[(i, j)] for j in range(3)]
    print(row)
```

## 集合（Set）

集合是Python中的一种无序不重复元素序列，使用花括号 {} 或 set() 函数创建。集合支持数学集合操作如并集、交集、差集等。

### 集合的创建

```python
# 基本创建方式
empty_set = set()           # 空集合（只能用set()创建）
numbers = {1, 2, 3, 4, 5}   # 使用花括号创建集合
fruits = {"apple", "banana", "cherry"}  # 字符串集合

# 注意：不能用{}创建空集合（会被认为是空字典）
empty_dict = {}             # 这是空字典
empty_set_correct = set()   # 这才是空集合
print(type(empty_dict))     # <class 'dict'>
print(type(empty_set_correct))  # <class 'set'>

# 使用set()构造函数
set_from_list = set([1, 2, 2, 3, 3, 4, 5])
print(set_from_list)  # {1, 2, 3, 4, 5}（重复元素被去除）

set_from_string = set("hello")
print(set_from_string)  # {'e', 'h', 'o', 'l'}（顺序不确定）

# 集合推导式
squares = {x**2 for x in range(10)}
print(f"平方集合：{squares}")  # {0, 1, 4, 9, 16, 25, 36, 49, 64, 81}

# 条件集合推导式
even_squares = {x**2 for x in range(10) if x % 2 == 0}
print(f"偶数平方集合：{even_squares}")  # {0, 4, 16, 36, 64}

# 从其他可迭代对象创建
set_from_tuple = set((1, 2, 2, 3, 3, 4))
set_from_range = set(range(5))

print(f"元组转集合：{set_from_tuple}")  # {1, 2, 3, 4}
print(f"范围转集合：{set_from_range}")  # {0, 1, 2, 3, 4}

# 不可变集合（frozenset）
frozen = frozenset([1, 2, 3, 4, 5])
print(f"不可变集合：{frozen}")

# 不可变集合可以作为字典的键
dict_with_frozenset_key = {frozen: "value"}
print(f"字典：{dict_with_frozenset_key}")

# 尝试修改frozenset会出错
try:
    frozen.add(6)  # AttributeError
except AttributeError as e:
    print(f"frozenset不可变：{e}")

# 集合的类型转换
list_data = [1, 2, 2, 3, 3, 4, 5, 5]
set_data = set(list_data)
back_to_list = list(set_data)
print(f"去重后：{back_to_list}")  # [1, 2, 3, 4, 5]（顺序可能不同）
```

### 集合的基本操作

```python
# 创建测试集合
set_a = {1, 2, 3, 4, 5}
set_b = {4, 5, 6, 7, 8}
set_c = {1, 2}
set_d = {9, 10}

# 成员关系测试
print(f"1是否在set_a中：{1 in set_a}")  # True
print(f"6是否在set_a中：{6 in set_a}")  # False
print(f"1是否不在set_a中：{1 not in set_a}")  # False

# 集合的长度
print(f"set_a的长度：{len(set_a)}")  # 5
print(f"set_b的长度：{len(set_b)}")  # 5

# 获取最大值和最小值
numbers = {3, 1, 4, 1, 5, 9, 2, 6}
print(f"最大值：{max(numbers)}")  # 9
print(f"最小值：{min(numbers)}")  # 1

# 集合的比较操作
print(f"set_a是否等于set_b：{set_a == set_b}")  # False
print(f"set_c是否是set_a的子集：{set_c <= set_a}")  # True
print(f"set_a是否是set_c的超集：{set_a >= set_c}")  # True
print(f"set_a是否是set_c的真超集：{set_a > set_c}")  # True
print(f"set_c是否是set_a的真子集：{set_c < set_a}")  # True

# 不相交集合
print(f"set_a和set_d是否不相交：{set_a.isdisjoint(set_d)}")  # True
print(f"set_a和set_b是否不相交：{set_a.isdisjoint(set_b)}")  # False

# 集合的深拷贝和浅拷贝
shallow_copy = set_a.copy()
print(f"浅拷贝：{shallow_copy}")

# 修改拷贝不影响原集合
# 集合是不可变元素的集合，所以深拷贝和浅拷贝效果相同
import copy
deep_copy = copy.deepcopy(set_a)
print(f"深拷贝：{deep_copy}")

# 集合的遍历
print("遍历集合并显示索引：")
for i, item in enumerate(set_a):
    print(f"索引{i}：{item}")

# 由于集合无序，索引只是遍历顺序，不代表集合中的位置
```

### 集合的增删操作

```python
# 创建测试集合
my_set = {1, 2, 3}

# add()方法添加单个元素
my_set.add(4)
print(f"添加4后：{my_set}")  # {1, 2, 3, 4}

# 添加已存在的元素不会改变集合
my_set.add(4)
print(f"再次添加4：{my_set}")  # {1, 2, 3, 4}

# update()方法添加多个元素
my_set.update([5, 6, 7])
print(f"更新后：{my_set}")  # {1, 2, 3, 4, 5, 6, 7}

# update()可以接受多个参数
my_set.update([8, 9], (10, 11), {12, 13})
print(f"多参数更新：{my_set}")  # {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}

# update()也可以接受字符串
my_set.update("abc")
print(f"添加字符串：{my_set}")  # {'1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c'}

# remove()方法删除元素（元素不存在会抛出KeyError）
try:
    my_set.remove('a')
    print(f"删除'a'后：{my_set}")

    my_set.remove('z')  # KeyError
except KeyError:
    print("'z'不存在于集合中")

# discard()方法删除元素（元素不存在不会抛出异常）
my_set.discard('b')
print(f"丢弃'b'后：{my_set}")

my_set.discard('z')  # 不会报错
print(f"丢弃不存在的'z'：{my_set}")

# pop()方法随机删除并返回一个元素
popped = my_set.pop()
print(f"弹出元素：{popped}")  # 随机弹出
print(f"弹出后：{my_set}")

# clear()方法清空集合
my_set.clear()
print(f"清空后：{my_set}")  # set()

# difference_update()方法就地差集操作
set1 = {1, 2, 3, 4, 5}
set2 = {3, 4, 5, 6, 7}
set1.difference_update(set2)
print(f"差集更新：{set1}")  # {1, 2}

# intersection_update()方法就地交集操作
set1 = {1, 2, 3, 4, 5}
set2 = {3, 4, 5, 6, 7}
set1.intersection_update(set2)
print(f"交集更新：{set1}")  # {3, 4, 5}

# symmetric_difference_update()方法就地对称差集操作
set1 = {1, 2, 3, 4, 5}
set2 = {3, 4, 5, 6, 7}
set1.symmetric_difference_update(set2)
print(f"对称差集更新：{set1}")  # {1, 2, 6, 7}

# union_update()方法就地并集操作（Python 3.9+）
set1 = {1, 2, 3, 4, 5}
set2 = {3, 4, 5, 6, 7}
# set1 |= set2  # Python 3.9+
# print(f"并集更新：{set1}")  # {1, 2, 3, 4, 5, 6, 7}
```

### 集合的查询操作

```python
# 创建测试集合
set_a = {1, 2, 3, 4, 5}
set_b = {4, 5, 6, 7, 8}

# in运算符检查元素是否存在
print(f"1是否在set_a中：{1 in set_a}")  # True
print(f"9是否在set_a中：{9 in set_a}")  # False

# not in运算符检查元素是否不存在
print(f"9是否不在set_a中：{9 not in set_a}")  # True

# isdisjoint()方法检查是否不相交
set_c = {9, 10}
set_d = {4, 5}
print(f"set_a和set_c是否不相交：{set_a.isdisjoint(set_c)}")  # True
print(f"set_a和set_d是否不相交：{set_a.isdisjoint(set_d)}")  # False

# issuperset()和issubset()方法检查超集和子集关系
set_e = {1, 2, 3}
print(f"set_a是否是set_e的超集：{set_a.issuperset(set_e)}")  # True
print(f"set_e是否是set_a的子集：{set_e.issubset(set_a)}")  # True

# >、<、>=、<=运算符检查真超集、真子集、超集和子集关系
print(f"set_a是否是set_e的真超集：{set_a > set_e}")  # True
print(f"set_e是否是set_a的真子集：{set_e < set_a}")  # True
print(f"set_a是否是set_e的超集：{set_a >= set_e}")  # True
print(f"set_e是否是set_a的子集：{set_e <= set_a}")  # True

# 获取集合长度
print(f"set_a的长度：{len(set_a)}")  # 5

# 获取最大值和最小值
print(f"set_a的最大值：{max(set_a)}")  # 5
print(f"set_a的最小值：{min(set_a)}")  # 1

# any()和all()函数检查集合元素
bool_set = {True, True, False}
print(f"是否存在True元素：{any(bool_set)}")  # True
print(f"是否所有元素都是True：{all(bool_set)}")  # False

# 使用集合进行去重统计
numbers = [1, 2, 2, 3, 3, 4, 5, 5, 6]
unique_count = len(set(numbers))
print(f"不重复元素数量：{unique_count}")  # 6
```

### 集合的数学运算

```python
# 创建测试集合
set_a = {1, 2, 3, 4, 5}
set_b = {4, 5, 6, 7, 8}

# 并集（union）
union_set1 = set_a | set_b  # 使用操作符
union_set2 = set_a.union(set_b)  # 使用方法
union_set3 = set_a.union([9, 10], (11, 12))  # 传入多个可迭代对象
print(f"并集：{union_set1}")  # {1, 2, 3, 4, 5, 6, 7, 8}
print(f"并集：{union_set2}")  # {1, 2, 3, 4, 5, 6, 7, 8}
print(f"多集合并集：{union_set3}")  # {1, 2, 3, 4, 5, 9, 10, 11, 12}

# 交集（intersection）
intersection_set1 = set_a & set_b  # 使用操作符
intersection_set2 = set_a.intersection(set_b)  # 使用方法
intersection_set3 = set_a.intersection([4, 5, 9], (5, 10))  # 多个交集
print(f"交集：{intersection_set1}")  # {4, 5}
print(f"交集：{intersection_set2}")  # {4, 5}
print(f"多集合交集：{intersection_set3}")  # {5}

# 差集（difference）
difference_set1 = set_a - set_b  # 使用操作符
difference_set2 = set_a.difference(set_b)  # 使用方法
print(f"set_a - set_b：{difference_set1}")  # {1, 2, 3}
print(f"set_a差集set_b：{difference_set2}")  # {1, 2, 3}

# 对称差集（symmetric_difference）
symmetric_diff1 = set_a ^ set_b  # 使用操作符
symmetric_diff2 = set_a.symmetric_difference(set_b)  # 使用方法
print(f"对称差集：{symmetric_diff1}")  # {1, 2, 3, 6, 7, 8}
print(f"对称差集：{symmetric_diff2}")  # {1, 2, 3, 6, 7, 8}

# 子集和超集检查
set_c = {1, 2}
set_d = {1, 2, 3, 4, 5}

print(f"set_c是set_d的子集：{set_c <= set_d}")  # True
print(f"set_d是set_c的超集：{set_d >= set_c}")  # True
print(f"set_c是set_d的真子集：{set_c < set_d}")  # True
print(f"set_d是set_c的真超集：{set_d > set_c}")  # True
print(f"set_c是set_c的真子集：{set_c < set_c}")  # False

# 不相交集合
set_e = {1, 2, 3}
set_f = {4, 5, 6}
set_g = {3, 4, 5}

print(f"set_e和set_f不相交：{set_e.isdisjoint(set_f)}")  # True
print(f"set_e和set_g不相交：{set_e.isdisjoint(set_g)}")  # False

# 集合的子集生成
def get_all_subsets(s):
    """生成集合的所有子集（幂集）"""
    subsets = []
    elements = list(s)
    n = len(elements)

    # 使用位运算生成所有子集
    for i in range(2**n):
        subset = set()
        for j in range(n):
            if i & (1 << j):
                subset.add(elements[j])
        subsets.append(subset)

    return subsets

original_set = {1, 2, 3}
all_subsets = get_all_subsets(original_set)
print(f"集合{original_set}的所有子集：")
for i, subset in enumerate(all_subsets):
    print(f"  {i+1}: {subset}")

# 集合的笛卡尔积
from itertools import product

set_x = {1, 2}
set_y = {'a', 'b'}
cartesian_product = set(product(set_x, set_y))
print(f"笛卡尔积：{cartesian_product}")  # {(1, 'b'), (2, 'b'), (1, 'a'), (2, 'a')}
```

### 集合的高级应用

```python
# 集合去重应用
duplicate_list = [1, 2, 2, 3, 3, 4, 5, 5, 6]
unique_list = list(set(duplicate_list))
print(f"去重后：{unique_list}")  # [1, 2, 3, 4, 5, 6]（顺序可能不同）

# 保持原顺序的去重
def deduplicate_preserve_order(seq):
    """保持顺序去重"""
    seen = set()
    result = []
    for item in seq:
        if item not in seen:
            seen.add(item)
            result.append(item)
    return result

duplicate_list = [1, 2, 2, 3, 3, 4, 5, 5, 6]
unique_ordered = deduplicate_preserve_order(duplicate_list)
print(f"有序去重：{unique_ordered}")  # [1, 2, 3, 4, 5, 6]

# 集合交集应用 - 查找共同元素
set1 = {1, 2, 3, 4, 5}
set2 = {3, 4, 5, 6, 7}
set3 = {5, 6, 7, 8, 9}

# 两个集合的交集
common_two = set1 & set2
print(f"两个集合的交集：{common_two}")  # {3, 4, 5}

# 多个集合的交集
common_multiple = set1 & set2 & set3
print(f"三个集合的交集：{common_multiple}")  # {5}

# 使用intersection方法
common_method = set1.intersection(set2, set3)
print(f"方法求交集：{common_method}")  # {5}

# 集合并集应用 - 合并所有元素
all_elements = set1 | set2 | set3
print(f"所有元素：{all_elements}")  # {1, 2, 3, 4, 5, 6, 7, 8, 9}

# 使用union方法
all_elements_method = set1.union(set2, set3)
print(f"方法求并集：{all_elements_method}")  # {1, 2, 3, 4, 5, 6, 7, 8, 9}

# 集合差集应用 - 找出不同元素
only_in_first = set1 - set2  # 只在第一个集合中的元素
only_in_second = set2 - set1  # 只在第二个集合中的元素
print(f"只在set1中：{only_in_first}")  # {1, 2}
print(f"只在set2中：{only_in_second}")  # {6, 7}

# 集合对称差集应用 - 找出不同时存在于两个集合中的元素
symmetric_diff = set1 ^ set2
print(f"对称差集：{symmetric_diff}")  # {1, 2, 6, 7}

# 集合在数据处理中的应用
# 查找唯一访客
visitors_day1 = {"user1", "user2", "user3", "user4"}
visitors_day2 = {"user3", "user4", "user5", "user6"}
visitors_day3 = {"user1", "user5", "user7", "user8"}

# 三天总访客数
all_visitors = visitors_day1 | visitors_day2 | visitors_day3
print(f"三天总访客：{len(all_visitors)}人")  # 8人

# 每天都访问的访客
daily_visitors = visitors_day1 & visitors_day2 & visitors_day3
print(f"每天访问：{daily_visitors}")  # set()

# 只访问一天的访客
only_day1 = visitors_day1 - (visitors_day2 | visitors_day3)
only_day2 = visitors_day2 - (visitors_day1 | visitors_day3)
only_day3 = visitors_day3 - (visitors_day1 | visitors_day2)
print(f"只访问第一天：{only_day1}")  # {'user2'}
print(f"只访问第二天：{only_day2}")  # {'user6'}
print(f"只访问第三天：{only_day3}")  # {'user7', 'user8'}

# 至少访问两天的访客
at_least_two_days = (visitors_day1 & visitors_day2) | \
                   (visitors_day1 & visitors_day3) | \
                   (visitors_day2 & visitors_day3)
print(f"至少访问两天：{at_least_two_days}")  # {'user3', 'user4', 'user1', 'user5'}

# 集合在权限管理中的应用
permissions_admin = {"read", "write", "delete", "manage"}
permissions_editor = {"read", "write"}
permissions_viewer = {"read"}

# 检查权限
user_permissions = {"read", "write"}
print(f"用户有管理员权限：{permissions_admin <= user_permissions}")  # False
print(f"用户有编辑权限：{permissions_editor <= user_permissions}")  # True
print(f"用户有查看权限：{permissions_viewer <= user_permissions}")  # True

# 权限升级
user_permissions |= {"delete"}
print(f"升级后有管理员权限：{permissions_admin <= user_permissions}")  # False
user_permissions.add("manage")
print(f"完全授权后有管理员权限：{permissions_admin <= user_permissions}")  # True

# 权限降级
user_permissions -= {"manage", "delete"}
print(f"降级后权限：{user_permissions}")  # {'read', 'write'}

# 集合在去重统计中的应用
# 统计一篇文章中不同单词的数量
article = """
Python is a great programming language. Python is easy to learn.
Python is widely used in data science, web development, and automation.
Many companies use Python for their projects because Python is versatile.
"""

# 处理文本
import re
words = re.findall(r'\b\w+\b', article.lower())
unique_words = set(words)
print(f"文章单词总数：{len(words)}个")
print(f"不重复单词：{len(unique_words)}个")
print(f"重复率：{(len(words) - len(unique_words)) / len(words) * 100:.1f}%")

# 集合在数据验证中的应用
required_fields = {"name", "age", "email"}
provided_fields = {"name", "age", "email", "phone"}

# 验证必填字段是否齐全
missing_fields = required_fields - provided_fields
extra_fields = provided_fields - required_fields

print(f"缺少字段：{missing_fields}")  # set()
print(f"额外字段：{extra_fields}")  # {'phone'}
print(f"必填字段齐全：{len(missing_fields) == 0}")  # True

# 集合推导式的应用
# 生成平方数集合
squares = {x**2 for x in range(10)}
print(f"平方数集合：{squares}")  # {0, 1, 4, 9, 16, 25, 36, 49, 64, 81}

# 生成质数集合（埃拉托斯特尼筛法）
def sieve_of_eratosthenes(n):
    """埃拉托斯特尼筛法生成质数"""
    primes = set(range(2, n+1))
    for i in range(2, int(n**0.5) + 1):
        if i in primes:
            # 删除i的所有倍数
            multiples = set(range(i*i, n+1, i))
            primes -= multiples
    return primes

primes = sieve_of_eratosthenes(30)
print(f"30以内质数：{sorted(primes)}")  # [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]

# 集合在密码学中的应用（简单示例）
def caesar_cipher_encrypt(text, shift):
    """凯撒密码加密"""
    alphabet = set("abcdefghijklmnopqrstuvwxyz")
    encrypted_chars = set()

    for char in text.lower():
        if char in alphabet:
            shifted_char = chr((ord(char) - ord('a') + shift) % 26 + ord('a'))
            encrypted_chars.add(shifted_char)

    return encrypted_chars

encrypted = caesar_cipher_encrypt("hello world", 3)
print(f"加密字符集合：{sorted(encrypted)}")  # ['d', 'h', 'o', 'r', 'w']

# 集合在去重和唯一性约束中的应用
# 模拟数据库唯一性约束
class UniqueConstraintSimulation:
    def __init__(self):
        self.stored_values = set()

    def add_value(self, value):
        """添加值，如果已存在则抛出异常"""
        if value in self.stored_values:
            raise ValueError(f"值 {value} 已存在")
        self.stored_values.add(value)
        return f"成功添加 {value}"

    def remove_value(self, value):
        """删除值"""
        if value in self.stored_values:
            self.stored_values.discard(value)
            return f"成功删除 {value}"
        return f"值 {value} 不存在"

    def get_values(self):
        """获取所有值"""
        return self.stored_values.copy()

# 模拟使用
simulator = UniqueConstraintSimulation()
print(simulator.add_value("user1"))
print(simulator.add_value("user2"))
try:
    print(simulator.add_value("user1"))  # 会抛出异常
except ValueError as e:
    print(f"错误：{e}")
print(simulator.get_values())
```

### 集合的性能优化

```python
import time
import sys

# 性能对比：列表 vs 集合
# 创建大数据集
large_list = list(range(100000))
large_set = set(range(100000))

# 成员关系测试性能对比
test_element = 99999

# 列表成员关系测试（O(n)）
start = time.time()
found_in_list = test_element in large_list
list_time = time.time() - start

# 集合成员关系测试（O(1)）
start = time.time()
found_in_set = test_element in large_set
set_time = time.time() - start

print(f"列表查找耗时：{list_time:.8f}秒")
print(f"集合查找耗时：{set_time:.8f}秒")
print(f"集合比列表快：{list_time/set_time:.2f}倍")

# 内存使用对比
print(f"列表内存：{sys.getsizeof(large_list)}字节")
print(f"集合内存：{sys.getsizeof(large_set)}字节")

# 去重性能对比
duplicate_list = [i % 10000 for i in range(100000)]

# 列表去重（低效）
start = time.time()
unique_list_slow = []
for item in duplicate_list:
    if item not in unique_list:  # O(n)操作
        unique_list_slow.append(item)
list_dedupe_time = time.time() - start

# 集合去重（高效）
start = time.time()
unique_set = list(set(duplicate_list))
set_dedupe_time = time.time() - start

print(f"列表去重耗时：{list_dedupe_time:.6f}秒")
print(f"集合去重耗时：{set_dedupe_time:.6f}秒")
print(f"集合去重比列表快：{list_dedupe_time/set_dedupe_time:.2f}倍")

# 集合操作性能对比
set_a = set(range(50000))
set_b = set(range(25000, 75000))

# 交集操作
start = time.time()
intersection = set_a & set_b
intersection_time = time.time() - start

# 并集操作
start = time.time()
union = set_a | set_b
union_time = time.time() - start

# 差集操作
start = time.time()
difference = set_a - set_b
difference_time = time.time() - start

print(f"交集操作耗时：{intersection_time:.6f}秒")
print(f"并集操作耗时：{union_time:.6f}秒")
print(f"差集操作耗时：{difference_time:.6f}秒")

# 集合操作的优化技巧
# 当一个集合很小的时候，可以优化检查
small_set = {1, 2, 3}
large_set = set(range(1000000))

# 优化技巧：检查小集合中的每个元素是否在大集合中
start = time.time()
are_all_in_large = all(item in large_set for item in small_set)
optimized_time = time.time() - start

print(f"优化检查耗时：{optimized_time:.8f}秒")

# 集合推导式的性能
start = time.time()
squares_comprehension = {x**2 for x in range(100000)}
comprehension_time = time.time() - start

start = time.time()
squares_loop = set()
for x in range(100000):
    squares_loop.add(x**2)
loop_time = time.time() - start

print(f"集合推导式耗时：{comprehension_time:.6f}秒")
print(f"循环添加耗时：{loop_time:.6f}秒")
print(f"推导式比循环快：{loop_time/comprehension_time:.2f}倍")

# 集合与列表的内存效率对比
large_list = list(range(100000))
large_set = set(range(100000))
large_range = range(100000)

print(f"列表内存：{sys.getsizeof(large_list)}字节")
print(f"集合内存：{sys.getsizeof(large_set)}字节")
print(f"range对象内存：{sys.getsizeof(large_range)}字节")

# 集合在大数据处理中的应用
def find_unique_elements(lists):
    """找出在所有列表中都唯一的元素"""
    if not lists:
        return set()

    # 使用集合操作找出所有列表的交集
    common_elements = set(lists[0])
    for lst in lists[1:]:
        common_elements &= set(lst)

    return common_elements

# 测试
list1 = [1, 2, 3, 4, 5]
list2 = [3, 4, 5, 6, 7]
list3 = [5, 6, 7, 8, 9]

unique_across_all = find_unique_elements([list1, list2, list3])
print(f"在所有列表中都存在的元素：{unique_across_all}")  # {5}

# 集合在缓存中的应用
class SimpleCache:
    """简单缓存实现"""

    def __init__(self, max_size=100):
        self.cache = {}
        self.access_order = []  # 记录访问顺序
        self.max_size = max_size

    def get(self, key):
        """获取缓存值"""
        if key in self.cache:
            # 更新访问顺序
            self.access_order.remove(key)
            self.access_order.append(key)
            return self.cache[key]
        return None

    def put(self, key, value):
        """放入缓存值"""
        if key in self.cache:
            # 更新已存在的值
            self.cache[key] = value
            self.access_order.remove(key)
            self.access_order.append(key)
        else:
            # 添加新值
            if len(self.cache) >= self.max_size:
                # 移除最少使用的项
                oldest = self.access_order.pop(0)
                del self.cache[oldest]

            self.cache[key] = value
            self.access_order.append(key)

    def get_cache_info(self):
        """获取缓存信息"""
        return {
            "缓存大小": len(self.cache),
            "最大容量": self.max_size,
            "访问顺序": self.access_order
        }

# 测试缓存
cache = SimpleCache(max_size=3)
for i in range(5):
    cache.put(f"key{i}", f"value{i}")

print(cache.get_cache_info())
print(f"key2值：{cache.get('key2')}")  # value2
print(f"key0值：{cache.get('key0')}")  # None（已被淘汰）

# 生成器在集合中的应用
def generate_primes(limit):
    """生成质数集合的生成器"""
    primes = set()
    for num in range(2, limit + 1):
        if all(num % prime != 0 for prime in primes if prime * prime <= num):
            primes.add(num)
            yield num

# 使用质数生成器
primes_gen = generate_primes(30)
primes_set = set(primes_gen)
print(f"30以内质数集合：{sorted(primes_set)}")  # [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]

# 集合在爬虫中的应用（模拟）
def crawl_pages(start_url, max_pages):
    """模拟网页爬虫集合应用"""
    visited = set()
    to_visit = [start_url]

    while to_visit and len(visited) < max_pages:
        url = to_visit.pop(0)
        if url not in visited:
            visited.add(url)

            # 模拟页面内容和链接
            page_content = f"内容来自：{url}"
            yield page_content

            # 模拟发现新链接
            new_links = [f"{url}/link{i}" for i in range(1, 4)]
            to_visit.extend(new_links)

# 使用爬虫生成器
# crawler = crawl_pages("http://example.com", 5)
# for page in crawler:
#     print(page)

# 集合的冻结应用
# frozenset在需要不可变集合时非常有用
config_options = frozenset(["debug", "verbose", "quiet"])
valid_options = {"debug", "verbose", "quiet", "silent"}

# 检查配置选项是否有效
invalid_options = config_options - valid_options
print(f"无效配置选项：{invalid_options}")  # set()

# frozenset可以作为字典的键
option_descriptions = {
    frozenset(["debug"]): "启用调试模式",
    frozenset(["verbose"]): "启用详细输出",
    frozenset(["quiet"]): "启用静默模式"
}

print(f"调试模式描述：{option_descriptions.get(frozenset(['debug']), '未知选项')}")

# 集合的布尔运算
set_a = {1, 2, 3, 4, 5}
set_b = {4, 5, 6, 7, 8}

# 使用all()和any()进行集合布尔运算
print(f"set_a中所有元素都大于0：{all(x > 0 for x in set_a)}")  # True
print(f"set_a中存在元素大于4：{any(x > 4 for x in set_a)}")  # True

# 集合的过滤应用
numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
even_numbers = {x for x in numbers if x % 2 == 0}
odd_numbers = {x for x in numbers if x % 2 == 1}

print(f"偶数集合：{even_numbers}")  # {2, 4, 6, 8, 10}
print(f"奇数集合：{odd_numbers}")   # {1, 3, 5, 7, 9}

# 集合的映射应用
numbers = {1, 2, 3, 4, 5}
squares = {x**2 for x in numbers}
print(f"平方集合：{squares}")  # {1, 4, 9, 16, 25}

# 集合的reduce应用（使用functools.reduce）
import functools

numbers = {1, 2, 3, 4, 5}
product = functools.reduce(lambda x, y: x * y, numbers)
print(f"所有数的乘积：{product}")  # 120

# 集合的函数式编程应用
numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

# map函数应用（集合推导式更常用）
squares_map = set(map(lambda x: x**2, numbers))
print(f"map生成的平方集合：{squares_map}")  # {1, 4, 9, 16, 25, 36, 49, 64, 81, 100}

# filter函数应用（集合推导式更常用）
even_filter = set(filter(lambda x: x % 2 == 0, numbers))
print(f"filter生成的偶数集合：{even_filter}")  # {2, 4, 6, 8, 10}

# 集合的性能监控
import timeit

# 性能测试：集合 vs 列表成员关系测试
def list_membership_test():
    large_list = list(range(10000))
    return 9999 in large_list

def set_membership_test():
    large_set = set(range(10000))
    return 9999 in large_set

list_time = timeit.timeit(list_membership_test, number=1000)
set_time = timeit.timeit(set_membership_test, number=1000)

print(f"列表成员关系测试耗时：{list_time:.6f}秒")
print(f"集合成员关系测试耗时：{set_time:.6f}秒")
print(f"集合比列表快：{list_time/set_time:.2f}倍")

# 集合的内存监控
import tracemalloc

# 启动内存跟踪
tracemalloc.start()

# 创建大列表
large_list = list(range(100000))
list_current, list_peak = tracemalloc.get_traced_memory()

# 创建大集合
large_set = set(range(100000))
set_current, set_peak = tracemalloc.get_traced_memory()

tracemalloc.stop()

print(f"列表内存使用：当前 {list_current/1024:.2f}KB，峰值 {list_peak/1024:.2f}KB")
print(f"集合内存使用：当前 {set_current/1024:.2f}KB，峰值 {set_peak/1024:.2f}KB")
```

## 字典（Dictionary）

字典是Python中另一种重要的数据结构，是一个无序的键值对集合（Python 3.7+保持插入顺序），键必须是不可变类型，值可以是任意类型。

### 字典的创建与查询

```python
# 基本创建方式
empty_dict = {}  # 空字典
person = {
    "name": "张三",
    "age": 30,
    "city": "北京"
}

# 使用dict()构造函数
dict1 = dict(name="李四", age=25, city="上海")
print(dict1)  # {'name': '李四', 'age': 25, 'city': '上海'}

# 从列表创建字典
key_value_pairs = [("name", "王五"), ("age", 35), ("city", "广州")]
dict2 = dict(key_value_pairs)
print(dict2)  # {'name': '王五', 'age': 35, 'city': '广州'}

# 从两个列表创建键和值
keys = ["name", "age", "city"]
values = ["赵六", 40, "深圳"]
dict3 = dict(zip(keys, values))
print(dict3)  # {'name': '赵六', 'age': 40, 'city': '深圳'}

# 字典推导式
squares = {x: x**2 for x in range(6)}
print(squares)  # {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25}

# 条件字典推导式
even_squares = {x: x**2 for x in range(10) if x % 2 == 0}
print(even_squares)  # {0: 0, 2: 4, 4: 16, 6: 36, 8: 64}

# 复杂字典推导式
word_info = {word: {"length": len(word), "first": word[0]} 
             for word in ["apple", "banana", "cherry"]}
print(word_info)
# {'apple': {'length': 5, 'first': 'a'}, 
#  'banana': {'length': 6, 'first': 'b'}, 
#  'cherry': {'length': 6, 'first': 'c'}}

# 嵌套字典
employees = {
    "部门1": {
        "经理": {"姓名": "张经理", "年龄": 45},
        "员工": {"姓名": "小李", "年龄": 28}
    },
    "部门2": {
        "经理": {"姓名": "王经理", "年龄": 50},
        "员工": {"姓名": "小赵", "年龄": 32}
    }
}
```

**字典的访问与查询**

```python
person = {
    "name": "张三",
    "age": 30,
    "city": "北京",
    "email": "zhangsan@example.com"
}

# 使用方括号访问（键不存在会抛出KeyError）
print(person["name"])  # 张三
print(person["age"])    # 30

# 使用get()方法访问（键不存在返回None或默认值）
print(person.get("name"))           # 张三
print(person.get("salary"))         # None
print(person.get("salary", 0))      # 0（提供默认值）

# 检查键是否存在
print("name" in person)     # True
print("salary" in person)   # False
print("name" not in person) # False

# 获取所有键、值、键值对
keys = person.keys()        # dict_keys(['name', 'age', 'city', 'email'])
values = person.values()    # dict_values(['张三', 30, '北京', 'zhangsan@example.com'])
items = person.items()      # dict_items([('name', '张三'), ('age', 30), ('city', '北京'), ('email', 'zhangsan@example.com')])

# 转换为列表
print(list(keys))     # ['name', 'age', 'city', 'email']
print(list(values))   # ['张三', 30, '北京', 'zhangsan@example.com']
print(list(items))    # [('name', '张三'), ('age', 30), ('city', '北京'), ('email', 'zhangsan@example.com')]

# 遍历字典
print("遍历键：")
for key in person:
    print(key)

print("\n遍历值：")
for value in person.values():
    print(value)

print("\n遍历键值对：")
for key, value in person.items():
    print(f"{key}: {value}")

# 使用setdefault()方法获取或设置默认值
education = person.setdefault("education", "本科")
print(education)  # 本科
print(person)     # 包含新增的education键

# 使用collections.defaultdict
from collections import defaultdict

# 为不存在的键提供默认值
word_count = defaultdict(int)
words = ["apple", "banana", "apple", "cherry", "banana", "apple"]
for word in words:
    word_count[word] += 1

print(dict(word_count))  # {'apple': 3, 'banana': 2, 'cherry': 1}
```

### 字典的增删改

**列表的添加与修改**
```python
person = {
    "name": "张三",
    "age": 30,
    "city": "北京"
}

# 直接赋值添加或修改
person["email"] = "zhangsan@example.com"  # 添加新键
person["age"] = 31                         # 修改现有键
print(person)

# 使用update()方法更新字典
new_info = {
    "age": 32,              # 更新现有键
    "salary": 50000,         # 添加新键
    "department": "技术部"    # 添加新键
}
person.update(new_info)
print(person)

# update()也可以接受列表或元组
person.update([("hobby", "读书"), ("married", True)])
print(person)

# 使用setdefault()添加键（仅当键不存在时）
result1 = person.setdefault("name", "默认姓名")  # 键已存在，返回原值
result2 = person.setdefault("phone", "13800138000")  # 键不存在，设置并返回新值

print(result1)  # 张三
print(result2)  # 13800138000
print(person)

# 使用|操作符合并字典（Python 3.9+）
dict1 = {"a": 1, "b": 2}
dict2 = {"b": 3, "c": 4}
merged = dict1 | dict2
print(merged)  # {'a': 1, 'b': 3, 'c': 4}

# 使用|=操作符更新字典（Python 3.9+）
dict1 |= dict2
print(dict1)  # {'a': 1, 'b': 3, 'c': 4}

# 嵌套字典的修改
company = {
    "employees": [
        {"name": "张三", "salary": 5000},
        {"name": "李四", "salary": 6000}
    ],
    "info": {
        "name": "科技公司",
        "location": "北京"
    }
}

# 修改嵌套字典中的值
company["employees"][0]["salary"] = 5500
company["info"]["location"] = "上海"

print(company)

# 批量修改字典
def update_person(person, updates):
    for key, value in updates.items():
        person[key] = value
    return person

person = {"name": "王五", "age": 30}
updates = {"age": 31, "city": "深圳", "married": True}
person = update_person(person, updates)
print(person)
```

**字典的删除操作**

```python
person = {
    "name": "张三",
    "age": 30,
    "city": "北京",
    "email": "zhangsan@example.com",
    "salary": 50000
}

# 使用del语句删除键值对
del person["city"]
print(person)  # 城市被删除

# 尝试删除不存在的键（会抛出KeyError）
try:
    del person["nonexistent"]
except KeyError:
    print("键不存在，无法删除")

# 使用pop()方法删除并返回值
age = person.pop("age")
print(f"删除的年龄：{age}")  # 30
print(person)              # 年龄键被删除

# pop()方法提供默认值
phone = person.pop("phone", "未提供")
print(f"电话：{phone}")  # 未提供

# popitem()方法删除并返回最后一个键值对（Python 3.7+）
last_item = person.popitem()
print(f"删除的最后一个键值对：{last_item}")
print(person)

# 使用clear()清空整个字典
person_copy = person.copy()
person_copy.clear()
print(f"清空后的字典：{person_copy}")  # {}

# 批量删除字典中的键
def remove_keys(dictionary, keys_to_remove):
    for key in keys_to_remove:
        dictionary.pop(key, None)  # 使用None作为默认值避免KeyError
    return dictionary

person = {
    "name": "张三",
    "age": 30,
    "city": "北京",
    "email": "zhangsan@example.com",
    "temp_field1": "临时数据1",
    "temp_field2": "临时数据2"
}

temp_keys = [key for key in person.keys() if key.startswith("temp_")]
person = remove_keys(person, temp_keys)
print(f"删除临时字段后：{person}")

# 字典推导式过滤（创建新字典）
person = {
    "name": "张三",
    "age": 30,
    "city": "北京",
    "email": "zhangsan@example.com",
    "salary": 50000
}

# 只保留字符串类型的值
string_values = {key: value for key, value in person.items() 
                 if isinstance(value, str)}
print(f"只保留字符串值：{string_values}")

# 根据键名过滤
basic_info = {key: value for key, value in person.items() 
             if key in ["name", "age", "city"]}
print(f"基本信息：{basic_info}")
```

### 字典的高级方法

```python
person = {
    "name": "张三",
    "age": 30,
    "city": "北京",
    "email": "zhangsan@example.com",
    "salary": 50000
}

# copy()方法创建字典副本
shallow_copy = person.copy()
print(f"浅拷贝：{shallow_copy}")

# 修改副本不影响原字典
shallow_copy["age"] = 31
print(f"原字典：{person['age']}")      # 30
print(f"拷贝字典：{shallow_copy['age']}")  # 31

# 深拷贝处理嵌套字典
import copy

nested_dict = {
    "personal": {"name": "张三", "age": 30},
    "work": {"company": "ABC公司", "position": "工程师"}
}

shallow = nested_dict.copy()
deep = copy.deepcopy(nested_dict)

# 修改浅拷贝影响原字典
shallow["personal"]["age"] = 31
print(f"原字典：{nested_dict['personal']['age']}")  # 31（受影响）

# 修改深拷贝不影响原字典
deep["personal"]["age"] = 32
print(f"原字典：{nested_dict['personal']['age']}")  # 31（不受影响）

# fromkeys()类方法创建新字典
keys = ["name", "age", "city"]
default_dict = dict.fromkeys(keys, "未知")
print(f"默认字典：{default_dict}")  # {'name': '未知', 'age': '未知', 'city': '未知'}

# fromkeys()的默认值是None
none_dict = dict.fromkeys(keys)
print(f"None字典：{none_dict}")  # {'name': None, 'age': None, 'city': None}

# 字典的集合操作（Python 3.9+）
dict1 = {"a": 1, "b": 2, "c": 3}
dict2 = {"b": 2, "c": 4, "d": 5}

# 获取共同键
common_keys = dict1.keys() & dict2.keys()
print(f"共同键：{common_keys}")  # {'b', 'c'}

# 获取所有键
all_keys = dict1.keys() | dict2.keys()
print(f"所有键：{all_keys}")  # {'d', 'b', 'a', 'c'}

# 获取独有键
unique_to_dict1 = dict1.keys() - dict2.keys()
print(f"dict1独有键：{unique_to_dict1}")  # {'a'}

# 合并字典中的相同键值对
common_items = dict1.items() & dict2.items()
print(f"相同键值对：{common_items}")  # {('b', 2)}

# 字典视图的动态性
person = {"name": "张三", "age": 30}
keys_view = person.keys()

print(f"修改前：{keys_view}")
person["city"] = "北京"
print(f"修改后：{keys_view}")  # 视图会反映字典的实时变化
```

### 字典的排序与比较

```python
students = {
    "张三": 85,
    "李四": 92,
    "王五": 78,
    "赵六": 88,
    "钱七": 95
}

# 按键排序
sorted_by_key = dict(sorted(students.items()))
print(f"按键排序：{sorted_by_key}")
# {'张三': 85, '李四': 92, '王五': 78, '赵六': 88, '钱七': 95}

# 按值排序
sorted_by_value = dict(sorted(students.items(), key=lambda item: item[1]))
print(f"按值升序排序：{sorted_by_value}")
# {'王五': 78, '张三': 85, '赵六': 88, '李四': 92, '钱七': 95}

sorted_by_value_desc = dict(sorted(students.items(), 
                                   key=lambda item: item[1], reverse=True))
print(f"按值降序排序：{sorted_by_value_desc}")
# {'钱七': 95, '李四': 92, '赵六': 88, '张三': 85, '王五': 78}

# 多级排序
students_info = {
    "张三": {"score": 85, "age": 20},
    "李四": {"score": 92, "age": 21},
    "王五": {"score": 78, "age": 20},
    "赵六": {"score": 85, "age": 19},
    "钱七": {"score": 92, "age": 22}
}

# 先按分数降序，再按年龄升序
sorted_students = dict(sorted(students_info.items(), 
                             key=lambda item: (item[1]["score"], -item[1]["age"])))
print(f"多级排序：{sorted_students}")

# 使用operator模块进行排序
import operator

# 按值排序（更高效）
sorted_by_value_op = dict(sorted(students.items(), 
                                key=operator.itemgetter(1)))
print(f"使用operator排序：{sorted_by_value_op}")

# 获取字典的n个最大/最小键值对
import heapq

# 获取分数最高的3个学生
top_3 = dict(heapq.nlargest(3, students.items(), key=lambda item: item[1]))
print(f"分数最高的3人：{top_3}")

# 获取分数最低的2个学生
bottom_2 = dict(heapq.nsmallest(2, students.items(), key=lambda item: item[1]))
print(f"分数最低的2人：{bottom_2}")
```

### 字典的高级应用

```python
# 字典作为缓存（备忘录模式）
def fibonacci(n, cache={}):
    if n in cache:
        return cache[n]
    if n <= 1:
        result = n
    else:
        result = fibonacci(n-1, cache) + fibonacci(n-2, cache)
    cache[n] = result
    return result

print(f"fibonacci(10)：{fibonacci(10)}")  # 55
print(f"缓存内容：{cache}")

# 字典作为函数参数的默认值陷阱
def add_to_list(item, my_dict={}):
    if "items" not in my_dict:
        my_dict["items"] = []
    my_dict["items"].append(item)
    return my_dict

# 多次调用会共享同一个字典
print(add_to_list(1))  # {'items': [1]}
print(add_to_list(2))  # {'items': [1, 2]}（不是期望的 {'items': [2]}）

# 正确的默认字典用法
def add_to_list_fixed(item, my_dict=None):
    if my_dict is None:
        my_dict = {}
    if "items" not in my_dict:
        my_dict["items"] = []
    my_dict["items"].append(item)
    return my_dict

print(add_to_list_fixed(1))  # {'items': [1]}
print(add_to_list_fixed(2))  # {'items': [2]}（符合期望）

# 使用字典实现多态
class Animal:
    def __init__(self, name, sound):
        self.name = name
        self.sound = sound
    
    def make_sound(self):
        return f"{self.name}发出{self.sound}声"

# 使用字典存储不同的发声函数
sound_functions = {
    "dog": lambda name: f"{name}汪汪叫",
    "cat": lambda name: f"{name}喵喵叫",
    "bird": lambda name: f"{name}唧唧叫"
}

def animal_sound(animal_type, name):
    sound_func = sound_functions.get(animal_type, lambda n: f"{name}未知动物")
    return sound_func(name)

print(animal_sound("dog", "旺财"))  # 旺财汪汪叫
print(animal_sound("cat", "咪咪"))  # 咪咪喵喵叫
print(animal_sound("fish", "小丑"))  # 小丑未知动物

# 字典的链式操作（使用dict()构造函数）
result = dict(
    (key, value * 2) 
    for key, value in {"a": 1, "b": 2, "c": 3}.items() 
    if value % 2 == 0
)
print(result)  # {'b': 4}

# 使用字典构建配置系统
class Config:
    def __init__(self):
        self._config = {}
    
    def set(self, key, value):
        self._config[key] = value
        return self  # 支持链式调用
    
    def get(self, key, default=None):
        return self._config.get(key, default)
    
    def update(self, **kwargs):
        self._config.update(kwargs)
        return self
    
    def to_dict(self):
        return self._config.copy()

# 使用配置系统
config = (Config()
          .set("host", "localhost")
          .set("port", 8080)
          .update(debug=True, timeout=30))

print(config.to_dict())  # {'host': 'localhost', 'port': 8080, 'debug': True, 'timeout': 30}

# 字典的性能优化
import time

# 比较字典查找的效率
large_dict = {i: f"value_{i}" for i in range(1000000)}
test_keys = [500000, 200000, 800000, 999999]

# 测试字典查找速度
start = time.time()
for key in test_keys:
    value = large_dict.get(key)
end = time.time()
print(f"字典查找耗时：{end - start:.6f}秒")

# 测试列表查找速度（用于对比）
large_list = list(range(1000000))
test_indices = [500000, 200000, 800000, 999999]

start = time.time()
for index in test_indices:
    value = large_list[index] if index < len(large_list) else None
end = time.time()
print(f"列表查找耗时：{end - start:.6f}秒")
```

### 字典的实用技巧

```python
# 字典合并的多种方法
dict1 = {"a": 1, "b": 2}
dict2 = {"b": 3, "c": 4}

# 方法1：使用update()
merged = dict1.copy()
merged.update(dict2)

# 方法2：使用字典推导式
merged = {**dict1, **dict2}

# 方法3：使用|操作符（Python 3.9+）
merged = dict1 | dict2

print(f"合并结果：{merged}")  # {'a': 1, 'b': 3, 'c': 4}

# 字典的扁平化
nested_dict = {
    "level1": {
        "level2": {
            "level3": "deep_value"
        },
        "other": "value"
    }
}

def flatten_dict(d, parent_key='', sep='_'):
    items = []
    for k, v in d.items():
        new_key = f"{parent_key}{sep}{k}" if parent_key else k
        if isinstance(v, dict):
            items.extend(flatten_dict(v, new_key, sep=sep).items())
        else:
            items.append((new_key, v))
    return dict(items)

flat_dict = flatten_dict(nested_dict)
print(f"扁平化字典：{flat_dict}")  # {'level1_level2_level3': 'deep_value', 'level1_other': 'value'}

# 反转字典（值变为键，键变为值）
def reverse_dict(d):
    return {v: k for k, v in d.items()}

original = {"a": 1, "b": 2, "c": 3}
reversed_dict = reverse_dict(original)
print(f"反转字典：{reversed_dict}")  # {1: 'a', 2: 'b', 3: 'c'}

# 处理重复值的反转
original_with_duplicates = {"a": 1, "b": 2, "c": 1}
reversed_with_lists = {}
for k, v in original_with_duplicates.items():
    reversed_with_lists.setdefault(v, []).append(k)

print(f"处理重复值的反转：{reversed_with_lists}")  # {1: ['a', 'c'], 2: ['b']}

# 字典统计
def dict_stats(d):
    return {
        "键的数量": len(d),
        "所有键类型统计": {type(k).__name__: sum(1 for k in d.keys() if isinstance(k, type(k))) 
                          for k in set(d.keys())},
        "所有值类型统计": {type(v).__name__: sum(1 for v in d.values() if isinstance(v, type(v))) 
                          for v in set(d.values())},
        "嵌套字典数量": sum(1 for v in d.values() if isinstance(v, dict))
    }

test_dict = {
    "name": "张三",
    "age": 30,
    "scores": {"math": 90, "english": 85},
    "active": True,
    123: "数字键",
    (1, 2): "元组键"
}

print(f"字典统计：{dict_stats(test_dict)}")

# 使用字典实现switch-case模式
def switch_case(value, cases):
    return cases.get(value, "默认情况")

# 使用字典替代if-elif-else
operation_dict = {
    "add": lambda a, b: a + b,
    "subtract": lambda a, b: a - b,
    "multiply": lambda a, b: a * b,
    "divide": lambda a, b: a / b if b != 0 else "除数不能为零"
}

def calculate(operation, a, b):
    func = operation_dict.get(operation)
    if func:
        return func(a, b)
    else:
        return "不支持的操作"

print(calculate("add", 5, 3))       # 8
print(calculate("divide", 10, 2))   # 5.0
print(calculate("power", 2, 3))     # 不支持的操作
```




## 字符串（Str）

字符串是Python中最常用的数据类型之一，提供了丰富的操作方法和功能。

### 字符串的创建与基本操作

```python
# 多种创建方式
single_quote = 'Hello World'
double_quote = "Hello World"
triple_single = '''多行字符串
第二行
第三行'''
triple_double = """多行字符串
第二行
第三行"""
raw_string = r'C:\Windows\System32'  # 原始字符串，不转义
unicode_string = u'Unicode字符串'     # Unicode字符串

# 字节字符串
byte_string = b'Hello World'
print(byte_string)  # b'Hello World'

# 字符串长度
text = "Python编程"
print(f"字符串长度：{len(text)}")  # 7（中文字符在Python 3中算1个字符）

# 字符串拼接
first = "Hello"
second = "World"
concatenated = first + " " + second
print(concatenated)  # Hello World

# 字符串重复
pattern = "AB" * 3
print(pattern)  # ABABAB

# 字符串比较
str1 = "apple"
str2 = "Apple"
str3 = "apple"

print(str1 == str2)  # False（区分大小写）
print(str1.lower() == str2.lower())  # True（不区分大小写）
print(str1 == str3)   # True

# 字符串排序
words = ["banana", "apple", "cherry", "date"]
sorted_words = sorted(words)
print(f"排序后：{sorted_words}")  # ['apple', 'banana', 'cherry', 'date']

# 大小写不敏感排序
case_insensitive = sorted(words, key=str.lower)
print(f"不区分大小写排序：{case_insensitive}")  # ['apple', 'banana', 'cherry', 'date']
```


### 字符串的索引与切片

```python
text = "Python Programming"

# 正向索引（从0开始）
print(text[0])      # P
print(text[6])      # （空格）
print(text[7])      # P

# 负向索引（从-1开始）
print(text[-1])     # g
print(text[-3])     # i
print(text[-len(text)])  # P

# 切片操作
print(text[0:6])        # Python
print(text[7:18])       # Programming
print(text[7:])         # Programming
print(text[:6])         # Python
print(text[::2])        # Pto rgamn（步长为2）
print(text[::3])        # Ph agmn（步长为3）

# 负步长切片
print(text[::-1])        # gnimmargorP nohtyP（反转）
print(text[11:2:-2])     # girP（从索引11到2，步长-2）
print(text[-1:-6:-1])    # gnimm（从后向前5个字符）

# 切片赋值（字符串不可变，但可以创建新字符串）
text = "Python Programming"
new_text = text[:6] + " 3.9" + text[6:]
print(new_text)  # Python 3.9 Programming

# 切片与步长结合
print(text[::2][::-1])  # nmarg otP（每隔一个字符取，然后反转）
```

### 字符串的查询方法

```python
text = "Python is easy to learn. Python is powerful."

# find()方法：查找子串位置（首次出现）
position = text.find("Python")
print(f"Python首次出现位置：{position}")  # 0

# 指定搜索范围
second_occurrence = text.find("Python", 1)
print(f"Python第二次出现位置：{second_occurrence}")  # 26

# rfind()方法：从右边查找
last_occurrence = text.rfind("Python")
print(f"Python最后一次出现位置：{last_occurrence}")  # 26

# index()方法：类似find()，但找不到会抛出ValueError
try:
    position = text.index("Java")
except ValueError:
    print("Java不在字符串中")

# count()方法：统计子串出现次数
python_count = text.count("Python")
print(f"Python出现次数：{python_count}")  # 2

# startswith()方法：检查是否以指定字符串开头
print(text.startswith("Python"))  # True
print(text.startswith("is"))      # False

# 元组参数检查多个可能的开头
print(text.startswith(("Python", "Java", "C++")))  # True

# endswith()方法：检查是否以指定字符串结尾
print(text.endswith("powerful."))  # True
print(text.endswith("learn."))     # False

# 检查多个可能的结尾
print(text.endswith(("powerful.", "learn.", "Python.")))  # True

# is系列方法
print("12345".isdigit())      # True（只包含数字）
print("123a".isdigit())       # False
print("12.5".isdigit())       # False

print("abc".isalpha())        # True（只包含字母）
print("abc123".isalpha())     # False

print("abc123".isalnum())     # True（只包含字母和数字）
print("abc@123".isalnum())    # False

print("hello world".islower())    # True（全是小写）
print("Hello World".islower())    # False

print("HELLO WORLD".isupper())    # True（全是大写）
print("Hello World".isupper())    # False

print("Hello World".istitle())    # True（标题格式）
print("hello world".istitle())    # False

print("   ".isspace())            # True（只包含空白字符）
print(" hello ".isspace())        # False

print("_hello_".isidentifier())   # True（有效的Python标识符）
print("123hello".isidentifier())  # False
```

### 字符串的转换方法

```python
text = "Hello World Python Programming"

# 大小写转换
print(text.lower())        # hello world python programming
print(text.upper())        # HELLO WORLD PYTHON PROGRAMMING
print(text.title())        # Hello World Python Programming（每个单词首字母大写）
print(text.capitalize())   # Hello world python programming（只有句首字母大写）
print(text.swapcase())     # hELLO wORLD pYTHON pROGRAMMING（大小写互换）

# casefold()方法：更激进的lower()，用于大小写不敏感比较
german_text = "Straße"
print(german_text.lower())      # straße
print(german_text.casefold())   # strasse（更好的国际化支持）

# 转换为首字母大写
words = ["apple", "banana", "cherry"]
capitalized_words = [word.capitalize() for word in words]
print(capitalized_words)  # ['Apple', 'Banana', 'Cherry']

# 每个单词首字母大写
title_words = [word.title() for word in words]
print(title_words)  # ['Apple', 'Banana', 'Cherry']
```

### 字符串的清理方法

```python
# strip()方法：去除两端空白
text = "   Hello World   "
print(f"原字符串：'{text}'")
print(f"去除两端空白：'{text.strip()}'")  # 'Hello World'

# lstrip()和rstrip()
print(f"去除左端空白：'{text.lstrip()}'")   # 'Hello World   '
print(f"去除右端空白：'{text.rstrip()}'")   # '   Hello World'

# 指定去除字符
text2 = "///Hello World///"
print(f"去除斜杠：'{text2.strip('/')}'")  # 'Hello World'

text3 = "xxHello Worldxx"
print(f"去除x：'{text3.strip('x')}'")    # 'Hello World'

# 去除多个字符
text4 = "=!*Hello World*!="
print(f"去除多个字符：'{text4.strip('=!*')}'")  # 'Hello World'

# 使用translate()方法进行字符清理
import string

text5 = "Hello! World, 123!"
# 创建转换表：删除标点符号和数字
translator = str.maketrans('', '', string.punctuation + string.digits)
clean_text = text5.translate(translator)
print(f"清理后：'{clean_text}'")  # 'Hello World'

# 只保留字母和空格
text6 = "Hello, 世界! 123 World."
clean_alpha = ''.join(c for c in text6 if c.isalpha() or c.isspace())
print(f"只保留字母和空格：'{clean_alpha}'")  # 'Hello 世界 World'
```

### 字符串的分割与连接

```python
# split()方法：分割字符串
text = "Python,Java,C++,JavaScript"

# 基本分割
languages = text.split(",")
print(languages)  # ['Python', 'Java', 'C++', 'JavaScript']

# 指定最大分割次数
languages_limited = text.split(",", 2)
print(languages_limited)  # ['Python', 'Java', 'C++,JavaScript']

# 默认按空白字符分割（多个空格视为一个分隔符）
text2 = "Python   Java\tC++\nJavaScript"
words = text2.split()
print(words)  # ['Python', 'Java', 'C++', 'JavaScript']

# rsplit()方法：从右边分割
text3 = "2023-12-06"
date_parts = text3.rsplit("-", 1)  # 只分割最后一个-
print(date_parts)  # ['2023-12', '06']

# partition()和rpartition()方法：分割成3部分
text4 = "user@example.com"
username, separator, domain = text4.partition("@")
print(f"用户名：{username}, 分隔符：{separator}, 域名：{domain}")

# 分割但保留分隔符
import re
text5 = "Python, Java, C++, JavaScript"
languages_with_sep = re.split(r'(\s*,\s*)', text5)
print(languages_with_sep)  # ['Python', ', ', 'Java', ', ', 'C++', ', ', 'JavaScript']

# splitlines()方法：按行分割
multiline_text = """第一行
第二行
第三行"""
lines = multiline_text.splitlines()
print(lines)  # ['第一行', '第二行', '第三行']

# join()方法：连接字符串
words = ["Python", "is", "awesome"]
sentence = " ".join(words)
print(sentence)  # Python is awesome

# 使用不同的分隔符
sentence_comma = ", ".join(words)
print(sentence_comma)  # Python, is, awesome

# 连接列表中的数字（需要先转换为字符串）
numbers = [1, 2, 3, 4, 5]
numbers_str = "-".join(map(str, numbers))
print(numbers_str)  # 1-2-3-4-5

# 使用os.path.join连接路径（跨平台）
import os
path_parts = ["home", "user", "documents", "file.txt"]
full_path = os.path.join(*path_parts)
print(f"系统路径：{full_path}")
```

### 字符串的替换与查找替换

```python
text = "Python is popular. Python is versatile. Python is powerful."

# replace()方法：替换字符串
new_text = text.replace("Python", "Java")
print(new_text)  # Java is popular. Java is versatile. Java is powerful.

# 指定替换次数
limited_replace = text.replace("Python", "Java", 2)
print(limited_replace)  # Java is popular. Java is versatile. Python is powerful.

# 多次替换
text2 = "Hello World, Hello Python"
text2 = text2.replace("Hello", "Hi").replace("World", "Universe")
print(text2)  # Hi Universe, Hi Python

# 使用字典进行多次替换
def multiple_replace(text, replacements):
    for old, new in replacements.items():
        text = text.replace(old, new)
    return text

text3 = "Python is easy to learn, Python is powerful."
replacements = {
    "Python": "Java",
    "easy": "simple",
    "powerful": "versatile"
}
result = multiple_replace(text3, replacements)
print(result)  # Java is simple to learn, Java is versatile.

# 使用正则表达式进行高级替换
import re

# 保留数字，其他字符替换为#
text4 = "Python 3.9 is released in 2020"
pattern = r'[A-Za-z.]+'  # 匹配字母和点
masked = re.sub(pattern, '#', text4)
print(masked)  # ### 3.9 # #### ## ####

# 保留字母，数字替换为*
letters_only = re.sub(r'\d+', '*', text4)
print(letters_only)  # Python *.* is released in *

# 回调函数替换
def replace_with_length(match):
    return str(len(match.group()))  # 返回匹配字符串的长度

text5 = "Python Java C++"
result = re.sub(r'\w+', replace_with_length, text5)
print(result)  # 6 4 3
```

### 字符串的格式化

```python
name = "Alice"
age = 25
height = 165.5

# f-string格式化（Python 3.6+，推荐）
basic_fstring = f"{name}今年{age}岁，身高{height}cm"
print(basic_fstring)  # Alice今年25岁，身高165.5cm

# 格式化选项
formatted_fstring = f"姓名：{name:>8}，年龄：{age:<3}，身高：{height:6.1f}"
print(formatted_fstring)  # 姓名：    Alice，年龄：25 ，身高： 165.5

# 复杂表达式
print(f"{age * 2}")           # 50
print(f"{name.upper()}")       # ALICE
print(f"{name.replace('e', '3')}")  # Alic3

# 多行f-string
multi_line_fstring = f"""
个人信息：
姓名：{name}
年龄：{age}
身高：{height}cm
"""
print(multi_line_fstring)

# format()方法格式化
basic_format = "{}今年{}岁，身高{}cm".format(name, age, height)
print(basic_format)  # Alice今年25岁，身高165.5cm

# 位置参数
positional_format = "姓名：{0}，年龄：{1}，姓名再次：{0}".format(name, age)
print(positional_format)  # 姓名：Alice，年龄：25，姓名再次：Alice

# 关键字参数
keyword_format = "姓名：{name}，年龄：{age}，姓名再次：{name}".format(
    name=name, age=age)
print(keyword_format)  # 姓名：Alice，年龄：25，姓名再次：Alice

# 混合位置和关键字参数
mixed_format = "{0}的年龄是{age}岁".format(name, age=age)
print(mixed_format)  # Alice的年龄是25岁

# 格式化选项
format_options = "姓名：{name:>8}，年龄：{age:<3}，身高：{height:6.1f}".format(
    name=name, age=age, height=height)
print(format_options)  # 姓名：    Alice，年龄：25 ，身高： 165.5

# %格式化（老式方法）
percent_format = "%s今年%d岁，身高%.1fcm" % (name, age, height)
print(percent_format)  # Alice今年25岁，身高165.5cm

# %格式化的变体
percent_variants = [
    "整数：%d" % 42,
    "浮点数：%.2f" % 3.14159,
    "字符串：%s" % "Hello",
    "八进制：%o" % 255,
    "十六进制：%x" % 255,
    "科学计数法：%e" % 12345.6
]
for variant in percent_variants:
    print(variant)

# 使用format_map()与字典
person_dict = {"name": "Bob", "age": 30, "city": "Beijing"}
format_map_result = "姓名：{name}，年龄：{age}，城市：{city}".format_map(person_dict)
print(format_map_result)  # 姓名：Bob，年龄：30，城市：Beijing

# 使用Template类（string模块）
from string import Template

template = Template("姓名：$name，年龄：$age")
template_result = template.substitute(name="Charlie", age=35)
print(template_result)  # 姓名：Charlie，年龄：35

# 使用safe_substitute避免KeyError
template_unsafe = Template("姓名：$name，年龄：$age，城市：$city")
safe_result = template_unsafe.safe_substitute(name="David", age=40)
print(safe_result)  # 姓名：David，年龄：40，城市：$city
```

### 正则表达式处理字符串

```python
import re

# 基本匹配
text = "Python 3.9, Java 8, C++ 14"

# 查找所有匹配项
versions = re.findall(r'\d+\.\d+', text)
print(f"找到所有版本：{versions}")  # ['3.9', '8', '14']

# 查找第一个匹配项
first_version = re.search(r'\d+\.\d+', text)
if first_version:
    print(f"第一个版本：{first_version.group()}")  # 3.9

# 分割字符串
languages = re.split(r'\s*,\s*', text)
print(f"分割结果：{languages}")  # ['Python 3.9', 'Java 8', 'C++ 14']

# 替换字符串
new_text = re.sub(r'(\w+)\s+(\d+\.\d+)', r'\1版本\2', text)
print(f"替换后：{new_text}")  # Python版本3.9, Java版本8, C++版本14

# 编译正则表达式（提高性能）
pattern = re.compile(r'\b[A-Z][a-z]+\b')  # 匹配首字母大写的单词
text2 = "Python is a programming Language created by Guido van Rossum."
capitalized_words = pattern.findall(text2)
print(f"首字母大写的单词：{capitalized_words}")  # ['Python', 'Language', 'Guido']

# 使用捕获组
email_pattern = re.compile(r'([a-zA-Z0-9._%+-]+)@([a-zA-Z0-9.-]+\.[a-zA-Z]{2,})')
email = "user@example.com"
match = email_pattern.match(email)
if match:
    print(f"用户名：{match.group(1)}，域名：{match.group(2)}")

# 使用命名捕获组
date_pattern = re.compile(r'(?P<year>\d{4})-(?P<month>\d{2})-(?P<day>\d{2})')
date = "2023-12-06"
date_match = date_pattern.match(date)
if date_match:
    print(f"年：{date_match.group('year')}")
    print(f"月：{date_match.group('month')}")
    print(f"日：{date_match.group('day')}")

# 查找所有匹配项并获取详细信息
text3 = "联系电话：123-456-7890，备用电话：987-654-3210"
phone_pattern = re.compile(r'(?P<area>\d{3})-(?P<prefix>\d{3})-(?P<line>\d{4})')
for match in phone_pattern.finditer(text3):
    print(f"区号：{match.group('area')}，前缀：{match.group('prefix')}" +
          f"，线路：{match.group('line')}")

# 使用标志
text4 = "Python python PYTHON"
# re.IGNORECASE：忽略大小写
case_insensitive = re.findall(r'python', text4, re.IGNORECASE)
print(f"忽略大小写匹配：{case_insensitive}")  # ['Python', 'python', 'PYTHON']

# re.MULTILINE：多行模式
multiline_text = """First line
Second line
Third line"""
line_start = re.findall(r'^\w+', multiline_text, re.MULTILINE)
print(f"每行开头的单词：{line_start}")  # ['First', 'Second', 'Third']

# re.DOTALL：使点号匹配换行符
text_with_newlines = "Hello\nWorld"
dot_matches_all = re.findall(r'Hello.*World', text_with_newlines, re.DOTALL)
print(f"跨越换行符匹配：{dot_matches_all}")  # ['Hello\nWorld']
```

### 字符串的性能优化

```python
import time
import sys

# 字符串拼接的性能比较
def string_concat_performance(n):
    # 方法1：使用+操作符
    start = time.time()
    result_plus = ""
    for i in range(n):
        result_plus += str(i)
    time_plus = time.time() - start
    
    # 方法2：使用join()
    start = time.time()
    result_join = "".join(str(i) for i in range(n))
    time_join = time.time() - start
    
    # 方法3：使用列表join()
    start = time.time()
    str_list = [str(i) for i in range(n)]
    result_list_join = "".join(str_list)
    time_list_join = time.time() - start
    
    print(f"方法1（+操作符）：{time_plus:.6f}秒，长度：{len(result_plus)}")
    print(f"方法2（join生成器）：{time_join:.6f}秒，长度：{len(result_join)}")
    print(f"方法3（列表join）：{time_list_join:.6f}秒，长度：{len(result_list_join)}")

# 运行性能测试
print("小规模测试（1000次）：")
string_concat_performance(1000)

print("\n大规模测试（10000次）：")
string_concat_performance(10000)

# 字符串interning（字符串驻留）
a = "hello"
b = "hello"
c = "".join(["h", "e", "l", "l", "o"])

print(f"a与b是否相同对象：{a is b}")  # True（短字符串会自动驻留）
print(f"a与c是否相同对象：{a is c}")  # False

# 手动intern
import sys
d = sys.intern("hello")
e = sys.intern("hello")
print(f"d与e是否相同对象：{d is e}")  # True

# 字符串的内存使用
str_short = "hello"
str_long = "a" * 1000
print(f"短字符串内存占用：{sys.getsizeof(str_short)}字节")
print(f"长字符串内存占用：{sys.getsizeof(str_long)}字节")

# 使用生成器处理大字符串，避免内存问题
def process_large_string_chunkwise(text, chunk_size=1000):
    for i in range(0, len(text), chunk_size):
        chunk = text[i:i+chunk_size]
        # 处理每个块
        yield chunk.upper()

large_text = "this is a very long string that we want to process in chunks " * 100
processed_chunks = list(process_large_string_chunkwise(large_text))
print(f"处理后块数：{len(processed_chunks)}")
print(f"第一个块：{processed_chunks[0][:50]}...")  # 只显示部分内容

# 使用字符串缓冲区提高性能
from io import StringIO

# 方法1：常规拼接
def regular_concat(words):
    result = ""
    for word in words:
        result += word + " "
    return result

# 方法2：使用StringIO
def stringio_concat(words):
    buffer = StringIO()
    for word in words:
        buffer.write(word + " ")
    return buffer.getvalue()

words = ["hello"] * 10000
start = time.time()
regular_result = regular_concat(words)
regular_time = time.time() - start

start = time.time()
stringio_result = stringio_concat(words)
stringio_time = time.time() - start

print(f"常规拼接耗时：{regular_time:.6f}秒")
print(f"StringIO拼接耗时：{stringio_time:.6f}秒")
```

