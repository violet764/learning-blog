# Python 基础：模块、文件操作与异常处理

本文档介绍Python中的模块与包管理、文件操作和异常处理机制，这些是Python编程中的核心概念，能够帮助你构建更加健壮和可维护的应用程序。

## 模块与包

模块和包是Python中组织代码的重要方式，它们允许我们将相关功能组织在一起，提高代码的可维护性和可重用性。

### 模块基础

Python中的模块是一个包含Python定义和语句的文件，它可以包含函数、类和变量。通过模块，我们可以将相关功能组织在一起，避免代码重复，并使项目结构更加清晰。

以下代码展示了Python中导入模块的各种方式，以及如何使用模块中的函数和变量：

```python
# 导入模块的不同方式

# 方式1：导入整个模块
# 使用 import 语句导入整个模块，然后通过 模块名.函数名 的方式访问
import math
print(f"π的值：{math.pi}")        # 使用 math 模块的 pi 常量
print(f"平方根：{math.sqrt(16)}")  # 使用 math 模块的 sqrt() 函数计算平方根

# 方式2：导入模块中的特定函数或变量
# 使用 from...import 语句直接导入需要的函数或变量，无需前缀
from math import pi, sqrt
print(f"π的值：{pi}")             # 直接使用 pi，无需前缀
print(f"平方根：{sqrt(16)}")       # 直接使用 sqrt()

# 方式3：导入模块中的所有内容（不推荐，可能导致命名冲突）
# 使用 from...import* 导入模块中的所有内容，容易造成命名空间污染
from math import *
print(f"正弦值：{sin(pi/2)}")      # 直接使用 sin() 函数

> **注意**: 尽量避免使用 `from module import *` 的导入方式，因为它会：
> 1. 污染当前命名空间，可能导致命名冲突
> 2. 降低代码可读性，难以追踪函数来源
> 3. 静态分析工具（如pylint、flake8）可能无法正确检测错误
> 4. 在模块更新时可能意外引入新的函数覆盖现有变量

# 方式4：给模块起别名
# 使用 as 关键字为模块设置别名，通常用于简化长模块名的输入
import numpy as np        # numpy 通常简写为 np
import pandas as pd       # pandas 通常简写为 pd
import matplotlib.pyplot as plt  # matplotlib.pyplot 通常简写为 plt

# 方式5：给导入的函数起别名
# 也可以为导入的函数或变量设置别名，避免命名冲突或简化调用
from math import sqrt as square_root
print(f"平方根：{square_root(9)}")

# 方式6：从子模块中导入
# 有些包包含多个子模块，可以从子模块中导入特定功能
from datetime import datetime, timedelta  # 从 datetime 子模块导入
from collections import defaultdict, Counter  # 从 collections 子模块导入
```

### 模块导入方式详解

这段代码演示了Python中六种常见的模块导入方式，每种方式都有其适用场景：
1. `import module` - 导入整个模块，通过`module.function()`调用
2. `from module import function` - 直接导入特定函数，可直接调用
3. `from module import *` - 导入模块所有内容（不推荐）
4. `import module as alias` - 为模块设置别名，简化调用
5. `from module import function as alias` - 为函数设置别名
6. `from submodule import function` - 从子模块导入特定功能

**各导入方式的特点：**

| 导入方式 | 语法 | 优点 | 缺点 |
|---------|------|------|------|
| 完整导入 | `import module` | 命名空间清晰，避免冲突 | 调用时需加前缀 |
| 部分导入 | `from module import func` | 简化调用，无需前缀 | 可能产生命名冲突 |
| 别名导入 | `import module as alias` | 简化长模块名调用 | 需要记住别名 |
| 函数别名 | `from module import func as alias` | 解决命名冲突 | 增加记忆负担 |

**查看模块信息**

以下是查看模块信息的示例：

```python
# 查看模块内容
# 使用 dir() 函数可以查看模块中包含的所有属性、函数和变量
import sys
print(f"sys模块包含的内容：{dir(sys)[:10]}...")  # 只显示前10个，避免输出过长

# 查看模块文档
# 每个模块通常都有 __doc__ 属性，包含模块的文档字符串
import math
print(f"math模块文档：{math.__doc__}")

# 查看模块文件位置
# __file__ 属性可以查看模块文件的实际存储位置
import os
print(f"os模块位置：{os.__file__}")

# 模块的内置属性
# 模块有许多有用的内置属性，可以帮助了解模块信息
print(f"math模块名：{math.__name__}")
print(f"math模块作者：{getattr(math, '__author__', '未知')}")  # 使用getattr安全访问属性
print(f"math模块版本：{getattr(math, '__version__', '未知')}")
```

**模块信息查看要点：**

- `dir(module)` - 列出模块的所有属性和方法
- `module.__doc__` - 获取模块的文档字符串
- `module.__file__` - 获取模块文件的物理路径
- `module.__name__` - 获取模块名称
- `getattr(module, attr, default)` - 安全获取模块属性，避免AttributeError

## 标准库模块详解

Python标准库提供了丰富的模块，这些模块无需安装即可直接使用。下面介绍几个最常用的标准库模块及其功能：

### math模块 - 数学运算

math模块提供了大量的数学函数和常数，适用于科学计算和工程应用。下面展示了math模块的常用功能：

```python
# math模块 - 数学运算
# math模块提供了大量的数学函数和常数，适用于科学计算和工程应用
import math

# 基本数学常数
print(f"π: {math.pi}")          # 圆周率π，约等于3.14159
print(f"e: {math.e}")            # 自然常数e，约等于2.71828
print(f"τ: {math.tau}")          # τ = 2π，约等于6.28318
print(f"无穷大: {math.inf}")     # 正无穷大
print(f"非数字: {math.nan}")     # NaN (Not a Number)，表示无效的数值运算结果

> **注意**: NaN是一个特殊值，表示"不是数字"的结果。需要注意：
> 1. NaN与任何值（包括它自己）比较都返回False：`math.nan != math.nan` 为True
> 2. 检查一个值是否为NaN应使用`math.isnan(x)`函数
> 3. NaN通常由无效数学运算产生，如0/0、sqrt(-1)等

# 基本数学函数
print(f"向上取整: {math.ceil(3.14)}")       # ceil(x) 返回不小于x的最小整数
print(f"向下取整: {math.floor(3.14)}")      # floor(x) 返回不大于x的最大整数
print(f"截断: {math.trunc(3.14)}")          # trunc(x) 返回x的整数部分
print(f"绝对值: {math.fabs(-3.14)}")         # fabs(x) 返回x的绝对值，返回浮点数
print(f"阶乘: {math.factorial(5)}")          # factorial(n) 返回n的阶乘
print(f"最大公约数: {math.gcd(24, 36)}")    # gcd(a,b) 返回a和b的最大公约数

# 幂和对数函数
print(f"2的3次方: {math.pow(2, 3)}")        # pow(x,y) 返回x的y次幂
print(f"平方根: {math.sqrt(16)}")            # sqrt(x) 返回x的平方根
print(f"自然对数: {math.log(10)}")           # log(x) 返回x的自然对数（以e为底）
print(f"以2为底的对数: {math.log2(10)}")     # log2(x) 返回以2为底x的对数
print(f"以10为底的对数: {math.log10(10)}")   # log10(x) 返回以10为底x的对数

# 三角函数
# 注意：三角函数的参数单位是弧度，不是角度
angle = math.pi / 4  # 45度转换为弧度

> **角度与弧度转换**:
> - 弧度 = 角度 × π/180
> - 角度 = 弧度 × 180/π
> - math.degrees(x) 将弧度转换为角度
> - math.radians(x) 将角度转换为弧度
print(f"正弦: {math.sin(angle)}")            # sin(x) 返回x的正弦值
print(f"余弦: {math.cos(angle)}")            # cos(x) 返回x的余弦值
print(f"正切: {math.tan(angle)}")            # tan(x) 返回x的正切值
print(f"反正弦: {math.asin(0.5)}")           # asin(x) 返回x的反正弦值
```

**math模块常用函数总结**

| 函数类别 | 函数名 | 功能说明 | 示例 |
|---------|--------|----------|------|
| 常数 | `math.pi` | 圆周率π | `math.pi ≈ 3.14159` |
| 常数 | `math.e` | 自然常数e | `math.e ≈ 2.71828` |
| 取整 | `math.ceil(x)` | 向上取整 | `math.ceil(3.14) = 4` |
| 取整 | `math.floor(x)` | 向下取整 | `math.floor(3.14) = 3` |
| 取整 | `math.trunc(x)` | 截断小数部分 | `math.trunc(3.14) = 3` |
| 幂运算 | `math.pow(x,y)` | x的y次幂 | `math.pow(2,3) = 8.0` |
| 幂运算 | `math.sqrt(x)` | 平方根 | `math.sqrt(16) = 4.0` |
| 对数 | `math.log(x)` | 自然对数 | `math.log(10) ≈ 2.302` |
| 对数 | `math.log2(x)` | 以2为底的对数 | `math.log2(8) = 3.0` |
| 对数 | `math.log10(x)` | 以10为底的对数 | `math.log10(100) = 2.0` |
| 三角函数 | `math.sin(x)` | 正弦函数 | `math.sin(0) = 0.0` |
| 三角函数 | `math.cos(x)` | 余弦函数 | `math.cos(0) = 1.0` |
| 三角函数 | `math.tan(x)` | 正切函数 | `math.tan(0) = 0.0` |
| 反三角函数 | `math.asin(x)` | 反正弦函数 | `math.asin(0) = 0.0` |
| 反三角函数 | `math.acos(x)` | 反余弦函数 | `math.acos(1) = 0.0` |
| 反三角函数 | `math.atan(x)` | 反正切函数 | `math.atan(0) = 0.0` |

### random模块 - 随机数生成

random模块提供了各种随机数生成函数，常用于模拟、游戏开发和数据抽样。以下代码展示了random模块的常用功能：

```python
# random模块 - 随机数生成
# random模块提供了各种随机数生成函数，常用于模拟、游戏开发和数据抽样
import random

# 基本随机数
print(f"随机浮点数[0,1): {random.random()}")         # random() 返回[0.0, 1.0)之间的随机浮点数
print(f"随机整数[1,10]: {random.randint(1, 10)}")   # randint(a,b) 返回[a,b]之间的随机整数（包含b）
print(f"随机整数[1,10): {random.randrange(1, 10)}")  # randrange(start,stop) 返回[start,stop)之间的随机整数

# 从序列中随机选择
items = ['apple', 'banana', 'cherry', 'date']
print(f"随机选择: {random.choice(items)}")                  # choice(seq) 从序列中随机选择一个元素
print(f"随机选择多个(不重复): {random.sample(items, 2)}")     # sample(seq,k) 从序列中随机选择k个不重复的元素
print(f"随机选择多个(可能重复): {random.choices(items, k=2)}") # choices(seq,k) 从序列中随机选择k个元素（可能重复）

# 打乱序列
# shuffle() 方法会直接修改原序列，将其中元素随机重排
numbers = list(range(1, 11))
print(f"原序列: {numbers}")
random.shuffle(numbers)      # 就地打乱列表顺序
print(f"打乱后: {numbers}")

> **注意**:
> 1. `shuffle()` 方法会直接修改原列表，不返回新列表
> 2. 如果不想修改原列表，可以先复制：`random.shuffle(numbers.copy())`
> 3. 对于不可变序列（如元组），不能使用shuffle()，可以先转换为列表

# 设置随机种子（保证可重复性）
# seed(n) 设置随机种子，使得每次运行程序时生成的随机数序列相同，便于调试和测试
random.seed(42)
print(f"种子42的随机数: {random.random()}")
random.seed(42)              # 重置相同的种子
print(f"重置种子的随机数: {random.random()}")  # 相同种子产生相同的随机数

> **随机种子应用场景**:
> 1. 调试程序时确保每次运行有相同的行为
> 2. 机器学习中划分训练集和测试集时确保可复现
> 3. 游戏中生成相同的地图或关卡
> 4. 密码学应用中应使用`secrets`模块而非random模块
> 5. 多线程环境下每个线程有自己的随机状态，需要分别设置种子
```

**random模块常用函数总结**

| 函数名 | 功能说明 | 参数说明 | 示例 |
|--------|----------|----------|------|
| `random()` | 返回[0.0, 1.0)之间的随机浮点数 | 无参数 | `random.random()` |
| `randint(a,b)` | 返回[a,b]之间的随机整数（包含b） | a:起始值, b:结束值 | `random.randint(1,10)` |
| `randrange(start,stop)` | 返回[start,stop)之间的随机整数 | start:起始值, stop:结束值 | `random.randrange(1,10)` |
| `choice(seq)` | 从序列中随机选择一个元素 | seq:序列对象 | `random.choice(['a','b','c'])` |
| `sample(seq,k)` | 从序列中随机选择k个不重复的元素 | seq:序列对象, k:选择数量 | `random.sample([1,2,3],2)` |
| `choices(seq,k)` | 从序列中随机选择k个元素（可能重复） | seq:序列对象, k:选择数量 | `random.choices([1,2,3],k=2)` |
| `shuffle(lst)` | 就地打乱列表顺序 | lst:列表对象 | `random.shuffle([1,2,3])` |
| `seed(n)` | 设置随机种子 | n:种子值 | `random.seed(42)` |

### datetime模块 - 日期和时间

datetime模块提供了处理日期和时间的类和函数，支持日期时间的创建、格式化、解析和计算。以下代码展示了datetime模块的基本用法：

```python
# datetime模块 - 日期和时间
# datetime模块提供了处理日期和时间的类和函数，支持日期时间的创建、格式化、解析和计算
from datetime import datetime, date, time, timedelta

# 获取当前日期和时间
# datetime.now() 返回当前本地日期和时间
now = datetime.now()
print(f"当前日期时间: {now}")
# strftime() 方法将datetime对象格式化为字符串
print(f"格式化日期时间: {now.strftime('%Y-%m-%d %H:%M:%S')}")

# 创建特定日期时间
# date(year,month,day) 创建日期对象
specific_date = date(2023, 12, 6)
# time(hour,minute,second) 创建时间对象
specific_time = time(14, 30, 45)
# datetime(year,month,day,hour,minute,second) 创建日期时间对象
specific_datetime = datetime(2023, 12, 6, 14, 30, 45)

print(f"特定日期: {specific_date}")
print(f"特定时间: {specific_time}")
print(f"特定日期时间: {specific_datetime}")

# 日期计算
# timedelta 表示两个日期或时间之间的差值
delta = timedelta(days=10, hours=5)  # 创建10天5小时的时间间隔
future_date = now + delta           # 当前时间加上时间间隔
print(f"10天5小时后: {future_date}")

# 日期差值
# 两个date对象相减得到timedelta对象
date1 = date(2023, 12, 6)
date2 = date(2024, 1, 1)
difference = date2 - date1
print(f"日期差: {difference.days}天")  # .days属性获取天数差
```

**datetime模块常用类和方法**

| 类名 | 功能说明 | 主要方法/属性 |
|------|----------|---------------|
| `datetime` | 日期时间对象 | `now()`, `strftime()`, `strptime()` |
| `date` | 日期对象 | `today()`, year, month, day |
| `time` | 时间对象 | hour, minute, second, microsecond |
| `timedelta` | 时间间隔对象 | days, seconds, microseconds |

**日期格式化符号说明**

| 符号 | 含义 | 示例 |
|------|------|------|
| `%Y` | 四位年份 | 2023 |
| `%m` | 月份（01-12） | 12 |
| `%d` | 日期（01-31） | 06 |
| `%H` | 小时（00-23） | 14 |
| `%M` | 分钟（00-59） | 30 |
| `%S` | 秒（00-59） | 45 |

**字符串日期解析**

以下代码展示如何将字符串解析为日期对象：

```python
# 字符串解析日期
# strptime(string,format) 将格式化的字符串解析为datetime对象
date_str = "2023-12-06 14:30:45"
parsed_date = datetime.strptime(date_str, "%Y-%m-%d %H:%M:%S")
print(f"解析的日期: {parsed_date}")
```

### os模块 - 操作系统接口

os模块提供了与操作系统交互的功能，包括文件系统操作、环境变量管理等：

```python
# os模块 - 操作系统接口
# os模块提供了与操作系统交互的功能，包括文件系统操作、环境变量管理等
import os

# 获取当前工作目录
# getcwd() 返回当前进程的工作目录
print(f"当前目录: {os.getcwd()}")

# 创建目录
# makedirs(path) 创建目录，exist_ok=True表示目录已存在时不报错
if not os.path.exists("test_dir"):
    os.makedirs("test_dir")
    print("目录创建成功")

# 列出目录内容
# listdir(path) 返回指定目录下的所有文件和目录名列表
print("当前目录内容:")
for item in os.listdir("."):
    item_type = "目录" if os.path.isdir(item) else "文件"  # isdir() 判断是否为目录
    print(f"  {item} ({item_type})")

# 路径操作
# dirname(path) 返回路径的目录部分；basename(path) 返回路径的文件名部分
file_path = "test_dir/example.txt"
dir_name = os.path.dirname(file_path)
base_name = os.path.basename(file_path)
print(f"目录名: {dir_name}")
print(f"文件名: {base_name}")

# 环境变量
# environ.get() 获取环境变量，第二个参数为默认值；os.environ[key] = value 设置环境变量
print(f"PATH环境变量: {os.environ.get('PATH', '未设置')}")
os.environ["MY_VAR"] = "我的变量"
print(f"自定义变量: {os.environ['MY_VAR']}")
```

**os模块常用函数总结**
| 函数名 | 功能说明 | 参数说明 | 示例 |
|--------|----------|----------|------|
| `getcwd()` | 获取当前工作目录 | 无参数 | `os.getcwd()` |
| `makedirs(path)` | 创建目录（可递归） | path:路径 | `os.makedirs("a/b/c")` |
| `listdir(path)` | 列出目录内容 | path:目录路径 | `os.listdir(".")` |
| `path.exists(path)` | 检查路径是否存在 | path:路径 | `os.path.exists("file.txt")` |
| `path.isfile(path)` | 检查是否为文件 | path:路径 | `os.path.isfile("file.txt")` |
| `path.isdir(path)` | 检查是否为目录 | path:路径 | `os.path.isdir("folder")` |
| `path.dirname(path)` | 获取路径的目录部分 | path:路径 | `os.path.dirname("/a/b/c.txt")` |
| `path.basename(path)` | 获取路径的文件名部分 | path:路径 | `os.path.basename("/a/b/c.txt")` |
| `environ.get(key)` | 获取环境变量 | key:变量名 | `os.environ.get("PATH")` |

### sys模块 - 系统相关参数和函数

sys模块提供了一系列与Python解释器及其环境相关的函数和变量。以下代码展示了sys模块的常用功能：

```python
# sys模块 - 系统相关参数和函数
# sys模块提供了一系列与Python解释器及其环境相关的函数和变量
import sys

# Python版本信息
# sys.version 返回Python版本字符串；sys.version_info 返回版本信息的元组
print(f"Python版本: {sys.version}")
print(f"版本信息: {sys.version_info}")

# 系统平台
# sys.platform 返回操作系统平台标识符
print(f"系统平台: {sys.platform}")

# 命令行参数
# sys.argv 是一个列表，包含命令行传递给脚本的参数，第一个元素是脚本名
print(f"脚本名称: {sys.argv[0]}")
print(f"命令行参数: {sys.argv[1:]}")

# Python路径
# sys.path 是一个列表，包含Python解释器搜索模块的目录路径
print(f"模块搜索路径: {sys.path[:3]}...")  # 显示前3个路径

# 递归深度限制
# getrecursionlimit() 返回递归深度限制；setrecursionlimit(limit) 设置新的递归深度限制
print(f"递归深度限制: {sys.getrecursionlimit()}")
sys.setrecursionlimit(2000)
print(f"新的递归深度限制: {sys.getrecursionlimit()}")
```

**sys模块重要属性和函数**
| 属性/函数名 | 功能说明 | 类型 |
|-------------|----------|------|
| `sys.version` | Python版本字符串 | str |
| `sys.version_info` | 版本信息元组 | tuple |
| `sys.platform` | 系统平台标识符 | str |
| `sys.argv` | 命令行参数列表 | list |
| `sys.path` | 模块搜索路径列表 | list |
| `sys.getrecursionlimit()` | 获取递归深度限制 | function |
| `sys.setrecursionlimit(limit)` | 设置递归深度限制 | function |

### collections模块 - 特殊容器数据类型

collections模块提供了Python标准内建容器dict、list、set和tuple的替代选择。以下代码展示了collections模块的主要功能：

```python
# collections模块 - 特殊容器数据类型
# collections模块提供了Python标准内建容器dict、list、set和tuple的替代选择
from collections import namedtuple, Counter, defaultdict, deque, OrderedDict

# namedtuple - 命名元组
# namedtuple创建一个继承自tuple的子类，可以通过属性名访问元素
Point = namedtuple('Point', ['x', 'y'])  # 创建Point类，有两个字段x和y
p1 = Point(1, 2)
print(f"点坐标: {p1}")
print(f"x坐标: {p1.x}, y坐标: {p1.y}")  # 通过属性名访问元素

# Counter - 计数器
# Counter是一个字典子类，用于可哈希对象的计数
words = ['apple', 'banana', 'apple', 'cherry', 'banana', 'apple']
word_counts = Counter(words)  # 统计每个单词出现的次数
print(f"词频统计: {word_counts}")
print(f"最常见的词: {word_counts.most_common(2)}")  # most_common(n)返回出现次数最多的n个元素

# defaultdict - 带默认值的字典
# defaultdict创建字典时指定默认值类型，访问不存在的键时自动创建默认值
d = defaultdict(list)  # 指定默认值为空列表
d['a'].append(1)       # d['a']自动创建为[]，然后append(1)
d['a'].append(2)
d['b'].append(3)
print(f"defaultdict: {dict(d)}")  # 转换为普通字典便于查看
```

**collections模块常用类总结**

| 类名 | 功能说明 | 特点 |
|------|----------|------|
| `namedtuple` | 命名元组 | 通过属性名访问元素，节省内存 |
| `Counter` | 计数器 | 统计元素出现次数，支持most_common() |
| `defaultdict` | 默认字典 | 访问不存在的键时自动创建默认值 |
| `deque` | 双端队列 | 支持两端高效添加和删除元素 |
| `OrderedDict` | 有序字典 | 保持键的插入顺序 |

**deque双端队列与OrderedDict有序字典**

```python
# deque - 双端队列
# deque是双向队列，支持从两端高效地添加和删除元素
dq = deque([1, 2, 3])
dq.append(4)     # append() 在右端添加元素
dq.appendleft(0) # appendleft() 在左端添加元素
dq.pop()         # pop() 从右端删除元素
dq.popleft()     # popleft() 从左端删除元素
print(f"deque: {dq}")

# OrderedDict - 有序字典（Python 3.7+dict默认有序）
# OrderedDict是一个字典子类，保持键的插入顺序（Python 3.7+中普通dict也是有序的）
od = OrderedDict()
od['first'] = 1
od['second'] = 2
od['third'] = 3
print(f"OrderedDict: {od}")
```

### itertools模块 - 迭代器工具

itertools模块包含了一系列用于高效迭代的函数，提供了许多创建和使用迭代器的工具：

```python
# itertools模块 - 迭代器工具
# itertools模块包含了一系列用于高效迭代的函数，提供了许多创建和使用迭代器的工具
import itertools

# count() - 无限计数器
# count(start,step) 创建一个从start开始，每次增加step的无限迭代器
for i in itertools.count(5):
    if i > 10:
        break
    print(i)

# cycle() - 无限循环
# cycle(iterable) 创建一个无限循环遍历iterable元素的迭代器
colors = ['red', 'green', 'blue']
for i, color in zip(range(6), itertools.cycle(colors)):
    print(f"{i}: {color}")

# product() - 笛卡尔积
# product(*iterables) 计算输入序列的笛卡尔积，相当于嵌套循环
colors = ['red', 'blue']
sizes = ['S', 'M', 'L']
combinations = list(itertools.product(colors, sizes))
print(f"组合: {combinations}")

# permutations() - 排列
# permutations(iterable,r) 返回长度为r的所有排列，r默认为len(iterable)
items = ['a', 'b', 'c']
perms = list(itertools.permutations(items, 2))
print(f"排列: {perms}")

# chain() - 连接迭代器
# chain(*iterables) 创建一个迭代器，将多个迭代器连接起来
chained = itertools.chain([1, 2], [3, 4], [5, 6])
print(f"连接: {list(chained)}")


# accumulate() - 累计
# accumulate(iterable,func) 创建一个迭代器，返回iterable的累计结果，func默认为加法
numbers = [1, 2, 3, 4, 5]
accumulated = list(itertools.accumulate(numbers))
print(f"累计: {accumulated}")

```

**itertools模块常用函数总结**

| 函数名 | 功能说明 | 参数说明 | 示例 |
|--------|----------|----------|------|
| `count(start,step)` | 无限计数器 | start:起始值, step:步长 | `itertools.count(0,2)` |
| `cycle(iterable)` | 无限循环 | iterable:可迭代对象 | `itertools.cycle([1,2,3])` |
| `product(*iterables)` | 笛卡尔积 | iterables:多个可迭代对象 | `itertools.product('AB','CD')` |
| `permutations(iterable,r)` | 排列 | iterable:可迭代对象, r:排列长度 | `itertools.permutations('ABC',2)` |
| `combinations(iterable,r)` | 组合 | iterable:可迭代对象, r:组合长度 | `itertools.combinations('ABC',2)` |
| `groupby(iterable,key)` | 分组 | iterable:可迭代对象, key:分组函数 | `itertools.groupby(data,key)` |
| `chain(*iterables)` | 连接迭代器 | iterables:多个可迭代对象 | `itertools.chain([1,2,3],[4,5,6])` |
| `accumulate(iterable,func)` | 累积 | iterable:可迭代对象, func:累积函数 | `itertools.accumulate([1,2,3,4,5])` |
**itertools组合与分组**

```python
# itertools模块 - 迭代器工具
import itertools

# combinations() - 组合
# combinations(iterable,r) 返回长度为r的所有组合，元素顺序不重要且不重复
items = ['a', 'b', 'c']
combs = list(itertools.combinations(items, 2))
print(f"组合: {combs}")

# groupby() - 分组
# groupby(iterable,key) 对iterable中连续相同元素进行分组，key函数指定分组依据
data = [('A', 1), ('B', 2), ('A', 3), ('B', 4), ('A', 5)]
for key, group in itertools.groupby(data, lambda x: x[0]):
    print(f"组 {key}: {list(group)}")
```

## 模块结构  

### 创建自定义模块

创建自定义模块是将代码组织和重用的有效方式。下面展示如何创建和使用自定义模块：

```python
# 创建一个简单的自定义模块 my_module.py

# my_module.py 内容示例：
"""
这是我的自定义模块
提供了一些实用的函数和变量
"""

# 模块级变量
# 这些变量定义在模块级别，可以通过 模块名.变量名 的方式访问
VERSION = "1.0.0"      # 模块版本号
AUTHOR = "Python开发者"  # 模块作者

def greet(name):
    """问候函数
    Args:
        name (str): 要问候的名字
    Returns:
        str: 包含问候语的字符串
    """
    return f"你好, {name}!"

def calculate_area(shape, *args):
    """计算面积
    Args:
        shape (str): 形状类型（如'rectangle'、'circle'）
        *args: 形状的参数（如矩形的长和宽，圆的半径）
    Returns:
        float: 形状的面积
    Raises:
        ValueError: 当形状类型不支持或参数不正确时
    """
    if shape == "rectangle":
        if len(args) != 2:
            raise ValueError("矩形需要长和宽两个参数")
        return args[0] * args[1]
    elif shape == "circle":
        if len(args) != 1:
            raise ValueError("圆形需要半径一个参数")
        import math
        return math.pi * args[0] ** 2
    else:
        raise ValueError(f"不支持的形状: {shape}")
```

**模块中的类定义**

```python
class Calculator:
    """简单计算器类"""

    def __init__(self):
        """初始化计算器，创建历史记录列表"""
        self.history = []

    def add(self, a, b):
        """加法运算，记录结果到历史"""
        result = a + b
        self.history.append(f"{a} + {b} = {result}")
        return result

    def subtract(self, a, b):
        """减法运算，记录结果到历史"""
        result = a - b
        self.history.append(f"{a} - {b} = {result}")
        return result

    def get_history(self):
        """获取计算历史的副本，防止外部修改"""
        return self.history.copy()

# 模块初始化代码
# 这部分代码在模块被导入时会执行，通常用于初始化操作
print(f"my_module {VERSION} 已加载")

> **模块设计注意事项**:
> 1. 模块级初始化代码应尽量简单，避免耗时操作
> 2. 如果需要复杂初始化，考虑使用惰性加载（在首次使用时才初始化）
> 3. 使用 `if __name__ == "__main__":` 代码块来标识可直接执行的测试代码
> 4. 模块级变量名应使用大写字母表示常量，小写字母表示变量
```

**使用自定义模块：**

```python
# 使用自定义模块的示例代码：

# 假设上述内容保存在 my_module.py 中

# 使用自定义模块
import my_module  # 导入整个模块

# 使用模块变量
print(f"模块版本: {my_module.VERSION}")  # 访问模块变量
print(f"模块作者: {my_module.AUTHOR}")

# 使用模块函数
greeting = my_module.greet("世界")
print(f"问候: {greeting}")

# 计算面积
rect_area = my_module.calculate_area("rectangle", 5, 3)  # 计算矩形面积
print(f"矩形面积: {rect_area}")

circle_area = my_module.calculate_area("circle", 2)  # 计算圆面积
print(f"圆形面积: {circle_area:.2f}")  # 保留两位小数

# 使用模块中的类
calc = my_module.Calculator()  # 创建Calculator实例
result1 = calc.add(10, 5)     # 使用加法
result2 = calc.subtract(10, 5)  # 使用减法
print(f"计算历史: {calc.get_history()}")

> **模块使用最佳实践**:
> 1. 使用绝对导入（从包根目录开始的完整路径）而非相对导入
> 2. 避免循环导入（A模块导入B，B模块又导入A）
> 3. 将大型模块拆分为多个小模块，使用包来组织
> 4. 使用 `__all__` 列表明确模块的公共接口
> 5. 文档字符串应遵循PEP 257规范，方便工具生成文档
```

### 包的结构与使用

包是包含多个模块的目录，提供了更高级别的代码组织方式。包通过包含`__init__.py`文件来标识。

**包结构示例**

```python
# 包是一个包含多个模块的目录
# 典型的包结构示例：

"""
my_package/
├── __init__.py          # 包初始化文件，标识这是一个Python包
├── module1.py           # 包的模块1
├── module2.py           # 包的模块2
├── subpackage/          # 子包
│   ├── __init__.py      # 子包初始化文件
│   ├── submodule1.py    # 子包的模块1
│   └── submodule2.py    # 子包的模块2
└── data/                # 数据目录（非Python包）
    └── config.json      # 配置文件
"""
```

**__init__.py文件示例**

```python
# my_package/__init__.py
"""
我的包初始化文件
定义包的公共接口
"""

# 导入包内的模块，使其在包级别可用
from .module1 import func1  # 从当前包的module1模块导入func1
from .module2 import Class2  # 从当前包的module2模块导入Class2

# 定义包级别变量
PACKAGE_NAME = "my_package"
PACKAGE_VERSION = "1.0.0"

def package_info():
    """返回包信息"""
    return f"{PACKAGE_NAME} v{PACKAGE_VERSION}"

> **__init__.py 文件作用**:
> 1. 标识目录为Python包，使其可以被导入
> 2. 执行包级别的初始化代码
> 3. 控制包的公共接口（通过导入和__all__列表）
> 4. Python 3.3+中，命名空间包可以没有__init__.py文件
```

**模块定义示例**

```python
# my_package/module1.py
def func1():
    """模块1的函数1"""
    return "来自模块1的函数1"

def func2():
    """模块1的函数2"""
    return "来自模块1的函数2"

# my_package/module2.py
class Class2:
    """模块2的类"""
    def __init__(self):
        self.value = "来自模块2的类"

    def method(self):
        return f"方法调用: {self.value}"
```

**包的使用示例**

```python
# 使用包的示例

# 导入整个包
import my_package  # 导入整个包
print(f"包信息: {my_package.package_info()}")  # 使用包中__init__.py定义的函数

# 导入包中的特定函数
from my_package import func1  # 从包中导入func1函数
print(f"函数调用: {func1()}")

# 导入包中的特定类
from my_package import Class2  # 从包中导入Class2类
obj = Class2()  # 创建类实例
print(f"类方法调用: {obj.method()}")

# 导入子包中的模块
from my_package.subpackage import submodule1  # 导入子包中的模块
# submodule1.some_function()  # 使用子包模块中的函数

# 使用点号导入
from my_package.module1 import func1 as m1_func1  # 导入函数并设置别名
print(f"别名函数调用: {m1_func1()}")

> **包导入技巧**:
> 1. `import package` 只导入__init__.py中定义的内容，不会导入子模块
> 2. `from package import module` 导入指定模块，但不包括子模块
> 3. `from package.module import function` 直接导入模块中的特定函数
> 4. `from package import *` 只导入__init__.py中__all__列表指定的内容
> 5. 相对导入使用点号前缀（.表示当前包，..表示父包）
```

### 包的安装与分发

Python包可以通过pip工具安装，也可以使用setuptools创建和分发自己的包。

**使用pip管理包**

> 以下内容是命令行操作，不是Python代码

```bash
# 基本安装命令
pip install package_name      # 安装指定的包

# 安装特定版本
pip install package_name==1.0.0  # 安装指定版本的包

# 安装最新版本
pip install --upgrade package_name  # 升级包到最新版本

# 从requirements文件安装
pip install -r requirements.txt  # 从requirements.txt文件安装所有依赖

# 卸载包
pip uninstall package_name       # 卸载指定的包

# 列出已安装的包
pip list                         # 列出所有已安装的包

# 查看包信息
pip show package_name            # 显示指定包的详细信息

# 创建requirements.txt文件
pip freeze > requirements.txt    # 将当前环境的所有包及版本输出到requirements.txt

# 使用虚拟环境
python -m venv myenv             # 创建名为myenv的虚拟环境
myenv\Scripts\activate (Windows) # 在Windows上激活虚拟环境
source myenv/bin/activate (Unix/Linux)  # 在Unix/Linux上激活虚拟环境
```

**使用setuptools创建分发包**

### 使用setuptools创建分发包

setuptools是Python生态系统中最常用的包构建和分发工具。它允许开发者创建可安装的Python包，方便他人使用。

```python
# setup.py 文件示例
"""
from setuptools import setup, find_packages

setup(
    name="my_package",                    # 包名：在PyPI上唯一标识你的包
    version="1.0.0",                      # 版本号：遵循语义化版本控制规范
    description="我的Python包",          # 简短描述：在PyPI上显示的包简介
    author="Your Name",                   # 作者姓名：包的创建者信息
    author_email="your.email@example.com",  # 作者邮箱：联系方式
    packages=find_packages(),             # 自动找到所有包：自动发现项目中的Python包
    install_requires=[                    # 依赖的其他包：指定运行此包所需的第三方依赖
        "numpy>=1.18.0",                 # numpy至少需要1.18.0版本
        "pandas>=1.0.0",                 # pandas至少需要1.0.0版本
    ],
    classifiers=[                         # 分类信息：帮助用户在PyPI上找到你的包
        "Development Status :: 3 - Alpha", # 开发状态：Alpha版本
        "Intended Audience :: Developers", # 目标受众：开发者
        "License :: OSI Approved :: MIT License", # 许可证：MIT许可证
        "Programming Language :: Python :: 3", # 编程语言：Python 3
        "Programming Language :: Python :: 3.8", # 支持Python 3.8
        "Programming Language :: Python :: 3.9", # 支持Python 3.9
        "Programming Language :: Python :: 3.10", # 支持Python 3.10
    ],
    python_requires=">=3.8",            # 最低Python版本要求：至少需要Python 3.8
)
"""

# 构建分发包
# python setup.py sdist bdist_wheel     # 创建源码包和轮子包
# sdist：源码分发包，包含项目的源代码
# bdist_wheel：wheel分发包，预编译的二进制包，安装更快

# 本地安装
# pip install .                         # 安装当前目录的包（开发模式）
# pip install -e .                      # 以可编辑模式安装，修改代码后无需重新安装

# 上传到PyPI
# pip install twine                     # 安装twine工具（专门用于上传包到PyPI）
# twine upload dist/*                   # 上传dist目录下的所有包到PyPI
```

> **包分发注意事项**:
> 1. 遵循语义化版本控制 (Semantic Versioning)：主版本.次版本.修订号
>    - 主版本号：当你做了不兼容的API修改时增加
>    - 次版本号：当你做了向下兼容的功能性新增时增加
>    - 修订号：当你做了向下兼容的问题修正时增加
> 2. 提供清晰的文档和README文件，说明安装和使用方法
> 3. 添加许可证文件（如MIT、Apache 2.0等）
> 4. 编写测试用例，确保包的可靠性
> 5. 考虑使用pyproject.toml替代setup.py（现代Python打包方式）
> 6. 发布前检查是否有安全漏洞：`pip-audit` 或 `safety`

## 高级模块技术

Python提供了一些高级的模块操作技术，可以实现动态导入、模块重载等高级功能。这些技术在插件系统、延迟加载和运行时代码生成等场景中非常有用。

### 动态导入与模块重载

动态导入允许我们在程序运行时根据条件导入模块，而模块重载则可以在不重启程序的情况下重新加载已修改的模块。

```python
# 动态导入模块
import importlib

# 动态导入模块
# importlib.import_module(name) 根据字符串形式的模块名导入模块
module_name = "math"
math_module = importlib.import_module(module_name)  # 动态导入math模块
print(f"动态导入的math模块: {math_module.sqrt(16)}")

# 动态导入函数
from importlib import import_module

def dynamic_import_function(module_name, function_name):
    """动态导入函数
    Args:
        module_name (str): 模块名
        function_name (str): 函数名
    Returns:
        function: 导入的函数对象，失败时返回None
    """
    try:
        module = import_module(module_name)     # 导入模块
        func = getattr(module, function_name)   # 获取模块中的函数
        return func
    except (ImportError, AttributeError) as e:
        print(f"导入失败: {e}")
        return None

# 动态调用函数
sqrt_func = dynamic_import_function("math", "sqrt")  # 动态导入math模块的sqrt函数
if sqrt_func:
    print(f"动态调用: {sqrt_func(25)}")

# 模块重载
import importlib
import my_module  # 假设已经导入

# 重新加载模块（修改模块后有用）
# importlib.reload(module) 重新加载已经导入的模块，使其内容更新
importlib.reload(my_module)

# 检查模块是否已加载
import sys
print(f"math模块在sys.modules中: {'math' in sys.modules}")
```

### 插件系统实现

插件系统是一种常见的软件架构模式，允许在不修改主程序的情况下扩展功能。以下是一个简单的插件管理系统实现：

```python
# 插件系统示例

# plugin_manager.py
class PluginManager:
    """插件管理器"""

    def __init__(self):
        """初始化插件管理器"""
        self.plugins = {}

    def load_plugin(self, plugin_name, plugin_path):
        """加载插件
        Args:
            plugin_name (str): 插件名称
            plugin_path (str): 插件文件路径
        Returns:
            bool: 加载成功返回True，失败返回False
        """
        try:
            # 从文件路径创建模块规范
            spec = importlib.util.spec_from_file_location(plugin_name, plugin_path)
            # 从规范创建模块
            module = importlib.util.module_from_spec(spec)
            # 将模块添加到sys.modules中
            sys.modules[plugin_name] = module
            # 执行模块代码
            spec.loader.exec_module(module)

            # 检查插件是否有必需的接口
            if hasattr(module, 'register') and hasattr(module, 'unregister'):
                self.plugins[plugin_name] = module
                module.register()
                print(f"插件 {plugin_name} 加载成功")
                return True
            else:
                print(f"插件 {plugin_name} 缺少必需的接口")
                return False
        except Exception as e:
            print(f"加载插件 {plugin_name} 失败: {e}")
            return False

    def unload_plugin(self, plugin_name):
        """卸载插件
        Args:
            plugin_name (str): 插件名称
        Returns:
            bool: 卸载成功返回True，失败返回False
        """
        if plugin_name in self.plugins:
            try:
                self.plugins[plugin_name].unregister()
                del self.plugins[plugin_name]
                print(f"插件 {plugin_name} 卸载成功")
                return True
            except Exception as e:
                print(f"卸载插件 {plugin_name} 失败: {e}")
                return False
        else:
            print(f"插件 {plugin_name} 未加载")
            return False

    def list_plugins(self):
        """列出所有插件
        Returns:
            list: 已加载的插件名列表
        """
        return list(self.plugins.keys())

# 创建一个简单的插件示例

# sample_plugin.py
def register():
    """注册插件"""
    print("示例插件已注册")

def unregister():
    """注销插件"""
    print("示例插件已注销")

def process_data(data):
    """处理数据
    Args:
        data (str): 要处理的数据
    Returns:
        str: 处理后的数据（转为大写）
    """
    return data.upper()

# 使用插件管理器
# manager = PluginManager()
# manager.load_plugin("sample_plugin", "sample_plugin.py")
# plugins = manager.list_plugins()
# print(f"已加载的插件: {plugins}")
```

### 模块缓存与性能优化

在某些场景下，模块导入可能会成为性能瓶颈。通过缓存和延迟加载技术，我们可以优化模块导入的性能。

```python
# 模块缓存与性能优化
import time
import functools

# 缓存模块导入结果
# 使用lru_cache装饰器缓存模块导入结果，避免重复导入
@functools.lru_cache(maxsize=32)
def cached_import(module_name):
    """缓存模块导入
    Args:
        module_name (str): 模块名
    Returns:
        module: 导入的模块
    """
    start = time.time()
    module = importlib.import_module(module_name)
    end = time.time()
    print(f"导入模块 {module_name} 耗时: {end - start:.6f}秒")
    return module

# 测试缓存效果
cached_import("math")
cached_import("math")  # 第二次会使用缓存，更快

# 条件导入
def try_import(module_name, fallback=None):
    """尝试导入模块，失败时返回回退值
    Args:
        module_name (str): 要导入的模块名
        fallback: 导入失败时的回退值
    Returns:
        module or fallback: 导入的模块或回退值
    """
    try:
        return importlib.import_module(module_name)
    except ImportError:
        print(f"模块 {module_name} 不可用，使用回退方案")
        return fallback

# 使用回退导入
optional_module = try_import("optional_dependency")
if optional_module is None:
    # 使用内置功能作为回退
    pass

# 延迟导入
class LazyImporter:
    """延迟导入器，只有在真正使用时才导入模块，减少启动时间"""

    def __init__(self, module_name):
        """初始化延迟导入器
        Args:
            module_name (str): 要延迟导入的模块名
        """
        self.module_name = module_name
        self._module = None  # 缓存已导入的模块

    def __getattr__(self, name):
        """动态获取模块属性，触发模块导入（如果尚未导入）
        Args:
            name (str): 属性名
        Returns:
            object: 模块属性
        """
        if self._module is None:
            self._module = importlib.import_module(self.module_name)
        return getattr(self._module, name)

# 使用延迟导入
heavy_module = LazyImporter("heavy_dependency")
# 只有在真正使用时才会导入模块
# some_func = heavy_module.some_function
```

### 运行时动态创建模块

Python允许我们在程序运行时动态创建模块，这对于某些特殊场景非常有用。

```python
# 运行时生成模块
import types

def create_module(name, functions):
    """动态创建模块
    Args:
        name (str): 模块名
        functions (dict): 函数名到函数对象的映射
    Returns:
        module: 动态创建的模块
    """
    # 创建新的模块对象
    module = types.ModuleType(name)

    # 将所有函数添加到模块中
    for func_name, func in functions.items():
        setattr(module, func_name, func)

    return module

# 创建自定义模块
custom_functions = {
    "add": lambda a, b: a + b,
    "multiply": lambda a, b: a * b,
    "greet": lambda name: f"Hello, {name}!"
}

my_dynamic_module = create_module("dynamic_module", custom_functions)
print(f"动态模块加法: {my_dynamic_module.add(5, 3)}")
print(f"动态模块乘法: {my_dynamic_module.multiply(5, 3)}")
```

## 文件操作

Python提供了强大的文件操作功能，可以处理各种类型的文件和不同的文件操作模式。

### 基本文件操作

Python提供了丰富的文件操作API，支持不同的打开模式和操作方式。掌握文件操作是处理数据和持久化信息的基础。

```python
# 文件的打开模式
# 'r' - 读取（默认）
# 'w' - 写入（覆盖已有内容）
# 'a' - 追加（在文件末尾添加内容）
# 'r+' - 读写（可以读取和写入）
# 'b' - 二进制模式（用于处理非文本文件）
# 't' - 文本模式（默认）

# 基本写入操作
# 使用with语句自动管理文件资源，确保文件操作完成后自动关闭
with open("example.txt", "w", encoding="utf-8") as file:
    file.write("第一行内容\n")  # 写入字符串并添加换行符
    file.write("第二行内容\n")
    file.write("第三行内容\n")
```

### 文件操作模式

Python文件操作支持多种打开模式，通过组合不同的字符可以实现不同的操作效果：

| 模式 | 说明 | 特点 |
|------|------|------|
| `r` | 只读模式（默认） | 文件必须存在，否则抛出FileNotFoundError |
| `w` | 只写模式 | 文件不存在则创建，存在则清空内容 |
| `a` | 追加模式 | 文件不存在则创建，写入内容追加到末尾 |
| `r+` | 读写模式 | 文件必须存在，可读可写 |
| `w+` | 读写模式 | 文件不存在则创建，存在则清空内容 |
| `a+` | 读写追加模式 | 文件不存在则创建，写入内容追加到末尾 |
| `rb` | 二进制只读模式 | 用于读取二进制文件，如图片、音频等 |
| `wb` | 二进制只写模式 | 用于写入二进制文件 |
| `ab` | 二进制追加模式 | 用于追加二进制数据 |
| `rt` | 文本只读模式 | 默认文本模式，处理文本文件 |
| `wt` | 文本只写模式 | 默认文本模式，写入文本文件 |
| `at` | 文本追加模式 | 默认文本模式，追加文本内容 |

**文件操作最佳实践**

1. **始终使用with语句**：确保文件正确关闭，即使出现异常也能自动清理资源
2. **明确指定编码**：使用`encoding`参数避免编码问题，推荐使用UTF-8
3. **选择合适的读取方法**：
   - 小文件：使用`read()`一次性读取
   - 大文件：使用`readline()`或迭代器逐行读取
   - 结构化数据：使用`readlines()`读取所有行
4. **异常处理**：妥善处理FileNotFoundError、PermissionError等常见异常

**实际应用示例**

```python
# 日志文件写入示例
def write_log(message, log_file="app.log"):
    """写入日志信息到文件"""
    import datetime
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    log_entry = f"[{timestamp}] {message}\n"

    # 使用追加模式写入日志
    with open(log_file, "a", encoding="utf-8") as file:
        file.write(log_entry)

# 配置文件读取示例
def read_config(config_file="config.ini"):
    """读取简单的键值对配置文件"""
    config = {}
    try:
        with open(config_file, "r", encoding="utf-8") as file:
            for line in file:
                line = line.strip()
                # 跳过空行和注释行
                if line and not line.startswith("#"):
                    if "=" in line:
                        key, value = line.split("=", 1)
                        config[key.strip()] = value.strip()
    except FileNotFoundError:
        print(f"配置文件 {config_file} 不存在，使用默认配置")
    return config

# CSV文件处理示例
def read_csv_simple(csv_file):
    """简单CSV文件读取"""
    data = []
    try:
        with open(csv_file, "r", encoding="utf-8") as file:
            headers = file.readline().strip().split(",")
            for line in file:
                values = line.strip().split(",")
                # 创建字典映射
                row = dict(zip(headers, values))
                data.append(row)
    except FileNotFoundError:
        print(f"CSV文件 {csv_file} 不存在")
    return data

# 示例调用
write_log("应用程序启动")
config = read_config()
print(f"配置信息: {config}")

# 创建示例CSV文件
with open("sample.csv", "w", encoding="utf-8") as f:
    f.write("name,age,city\n")
    f.write("张三,25,北京\n")
    f.write("李四,30,上海\n")

csv_data = read_csv_simple("sample.csv")
print(f"CSV数据: {csv_data}")
```

**注意事项**

> **重要提醒**：
> 1. 文件路径应使用正斜杠`/`或原始字符串`r"path"`，避免转义字符问题
> 2. 处理大文件时避免一次性读取全部内容，应分块处理或逐行读取
> 3. 二进制文件操作时不要指定encoding参数
> 4. 在网络文件系统上操作时要考虑延迟和权限问题
> 5. 敏感数据（如密码）不应明文存储在文件中

```python
# 基本读取操作
with open("example.txt", "r", encoding="utf-8") as file:
    # 读取全部内容
    content = file.read()  # 读取整个文件内容到字符串
    print("全部内容：")
    print(content)
```

```python
# 逐行读取
# 迭代文件对象可以逐行读取，适合处理大文件
with open("example.txt", "r", encoding="utf-8") as file:
    print("逐行读取：")
    for line in file:
        print(f"行内容：{line.strip()}")  # strip()去除行首尾空白字符，包括换行符
```

```python
# 读取所有行到列表
with open("example.txt", "r", encoding="utf-8") as file:
    lines = file.readlines()  # 读取所有行到列表，每行包含换行符
    print(f"所有行：{lines}")
    # 去除每行的换行符
    clean_lines = [line.strip() for line in lines]
    print(f"清理后的行：{clean_lines}")
```

```python
# 追加内容
# 'a'模式在文件末尾添加内容，不会覆盖原有内容
with open("example.txt", "a", encoding="utf-8") as file:
    file.write("追加的内容\n")
    file.write("另一行追加内容\n")
```

```python
# 读写操作
# 'r+'模式允许同时读取和写入
with open("example.txt", "r+", encoding="utf-8") as file:
    content = file.read()
    print(f"读取内容：{content}")
    file.write("新追加的内容\n")
    file.seek(0)  # 回到文件开头
    new_content = file.read()
    print(f"追加后的内容：{new_content}")
```

### 文件的上下文管理器

使用上下文管理器和错误处理可以使文件操作更加安全可靠，防止资源泄露和程序崩溃。

```python
# 使用with语句自动管理文件资源
# with语句会在代码块执行完毕后自动关闭文件，即使在代码块中发生异常
def safe_file_read(filename):
    """安全读取文件内容
    Args:
        filename (str): 要读取的文件名
    Returns:
        str or None: 文件内容，出错时返回None
    """
    try:
        with open(filename, "r", encoding="utf-8") as file:
            content = file.read()
            return content
    except FileNotFoundError:
        print(f"错误：文件 {filename} 不存在")
        return None
    except PermissionError:
        print(f"错误：没有权限访问文件 {filename}")
        return None
    except UnicodeDecodeError:
        print(f"错误：文件 {filename} 编码问题")
        return None
    except Exception as e:
        print(f"未知错误：{e}")
        return None

content = safe_file_read("nonexistent.txt")
```

**错误处理最佳实践**

1. **具体异常优先**：先捕获具体的异常类型，再捕获通用异常
2. **资源清理**：使用`with`语句或`finally`块确保资源正确释放
3. **日志记录**：记录错误信息便于调试和监控
4. **用户友好**：向用户提供清晰易懂的错误信息

**实际应用示例**

```python
# 批量文件处理示例
def process_files(file_list):
    """批量处理文件列表"""
    results = []
    for filename in file_list:
        try:
            with open(filename, "r", encoding="utf-8") as file:
                content = file.read()
                # 简单处理：统计行数和字符数
                lines = content.count('\n') + 1
                chars = len(content)
                results.append({
                    'filename': filename,
                    'lines': lines,
                    'chars': chars
                })
                print(f"处理完成: {filename} - {lines}行, {chars}字符")
        except FileNotFoundError:
            print(f"警告: 文件 {filename} 不存在，跳过处理")
        except PermissionError:
            print(f"错误: 没有权限访问 {filename}，跳过处理")
        except UnicodeDecodeError:
            print(f"警告: 文件 {filename} 编码错误，尝试其他编码")
            # 尝试其他编码
            try:
                with open(filename, "r", encoding="gbk") as file:
                    content = file.read()
                    lines = content.count('\n') + 1
                    chars = len(content)
                    results.append({
                        'filename': filename,
                        'lines': lines,
                        'chars': chars
                    })
                    print(f"使用GBK编码处理完成: {filename}")
            except Exception as e:
                print(f"错误: 无法处理文件 {filename} - {e}")
        except Exception as e:
            print(f"未预期错误: 处理 {filename} 时出错 - {e}")
    return results

# 示例调用
files_to_process = ["example.txt", "nonexistent.txt", "sample.csv"]
processing_results = process_files(files_to_process)
print(f"处理结果: {processing_results}")
```

**注意事项**

> **重要提醒**：
> 1. 不要忽略异常处理，即使是"不可能"出现的错误
> 2. 避免空的except块，至少应该记录日志
> 3. 对于重要操作，考虑实现重试机制
> 4. 敏感信息（如文件路径）不要直接暴露给最终用户

```python
# 多种异常处理方式
def advanced_file_operations(filename, mode="r"):
    """高级文件操作，支持多种模式的异常处理
    Args:
        filename (str): 文件名
        mode (str): 文件打开模式，默认为"r"
    Returns:
        str or bool: 操作结果
    """
    try:
        with open(filename, mode, encoding="utf-8") as file:
            if mode == "r":
                return file.read()
            elif mode in ["w", "a"]:
                return "文件已准备写入"
            else:
                raise ValueError(f"不支持的文件模式：{mode}")
    except FileNotFoundError:
        # 对于写入模式，文件不存在是正常的
        if mode in ["w", "a"]:
            print(f"文件 {filename} 不存在，将创建新文件")
            with open(filename, mode, encoding="utf-8") as file:
                return "文件已创建并准备写入"
        else:
            print(f"错误：文件 {filename} 不存在")
            return None
    except IsADirectoryError:
        print(f"错误：{filename} 是一个目录，不是文件")
        return None
    except Exception as e:
        print(f"文件操作出错：{e}")
        return None
```

```python
# 确保文件路径存在
import os

def ensure_directory_exists(filepath):
    """确保文件的目录存在
    Args:
        filepath (str): 文件路径
    """
    directory = os.path.dirname(filepath)  # 获取文件路径的目录部分
    if directory and not os.path.exists(directory):
        os.makedirs(directory)  # 创建目录（包括父目录）
        print(f"创建目录：{directory}")

# 安全的文件写入
def safe_file_write(filename, content):
    """安全地写入文件内容
    Args:
        filename (str): 文件名
        content (str): 要写入的内容
    Returns:
        bool: 写入成功返回True，失败返回False
    """
    ensure_directory_exists(filename)  # 确保目录存在
    try:
        with open(filename, "w", encoding="utf-8") as file:
            file.write(content)
        return True
    except Exception as e:
        print(f"写入文件时出错：{e}")
        return False

# 测试安全写入
safe_file_write("output/subdir/example.txt", "这是子目录中的文件\n多行内容")
```

### 文件的指针操作

文件指针是指文件中当前读写操作的位置，可以通过seek()和tell()方法控制。

```python
# 创建测试文件
with open("pointer_test.txt", "w", encoding="utf-8") as file:
    file.write("12345\n")
    file.write("67890\n")
    file.write("abcde\n")
    file.write("fghij\n")
```

**文件指针操作**

文件指针操作是精确控制文件读写位置的重要手段，特别适用于大文件处理和二进制文件操作：

| 方法 | 功能 | 参数说明 |
|------|------|----------|
| `tell()` | 获取当前指针位置 | 无参数，返回字节位置 |
| `seek(offset, whence=0)` | 移动指针位置 | offset:偏移量, whence:参考位置 |
| `whence=0` | 从文件开头计算 | 默认值 |
| `whence=1` | 从当前位置计算 | 相对定位 |
| `whence=2` | 从文件末尾计算 | 通常用于获取文件大小 |

**实际应用示例**

```python
# 大文件分段处理示例
def process_large_file_in_chunks(filename, chunk_size=1024):
    """分段处理大文件，避免内存不足"""
    try:
        with open(filename, "r", encoding="utf-8") as file:
            chunk_num = 0
            while True:
                # 记录当前处理位置
                start_pos = file.tell()

                # 读取一块数据
                chunk = file.read(chunk_size)
                if not chunk:
                    break

                # 处理数据块
                chunk_num += 1
                lines = chunk.count('\n')
                print(f"块 {chunk_num}: 位置 {start_pos}-{file.tell()}, 行数: {lines}")

                # 模拟数据处理
                processed_data = chunk.upper()

        print(f"文件处理完成，共处理 {chunk_num} 块")
        return True
    except Exception as e:
        print(f"处理文件时出错: {e}")
        return False

# 二进制文件头部信息读取示例
def read_binary_header(filename):
    """读取二进制文件头部信息"""
    try:
        with open(filename, "rb") as file:
            # 读取文件头（假设前16字节为头部信息）
            header = file.read(16)
            if len(header) < 16:
                print("文件太短，无法读取完整头部")
                return None

            # 解析头部信息（示例格式）
            print(f"文件头: {header.hex()}")

            # 移动到指定位置读取特定数据
            file.seek(32)  # 移动到32字节位置
            specific_data = file.read(8)  # 读取8字节数据
            print(f"特定位置数据: {specific_data.hex()}")

            # 获取文件大小
            file.seek(0, 2)  # 移动到文件末尾
            file_size = file.tell()
            print(f"文件总大小: {file_size} 字节")

        return {
            'header': header,
            'specific_data': specific_data,
            'file_size': file_size
        }
    except Exception as e:
        print(f"读取二进制文件头时出错: {e}")
        return None

# 示例调用
process_large_file_in_chunks("pointer_test.txt", 20)
```

**注意事项**

> **重要提醒**：
> 1. 文本模式和二进制模式下的指针位置计算方式不同
> 2. 在文本模式下，某些位置可能无法精确seek（特别是使用whence=1或whence=2时）
> 3. 处理Unicode字符时要注意字符边界，避免截断多字节字符
> 4. 在网络文件系统上频繁seek可能影响性能

```python
# 文件指针操作
with open("pointer_test.txt", "r", encoding="utf-8") as file:
    # 获取当前指针位置
    print(f"初始指针位置：{file.tell()}")  # 0，开始位置

    # 读取前5个字符
    first_five = file.read(5)  # 读取指定数量的字符
    print(f"前5个字符：'{first_five}'")
    print(f"读取后指针位置：{file.tell()}")  # 5，指针向后移动5个字符

    # 移动指针到文件开头
    file.seek(0)  # seek(pos) 将指针移动到指定位置
    print(f"回到开头后指针位置：{file.tell()}")  # 0

    # 读取一行
    first_line = file.readline()  # 读取一行内容（包括换行符）
    print(f"第一行：'{first_line.strip()}'")
    print(f"读取一行后指针位置：{file.tell()}")  # 6（包括换行符）
```

```python
# 继续文件指针操作
with open("pointer_test.txt", "r", encoding="utf-8") as file:
    # 移动到特定位置
    file.seek(10)  # 移动到第10个字节位置
    content_from_10 = file.read()
    print(f"从位置10开始的内容：'{content_from_10.strip()}'")

    # 相对当前位置移动
    current_pos = file.tell()
    file.seek(current_pos + 5)  # 从当前位置再向后移动5个字符
    content_after_relative = file.read()
    print(f"从相对位置开始的内容：'{content_after_relative.strip()}'")
```

```python
# 文件指针操作（续）
with open("pointer_test.txt", "r", encoding="utf-8") as file:
    # 移动到文件末尾
    file.seek(0, 2)  # 2表示从文件末尾开始计算
    print(f"文件末尾位置：{file.tell()}")

    # 获取文件大小
    file.seek(0, 2)  # 移动到末尾
    file_size = file.tell()  # tell()返回当前位置，即文件大小
    print(f"文件大小：{file_size} 字节")
```

```python
# 读取文件的特定部分
def read_file_section(filename, start_byte, length):
    """读取文件的特定部分
    Args:
        filename (str): 文件名
        start_byte (int): 开始字节位置
        length (int): 要读取的字节数
    Returns:
        bytes: 读取的内容
    """
    with open(filename, "rb") as file:  # 使用二进制模式精确控制
        file.seek(start_byte)  # 移动到起始位置
        return file.read(length)  # 读取指定长度的内容

section_content = read_file_section("pointer_test.txt", 5, 10)
print(f"文件5-15字节的内容：{section_content}")
```

### 二进制文件操作

二进制文件操作用于处理非文本文件，如图片、音频、视频和自定义格式的数据文件。

```python
# 写入二进制数据
# bytes对象用于存储二进制数据，可以包含0-255的任意值
data = bytes([65, 66, 67, 68, 69])  # A B C D E的ASCII码

with open("binary_data.bin", "wb") as file:  # 'wb'表示二进制写入模式
    file.write(data)
```

**二进制文件操作特点**

二进制文件操作与文本文件操作有显著区别：

1. **模式标识**：使用'b'后缀（如'rb', 'wb', 'ab'）
2. **数据类型**：读写的是bytes对象，而非str对象
3. **编码无关**：不需要指定encoding参数
4. **精确控制**：可以精确控制每个字节的数据

**实际应用示例**

```python
# 图片文件处理示例
def process_image_file(image_path):
    """处理图片文件示例"""
    try:
        # 读取图片文件
        with open(image_path, "rb") as file:
            # 读取文件头部信息（通常包含格式信息）
            header = file.read(10)  # 读取前10个字节

            # 判断图片格式（简化示例）
            if header.startswith(b'\xff\xd8\xff'):
                format_type = "JPEG"
            elif header.startswith(b'\x89PNG\r\n\x1a\n'):
                format_type = "PNG"
            elif header.startswith(b'GIF87a') or header.startswith(b'GIF89a'):
                format_type = "GIF"
            else:
                format_type = "Unknown"

            print(f"图片格式: {format_type}")

            # 获取文件大小
            file.seek(0, 2)  # 移动到文件末尾
            file_size = file.tell()
            print(f"文件大小: {file_size} 字节")

            # 重置指针到开头
            file.seek(0)

            # 读取完整文件内容
            image_data = file.read()
            print(f"读取完成，数据长度: {len(image_data)} 字节")

        return {
            'format': format_type,
            'size': file_size,
            'data': image_data
        }
    except FileNotFoundError:
        print(f"错误: 图片文件 {image_path} 不存在")
        return None
    except Exception as e:
        print(f"处理图片时出错: {e}")
        return None

# 结构化数据序列化示例
import struct

def save_student_records(records, filename):
    """保存学生记录到二进制文件"""
    try:
        with open(filename, "wb") as file:
            # 写入记录数量
            file.write(struct.pack('I', len(records)))  # I表示无符号整数

            # 写入每条记录
            for record in records:
                student_id = record['id']
                name = record['name'].encode('utf-8')  # 字符串需要编码
                age = record['age']
                score = record['score']

                # 写入ID（整数）
                file.write(struct.pack('I', student_id))

                # 写入名字长度和名字
                file.write(struct.pack('I', len(name)))
                file.write(name)

                # 写入年龄和分数
                file.write(struct.pack('I', age))
                file.write(struct.pack('f', score))  # f表示浮点数

        print(f"成功保存 {len(records)} 条记录到 {filename}")
        return True
    except Exception as e:
        print(f"保存记录时出错: {e}")
        return False

def load_student_records(filename):
    """从二进制文件加载学生记录"""
    try:
        records = []
        with open(filename, "rb") as file:
            # 读取记录数量
            count = struct.unpack('I', file.read(4))[0]

            # 读取每条记录
            for _ in range(count):
                # 读取ID
                student_id = struct.unpack('I', file.read(4))[0]

                # 读取名字
                name_length = struct.unpack('I', file.read(4))[0]
                name = file.read(name_length).decode('utf-8')

                # 读取年龄和分数
                age = struct.unpack('I', file.read(4))[0]
                score = struct.unpack('f', file.read(4))[0]

                records.append({
                    'id': student_id,
                    'name': name,
                    'age': age,
                    'score': score
                })

        print(f"成功加载 {len(records)} 条记录")
        return records
    except Exception as e:
        print(f"加载记录时出错: {e}")
        return []

# 示例调用
student_data = [
    {'id': 1001, 'name': '张三', 'age': 20, 'score': 85.5},
    {'id': 1002, 'name': '李四', 'age': 21, 'score': 92.0},
    {'id': 1003, 'name': '王五', 'age': 19, 'score': 78.5}
]

save_student_records(student_data, "students.dat")
loaded_data = load_student_records("students.dat")
print(f"加载的数据: {loaded_data}")
```

**注意事项**

> **重要提醒**：
> 1. 二进制模式下读写的是bytes对象，字符串需要编码/解码
> 2. 使用struct模块处理结构化数据时要注意字节序问题
> 3. 大端序和小端序在不同平台上可能表现不同
> 4. 处理敏感数据时要考虑加密保护
> 5. 二进制文件不具备人类可读性，需要额外的文档说明格式

```python
# 读取二进制数据
with open("binary_data.bin", "rb") as file:  # 'rb'表示二进制读取模式
    binary_content = file.read()
    print(f"二进制数据：{binary_content}")
    print(f"转换为字符串：{binary_content.decode('ascii')}")  # 使用ascii解码
```

```python
# 处理结构化的二进制数据
import struct

# 创建二进制结构
name = "Alice"
age = 25
height = 165.5

# 打包为二进制数据
# 格式字符串 "5sif" 的含义：
# 5s: 5字节的字符串
# i: 4字节的整数
# f: 4字节的浮点数
packed_data = struct.pack("5sif", name.encode(), age, height)
with open("person.bin", "wb") as file:
    file.write(packed_data)
```

```python
# 读取并解析二进制数据
with open("person.bin", "rb") as file:
    data = file.read()
    # 使用相同的格式字符串解包
    unpacked_name, unpacked_age, unpacked_height = struct.unpack("5sif", data)
    print(f"姓名：{unpacked_name.decode().strip()}")  # 解码并去除填充的空字节
    print(f"年龄：{unpacked_age}")
    print(f"身高：{unpacked_height}")
```

```python
# 处理大文件的分块读写
def copy_large_file_chunkwise(source, destination, chunk_size=8192):
    """分块复制大文件，避免内存不足
    Args:
        source (str): 源文件路径
        destination (str): 目标文件路径
        chunk_size (int): 块大小，默认8192字节
    Returns:
        bool: 复制成功返回True，失败返回False
    """
    try:
        with open(source, "rb") as src, open(destination, "wb") as dst:
            while True:
                chunk = src.read(chunk_size)  # 读取一块数据
                if not chunk:  # 读取到文件末尾
                    break
                dst.write(chunk)  # 写入一块数据
        print(f"文件 {source} 成功复制到 {destination}")
        return True
    except Exception as e:
        print(f"复制文件时出错：{e}")
        return False

# 创建测试大文件
with open("large_test.txt", "w") as file:
    file.write("测试数据\n" * 10000)  # 创建包含10000行的文件

# 测试分块复制
copy_large_file_chunkwise("large_test.txt", "large_test_copy.txt")
```

### 文件系统操作

Python提供了多个模块用于文件和目录操作，包括os、shutil和pathlib等。

```python
import os
import shutil
from pathlib import Path

# 使用os模块进行文件系统操作

# 检查文件/目录是否存在
print(f"example.txt存在：{os.path.exists('example.txt')}")  # exists(path)检查路径是否存在
print(f"nonexistent.txt存在：{os.path.exists('nonexistent.txt')}")

# 检查是否为文件或目录
print(f"example.txt是文件：{os.path.isfile('example.txt')}")  # isfile(path)判断是否为文件
print(f".是目录：{os.path.isdir('.')}")  # isdir(path)判断是否为目录
```

```python
# 获取文件信息
if os.path.exists("example.txt"):
    file_size = os.path.getsize("example.txt")  # 获取文件大小（字节）
    file_mtime = os.path.getmtime("example.txt")  # 获取最后修改时间（时间戳）
    import datetime
    modified_time = datetime.datetime.fromtimestamp(file_mtime)  # 转换为可读时间
    print(f"文件大小：{file_size} 字节")
    print(f"修改时间：{modified_time}")

# 获取当前工作目录
current_dir = os.getcwd()  # getcwd()获取当前工作目录
print(f"当前目录：{current_dir}")
```

```python
# 创建目录
if not os.path.exists("test_directory"):
    os.makedirs("test_directory/subdir", exist_ok=True)  # 创建多级目录
    print("目录创建成功")

# 列出目录内容
print("当前目录内容：")
for item in os.listdir("."):  # 列出当前目录下所有文件和目录
    item_path = os.path.join(".", item)  # 拼接完整路径
    item_type = "目录" if os.path.isdir(item_path) else "文件"
    print(f"  {item} ({item_type})")
```

```python
# 删除文件和目录
# 注意：删除操作不可逆，请谨慎使用

# 删除文件
if os.path.exists("temp_file.txt"):
    os.remove("temp_file.txt")  # 删除文件
    print("临时文件已删除")

# 删除空目录
if os.path.exists("empty_dir"):
    os.rmdir("empty_dir")  # 只能删除空目录
    print("空目录已删除")

# 删除非空目录
if os.path.exists("test_directory"):
    shutil.rmtree("test_directory")  # 递归删除整个目录树
    print("非空目录已删除")
```

```python
# 使用pathlib（更现代的文件系统操作）
# pathlib提供了面向对象的文件系统接口，使路径操作更直观
from pathlib import Path

# 创建Path对象
current_path = Path(".")  # 当前目录的Path对象
file_path = Path("example.txt")  # 文件的Path对象
new_dir_path = Path("new_directory")  # 目录的Path对象

# Path对象的方法
print(f"当前目录：{current_path.resolve()}")  # resolve()返回绝对路径
print(f"文件路径：{file_path}")
print(f"文件名：{file_path.name}")  # name属性获取文件名（不含目录）
print(f"文件后缀：{file_path.suffix}")  # suffix属性获取文件扩展名
print(f"文件目录：{file_path.parent}")  # parent属性获取父目录
```

```python
# 继续pathlib操作
# 创建目录
new_dir_path.mkdir(exist_ok=True)  # 创建目录，exist_ok=True表示已存在时不报错
print(f"目录 {new_dir_path} 创建成功")

# 遍历目录
print("目录结构：")
for path in current_path.rglob("*.txt"):  # rglob()递归查找匹配模式的文件
    print(f"  {path}")

# 复制和移动文件
shutil.copy("example.txt", "example_copy.txt")  # 复制文件
shutil.move("example_copy.txt", "moved_example.txt")  # 移动文件
```

```python
# 获取文件扩展名
def get_file_extension(filename):
    """获取文件扩展名
    Args:
        filename (str): 文件名
    Returns:
        str: 文件扩展名（包括点）
    """
    return Path(filename).suffix

print(f"example.txt的扩展名：{get_file_extension('example.txt')}")
print(f"archive.tar.gz的扩展名：{Path('archive.tar.gz').suffix}")  # 只返回最后的扩展名
print(f"archive.tar.gz的所有扩展名：{''.join(Path('archive.tar.gz').suffixes)}")  # suffixes返回所有扩展名列表
```

### 高级文件操作

Python提供了许多高级文件操作功能，包括临时文件、文件压缩、哈希计算和文件监控等。

```python
# 文件的临时操作
import tempfile
import os

# 创建临时文件
# NamedTemporaryFile创建一个真实的临时文件，在文件系统中有名称
with tempfile.NamedTemporaryFile(mode='w', delete=False) as temp:
    temp.write("这是临时文件内容\n")
    temp_path = temp.name  # 获取临时文件路径
    print(f"临时文件路径：{temp_path}")
```

```python
# 临时文件不会被自动删除（因为delete=False）
with open(temp_path, 'r') as f:
    print(f"临时文件内容：{f.read()}")

# 创建临时目录
# TemporaryDirectory创建一个临时目录，在with块结束后自动删除
with tempfile.TemporaryDirectory() as temp_dir:
    temp_file_path = os.path.join(temp_dir, "temp.txt")
    with open(temp_file_path, 'w') as f:
        f.write("临时目录中的文件")
    print(f"临时目录：{temp_dir}")
    print(f"临时目录内容：{os.listdir(temp_dir)}")
    # 临时目录在with块结束后自动删除
```

```python
# 文件压缩
import zipfile
import gzip
import tarfile
import shutil

# ZIP文件操作
# zipfile模块用于创建和读取ZIP压缩文件
with zipfile.ZipFile("example.zip", "w", zipfile.ZIP_DEFLATED) as zipf:
    zipf.write("example.txt")  # 添加现有文件到ZIP
    zipf.write("pointer_test.txt")
    # 添加字符串内容作为ZIP内的文件
    zipf.writestr("internal.txt", "这是ZIP文件内的文件")
```

```python
# 读取ZIP文件
with zipfile.ZipFile("example.zip", "r") as zipf:
    print("ZIP文件内容：")
    for name in zipf.namelist():  # namelist()返回ZIP中所有文件名
        print(f"  {name}")
        # 读取ZIP内的文件内容
        with zipf.open(name) as f:  # open()打开ZIP内的文件
            content = f.read().decode('utf-8')
            print(f"    {name[:20]}...: {content[:50]}...")
```

```python
# GZIP压缩
# gzip模块用于处理gzip压缩文件
with open("example.txt", "rb") as f_in:
    with gzip.open("example.txt.gz", "wb") as f_out:
        shutil.copyfileobj(f_in, f_out)  # 复制文件对象的内容

# 读取GZIP文件
with gzip.open("example.txt.gz", "rt", encoding="utf-8") as f:
    content = f.read()
    print(f"GZIP文件内容：{content[:100]}...")
```

```python
# 文件哈希计算
import hashlib

def calculate_file_hash(filename, hash_algorithm="md5"):
    """计算文件的哈希值
    Args:
        filename (str): 文件名
        hash_algorithm (str): 哈希算法，默认为"md5"
    Returns:
        str: 文件的哈希值（十六进制字符串）
    """
    hash_obj = hashlib.new(hash_algorithm)  # 创建哈希对象
    with open(filename, "rb") as file:
        # 分块读取大文件，避免内存不足
        for chunk in iter(lambda: file.read(4096), b""):
            hash_obj.update(chunk)  # 更新哈希计算
    return hash_obj.hexdigest()  # 返回十六进制哈希值

if os.path.exists("example.txt"):
    md5_hash = calculate_file_hash("example.txt", "md5")  # 计算MD5哈希
    sha256_hash = calculate_file_hash("example.txt", "sha256")  # 计算SHA256哈希
    print(f"example.txt的MD5：{md5_hash}")
    print(f"example.txt的SHA256：{sha256_hash}")
```

```python
# 监控文件变化
import time

def monitor_file_changes(filename, interval=1):
    """监控文件变化
    Args:
        filename (str): 要监控的文件名
        interval (int): 检查间隔（秒），默认为1秒
    """
    last_mtime = os.path.getmtime(filename) if os.path.exists(filename) else 0
    print(f"开始监控文件：{filename}")

    try:
        while True:
            if os.path.exists(filename):
                current_mtime = os.path.getmtime(filename)  # 获取当前修改时间
                if current_mtime > last_mtime:  # 比较修改时间
                    print(f"文件 {filename} 已修改（{time.ctime(current_mtime)}）")
                    last_mtime = current_mtime
            else:
                print(f"文件 {filename} 已删除")
                break
            time.sleep(interval)  # 等待一段时间再检查
    except KeyboardInterrupt:
        print(f"停止监控文件：{filename}")

# 注释掉实际运行，避免脚本阻塞
# monitor_file_changes("example.txt")
```

```python
# 文件备份功能
import datetime
from pathlib import Path

def backup_file(filename, backup_dir="backups"):
    """备份文件
    Args:
        filename (str): 要备份的文件名
        backup_dir (str): 备份目录，默认为"backups"
    Returns:
        bool: 备份成功返回True，失败返回False
    """
    if not os.path.exists(filename):
        print(f"文件 {filename} 不存在")
        return False

    # 创建备份目录
    os.makedirs(backup_dir, exist_ok=True)

    # 生成备份文件名（包含时间戳）
    timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
    backup_name = f"{Path(filename).stem}_{timestamp}{Path(filename).suffix}"
    backup_path = os.path.join(backup_dir, backup_name)

    try:
        shutil.copy2(filename, backup_path)  # copy2保留元数据（如修改时间）
        print(f"文件已备份到：{backup_path}")
        return True
    except Exception as e:
        print(f"备份失败：{e}")
        return False

# 执行备份
backup_file("example.txt")
```

```python
# 文件的原子性操作
# 原子性操作确保文件操作的完整性，防止操作过程中被中断导致数据损坏
import fcntl  # Unix-like系统上的文件锁模块

def atomic_write(filename, content):
    """原子性写入文件（适用于Unix-like系统）
    Args:
        filename (str): 目标文件名
        content (str): 要写入的内容
    Returns:
        bool: 写入成功返回True，失败返回False
    """
    temp_file = f"{filename}.tmp"  # 临时文件名

    try:
        with open(temp_file, "w", encoding="utf-8") as f:
            # 获取文件锁，防止并发写入
            fcntl.flock(f.fileno(), fcntl.LOCK_EX)  # LOCK_EX表示排他锁
            f.write(content)
            f.flush()  # 确保内容写入磁盘
            os.fsync(f.fileno())  # 强制同步到磁盘

        # 原子性重命名（在大多数Unix系统上是原子操作）
        os.replace(temp_file, filename)
        print(f"内容已原子性写入文件：{filename}")
        return True
    except Exception as e:
        print(f"原子性写入失败：{e}")
        return False

# 在Windows系统上可以使用类似的原子性操作
def atomic_write_windows(filename, content):
    """Windows系统的原子性写入
    Args:
        filename (str): 目标文件名
        content (str): 要写入的内容
    Returns:
        bool: 写入成功返回True，失败返回False
    """
    temp_file = f"{filename}.tmp"

    try:
        with open(temp_file, "w", encoding="utf-8") as f:
            f.write(content)
            f.flush()
            os.fsync(f.fileno())

        # Windows上的原子性重命名
        os.replace(temp_file, filename)
        print(f"内容已原子性写入文件：{filename}")
        return True
    except Exception as e:
        print(f"原子性写入失败：{e}")
        return False
```

## 异常处理

异常处理是Python中处理错误和异常情况的重要机制，它允许程序在遇到错误时优雅地处理，而不是直接崩溃。

### 基本异常结构

Python使用try-except结构来捕获和处理异常，使得程序在出现错误时能够优雅地恢复而不是崩溃。

```python
# try-except基本结构
try:
    # 可能引发异常的代码
    num1 = int(input("请输入第一个数字："))  # 可能引发ValueError
    num2 = int(input("请输入第二个数字："))  # 可能引发ValueError
    result = num1 / num2                     # 可能引发ZeroDivisionError
    print(f"结果是：{result}")
except ValueError:
    # 处理特定异常：当输入无法转换为整数时触发
    print("请输入有效的数字！")
except ZeroDivisionError:
    # 处理除零错误：当除数为0时触发
    print("不能除以零！")
except Exception as e:
    # 处理所有其他异常：作为最后的保障
    print(f"发生未知错误：{e}")
else:
    # 没有异常时执行：当try块中没有异常时执行
    print("计算成功完成！")
finally:
    # 无论是否有异常都会执行：常用于资源清理
    print("程序执行完毕。")

# 单个except处理多种异常
try:
    # 一些可能产生多种异常的代码
    x = int("abc")      # ValueError：字符串无法转换为整数
    # y = 10 / 0        # ZeroDivisionError（被上一行阻止）
except (ValueError, ZeroDivisionError) as e:
    # 一个except块可以捕获多种异常类型
    print(f"发生了错误：{e}")
    print(f"错误类型：{type(e).__name__}")

# 没有异常类名（捕获所有异常，不推荐）
try:
    risky_operation()  # 假设这是一个可能失败的操作
except:
    # 裸露的except会捕获所有异常，隐藏了错误信息，难以调试
    print("发生了某种异常")
```

### 异常处理实践

1. **具体异常优先**：先捕获具体的异常类型，再捕获通用异常
2. **避免裸露except**：不要使用没有指定异常类型的except块
3. **合理使用else和finally**：else用于无异常时执行，finally用于清理资源
4. **记录异常信息**：使用logging模块记录异常详情便于调试
5. **自定义异常**：为特定业务场景创建自定义异常类

**实际应用示例**

```python
# Web请求异常处理示例
import random
import time

def simulate_web_request(url, timeout=5):
    """模拟Web请求"""
    try:
        print(f"请求URL: {url}")

        # 模拟网络延迟
        time.sleep(random.uniform(0.1, 1.0))

        # 模拟不同类型的响应
        responses = [
            {"status": 200, "data": "成功响应"},
            {"status": 404, "error": "页面未找到"},
            {"status": 500, "error": "服务器内部错误"},
            None  # 模拟超时或连接失败
        ]

        response = random.choice(responses)

        if response is None:
            raise TimeoutError("请求超时")
        elif response["status"] == 404:
            raise FileNotFoundError("资源未找到")
        elif response["status"] == 500:
            raise ConnectionError("服务器错误")
        else:
            return response["data"]

    except TimeoutError as e:
        print(f"超时错误: {e}")
        raise  # 重新抛出异常
    except FileNotFoundError as e:
        print(f"资源错误: {e}")
        return None
    except ConnectionError as e:
        print(f"连接错误: {e}")
        # 尝试重试
        print("尝试重新连接...")
        time.sleep(1)
        return simulate_web_request(url, timeout)
    except Exception as e:
        print(f"未预期错误: {e}")
        raise

# 数据库操作异常处理示例
class DatabaseError(Exception):
    """数据库操作异常"""
    pass

class ConnectionError(DatabaseError):
    """数据库连接异常"""
    pass

class QueryError(DatabaseError):
    """查询执行异常"""
    pass

def database_operation(operation_type):
    """模拟数据库操作"""
    try:
        if operation_type == "connect":
            # 模拟连接操作
            if random.random() < 0.3:  # 30%概率失败
                raise ConnectionError("无法连接到数据库服务器")
            print("数据库连接成功")
            return True
        elif operation_type == "query":
            # 模拟查询操作
            if random.random() < 0.2:  # 20%概率失败
                raise QueryError("SQL语法错误或表不存在")
            print("查询执行成功")
            return [{"id": 1, "name": "示例数据"}]
        else:
            raise ValueError(f"不支持的操作类型: {operation_type}")

    except ConnectionError as e:
        print(f"数据库连接失败: {e}")
        # 可以在这里实现重连逻辑
        return False
    except QueryError as e:
        print(f"查询执行失败: {e}")
        # 可以记录错误日志
        return None
    except ValueError as e:
        print(f"参数错误: {e}")
        raise  # 重新抛出，因为这是调用者的问题

# 示例调用
try:
    result = simulate_web_request("https://api.example.com/data")
    if result:
        print(f"请求结果: {result}")

    # 数据库操作示例
    if database_operation("connect"):
        data = database_operation("query")
        if data:
            print(f"查询数据: {data}")

except Exception as e:
    print(f"程序执行过程中发生严重错误: {e}")
```

**注意事项**

> **重要提醒**：
> 1. 不要忽略异常处理，即使是"不可能"出现的错误
> 2. 避免空的except块，至少应该记录日志
> 3. 对于重要操作，考虑实现重试机制
> 4. 敏感信息（如数据库密码）不要直接暴露在异常信息中
> 5. 异常处理会影响程序性能，不要过度使用

### 常见内置异常类型

Python提供了多种内置异常类型，用于表示不同种类的错误情况。了解这些异常类型有助于编写更健壮的程序，并进行适当的错误处理。

#### 基础异常类型示例

以下代码展示了Python中最常见的内置异常类型及其使用场景：

```python
# ValueError - 值错误
# 当函数接收到类型正确但值不合适的参数时引发
try:
    num = int("abc")  # "abc"是字符串类型，但内容无法转换为整数
except ValueError as e:
    print(f"ValueError: {e}")

# TypeError - 类型错误
# 当操作或函数应用于不适当类型的对象时引发
try:
    result = "5" + 3  # 字符串不能与数字直接相加
except TypeError as e:
    print(f"TypeError: {e}")

# IndexError - 索引错误
# 当使用超出序列范围的索引时引发
try:
    items = [1, 2, 3]
    item = items[5]  # 列表只有3个元素，索引5超出范围
except IndexError as e:
    print(f"IndexError: {e}")

# KeyError - 键错误
# 当使用字典中不存在的键时引发
try:
    data = {"name": "Alice", "age": 25}
    value = data["salary"]  # "salary"键不存在
except KeyError as e:
    print(f"KeyError: {e}")

# AttributeError - 属性错误
# 当试图访问对象不存在的属性或方法时引发
try:
    text = "hello"
    length = text.len()  # 字符串对象没有len方法，应该是len(text)
except AttributeError as e:
    print(f"AttributeError: {e}")

# FileNotFoundError - 文件未找到错误
# 当试图打开不存在的文件时引发
try:
    with open("nonexistent.txt", "r") as file:
        content = file.read()
except FileNotFoundError as e:
    print(f"FileNotFoundError: {e}")

# PermissionError - 权限错误
# 当试图执行没有足够权限的操作时引发
try:
    # 尝试访问可能没有权限的文件
    with open("/etc/passwd", "r") as file:  # Linux系统上的系统文件
        content = file.read()
except PermissionError as e:
    print(f"PermissionError: {e}")
except FileNotFoundError:
    print("文件不存在")

# ZeroDivisionError - 除零错误
# 当除数为零时引发
try:
    result = 10 / 0  # 除数为零
except ZeroDivisionError as e:
    print(f"ZeroDivisionError: {e}")

# ImportError - 导入错误
# 当import语句找不到模块或无法加载模块时引发
try:
    import nonexistent_module  # 不存在的模块
except ImportError as e:
    print(f"ImportError: {e}")

# MemoryError - 内存错误（模拟）
# 当操作需要内存超过可用内存时引发
try:
    # 尝试分配大量内存（注意：这可能会导致系统问题）
    # large_list = [0] * 10**10  # 可能导致MemoryError
    print("跳过内存分配测试")
except MemoryError as e:
    print(f"MemoryError: {e}")

# OverflowError - 溢出错误
# 当数值运算结果太大而无法表示时引发
import math
try:
    result = math.exp(1000)  # e的1000次方，超出浮点数表示范围
except OverflowError as e:
    print(f"OverflowError: {e}")

# StopIteration - 迭代器耗尽
# 当迭代器没有更多元素可提供时引发
iterator = iter([1, 2, 3])
try:
    while True:
        item = next(iterator)
        print(item)
    next(iterator)  # 迭代器已耗尽，再次调用会引发StopIteration
except StopIteration as e:
    print(f"StopIteration: 迭代器已耗尽")
```

#### 自定义异常

在实际开发中，我们经常需要定义自己的异常类型来处理特定的业务逻辑错误。自定义异常可以让错误处理更加精确和有意义。

```python
# 定义自定义异常类
class InvalidAgeError(Exception):
    """年龄无效异常"""
    def __init__(self, age):
        self.age = age
        self.message = f"无效的年龄：{age}。年龄必须在0-120之间"
        super().__init__(self.message)

class DuplicateUserError(Exception):
    """用户重复异常"""
    def __init__(self, username):
        self.username = username
        super().__init__(f"用户名'{username}'已存在")

# 使用自定义异常
def validate_age(age):
    """验证年龄
    Args:
        age (int/float): 要验证的年龄

    Returns:
        bool: 年龄有效返回True

    Raises:
        TypeError: 当年龄不是数字类型时引发
        InvalidAgeError: 当年龄不在有效范围内时引发
    """
    if not isinstance(age, (int, float)):
        raise TypeError("年龄必须是数字")
    if age < 0 or age > 120:
        raise InvalidAgeError(age)
    return True

# 测试自定义异常
try:
    validate_age(-5)
except InvalidAgeError as e:
    print(f"捕获到自定义异常：{e}")

try:
    validate_age("abc")
except TypeError as e:
    print(f"捕获到类型错误：{e}")

# 更复杂的自定义异常类
class DatabaseError(Exception):
    """数据库错误基类"""
    def __init__(self, message, error_code=None):
        super().__init__(message)
        self.error_code = error_code

class ConnectionError(DatabaseError):
    """连接错误"""
    pass

class QueryError(DatabaseError):
    """查询错误"""
    def __init__(self, message, query=None, error_code=None):
        super().__init__(message, error_code)
        self.query = query

# 使用数据库异常类
def execute_query(query):
    """模拟执行数据库查询
    Args:
        query (str): SQL查询语句

    Returns:
        str: 查询结果

    Raises:
        QueryError: 当查询为空或包含非法操作时引发
    """
    if not query:
        raise QueryError("查询不能为空", query=query, error_code=1001)
    if query.upper().startswith("DROP"):
        raise QueryError("不允许的查询操作", query=query, error_code=1002)
    return f"查询结果：{query}"

# 测试数据库异常
try:
    execute_query("")
except QueryError as e:
    print(f"查询错误：{e}")
    print(f"错误代码：{e.error_code}")
    print(f"执行的查询：{e.query}")

try:
    execute_query("DROP TABLE users")
except QueryError as e:
    print(f"查询错误：{e}")
    print(f"错误代码：{e.error_code}")
```

#### 异常链

异常链允许我们将一个异常作为另一个异常的原因，这样可以保留原始错误信息，便于调试和问题追踪。

```python
# 使用raise...from...创建异常链
def read_config_file(filename):
    """读取配置文件
    Args:
        filename (str): 配置文件名

    Returns:
        str: 配置文件内容

    Raises:
        ConfigurationError: 当配置文件不存在时引发，原始FileNotFoundError作为原因
    """
    try:
        with open(filename, "r") as file:
            return file.read()
    except FileNotFoundError as e:
        # 创建新异常并保持原始异常信息
        raise ConfigurationError(f"配置文件 {filename} 不存在") from e

class ConfigurationError(Exception):
    """配置错误"""
    pass

# 测试异常链
try:
    read_config_file("nonexistent_config.ini")
except ConfigurationError as e:
    print(f"捕获到配置错误：{e}")
    print(f"原始异常：{e.__cause__}")
    # 打印完整的异常链
    import traceback
    traceback.print_exc()

# 显式抑制异常链
def suppressed_example():
    """演示如何抑制异常链"""
    try:
        raise ValueError("原始错误")
    except ValueError as e:
        # 使用None抑制异常链
        raise RuntimeError("新错误") from None

try:
    suppressed_example()
except RuntimeError as e:
    print(f"捕获到运行时错误：{e}")
    print(f"是否还有原始异常：{e.__cause__ is None}")  # True

# 自定义异常链
class BusinessLogicError(Exception):
    """业务逻辑错误"""
    def __init__(self, message, underlying_error=None):
        super().__init__(message)
        self.underlying_error = underlying_error

def process_data(data):
    """处理数据
    Args:
        data: 要处理的数据

    Returns:
        str: 处理后的数据

    Raises:
        BusinessLogicError: 当数据处理失败时引发，包含底层错误信息
    """
    try:
        # 假设这里有一些可能失败的处理
        if data is None:
            raise ValueError("数据不能为空")
        return data.upper()
    except Exception as e:
        raise BusinessLogicError("数据处理失败", e)

try:
    process_data(None)
except BusinessLogicError as e:
    print(f"业务逻辑错误：{e}")
    print(f"底层错误：{e.underlying_error}")
```

#### 异常处理的高级技巧

掌握异常处理的高级技巧可以帮助我们编写更高效、更易维护的代码。

```python
# 使用traceback模块获取详细的异常信息
import traceback

def detailed_exception_handling():
    """详细的异常处理示例，展示如何获取完整的异常信息"""
    try:
        # 一些复杂的操作
        data = {"name": "Alice", "age": "twenty-five"}  # 字符串形式的年龄
        age = data["age"] * 2  # 这会失败，因为字符串不能乘2
        return age
    except KeyError as e:
        print(f"键错误：{e}")
        traceback.print_exc()  # 打印堆栈跟踪
    except TypeError as e:
        print(f"类型错误：{e}")
        # 获取详细的异常信息
        exc_type, exc_value, exc_traceback = sys.exc_info()
        print(f"异常类型：{exc_type}")
        print(f"异常值：{exc_value}")
        traceback.print_tb(exc_traceback)
    finally:
        print("清理资源")

import sys
detailed_exception_handling()

# 异常处理中的上下文管理
class DatabaseConnection:
    """模拟数据库连接，演示如何在上下文管理器中处理异常"""
    def __init__(self, db_name):
        """初始化数据库连接
        Args:
            db_name (str): 数据库名称
        """
        self.db_name = db_name
        self.connected = False

    def connect(self):
        """建立数据库连接"""
        print(f"连接到数据库 {self.db_name}")
        self.connected = True
        # 模拟连接失败
        if "bad" in self.db_name:
            raise ConnectionError("无法连接到数据库")

    def disconnect(self):
        """断开数据库连接"""
        if self.connected:
            print(f"断开与数据库 {self.db_name} 的连接")
            self.connected = False

    def __enter__(self):
        """进入上下文管理器"""
        self.connect()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """退出上下文管理器
        Args:
            exc_type: 异常类型
            exc_val: 异常值
            exc_tb: 异常 traceback

        Returns:
            bool: 如果返回True，则抑制异常；返回False（默认）则继续传播异常
        """
        self.disconnect()
        # 如果返回True，则抑制异常
        # return False（默认）则继续传播异常
        return False

# 使用上下文管理器
try:
    with DatabaseConnection("good_db") as conn:
        print("执行数据库操作")
except ConnectionError as e:
    print(f"连接错误：{e}")

# 使用上下文管理器处理异常
try:
    with DatabaseConnection("bad_db") as conn:
        print("执行数据库操作")
except ConnectionError as e:
    print(f"连接错误：{e}")

# 异常处理的性能考虑
import time

def exception_vs_conditional(n):
    """比较异常处理和条件判断的性能
    Args:
        n (int): 循环次数
    """
    # 方法1：使用条件判断
    start = time.time()
    for i in range(n):
        d = {"key": "value"}
        if "key" in d:
            value = d["key"]
    conditional_time = time.time() - start

    # 方法2：使用异常处理
    start = time.time()
    for i in range(n):
        d = {"key": "value"}
        try:
            value = d["key"]
        except KeyError:
            value = None
    exception_time = time.time() - start

    print(f"条件判断时间：{conditional_time:.6f}秒")
    print(f"异常处理时间：{exception_time:.6f}秒")
    print(f"性能差异：{exception_time/conditional_time:.2f}倍")

exception_vs_conditional(100000)

# 异常处理的最佳实践
def best_practice_example():
    """异常处理最佳实践示例，演示良好的异常处理模式"""
    try:
        # 1. 尽量精确地捕获特定异常
        file_path = "example.txt"
        with open(file_path, "r") as file:
            content = file.read()

        # 2. 使用finally或with语句确保资源清理
        # 3. 在except块中执行恢复操作
        print("文件读取成功")

    except FileNotFoundError:
        # 4. 为每种异常类型提供特定的处理
        print(f"文件 {file_path} 不存在，将创建新文件")
        with open(file_path, "w") as file:
            file.write("默认内容")

    except PermissionError:
        print(f"没有权限访问文件 {file_path}")

    except Exception as e:
        # 5. 捕获通用异常作为最后的保障
        print(f"读取文件时发生未知错误：{e}")
        # 记录错误日志
        import logging
        logging.exception("文件读取失败")

    else:
        # 6. 使用else块处理无异常的情况
        print(f"文件内容长度：{len(content)}")

    finally:
        # 7. 使用finally块执行必要的清理
        print("文件操作完成")

best_practice_example()

# 异常重试机制
import random
import time

def retry_on_exception(max_retries=3, delay=1):
    """重试装饰器，用于为可能失败的操作添加重试机制
    Args:
        max_retries (int): 最大重试次数，默认为3次
        delay (int): 重试间隔时间（秒），默认为1秒

    Returns:
        function: 装饰器函数
    """
    def decorator(func):
        def wrapper(*args, **kwargs):
            last_exception = None

            for attempt in range(max_retries):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    last_exception = e
                    if attempt < max_retries - 1:
                        print(f"操作失败（尝试 {attempt + 1}/{max_retries}）：{e}")
                        print(f"{delay}秒后重试...")
                        time.sleep(delay)
                    else:
                        print(f"所有 {max_retries} 次尝试都失败了")

            # 如果所有尝试都失败，重新抛出最后一个异常
            raise last_exception
        return wrapper
    return decorator

# 使用重试装饰器
@retry_on_exception(max_retries=3, delay=1)
def unreliable_operation():
    """不可靠的操作（有概率失败）
    Returns:
        str: 操作成功时返回结果

    Raises:
        ConnectionError: 当操作失败时引发
    """
    if random.random() < 0.7:  # 70%的失败率
        raise ConnectionError("连接超时")
    return "操作成功"

try:
    result = unreliable_operation()
    print(f"最终结果：{result}")
except Exception as e:
    print(f"操作彻底失败：{e}")
```

