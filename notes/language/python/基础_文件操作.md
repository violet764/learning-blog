#### 模块与包

模块和包是Python中组织代码的重要方式，它们允许我们将相关功能组织在一起，提高代码的可维护性和可重用性。

##### 模块基础

```python
# 导入模块的不同方式

# 方式1：导入整个模块
import math
print(f"π的值：{math.pi}")
print(f"平方根：{math.sqrt(16)}")

# 方式2：导入模块中的特定函数或变量
from math import pi, sqrt
print(f"π的值：{pi}")
print(f"平方根：{sqrt(16)}")

# 方式3：导入模块中的所有内容（不推荐，可能导致命名冲突）
from math import *
print(f"正弦值：{sin(pi/2)}")

# 方式4：给模块起别名
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# 方式5：给导入的函数起别名
from math import sqrt as square_root
print(f"平方根：{square_root(9)}")

# 方式6：从子模块中导入
from datetime import datetime, timedelta
from collections import defaultdict, Counter

# 查看模块内容
import sys
print(f"sys模块包含的内容：{dir(sys)[:10]}...")  # 只显示前10个

# 查看模块文档
import math
print(f"math模块文档：{math.__doc__}")

# 查看模块文件位置
import os
print(f"os模块位置：{os.__file__}")

# 模块的内置属性
print(f"math模块名：{math.__name__}")
print(f"math模块作者：{getattr(math, '__author__', '未知')}")
print(f"math模块版本：{getattr(math, '__version__', '未知')}")
```

##### 标准库模块详解

```python
# math模块 - 数学运算
import math

# 基本数学常数
print(f"π: {math.pi}")
print(f"e: {math.e}")
print(f"τ: {math.tau}")  # 2π
print(f"无穷大: {math.inf}")
print(f"非数字: {math.nan}")

# 基本数学函数
print(f"向上取整: {math.ceil(3.14)}")
print(f"向下取整: {math.floor(3.14)}")
print(f"截断: {math.trunc(3.14)}")
print(f"绝对值: {math.fabs(-3.14)}")
print(f"阶乘: {math.factorial(5)}")
print(f"最大公约数: {math.gcd(24, 36)}")

# 幂和对数函数
print(f"2的3次方: {math.pow(2, 3)}")
print(f"平方根: {math.sqrt(16)}")
print(f"自然对数: {math.log(10)}")
print(f"以2为底的对数: {math.log2(10)}")
print(f"以10为底的对数: {math.log10(10)}")

# 三角函数
angle = math.pi / 4  # 45度
print(f"正弦: {math.sin(angle)}")
print(f"余弦: {math.cos(angle)}")
print(f"正切: {math.tan(angle)}")
print(f"反正弦: {math.asin(0.5)}")

# random模块 - 随机数生成
import random

# 基本随机数
print(f"随机浮点数[0,1): {random.random()}")
print(f"随机整数[1,10]: {random.randint(1, 10)}")
print(f"随机整数[1,10): {random.randrange(1, 10)}")

# 从序列中随机选择
items = ['apple', 'banana', 'cherry', 'date']
print(f"随机选择: {random.choice(items)}")
print(f"随机选择多个(不重复): {random.sample(items, 2)}")
print(f"随机选择多个(可能重复): {random.choices(items, k=2)}")

# 打乱序列
numbers = list(range(1, 11))
print(f"原序列: {numbers}")
random.shuffle(numbers)
print(f"打乱后: {numbers}")

# 设置随机种子（保证可重复性）
random.seed(42)
print(f"种子42的随机数: {random.random()}")
random.seed(42)
print(f"重置种子的随机数: {random.random()}")  # 相同

# datetime模块 - 日期和时间
from datetime import datetime, date, time, timedelta

# 获取当前日期和时间
now = datetime.now()
print(f"当前日期时间: {now}")
print(f"格式化日期时间: {now.strftime('%Y-%m-%d %H:%M:%S')}")

# 创建特定日期时间
specific_date = date(2023, 12, 6)
specific_time = time(14, 30, 45)
specific_datetime = datetime(2023, 12, 6, 14, 30, 45)

print(f"特定日期: {specific_date}")
print(f"特定时间: {specific_time}")
print(f"特定日期时间: {specific_datetime}")

# 日期计算
delta = timedelta(days=10, hours=5)
future_date = now + delta
print(f"10天5小时后: {future_date}")

# 日期差值
date1 = date(2023, 12, 6)
date2 = date(2024, 1, 1)
difference = date2 - date1
print(f"日期差: {difference.days}天")

# 字符串解析日期
date_str = "2023-12-06 14:30:45"
parsed_date = datetime.strptime(date_str, "%Y-%m-%d %H:%M:%S")
print(f"解析的日期: {parsed_date}")

# os模块 - 操作系统接口
import os

# 获取当前工作目录
print(f"当前目录: {os.getcwd()}")

# 创建目录
if not os.path.exists("test_dir"):
    os.makedirs("test_dir")
    print("目录创建成功")

# 列出目录内容
print("当前目录内容:")
for item in os.listdir("."):
    item_type = "目录" if os.path.isdir(item) else "文件"
    print(f"  {item} ({item_type})")

# 路径操作
file_path = "test_dir/example.txt"
dir_name = os.path.dirname(file_path)
base_name = os.path.basename(file_path)
print(f"目录名: {dir_name}")
print(f"文件名: {base_name}")

# 环境变量
print(f"PATH环境变量: {os.environ.get('PATH', '未设置')}")
os.environ["MY_VAR"] = "我的变量"
print(f"自定义变量: {os.environ['MY_VAR']}")

# sys模块 - 系统相关参数和函数
import sys

# Python版本信息
print(f"Python版本: {sys.version}")
print(f"版本信息: {sys.version_info}")

# 系统平台
print(f"系统平台: {sys.platform}")

# 命令行参数
print(f"脚本名称: {sys.argv[0]}")
print(f"命令行参数: {sys.argv[1:]}")

# Python路径
print(f"模块搜索路径: {sys.path[:3]}...")  # 显示前3个路径

# 递归深度限制
print(f"递归深度限制: {sys.getrecursionlimit()}")
sys.setrecursionlimit(2000)
print(f"新的递归深度限制: {sys.getrecursionlimit()}")

# collections模块 - 特殊容器数据类型
from collections import namedtuple, Counter, defaultdict, deque, OrderedDict

# namedtuple - 命名元组
Point = namedtuple('Point', ['x', 'y'])
p1 = Point(1, 2)
print(f"点坐标: {p1}")
print(f"x坐标: {p1.x}, y坐标: {p1.y}")

# Counter - 计数器
words = ['apple', 'banana', 'apple', 'cherry', 'banana', 'apple']
word_counts = Counter(words)
print(f"词频统计: {word_counts}")
print(f"最常见的词: {word_counts.most_common(2)}")

# defaultdict - 带默认值的字典
d = defaultdict(list)
d['a'].append(1)
d['a'].append(2)
d['b'].append(3)
print(f"defaultdict: {dict(d)}")

# deque - 双端队列
dq = deque([1, 2, 3])
dq.append(4)     # 右端添加
dq.appendleft(0) # 左端添加
dq.pop()         # 右端删除
dq.popleft()     # 左端删除
print(f"deque: {dq}")

# OrderedDict - 有序字典（Python 3.7+dict默认有序）
od = OrderedDict()
od['first'] = 1
od['second'] = 2
od['third'] = 3
print(f"OrderedDict: {od}")

# itertools模块 - 迭代器工具
import itertools

# count() - 无限计数器
# for i in itertools.count(5):
#     if i > 10:
#         break
#     print(i)

# cycle() - 无限循环
# colors = ['red', 'green', 'blue']
# for i, color in zip(range(6), itertools.cycle(colors)):
#     print(f"{i}: {color}")

# product() - 笛卡尔积
colors = ['red', 'blue']
sizes = ['S', 'M', 'L']
combinations = list(itertools.product(colors, sizes))
print(f"组合: {combinations}")

# permutations() - 排列
items = ['a', 'b', 'c']
perms = list(itertools.permutations(items, 2))
print(f"排列: {perms}")

# combinations() - 组合
combs = list(itertools.combinations(items, 2))
print(f"组合: {combs}")

# groupby() - 分组
data = [('A', 1), ('B', 2), ('A', 3), ('B', 4), ('A', 5)]
for key, group in itertools.groupby(data, lambda x: x[0]):
    print(f"组 {key}: {list(group)}")
```

##### 创建自定义模块

```python
# 创建一个简单的自定义模块 my_module.py

# my_module.py 内容示例：
"""
这是我的自定义模块
提供了一些实用的函数和变量
"""

# 模块级变量
VERSION = "1.0.0"
AUTHOR = "Python开发者"

def greet(name):
    """问候函数"""
    return f"你好, {name}!"

def calculate_area(shape, *args):
    """计算面积"""
    if shape == "rectangle":
        if len(args) != 2:
            raise ValueError("矩形需要长和宽两个参数")
        return args[0] * args[1]
    elif shape == "circle":
        if len(args) != 1:
            raise ValueError("圆形需要半径一个参数")
        import math
        return math.pi * args[0] ** 2
    else:
        raise ValueError(f"不支持的形状: {shape}")

class Calculator:
    """简单计算器类"""
    
    def __init__(self):
        self.history = []
    
    def add(self, a, b):
        result = a + b
        self.history.append(f"{a} + {b} = {result}")
        return result
    
    def subtract(self, a, b):
        result = a - b
        self.history.append(f"{a} - {b} = {result}")
        return result
    
    def get_history(self):
        return self.history.copy()

# 模块初始化代码
print(f"my_module {VERSION} 已加载")

# 使用自定义模块的示例代码：

# 假设上述内容保存在 my_module.py 中

# 使用自定义模块
import my_module

# 使用模块变量
print(f"模块版本: {my_module.VERSION}")
print(f"模块作者: {my_module.AUTHOR}")

# 使用模块函数
greeting = my_module.greet("世界")
print(f"问候: {greeting}")

# 计算面积
rect_area = my_module.calculate_area("rectangle", 5, 3)
print(f"矩形面积: {rect_area}")

circle_area = my_module.calculate_area("circle", 2)
print(f"圆形面积: {circle_area:.2f}")

# 使用模块中的类
calc = my_module.Calculator()
result1 = calc.add(10, 5)
result2 = calc.subtract(10, 5)
print(f"计算历史: {calc.get_history()}")
```

##### 包的结构与使用

```python
# 包是一个包含多个模块的目录
# 典型的包结构示例：

"""
my_package/
├── __init__.py          # 包初始化文件
├── module1.py
├── module2.py
├── subpackage/
│   ├── __init__.py
│   ├── submodule1.py
│   └── submodule2.py
└── data/
    └── config.json
"""

# __init__.py 文件示例

# my_package/__init__.py
"""
我的包初始化文件
定义包的公共接口
"""

# 导入包内的模块
from .module1 import func1
from .module2 import Class2

# 定义包级别变量
PACKAGE_NAME = "my_package"
PACKAGE_VERSION = "1.0.0"

def package_info():
    """返回包信息"""
    return f"{PACKAGE_NAME} v{PACKAGE_VERSION}"

# my_package/module1.py
def func1():
    """模块1的函数1"""
    return "来自模块1的函数1"

def func2():
    """模块1的函数2"""
    return "来自模块1的函数2"

# my_package/module2.py
class Class2:
    """模块2的类"""
    def __init__(self):
        self.value = "来自模块2的类"
    
    def method(self):
        return f"方法调用: {self.value}"

# 使用包的示例

# 导入整个包
import my_package
print(f"包信息: {my_package.package_info()}")

# 导入包中的特定函数
from my_package import func1
print(f"函数调用: {func1()}")

# 导入包中的特定类
from my_package import Class2
obj = Class2()
print(f"类方法调用: {obj.method()}")

# 导入子包中的模块
from my_package.subpackage import submodule1
# submodule1.some_function()

# 使用点号导入
from my_package.module1 import func1 as m1_func1
print(f"别名函数调用: {m1_func1()}")
```

##### 包的安装与分发

```python
# 使用pip安装包

# 基本安装命令（这些是命令行操作，不是Python代码）
# pip install package_name

# 安装特定版本
# pip install package_name==1.0.0

# 安装最新版本
# pip install --upgrade package_name

# 从requirements文件安装
# pip install -r requirements.txt

# 卸载包
# pip uninstall package_name

# 列出已安装的包
# pip list

# 查看包信息
# pip show package_name

# 创建requirements.txt文件
# pip freeze > requirements.txt

# 使用虚拟环境
# python -m venv myenv
# myenv\Scripts\activate (Windows)
# source myenv/bin/activate (Unix/Linux)

# setuptools - 创建分发包

# setup.py 文件示例
"""
from setuptools import setup, find_packages

setup(
    name="my_package",
    version="1.0.0",
    description="我的Python包",
    author="Your Name",
    author_email="your.email@example.com",
    packages=find_packages(),
    install_requires=[
        "numpy>=1.18.0",
        "pandas>=1.0.0",
    ],
    classifiers=[
        "Development Status :: 3 - Alpha",
        "Intended Audience :: Developers",
        "License :: OSI Approved :: MIT License",
        "Programming Language :: Python :: 3",
        "Programming Language :: Python :: 3.8",
        "Programming Language :: Python :: 3.9",
        "Programming Language :: Python :: 3.10",
    ],
    python_requires=">=3.8",
)
"""

# 构建分发包
# python setup.py sdist bdist_wheel

# 本地安装
# pip install .

# 上传到PyPI
# pip install twine
# twine upload dist/*
```

##### 高级模块技术

```python
# 动态导入模块
import importlib

# 动态导入模块
module_name = "math"
math_module = importlib.import_module(module_name)
print(f"动态导入的math模块: {math_module.sqrt(16)}")

# 动态导入函数
from importlib import import_module

def dynamic_import_function(module_name, function_name):
    """动态导入函数"""
    try:
        module = import_module(module_name)
        func = getattr(module, function_name)
        return func
    except (ImportError, AttributeError) as e:
        print(f"导入失败: {e}")
        return None

# 动态调用函数
sqrt_func = dynamic_import_function("math", "sqrt")
if sqrt_func:
    print(f"动态调用: {sqrt_func(25)}")

# 模块重载
import importlib
import my_module  # 假设已经导入

# 重新加载模块（修改模块后有用）
importlib.reload(my_module)

# 检查模块是否已加载
import sys
print(f"math模块在sys.modules中: {'math' in sys.modules}")

# 插件系统示例

# plugin_manager.py
class PluginManager:
    """插件管理器"""
    
    def __init__(self):
        self.plugins = {}
    
    def load_plugin(self, plugin_name, plugin_path):
        """加载插件"""
        try:
            spec = importlib.util.spec_from_file_location(plugin_name, plugin_path)
            module = importlib.util.module_from_spec(spec)
            sys.modules[plugin_name] = module
            spec.loader.exec_module(module)
            
            # 检查插件是否有必需的接口
            if hasattr(module, 'register') and hasattr(module, 'unregister'):
                self.plugins[plugin_name] = module
                module.register()
                print(f"插件 {plugin_name} 加载成功")
                return True
            else:
                print(f"插件 {plugin_name} 缺少必需的接口")
                return False
        except Exception as e:
            print(f"加载插件 {plugin_name} 失败: {e}")
            return False
    
    def unload_plugin(self, plugin_name):
        """卸载插件"""
        if plugin_name in self.plugins:
            try:
                self.plugins[plugin_name].unregister()
                del self.plugins[plugin_name]
                print(f"插件 {plugin_name} 卸载成功")
                return True
            except Exception as e:
                print(f"卸载插件 {plugin_name} 失败: {e}")
                return False
        else:
            print(f"插件 {plugin_name} 未加载")
            return False
    
    def list_plugins(self):
        """列出所有插件"""
        return list(self.plugins.keys())

# 创建一个简单的插件示例

# sample_plugin.py
def register():
    """注册插件"""
    print("示例插件已注册")

def unregister():
    """注销插件"""
    print("示例插件已注销")

def process_data(data):
    """处理数据"""
    return data.upper()

# 使用插件管理器
# manager = PluginManager()
# manager.load_plugin("sample_plugin", "sample_plugin.py")
# plugins = manager.list_plugins()
# print(f"已加载的插件: {plugins}")

# 模块缓存与性能优化
import time
import functools

# 缓存模块导入结果
@functools.lru_cache(maxsize=32)
def cached_import(module_name):
    """缓存模块导入"""
    start = time.time()
    module = importlib.import_module(module_name)
    end = time.time()
    print(f"导入模块 {module_name} 耗时: {end - start:.6f}秒")
    return module

# 测试缓存效果
cached_import("math")
cached_import("math")  # 第二次会使用缓存

# 条件导入
def try_import(module_name, fallback=None):
    """尝试导入模块，失败时返回回退值"""
    try:
        return importlib.import_module(module_name)
    except ImportError:
        print(f"模块 {module_name} 不可用，使用回退方案")
        return fallback

# 使用回退导入
optional_module = try_import("optional_dependency")
if optional_module is None:
    # 使用内置功能作为回退
    pass

# 延迟导入
class LazyImporter:
    """延迟导入器"""
    
    def __init__(self, module_name):
        self.module_name = module_name
        self._module = None
    
    def __getattr__(self, name):
        if self._module is None:
            self._module = importlib.import_module(self.module_name)
        return getattr(self._module, name)

# 使用延迟导入
heavy_module = LazyImporter("heavy_dependency")
# 只有在真正使用时才会导入模块
# some_func = heavy_module.some_function

# 运行时生成模块
import types

def create_module(name, functions):
    """动态创建模块"""
    module = types.ModuleType(name)
    
    for func_name, func in functions.items():
        setattr(module, func_name, func)
    
    return module

# 创建自定义模块
custom_functions = {
    "add": lambda a, b: a + b,
    "multiply": lambda a, b: a * b,
    "greet": lambda name: f"Hello, {name}!"
}

my_dynamic_module = create_module("dynamic_module", custom_functions)
print(f"动态模块加法: {my_dynamic_module.add(5, 3)}")
print(f"动态模块乘法: {my_dynamic_module.multiply(5, 3)}")
```




#### 文件操作

Python提供了强大的文件操作功能，可以处理各种类型的文件和不同的文件操作模式。

##### 基本文件操作

```python
# 文件的打开模式
# 'r' - 读取（默认）
# 'w' - 写入（覆盖已有内容）
# 'a' - 追加
# 'r+' - 读写
# 'b' - 二进制模式
# 't' - 文本模式（默认）

# 基本写入操作
with open("example.txt", "w", encoding="utf-8") as file:
    file.write("第一行内容\n")
    file.write("第二行内容\n")
    file.write("第三行内容\n")

# 基本读取操作
with open("example.txt", "r", encoding="utf-8") as file:
    # 读取全部内容
    content = file.read()
    print("全部内容：")
    print(content)

# 逐行读取
with open("example.txt", "r", encoding="utf-8") as file:
    print("逐行读取：")
    for line in file:
        print(f"行内容：{line.strip()}")

# 读取所有行到列表
with open("example.txt", "r", encoding="utf-8") as file:
    lines = file.readlines()
    print(f"所有行：{lines}")
    # 去除每行的换行符
    clean_lines = [line.strip() for line in lines]
    print(f"清理后的行：{clean_lines}")

# 追加内容
with open("example.txt", "a", encoding="utf-8") as file:
    file.write("追加的内容\n")
    file.write("另一行追加内容\n")

# 读写操作
with open("example.txt", "r+", encoding="utf-8") as file:
    content = file.read()
    print(f"读取内容：{content}")
    file.write("新追加的内容\n")
    file.seek(0)  # 回到文件开头
    new_content = file.read()
    print(f"追加后的内容：{new_content}")
```

##### 文件的上下文管理器与错误处理

```python
# 使用with语句自动管理文件资源
def safe_file_read(filename):
    try:
        with open(filename, "r", encoding="utf-8") as file:
            content = file.read()
            return content
    except FileNotFoundError:
        print(f"错误：文件 {filename} 不存在")
        return None
    except PermissionError:
        print(f"错误：没有权限访问文件 {filename}")
        return None
    except UnicodeDecodeError:
        print(f"错误：文件 {filename} 编码问题")
        return None
    except Exception as e:
        print(f"未知错误：{e}")
        return None

content = safe_file_read("nonexistent.txt")

# 多种异常处理方式
def advanced_file_operations(filename, mode="r"):
    try:
        with open(filename, mode, encoding="utf-8") as file:
            if mode == "r":
                return file.read()
            elif mode in ["w", "a"]:
                return "文件已准备写入"
            else:
                raise ValueError(f"不支持的文件模式：{mode}")
    except FileNotFoundError:
        # 对于写入模式，文件不存在是正常的
        if mode in ["w", "a"]:
            print(f"文件 {filename} 不存在，将创建新文件")
            with open(filename, mode, encoding="utf-8") as file:
                return "文件已创建并准备写入"
        else:
            print(f"错误：文件 {filename} 不存在")
            return None
    except IsADirectoryError:
        print(f"错误：{filename} 是一个目录，不是文件")
        return None
    except Exception as e:
        print(f"文件操作出错：{e}")
        return None

# 确保文件路径存在
import os

def ensure_directory_exists(filepath):
    """确保文件的目录存在"""
    directory = os.path.dirname(filepath)
    if directory and not os.path.exists(directory):
        os.makedirs(directory)
        print(f"创建目录：{directory}")

# 安全的文件写入
def safe_file_write(filename, content):
    ensure_directory_exists(filename)
    try:
        with open(filename, "w", encoding="utf-8") as file:
            file.write(content)
        return True
    except Exception as e:
        print(f"写入文件时出错：{e}")
        return False

# 测试安全写入
safe_file_write("output/subdir/example.txt", "这是子目录中的文件\n多行内容")
```

##### 文件的指针操作

```python
# 创建测试文件
with open("pointer_test.txt", "w", encoding="utf-8") as file:
    file.write("12345\n")
    file.write("67890\n")
    file.write("abcde\n")
    file.write("fghij\n")

# 文件指针操作
with open("pointer_test.txt", "r", encoding="utf-8") as file:
    # 获取当前指针位置
    print(f"初始指针位置：{file.tell()}")  # 0
    
    # 读取前5个字符
    first_five = file.read(5)
    print(f"前5个字符：'{first_five}'")
    print(f"读取后指针位置：{file.tell()}")  # 5
    
    # 移动指针到文件开头
    file.seek(0)
    print(f"回到开头后指针位置：{file.tell()}")  # 0
    
    # 读取一行
    first_line = file.readline()
    print(f"第一行：'{first_line.strip()}'")
    print(f"读取一行后指针位置：{file.tell()}")  # 6（包括换行符）
    
    # 移动到特定位置
    file.seek(10)  # 移动到第10个字节
    content_from_10 = file.read()
    print(f"从位置10开始的内容：'{content_from_10.strip()}'")
    
    # 相对当前位置移动
    current_pos = file.tell()
    file.seek(current_pos + 5)
    content_after_relative = file.read()
    print(f"从相对位置开始的内容：'{content_after_relative.strip()}'")
    
    # 移动到文件末尾
    file.seek(0, 2)  # 2表示从文件末尾开始
    print(f"文件末尾位置：{file.tell()}")
    
    # 获取文件大小
    file.seek(0, 2)  # 移动到末尾
    file_size = file.tell()
    print(f"文件大小：{file_size} 字节")

# 读取文件的特定部分
def read_file_section(filename, start_byte, length):
    """读取文件的特定部分"""
    with open(filename, "rb") as file:  # 使用二进制模式精确控制
        file.seek(start_byte)
        return file.read(length)

section_content = read_file_section("pointer_test.txt", 5, 10)
print(f"文件5-15字节的内容：{section_content}")
```

##### 二进制文件操作

```python
# 写入二进制数据
data = bytes([65, 66, 67, 68, 69])  # A B C D E的ASCII码

with open("binary_data.bin", "wb") as file:
    file.write(data)

# 读取二进制数据
with open("binary_data.bin", "rb") as file:
    binary_content = file.read()
    print(f"二进制数据：{binary_content}")
    print(f"转换为字符串：{binary_content.decode('ascii')}")

# 处理结构化的二进制数据
import struct

# 创建二进制结构
name = "Alice"
age = 25
height = 165.5

# 打包为二进制数据
packed_data = struct.pack("5sif", name.encode(), age, height)
with open("person.bin", "wb") as file:
    file.write(packed_data)

# 读取并解析二进制数据
with open("person.bin", "rb") as file:
    data = file.read()
    unpacked_name, unpacked_age, unpacked_height = struct.unpack("5sif", data)
    print(f"姓名：{unpacked_name.decode().strip()}")
    print(f"年龄：{unpacked_age}")
    print(f"身高：{unpacked_height}")

# 处理大文件的分块读写
def copy_large_file_chunkwise(source, destination, chunk_size=8192):
    """分块复制大文件"""
    try:
        with open(source, "rb") as src, open(destination, "wb") as dst:
            while True:
                chunk = src.read(chunk_size)
                if not chunk:
                    break
                dst.write(chunk)
        print(f"文件 {source} 成功复制到 {destination}")
        return True
    except Exception as e:
        print(f"复制文件时出错：{e}")
        return False

# 创建测试大文件
with open("large_test.txt", "w") as file:
    file.write("测试数据\n" * 10000)

# 测试分块复制
copy_large_file_chunkwise("large_test.txt", "large_test_copy.txt")
```

##### 文件系统操作

```python
import os
import shutil
from pathlib import Path

# 使用os模块进行文件系统操作

# 检查文件/目录是否存在
print(f"example.txt存在：{os.path.exists('example.txt')}")
print(f"nonexistent.txt存在：{os.path.exists('nonexistent.txt')}")

# 检查是否为文件或目录
print(f"example.txt是文件：{os.path.isfile('example.txt')}")
print(f".是目录：{os.path.isdir('.')}")

# 获取文件信息
if os.path.exists("example.txt"):
    file_size = os.path.getsize("example.txt")
    file_mtime = os.path.getmtime("example.txt")
    import datetime
    modified_time = datetime.datetime.fromtimestamp(file_mtime)
    print(f"文件大小：{file_size} 字节")
    print(f"修改时间：{modified_time}")

# 获取当前工作目录
current_dir = os.getcwd()
print(f"当前目录：{current_dir}")

# 创建目录
if not os.path.exists("test_directory"):
    os.makedirs("test_directory/subdir", exist_ok=True)
    print("目录创建成功")

# 列出目录内容
print("当前目录内容：")
for item in os.listdir("."):
    item_path = os.path.join(".", item)
    item_type = "目录" if os.path.isdir(item_path) else "文件"
    print(f"  {item} ({item_type})")

# 删除文件和目录
# 删除文件
if os.path.exists("temp_file.txt"):
    os.remove("temp_file.txt")
    print("临时文件已删除")

# 删除空目录
if os.path.exists("empty_dir"):
    os.rmdir("empty_dir")
    print("空目录已删除")

# 删除非空目录
if os.path.exists("test_directory"):
    shutil.rmtree("test_directory")
    print("非空目录已删除")

# 使用pathlib（更现代的文件系统操作）
from pathlib import Path

# 创建Path对象
current_path = Path(".")
file_path = Path("example.txt")
new_dir_path = Path("new_directory")

# Path对象的方法
print(f"当前目录：{current_path.resolve()}")
print(f"文件路径：{file_path}")
print(f"文件名：{file_path.name}")
print(f"文件后缀：{file_path.suffix}")
print(f"文件目录：{file_path.parent}")

# 创建目录
new_dir_path.mkdir(exist_ok=True)
print(f"目录 {new_dir_path} 创建成功")

# 遍历目录
print("目录结构：")
for path in current_path.rglob("*.txt"):  # 递归查找所有txt文件
    print(f"  {path}")

# 复制和移动文件
shutil.copy("example.txt", "example_copy.txt")  # 复制文件
shutil.move("example_copy.txt", "moved_example.txt")  # 移动文件

# 获取文件扩展名
def get_file_extension(filename):
    """获取文件扩展名"""
    return Path(filename).suffix

print(f"example.txt的扩展名：{get_file_extension('example.txt')}")
print(f"archive.tar.gz的扩展名：{Path('archive.tar.gz').suffix}")
print(f"archive.tar.gz的所有扩展名：{''.join(Path('archive.tar.gz').suffixes)}")
```

##### 高级文件操作

```python
# 文件的临时操作
import tempfile

# 创建临时文件
with tempfile.NamedTemporaryFile(mode='w', delete=False) as temp:
    temp.write("这是临时文件内容\n")
    temp_path = temp.name
    print(f"临时文件路径：{temp_path}")

# 临时文件不会被自动删除（因为delete=False）
with open(temp_path, 'r') as f:
    print(f"临时文件内容：{f.read()}")

# 创建临时目录
with tempfile.TemporaryDirectory() as temp_dir:
    temp_file_path = os.path.join(temp_dir, "temp.txt")
    with open(temp_file_path, 'w') as f:
        f.write("临时目录中的文件")
    print(f"临时目录：{temp_dir}")
    print(f"临时目录内容：{os.listdir(temp_dir)}")
    # 临时目录在with块结束后自动删除

# 文件压缩
import zipfile
import gzip
import tarfile

# ZIP文件操作
with zipfile.ZipFile("example.zip", "w", zipfile.ZIP_DEFLATED) as zipf:
    zipf.write("example.txt")
    zipf.write("pointer_test.txt")
    # 添加字符串内容
    zipf.writestr("internal.txt", "这是ZIP文件内的文件")

# 读取ZIP文件
with zipfile.ZipFile("example.zip", "r") as zipf:
    print("ZIP文件内容：")
    for name in zipf.namelist():
        print(f"  {name}")
        # 读取ZIP内的文件内容
        with zipf.open(name) as f:
            content = f.read().decode('utf-8')
            print(f"    {name[:20]}...: {content[:50]}...")

# GZIP压缩
with open("example.txt", "rb") as f_in:
    with gzip.open("example.txt.gz", "wb") as f_out:
        shutil.copyfileobj(f_in, f_out)

# 读取GZIP文件
with gzip.open("example.txt.gz", "rt", encoding="utf-8") as f:
    content = f.read()
    print(f"GZIP文件内容：{content[:100]}...")

# 文件哈希计算
import hashlib

def calculate_file_hash(filename, hash_algorithm="md5"):
    """计算文件的哈希值"""
    hash_obj = hashlib.new(hash_algorithm)
    with open(filename, "rb") as file:
        # 分块读取大文件
        for chunk in iter(lambda: file.read(4096), b""):
            hash_obj.update(chunk)
    return hash_obj.hexdigest()

if os.path.exists("example.txt"):
    md5_hash = calculate_file_hash("example.txt", "md5")
    sha256_hash = calculate_file_hash("example.txt", "sha256")
    print(f"example.txt的MD5：{md5_hash}")
    print(f"example.txt的SHA256：{sha256_hash}")

# 监控文件变化
import time

def monitor_file_changes(filename, interval=1):
    """监控文件变化"""
    last_mtime = os.path.getmtime(filename) if os.path.exists(filename) else 0
    print(f"开始监控文件：{filename}")
    
    try:
        while True:
            if os.path.exists(filename):
                current_mtime = os.path.getmtime(filename)
                if current_mtime > last_mtime:
                    print(f"文件 {filename} 已修改（{time.ctime(current_mtime)}）")
                    last_mtime = current_mtime
            else:
                print(f"文件 {filename} 已删除")
                break
            time.sleep(interval)
    except KeyboardInterrupt:
        print(f"停止监控文件：{filename}")

# 注释掉实际运行，避免脚本阻塞
# monitor_file_changes("example.txt")

# 文件备份功能
import datetime

def backup_file(filename, backup_dir="backups"):
    """备份文件"""
    if not os.path.exists(filename):
        print(f"文件 {filename} 不存在")
        return False
    
    # 创建备份目录
    os.makedirs(backup_dir, exist_ok=True)
    
    # 生成备份文件名（包含时间戳）
    timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
    backup_name = f"{Path(filename).stem}_{timestamp}{Path(filename).suffix}"
    backup_path = os.path.join(backup_dir, backup_name)
    
    try:
        shutil.copy2(filename, backup_path)
        print(f"文件已备份到：{backup_path}")
        return True
    except Exception as e:
        print(f"备份失败：{e}")
        return False

# 执行备份
backup_file("example.txt")

# 文件的原子性操作
import fcntl

def atomic_write(filename, content):
    """原子性写入文件（适用于Unix-like系统）"""
    temp_file = f"{filename}.tmp"
    
    try:
        with open(temp_file, "w", encoding="utf-8") as f:
            # 获取文件锁
            fcntl.flock(f.fileno(), fcntl.LOCK_EX)
            f.write(content)
            f.flush()  # 确保内容写入磁盘
            os.fsync(f.fileno())  # 强制同步
        
        # 原子性重命名
        os.replace(temp_file, filename)
        print(f"内容已原子性写入文件：{filename}")
        return True
    except Exception as e:
        print(f"原子性写入失败：{e}")
        return False

# 在Windows系统上可以使用类似的原子性操作
def atomic_write_windows(filename, content):
    """Windows系统的原子性写入"""
    temp_file = f"{filename}.tmp"
    
    try:
        with open(temp_file, "w", encoding="utf-8") as f:
            f.write(content)
            f.flush()
            os.fsync(f.fileno())
        
        # Windows上的原子性重命名
        os.replace(temp_file, filename)
        print(f"内容已原子性写入文件：{filename}")
        return True
    except Exception as e:
        print(f"原子性写入失败：{e}")
        return False
```

#### 异常处理

异常处理是Python中处理错误和异常情况的重要机制，它允许程序在遇到错误时优雅地处理，而不是直接崩溃。

##### 基本异常结构

```python
# try-except基本结构
try:
    # 可能引发异常的代码
    num1 = int(input("请输入第一个数字："))
    num2 = int(input("请输入第二个数字："))
    result = num1 / num2
    print(f"结果是：{result}")
except ValueError:
    # 处理特定异常
    print("请输入有效的数字！")
except ZeroDivisionError:
    # 处理除零错误
    print("不能除以零！")
except Exception as e:
    # 处理所有其他异常
    print(f"发生未知错误：{e}")
else:
    # 没有异常时执行
    print("计算成功完成！")
finally:
    # 无论是否有异常都会执行
    print("程序执行完毕。")

# 单个except处理多种异常
try:
    # 一些可能产生多种异常的代码
    x = int("abc")  # ValueError
    # y = 10 / 0   # ZeroDivisionError（被上一行阻止）
except (ValueError, ZeroDivisionError) as e:
    print(f"发生了错误：{e}")
    print(f"错误类型：{type(e).__name__}")

# 没有异常类名（捕获所有异常，不推荐）
try:
    risky_operation()
except:
    print("发生了某种异常")  # 隐藏了错误信息，难以调试
```

##### 常见内置异常类型

```python
# ValueError - 值错误
try:
    num = int("abc")
except ValueError as e:
    print(f"ValueError: {e}")

# TypeError - 类型错误
try:
    result = "5" + 3  # 字符串不能与数字相加
except TypeError as e:
    print(f"TypeError: {e}")

# IndexError - 索引错误
try:
    items = [1, 2, 3]
    item = items[5]  # 超出列表范围
except IndexError as e:
    print(f"IndexError: {e}")

# KeyError - 键错误
try:
    data = {"name": "Alice", "age": 25}
    value = data["salary"]  # 键不存在
except KeyError as e:
    print(f"KeyError: {e}")

# AttributeError - 属性错误
try:
    text = "hello"
    length = text.len()  # 字符串没有len方法
except AttributeError as e:
    print(f"AttributeError: {e}")

# FileNotFoundError - 文件未找到错误
try:
    with open("nonexistent.txt", "r") as file:
        content = file.read()
except FileNotFoundError as e:
    print(f"FileNotFoundError: {e}")

# PermissionError - 权限错误
try:
    # 尝试访问可能没有权限的文件
    with open("/etc/passwd", "r") as file:  # Linux系统
        content = file.read()
except PermissionError as e:
    print(f"PermissionError: {e}")
except FileNotFoundError:
    print("文件不存在")

# ZeroDivisionError - 除零错误
try:
    result = 10 / 0
except ZeroDivisionError as e:
    print(f"ZeroDivisionError: {e}")

# ImportError - 导入错误
try:
    import nonexistent_module
except ImportError as e:
    print(f"ImportError: {e}")

# MemoryError - 内存错误（模拟）
try:
    # 尝试分配大量内存（注意：这可能会导致系统问题）
    # large_list = [0] * 10**10  # 可能导致MemoryError
    print("跳过内存分配测试")
except MemoryError as e:
    print(f"MemoryError: {e}")

# OverflowError - 溢出错误
import math
try:
    result = math.exp(1000)  # 数值太大
except OverflowError as e:
    print(f"OverflowError: {e}")

# StopIteration - 迭代器耗尽
iterator = iter([1, 2, 3])
try:
    while True:
        item = next(iterator)
        print(item)
    next(iterator)  # 迭代器已耗尽
except StopIteration as e:
    print(f"StopIteration: 迭代器已耗尽")
```

##### 自定义异常

```python
# 定义自定义异常类
class InvalidAgeError(Exception):
    """年龄无效异常"""
    def __init__(self, age):
        self.age = age
        self.message = f"无效的年龄：{age}。年龄必须在0-120之间"
        super().__init__(self.message)

class DuplicateUserError(Exception):
    """用户重复异常"""
    def __init__(self, username):
        self.username = username
        super().__init__(f"用户名'{username}'已存在")

# 使用自定义异常
def validate_age(age):
    """验证年龄"""
    if not isinstance(age, (int, float)):
        raise TypeError("年龄必须是数字")
    if age < 0 or age > 120:
        raise InvalidAgeError(age)
    return True

# 测试自定义异常
try:
    validate_age(-5)
except InvalidAgeError as e:
    print(f"捕获到自定义异常：{e}")

try:
    validate_age("abc")
except TypeError as e:
    print(f"捕获到类型错误：{e}")

# 更复杂的自定义异常类
class DatabaseError(Exception):
    """数据库错误基类"""
    def __init__(self, message, error_code=None):
        super().__init__(message)
        self.error_code = error_code

class ConnectionError(DatabaseError):
    """连接错误"""
    pass

class QueryError(DatabaseError):
    """查询错误"""
    def __init__(self, message, query=None, error_code=None):
        super().__init__(message, error_code)
        self.query = query

# 使用数据库异常类
def execute_query(query):
    """模拟执行数据库查询"""
    if not query:
        raise QueryError("查询不能为空", query=query, error_code=1001)
    if query.upper().startswith("DROP"):
        raise QueryError("不允许的查询操作", query=query, error_code=1002)
    return f"查询结果：{query}"

# 测试数据库异常
try:
    execute_query("")
except QueryError as e:
    print(f"查询错误：{e}")
    print(f"错误代码：{e.error_code}")
    print(f"执行的查询：{e.query}")

try:
    execute_query("DROP TABLE users")
except QueryError as e:
    print(f"查询错误：{e}")
    print(f"错误代码：{e.error_code}")
```

##### 异常链

```python
# 使用raise...from...创建异常链
def read_config_file(filename):
    """读取配置文件"""
    try:
        with open(filename, "r") as file:
            return file.read()
    except FileNotFoundError as e:
        # 创建新异常并保持原始异常信息
        raise ConfigurationError(f"配置文件 {filename} 不存在") from e

class ConfigurationError(Exception):
    """配置错误"""
    pass

# 测试异常链
try:
    read_config_file("nonexistent_config.ini")
except ConfigurationError as e:
    print(f"捕获到配置错误：{e}")
    print(f"原始异常：{e.__cause__}")
    # 打印完整的异常链
    import traceback
    traceback.print_exc()

# 显式抑制异常链
def suppressed_example():
    try:
        raise ValueError("原始错误")
    except ValueError as e:
        # 使用None抑制异常链
        raise RuntimeError("新错误") from None

try:
    suppressed_example()
except RuntimeError as e:
    print(f"捕获到运行时错误：{e}")
    print(f"是否还有原始异常：{e.__cause__ is None}")  # True

# 自定义异常链
class BusinessLogicError(Exception):
    """业务逻辑错误"""
    def __init__(self, message, underlying_error=None):
        super().__init__(message)
        self.underlying_error = underlying_error

def process_data(data):
    """处理数据"""
    try:
        # 假设这里有一些可能失败的处理
        if data is None:
            raise ValueError("数据不能为空")
        return data.upper()
    except Exception as e:
        raise BusinessLogicError("数据处理失败", e)

try:
    process_data(None)
except BusinessLogicError as e:
    print(f"业务逻辑错误：{e}")
    print(f"底层错误：{e.underlying_error}")
```

##### 异常处理的高级技巧

```python
# 使用traceback模块获取详细的异常信息
import traceback

def detailed_exception_handling():
    """详细的异常处理示例"""
    try:
        # 一些复杂的操作
        data = {"name": "Alice", "age": "twenty-five"}  # 字符串形式的年龄
        age = data["age"] * 2  # 这会失败，因为字符串不能乘2
        return age
    except KeyError as e:
        print(f"键错误：{e}")
        traceback.print_exc()  # 打印堆栈跟踪
    except TypeError as e:
        print(f"类型错误：{e}")
        # 获取详细的异常信息
        exc_type, exc_value, exc_traceback = sys.exc_info()
        print(f"异常类型：{exc_type}")
        print(f"异常值：{exc_value}")
        traceback.print_tb(exc_traceback)
    finally:
        print("清理资源")

import sys
detailed_exception_handling()

# 异常处理中的上下文管理
class DatabaseConnection:
    """模拟数据库连接"""
    def __init__(self, db_name):
        self.db_name = db_name
        self.connected = False
    
    def connect(self):
        print(f"连接到数据库 {self.db_name}")
        self.connected = True
        # 模拟连接失败
        if "bad" in self.db_name:
            raise ConnectionError("无法连接到数据库")
    
    def disconnect(self):
        if self.connected:
            print(f"断开与数据库 {self.db_name} 的连接")
            self.connected = False
    
    def __enter__(self):
        self.connect()
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.disconnect()
        # 如果返回True，则抑制异常
        # return False（默认）则继续传播异常
        return False

# 使用上下文管理器
try:
    with DatabaseConnection("good_db") as conn:
        print("执行数据库操作")
except ConnectionError as e:
    print(f"连接错误：{e}")

# 使用上下文管理器处理异常
try:
    with DatabaseConnection("bad_db") as conn:
        print("执行数据库操作")
except ConnectionError as e:
    print(f"连接错误：{e}")

# 异常处理的性能考虑
import time

def exception_vs_conditional(n):
    """比较异常处理和条件判断的性能"""
    
    # 方法1：使用条件判断
    start = time.time()
    for i in range(n):
        d = {"key": "value"}
        if "key" in d:
            value = d["key"]
    conditional_time = time.time() - start
    
    # 方法2：使用异常处理
    start = time.time()
    for i in range(n):
        d = {"key": "value"}
        try:
            value = d["key"]
        except KeyError:
            value = None
    exception_time = time.time() - start
    
    print(f"条件判断时间：{conditional_time:.6f}秒")
    print(f"异常处理时间：{exception_time:.6f}秒")
    print(f"性能差异：{exception_time/conditional_time:.2f}倍")

exception_vs_conditional(100000)

# 异常处理的最佳实践
def best_practice_example():
    """异常处理最佳实践示例"""
    try:
        # 1. 尽量精确地捕获特定异常
        file_path = "example.txt"
        with open(file_path, "r") as file:
            content = file.read()
        
        # 2. 使用finally或with语句确保资源清理
        # 3. 在except块中执行恢复操作
        print("文件读取成功")
        
    except FileNotFoundError:
        # 4. 为每种异常类型提供特定的处理
        print(f"文件 {file_path} 不存在，将创建新文件")
        with open(file_path, "w") as file:
            file.write("默认内容")
            
    except PermissionError:
        print(f"没有权限访问文件 {file_path}")
        
    except Exception as e:
        # 5. 捕获通用异常作为最后的保障
        print(f"读取文件时发生未知错误：{e}")
        # 记录错误日志
        import logging
        logging.exception("文件读取失败")
        
    else:
        # 6. 使用else块处理无异常的情况
        print(f"文件内容长度：{len(content)}")
        
    finally:
        # 7. 使用finally块执行必要的清理
        print("文件操作完成")

best_practice_example()

# 异常重试机制
import random
import time

def retry_on_exception(max_retries=3, delay=1):
    """重试装饰器"""
    def decorator(func):
        def wrapper(*args, **kwargs):
            last_exception = None
            
            for attempt in range(max_retries):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    last_exception = e
                    if attempt < max_retries - 1:
                        print(f"操作失败（尝试 {attempt + 1}/{max_retries}）：{e}")
                        print(f"{delay}秒后重试...")
                        time.sleep(delay)
                    else:
                        print(f"所有 {max_retries} 次尝试都失败了")
            
            # 如果所有尝试都失败，重新抛出最后一个异常
            raise last_exception
        return wrapper
    return decorator

# 使用重试装饰器
@retry_on_exception(max_retries=3, delay=1)
def unreliable_operation():
    """不可靠的操作（有概率失败）"""
    if random.random() < 0.7:  # 70%的失败率
        raise ConnectionError("连接超时")
    return "操作成功"

try:
    result = unreliable_operation()
    print(f"最终结果：{result}")
except Exception as e:
    print(f"操作彻底失败：{e}")
```

