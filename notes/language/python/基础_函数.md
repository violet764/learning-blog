# Python 基础：函数

> 函数是 Python 中组织代码的基本单元，它允许我们将相关的代码组织在一起，提高代码的可重用性和可维护性。掌握函数的各种用法对于编写高质量 Python 代码至关重要。

---

##  函数定义与调用

函数是一段可重复使用的代码块，它接受输入（参数），执行特定操作，然后返回结果。函数可以帮助我们将复杂的问题分解为更小的、可管理的部分。

在 Python 中，我们使用 `def` 关键字来定义函数。

```python
# 基本函数定义
def greet(name):
    """问候函数

    Args:
        name (str): 要问候的人名

    Returns:
        str: 包含问候语的字符串
    """
    return f"你好, {name}!"

# 调用函数
print(greet("小明"))  # 输出: 你好, 小明!
```

### 函数参数类型

Python 函数支持多种参数类型，让函数调用更加灵活：

**位置参数**：按顺序传递的参数
```python
def introduce(name, age):
    return f"我叫{name}，今年{age}岁"

introduce("张三", 25)  # 位置参数
```

**默认参数**：参数有默认值，调用时可以省略
```python
def introduce(name, age=25):
    return f"我叫{name}，今年{age}岁"

introduce("张三")      # 使用默认值 25
introduce("李四", 30)  # 传入新值
```

**可变参数**：接收任意数量的参数
```python
# *args - 可变位置参数（接收为元组）
def sum_all(*numbers):
    return sum(numbers)

sum_all(1, 2, 3, 4, 5)  # numbers = (1, 2, 3, 4, 5)

# **kwargs - 可变关键字参数（接收为字典）
def create_profile(**kwargs):
    return kwargs

create_profile(name="张三", age=25, city="北京")
# 返回: {'name': '张三', 'age': 25, 'city': '北京'}
```

---

##  匿名函数（Lambda）


Lambda 是 Python 中的匿名函数，它是一段简单的表达式，不能包含复杂的逻辑。Lambda 函数适用于需要简短函数的场景，如排序、映射等。

**语法格式**：
```python
lambda 参数列表: 表达式
```

**Lambda 的使用场景**

```python
# 场景1：简单计算
square = lambda x: x ** 2
print(square(5))  # 25

# 场景2：多参数
add = lambda x, y: x + y
print(add(3, 4))  # 7

# 场景3：条件表达式
max_num = lambda x, y: x if x > y else y
print(max_num(10, 20))  # 20

# 场景4：作为函数参数
numbers = [1, 5, 3, 8, 2]
sorted_nums = sorted(numbers, key=lambda x: -x)  # 降序排序
print(sorted_nums)  # [8, 5, 3, 2, 1]

# 场景5：与内置函数配合
# map() - 对每个元素执行操作
squared = list(map(lambda x: x ** 2, range(5)))
print(squared)  # [0, 1, 4, 9, 16]

# filter() - 过滤元素
evens = list(filter(lambda x: x % 2 == 0, range(10)))
print(evens)  # [0, 2, 4, 6, 8]

# reduce() - 累积计算
from functools import reduce
product = reduce(lambda x, y: x * y, [1, 2, 3, 4])
print(product)  # 24
```

**Lambda 的局限性**

Lambda 函数只能包含单个表达式，不能包含语句（如 if、for、while）。对于复杂逻辑，应该使用常规函数。

---

## 作用域与 LEGB 规则

作用域是指变量在程序中可以被访问的区域。Python 中变量的作用域决定了变量的生命周期和可见性。

**LEGB 规则**

Python 中变量的查找顺序遵循 LEGB 规则：

1. **L (Local)** - 局部作用域：函数内部定义的变量
2. **E (Enclosing)** - 闭包作用域：外层函数的变量
3. **G (Global)** - 全局作用域：模块（文件）级别的变量
4. **B (Built-in)** - 内置作用域：Python 内置的函数和异常

```python
# 全局变量
global_var = "全局变量"

def outer_function():
    """外层函数 - 定义闭包作用域"""
    enclosing_var = "闭包变量"

    def inner_function():
        """内层函数 - 定义局部作用域"""
        local_var = "局部变量"

        # 访问各层变量
        print(f"局部变量: {local_var}")
        print(f"闭包变量: {enclosing_var}")
        print(f"全局变量: {global_var}")
        print(f"内置变量: {abs(-5)}")  # abs 是内置函数

        # 修改闭包变量（需要 nonlocal）
        nonlocal enclosing_var
        enclosing_var = "修改后的闭包变量"

        # 修改全局变量（需要 global）
        global global_var
        global_var = "修改后的全局变量"

    inner_function()
    print(f"外层函数中: {enclosing_var}")

outer_function()
print(f"全局变量: {global_var}")
```

**global 和 nonlocal 关键字**

- `global`：在函数内部声明要使用全局变量
- `nonlocal`：在嵌套函数中声明要使用外层函数的变量

---

##  闭包


闭包是指一个函数记住其外部作用域中的变量，即使外部函数已经返回。闭包使得内部函数可以访问外部函数的局部变量。

**闭包的工作原理**

```python
# 基本闭包示例
def outer(x):
    """外层函数，返回内层函数"""
    def inner(y):
        """内层函数，引用外层函数的变量 x"""
        return x + y
    return inner

# 创建闭包
add_5 = outer(5)  # x=5 的闭包
add_10 = outer(10)  # x=10 的闭包

print(add_5(3))   # 8 (5 + 3)
print(add_10(3))  # 13 (10 + 3)
```

**闭包的应用场景**

**1. 工厂函数**：创建专用函数
```python
def multiplier(factor):
    """乘数工厂函数"""
    def multiply(x):
        return x * factor
    return multiply

double = multiplier(2)  # 创建乘以2的函数
triple = multiplier(3)  # 创建乘以3的函数

print(double(5))   # 10
print(triple(5))   # 15
```

**2. 保存可变状态**：替代类的作用
```python
def counter():
    """计数器闭包"""
    count = 0

    def increment():
        nonlocal count
        count += 1
        return count

    return increment

c = counter()
print(c())  # 1
print(c())  # 2
print(c())  # 3
```

---

## 递归函数


递归是指函数调用自身的编程技术。递归函数通常有两个部分：
- **基例（Base Case）**：终止条件
- **递归步骤（Recursive Step）**：将问题分解为更小的子问题

**递归的应用**

```python
# 阶乘递归
def factorial(n):
    """计算阶乘
    基例: n = 0 或 n = 1 时返回 1
    递归: n! = n * (n-1)!
    """
    if n < 0:
        raise ValueError("阶乘只适用于非负整数")
    if n == 0 or n == 1:
        return 1
    return n * factorial(n - 1)

print(factorial(5))  # 120

# 斐波那契数列
def fibonacci(n):
    """计算斐波那契数列
    基例: F(0) = 0, F(1) = 1
    递归: F(n) = F(n-1) + F(n-2)
    """
    if n <= 0:
        return 0
    if n == 1:
        return 1
    return fibonacci(n - 1) + fibonacci(n - 2)

# 打印前10个斐波那契数
for i in range(10):
    print(f"F({i}) = {fibonacci(i)}")

# 记忆化优化 - 避免重复计算
from functools import lru_cache

@lru_cache(maxsize=None)
def fibonacci_memo(n):
    if n <= 1:
        return n
    return fibonacci_memo(n - 1) + fibonacci_memo(n - 2)

print(fibonacci_memo(100))  # 很大的数，快速计算
```

**二叉树遍历（递归实现）**

```python
class TreeNode:
    def __init__(self, value, left=None, right=None):
        self.value = value
        self.left = left
        self.right = right

# 前序遍历：根-左-右
def preorder(node):
    if node is None:
        return []
    return [node.value] + preorder(node.left) + preorder(node.right)

# 中序遍历：左-根-右
def inorder(node):
    if node is None:
        return []
    return inorder(node.left) + [node.value] + inorder(node.right)

# 后序遍历：左-右-根
def postorder(node):
    if node is None:
        return []
    return postorder(node.left) + postorder(node.right) + [node.value]

# 构建测试树
#       1
#      / \
#     2   3
#    / \
#   4   5

root = TreeNode(1,
    TreeNode(2, TreeNode(4), TreeNode(5)),
    TreeNode(3)
)

print(f"前序: {preorder(root)}")   # [1, 2, 4, 5, 3]
print(f"中序: {inorder(root)}")    # [4, 2, 5, 1, 3]
print(f"后序: {postorder(root)}")  # [4, 5, 2, 3, 1]
```

---

## 生成器函数

生成器是一种特殊的迭代器，使用 `yield` 关键字来返回值。与普通函数不同，生成器会在每次 yield 后暂停执行，并保存当前状态，下次调用时从暂停处继续执行。

**生成器的特点**

- **惰性计算**：按需生成值，节省内存
- **状态保存**：自动保存函数执行状态
- **只能迭代一次**：生成器迭代完后为空

```python
# 基本生成器
def count_up_to(n):
    """计数到 n 的生成器"""
    count = 1
    while count <= n:
        yield count
        count += 1

# 使用生成器
for i in count_up_to(5):
    print(i)  # 1, 2, 3, 4, 5
```

**生成器表达式**

生成器表达式类似于列表推导式，但使用圆括号，返回生成器对象：

```python
# 列表推导式 - 立即生成整个列表
squared_list = [x ** 2 for x in range(5)]
print(squared_list)  # [0, 1, 4, 9, 16]

# 生成器表达式 - 惰性生成
squared_gen = (x ** 2 for x in range(5))
print(list(squared_gen))  # [0, 1, 4, 9, 16]
```

**生成器的高级用法**

```python
# 斐波那契生成器
def fibonacci_generator():
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b

fib = fibonacci_generator()
for i in range(10):
    print(next(fib), end=" ")  # 0 1 1 2 3 5 8 13 21 34

# 生成器方法：send, throw, close
def generator_with_methods():
    try:
        while True:
            received = yield "waiting"
            print(f"Received: {received}")
    except GeneratorExit:
        print("Generator closed")

gen = generator_with_methods()
print(next(gen))           # "waiting"
print(gen.send("hello"))   # Received: hello -> "waiting"
gen.close()                # Generator closed
```

**管道式生成器**

```python
# 管道操作：函数式风格的数据处理
def integers(n):
    """生成无限整数序列"""
    i = 0
    while True:
        yield i
        i += 1

def take(n, gen):
    """从生成器取 n 个元素"""
    for _ in range(n):
        yield next(gen)

def pipeline_filter(gen, predicate):
    """过滤生成器元素"""
    for item in gen:
        if predicate(item):
            yield item

# 取前10个偶数
result = list(take(10, pipeline_filter(integers(0), lambda x: x % 2 == 0)))
print(result)  # [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
```

---

## 装饰器

装饰器是 Python 中一种强大的特性，它允许我们在不修改原函数代码的情况下，为函数添加额外的功能。装饰器本质上是一个接受函数作为参数并返回新函数的函数。

### 基本装饰器

```python
# 基本装饰器
def simple_decorator(func):
    """简单装饰器 - 在函数调用前后添加额外操作

    Args:
        func: 被装饰的函数

    Returns:
        包装后的函数
    """
    def wrapper():
        print("函数调用前的操作")
        func()  # 调用原函数
        print("函数调用后的操作")
    return wrapper

@simple_decorator  # 等价于: greet = simple_decorator(greet)
def greet():
    """问候函数"""
    print("Hello, World!")

greet()
# 输出:
# 函数调用前的操作
# Hello, World!
# 函数调用后的操作
```

### 带参数的装饰器

```python
# 计时装饰器
def timing_decorator(func):
    """计时装饰器 - 测量函数执行时间"""
    import time
    import functools

    @functools.wraps(func)  # 保留原函数的元数据
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"{func.__name__} 执行时间: {end - start:.4f}秒")
        return result
    return wrapper

@timing_decorator
def slow_function(n):
    total = 0
    for i in range(n):
        total += i
    return total

result = slow_function(100000)
```

### 带参数的装饰器工厂

```python
# 装饰器工厂 - 返回装饰器的函数
def repeat(n):
    """重复执行函数n次"""
    def decorator(func):
        import functools

        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            results = []
            for i in range(n):
                print(f"第 {i+1} 次执行:")
                result = func(*args, **kwargs)
                results.append(result)
            return results
        return wrapper
    return decorator

@repeat(3)  # repeat(3) 返回装饰器
def multiply(a, b):
    result = a * b
    print(f"{a} × {b} = {result}")
    return result

results = multiply(5, 3)
```

### 类装饰器

```python
# 类装饰器 - 统计函数调用次数
class CountCalls:
    """计数调用装饰器类"""

    def __init__(self, func):
        import functools
        functools.update_wrapper(self, func)
        self.func = func
        self.call_count = 0

    def __call__(self, *args, **kwargs):
        self.call_count += 1
        print(f"调用 {self.func.__name__} 第 {self.call_count} 次")
        return self.func(*args, **kwargs)

@CountCalls
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

for i in range(6):
    print(f"fibonacci({i}) = {fibonacci(i)}")
```

### 堆叠装饰器

```python
# 多个装饰器可以叠加使用
def bold(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        return f"<b>{func(*args, **kwargs)}</b>"
    return wrapper

def italic(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        return f"<i>{func(*args, **kwargs)}</i>"
    return wrapper

@bold
@italic
def format_text(text):
    return text

result = format_text("Hello")
# 先应用 italic，再应用 bold
# 输出: <b><i>Hello</i></b>
```

### 缓存装饰器

```python
# 记忆化装饰器 - 缓存函数调用结果
def memoize(func):
    cache = {}

    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        key = str(args) + str(sorted(kwargs.items()))
        if key not in cache:
            cache[key] = func(*args, **kwargs)
            print(f"计算并缓存结果：{key}")
        else:
            print(f"使用缓存结果：{key}")
        return cache[key]
    return wrapper

@memoize
def expensive_function(n):
    print(f"计算 {n} 的平方...")
    return n * n

expensive_function(5)  # 计算并缓存结果
expensive_function(5)  # 使用缓存结果
expensive_function(10) # 计算并缓存结果
```

---
