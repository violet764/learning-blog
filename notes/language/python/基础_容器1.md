# 基础语法


## 列表（List）

列表是Python中最常用的数据结构之一，是一个有序的可变集合，可以包含任意类型的元素。

### 列表的创建

```python
# 基本创建方式
empty_list = []                    # 空列表
numbers = [1, 2, 3, 4, 5]         # 数字列表
fruits = ["apple", "banana", "orange"]  # 字符串列表
mixed = [1, "hello", 3.14, True]   # 混合类型列表

# 使用list()构造函数
string_list = list("Python")       # ['P', 'y', 't', 'h', 'o', 'n']
range_list = list(range(10))       # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
tuple_list = list((1, 2, 3))       # [1, 2, 3]
dict_list = list({"a": 1, "b": 2}) # ['a', 'b']

# 列表推导式
squares = [x**2 for x in range(10)]  # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
evens = [x for x in range(20) if x % 2 == 0]  # [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]

# 重复创建
zeros = [0] * 10  # [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
pattern = [1, 2] * 3  # [1, 2, 1, 2, 1, 2]

# 嵌套列表
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
three_d = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
```

### 列表的索引与切片

```python
numbers = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]

# 正向索引（从0开始）
print(numbers[0])   # 第一个元素：10
print(numbers[4])   # 第五个元素：50
print(numbers[9])   # 最后一个元素：100

# 负向索引（从-1开始）
print(numbers[-1])  # 最后一个元素：100
print(numbers[-3])  # 倒数第三个元素：80
print(numbers[-10]) # 第一个元素：10

# 切片操作
print(numbers[2:7])     # [30, 40, 50, 60, 70]
print(numbers[:5])      # [10, 20, 30, 40, 50]
print(numbers[5:])      # [60, 70, 80, 90, 100]
print(numbers[::2])     # [10, 30, 50, 70, 90] 步长为2
print(numbers[1::3])    # [20, 50, 80] 从索引1开始，步长为3
print(numbers[::-1])    # [100, 90, 80, 70, 60, 50, 40, 30, 20, 10] 反向
print(numbers[7:2:-1])  # [80, 70, 60, 50, 40] 反向切片

# 切片赋值
numbers[2:5] = [300, 400, 500]  # 替换切片
print(numbers)  # [10, 20, 300, 400, 500, 60, 70, 80, 90, 100]

numbers[1:6:2] = [200, 401, 501]  # 带步长的切片赋值
print(numbers)  # [10, 200, 300, 401, 500, 501, 70, 80, 90, 100]

# 删除切片
del numbers[2:7]
print(numbers)  # [10, 200, 70, 80, 90, 100]
```


### 列表的查询操作

```python
fruits = ["apple", "banana", "cherry", "apple", "orange"]

# index() - 查找元素的位置
first_apple = fruits.index("apple")
print(f"第一个apple的位置：{first_apple}")  # 0

# 指定搜索范围
second_apple = fruits.index("apple", 1)  # 从索引1开始查找
print(f"第二个apple的位置：{second_apple}")  # 3

# 查找不存在的元素
try:
    position = fruits.index("grape")
except ValueError:
    print("grape不在列表中")

# count() - 统计元素出现的次数
apple_count = fruits.count("apple")
print(f"apple出现的次数：{apple_count}")  # 2

# in运算符 - 检查元素是否存在
print("apple" in fruits)  # True
print("grape" in fruits)  # False
print("grape" not in fruits)  # True

# 获取最大值和最小值
numbers = [3, 1, 4, 1, 5, 9, 2, 6]
print(f"最大值：{max(numbers)}")  # 9
print(f"最小值：{min(numbers)}")  # 1

# 获取列表长度
print(f"列表长度：{len(fruits)}")  # 5

# 获取元素总和
print(f"数字总和：{sum(numbers)}")  # 31

# all()和any()函数
bool_list = [True, True, False]
print(f"所有元素为True：{all(bool_list)}")  # False
print(f"存在元素为True：{any(bool_list)}")  # True
```

### 列表的增删改操作


**列表的一些增删改方法：**

| 方法/操作 | 描述 | 参数 | 返回值 | 是否修改原列表 |
|-----------|------|------|--------|---------------|
| `append(item)` | 在列表末尾添加一个元素 | `item`: 要添加的任意对象 | None | 是 |
| `extend(iterable)` | 将可迭代对象的所有元素添加到末尾 | `iterable`: 可迭代对象（列表、字符串等） | None | 是 |
| `insert(index, item)` | 在指定位置插入元素 | `index`: 插入位置<br>`item`: 要插入的对象 | None | 是 |
| `+` 操作符 | 通过组合两个列表创建新列表 | 两个列表对象 | 新列表 | 否 |
| `remove(item)` | 删除第一次出现的指定元素 | `item`: 要删除的元素 | None | 是 |
| `pop([index])` | 删除并返回指定索引处的元素（无索引则删除最后一个） | `index`: 可选位置（默认为-1） | 被删除的元素 | 是 |
| `del` 语句 | 删除指定位置的元素或切片 | 索引或切片 | None | 是 |
| `clear()` | 删除列表中的所有元素 | 无 | None | 是 |
| `index(item[, start[, end]])` | 查找元素第一次出现的索引 | `item`: 要查找的元素<br>`start`: 可选起始索引<br>`end`: 可选结束索引 | 第一次出现的索引 | 否 |
| `count(item)` | 统计元素出现的次数 | `item`: 要统计的元素 | 出现次数 | 否 |
| `in` 操作符 | 检查元素是否存在于列表中 o(n) | 要搜索的元素 | 布尔值 | 否 |
| `not in` 操作符 | 检查元素是否不存在于列表中 | 要搜索的元素 | 布尔值 | 否 |
| `max()` | 返回最大的元素 | 可迭代对象 | 最大元素 | 否 |
| `min()` | 返回最小的元素 | 可迭代对象 | 最小元素 | 否 |
| `len()` | 返回元素数量 | 可迭代对象 | 元素数量 | 否 |
| `sum()` | 返回所有元素的和 | 数字可迭代对象 | 元素之和 | 否 |
| `all()` | 如果所有元素都为真则返回True | 可迭代对象 | 布尔值 | 否 |
| `any()` | 如果任一元素为真则返回True | 可迭代对象 | 布尔值 | 否 |  



**列表的添加操作**
```python
numbers = [1, 2, 3]

# append() - 在末尾添加单个元素
numbers.append(4)
print(numbers)  # [1, 2, 3, 4]

numbers.append([5, 6])  # 添加整个列表作为单个元素
print(numbers)  # [1, 2, 3, 4, [5, 6]]

# extend() - 扩展列表（添加可迭代对象的所有元素）
numbers.extend([7, 8, 9])
print(numbers)  # [1, 2, 3, 4, [5, 6], 7, 8, 9]

numbers.extend("abc")  # 添加字符串的每个字符
print(numbers)  # [1, 2, 3, 4, [5, 6], 7, 8, 9, 'a', 'b', 'c']

# insert() - 在指定位置插入元素
numbers.insert(0, 0)  # 在开头插入
print(numbers)  # [0, 1, 2, 3, 4, [5, 6], 7, 8, 9, 'a', 'b', 'c']

numbers.insert(3, "middle")  # 在索引3处插入
print(numbers)  # [0, 1, 2, 'middle', 3, 4, [5, 6], 7, 8, 9, 'a', 'b', 'c']

numbers.insert(len(numbers), "end")  # 在末尾插入（等同于append）
print(numbers[-3:])  # ['b', 'c', 'end']

# 使用+操作符创建新列表
list1 = [1, 2, 3]
list2 = [4, 5, 6]
combined = list1 + list2
print(combined)  # [1, 2, 3, 4, 5, 6]

# 注意：+操作符创建新列表，不修改原列表
print(list1)    # [1, 2, 3] 原列表不变
print(list2)    # [4, 5, 6] 原列表不变
```



**列表的删除操作**

```python
numbers = [10, 20, 30, 40, 50, 30, 60, 30]

# remove() - 删除第一个匹配的元素
numbers.remove(30)
print(numbers)  # [10, 20, 40, 50, 30, 60, 30]

# 尝试删除不存在的元素
try:
    numbers.remove(999)
except ValueError:
    print("元素不存在，无法删除")

# pop() - 删除并返回指定位置的元素
last = numbers.pop()  # 删除最后一个元素
print(f"删除的元素：{last}")  # 30
print(numbers)  # [10, 20, 40, 50, 30, 60]

first = numbers.pop(0)  # 删除第一个元素
print(f"删除的元素：{first}")  # 10
print(numbers)  # [20, 40, 50, 30, 60]

middle = numbers.pop(2)  # 删除索引2的元素
print(f"删除的元素：{middle}")  # 50
print(numbers)  # [20, 40, 30, 60]

# del语句 - 删除指定元素或切片
del numbers[1]  # 删除索引1的元素
print(numbers)  # [20, 30, 60]

del numbers[1:]  # 删除从索引1到末尾的所有元素
print(numbers)  # [20]

# clear() - 清空整个列表
numbers.clear()
print(numbers)  # []

# 列表推导式删除（创建新列表）
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
evens = [x for x in numbers if x % 2 == 0]  # 只保留偶数
print(evens)  # [2, 4, 6, 8, 10]
```


**列表的修改操作**

```python
fruits = ["apple", "banana", "cherry"]

# 直接赋值修改
fruits[1] = "blueberry"
print(fruits)  # ['apple', 'blueberry', 'cherry']

# 批量修改
fruits[1:2] = ["banana", "orange", "pear"]
print(fruits)  # ['apple', 'banana', 'orange', 'pear', 'cherry']

# 使用+=操作符
fruits += ["grape", "mango"]
print(fruits)  # ['apple', 'banana', 'orange', 'pear', 'cherry', 'grape', 'mango']

# 使用*=操作符重复
fruits *= 2
print(fruits)  # 列表内容重复一次
```


### 列表的排序操作

`sort()` 方法用于对列表进行原地排序，直接修改原列表而不创建新列表。
```python
list.sort(key=None, reverse=False)
"""
key（可选）：指定一个函数，用于从每个列表元素中提取比较键。默认值为 None，表示直接比较元素本身。  
reverse（可选）：布尔值，默认为 False。如果设置为 True，则按降序排序；否则按升序排序。  
无返回值（返回 None） 
"""
```

`sorted()` 函数返回一个新的已排序列表，不修改原始列表。

```python
sorted(iterable, key=None, reverse=False)
"""
iterable：可迭代对象（如列表、元组、字符串等）  
key（可选）：指定一个函数，用于从每个元素中提取比较键  
reverse（可选）：布尔值，控制排序方向（False为升序，True为降序）  
key（可选）：指定一个函数，用于从每个列表元素中提取比较键。默认值为 None，表示直接比较元素本身。  
reverse（可选）：布尔值，默认为 False。如果设置为 True，则按降序排序；否则按升序排序。  
返回一个新的已排序列表
"""
```
 
代码示例：  

```python
numbers = [3, 1, 4, 1, 5, 9, 2, 6, 5]

# sort()方法 - 原地排序
numbers.sort()
print(f"升序排序：{numbers}")  # [1, 1, 2, 3, 4, 5, 5, 6, 9]

# 降序排序
numbers.sort(reverse=True)
print(f"降序排序：{numbers}")  # [9, 6, 5, 5, 4, 3, 2, 1, 1]

# 使用key参数自定义排序
fruits = ["apple", "banana", "cherry", "orange", "grape"]
fruits.sort(key=len)  # 按长度排序
print(f"按长度排序：{fruits}")  # ['apple', 'grape', 'banana', 'orange', 'cherry']

fruits.sort(key=len, reverse=True)  # 按长度降序
print(f"按长度降序：{fruits}")  # ['banana', 'orange', 'cherry', 'apple', 'grape']

# 复杂对象排序
students = [
    {"name": "Alice", "age": 25, "score": 85},
    {"name": "Bob", "age": 23, "score": 92},
    {"name": "Charlie", "age": 26, "score": 78}
]

students.sort(key=lambda x: x["age"])  # 按年龄排序
print(f"按年龄排序：{students}")

students.sort(key=lambda x: x["score"], reverse=True)  # 按分数降序
print(f"按分数降序：{students}")

# sorted()函数 - 返回新列表
numbers = [3, 1, 4, 1, 5, 9, 2, 6, 5]
sorted_numbers = sorted(numbers)
print(f"原列表：{numbers}")
print(f"新排序列表：{sorted_numbers}")

# 多级排序
students = [
    {"name": "Alice", "age": 25, "score": 85},
    {"name": "Bob", "age": 23, "score": 92},
    {"name": "Charlie", "age": 23, "score": 78},
    {"name": "David", "age": 25, "score": 92}
]

# 先按年龄升序，再按分数降序
students.sort(key=lambda x: (x["age"], -x["score"]))
print(f"多级排序：{students}")
```

### 列表的其余方法

```python

numbers = [1, 2, 3, 4, 5]

# reverse() - 反转列表
numbers.reverse()
print(f"反转后的列表：{numbers}")  # [5, 4, 3, 2, 1]


# copy() - 创建列表的浅拷贝
numbers_copy = numbers.copy()
print(f"拷贝的列表：{numbers_copy}")

# 修改拷贝不影响原列表
numbers_copy.append(6)
print(f"原列表：{numbers}")  # [5, 4, 3, 2, 1]
print(f"拷贝列表：{numbers_copy}")  # [5, 4, 3, 2, 1, 6]

# 深拷贝（处理嵌套列表）
import copy
nested_list = [[1, 2], [3, 4]]
shallow_copy = nested_list.copy()
deep_copy = copy.deepcopy(nested_list)

# 修改浅拷贝影响原列表
shallow_copy[0].append(5)
print(f"原嵌套列表：{nested_list}")  # [[1, 2, 5], [3, 4]]

# 修改深拷贝不影响原列表
deep_copy[1].append(6)
print(f"原嵌套列表：{nested_list}")  # [[1, 2, 5], [3, 4]]

# 列表的数学操作
list1 = [1, 2, 3]
list2 = [4, 5, 6]

# 拼接
concatenated = list1 + list2
print(f"拼接：{concatenated}")  # [1, 2, 3, 4, 5, 6]

# 重复
repeated = list1 * 3
print(f"重复：{repeated}")  # [1, 2, 3, 1, 2, 3, 1, 2, 3]

# 列表推导式的高级用法
# 条件表达式
result = [x if x % 2 == 0 else x*2 for x in range(10)]
print(f"偶数保留，奇数翻倍：{result}")  # [0, 2, 2, 6, 4, 10, 6, 14, 8, 18]

# 嵌套循环
matrix = [[i*j for j in range(3)] for i in range(3)]
print(f"3x3矩阵：{matrix}")  # [[0, 0, 0], [0, 1, 2], [0, 2, 4]]

# 带条件的嵌套循环
result = [(i, j) for i in range(3) for j in range(3) if i != j]
print(f"不同坐标对：{result}")  # [(0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1)]
```

**列表的高级应用**

```python
# 列表作为栈使用（LIFO）
stack = []

# push操作
stack.append(1)
stack.append(2)
stack.append(3)
print(f"栈内容：{stack}")  # [1, 2, 3]

# pop操作
top = stack.pop()
print(f"弹出元素：{top}")  # 3
print(f"栈内容：{stack}")  # [1, 2]

# 列表作为队列使用（FIFO，效率较低）
from collections import deque

queue = deque([1, 2, 3])
queue.append(4)  # enqueue
print(f"队列：{queue}")  # deque([1, 2, 3, 4])

front = queue.popleft()  # dequeue
print(f"出队元素：{front}")  # 1
print(f"队列：{queue}")  # deque([2, 3, 4])

# 列表推导式的高级技巧
# 提取字典列表中的特定字段
people = [
    {"name": "Alice", "age": 25, "city": "Beijing"},
    {"name": "Bob", "age": 30, "city": "Shanghai"},
    {"name": "Charlie", "age": 35, "city": "Guangzhou"}
]

names = [person["name"] for person in people]
print(f"所有姓名：{names}")  # ['Alice', 'Bob', 'Charlie']

# 过滤和转换
adults = [person["name"] for person in people if person["age"] >= 30]
print(f"成年人姓名：{adults}")  # ['Bob', 'Charlie']

# 复杂的数据处理
data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# 列表的函数式编程
from functools import reduce

# map函数 - 对每个元素应用函数
squares = list(map(lambda x: x**2, data))
print(f"平方数：{squares}")  # [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

# filter函数 - 过滤元素
evens = list(filter(lambda x: x % 2 == 0, data))
print(f"偶数：{evens}")  # [2, 4, 6, 8, 10]

# reduce函数 - 累积操作
product = reduce(lambda x, y: x * y, data)
print(f"所有数的乘积：{product}")  # 3628800

# 列表性能优化
import time

# 方法1：循环追加
start = time.time()
result = []
for i in range(1000000):
    result.append(i * 2)
end = time.time()
print(f"循环追加耗时：{end - start:.4f}秒")

# 方法2：列表推导式
start = time.time()
result = [i * 2 for i in range(1000000)]
end = time.time()
print(f"列表推导式耗时：{end - start:.4f}秒")

# 列表与内存
import sys

small_list = list(range(100))
large_list = list(range(1000000))
print(f"小列表内存：{sys.getsizeof(small_list)}字节")
print(f"大列表内存：{sys.getsizeof(large_list)}字节")
```

## 元组（Tuple）

元组是Python中的一种不可变序列类型，一旦创建就不能修改。元组使用圆括号 () 定义，也可以省略圆括号。

### 元组的创建与查询

```python
# 基本创建方式
empty_tuple = ()                # 空元组
single_element = (42,)          # 单元素元组（注意逗号）
numbers = (1, 2, 3, 4, 5)       # 基本元组
mixed = (1, "hello", 3.14, True)  # 混合类型元组

# 省略圆括号创建元组
coordinates = 10, 20, 30
print(coordinates)  # (10, 20, 30)

# 使用tuple()构造函数
tuple_from_list = tuple([1, 2, 3, 4, 5])
print(tuple_from_list)  # (1, 2, 3, 4, 5)

tuple_from_string = tuple("Python")
print(tuple_from_string)  # ('P', 'y', 't', 'h', 'o', 'n')

# 嵌套元组
nested_tuple = ((1, 2), (3, 4), (5, 6))
print(nested_tuple)  # ((1, 2), (3, 4), (5, 6))

# 多重赋值创建元组
a, b, c = 1, 2, 3
print(f"a={a}, b={b}, c={c}")  # a=1, b=2, c=3

# 函数返回多个值
def get_coordinates():
    return 10, 20, 30  # 返回元组

x, y, z = get_coordinates()  # 自动解包
print(f"坐标：x={x}, y={y}, z={z}")  # 坐标：x=10, y=20, z=30
```

### 元组的索引与切片

```python
coordinates = (10, 20, 30, 40, 50)

# 正向索引（从0开始）
print(coordinates[0])   # 10
print(coordinates[2])   # 30
print(coordinates[4])   # 50

# 负向索引（从-1开始）
print(coordinates[-1])  # 50
print(coordinates[-3])  # 30

# 切片操作
print(coordinates[1:4])     # (20, 30, 40)
print(coordinates[:3])     # (10, 20, 30)
print(coordinates[2:])      # (30, 40, 50)
print(coordinates[::2])    # (10, 30, 50) 步长为2
print(coordinates[::-1])   # (50, 40, 30, 20, 10) 反向

# 元组的嵌套索引
nested = ((1, 2), (3, 4), (5, 6))
print(nested[1])        # (3, 4)
print(nested[1][0])     # 3
print(nested[2][1])     # 6
```

### 元组的不可变性

```python
# 元组创建后不能修改
coordinates = (10, 20, 30)

# 以下操作会引发TypeError
try:
    coordinates[0] = 100  # TypeError: 'tuple' object does not support item assignment
except TypeError as e:
    print(f"错误：{e}")

# 但是可以引用可变对象
mutable_tuple = ([1, 2], [3, 4])
mutable_tuple[0].append(3)  # 修改列表元素是可以的
print(mutable_tuple)  # ([1, 2, 3], [3, 4])

# 删除元组
del coordinates
# print(coordinates)  # NameError: name 'coordinates' is not defined
```

### 元组的方法

```python
fruits = ("apple", "banana", "cherry", "apple", "orange")

# count() - 统计元素出现的次数
apple_count = fruits.count("apple")
print(f"apple出现的次数：{apple_count}")  # 2

# index() - 查找元素第一次出现的索引
first_apple_index = fruits.index("apple")
print(f"第一个apple的索引：{first_apple_index}")  # 0

# 指定搜索范围
second_apple_index = fruits.index("apple", 1)
print(f"第二个apple的索引：{second_apple_index}")  # 3

# in和not in操作符
print("apple" in fruits)    # True
print("grape" in fruits)    # False
print("grape" not in fruits) # True

# 获取长度
print(f"元组长度：{len(fruits)}")  # 5

# 最大值和最小值
numbers = (3, 1, 4, 1, 5, 9, 2, 6)
print(f"最大值：{max(numbers)}")  # 9
print(f"最小值：{min(numbers)}")  # 1

# 总和
print(f"总和：{sum(numbers)}")  # 31
```

### 元组的解包

```python
# 基本解包
coordinates = (10, 20, 30)
x, y, z = coordinates
print(f"x={x}, y={y}, z={z}")  # x=10, y=20, z=30

# 使用星号(*)收集多余元素
a, *middle, b = (1, 2, 3, 4, 5)
print(f"a={a}, middle={middle}, b={b}")  # a=1, middle=[2, 3, 4], b=5

# 忽略某些值
first, _, third, *_ = (1, 2, 3, 4, 5)
print(f"first={first}, third={third}")  # first=1, third=3

# 嵌套解包
person = ("Alice", 25, ("北京", "朝阳区"))
name, age, (city, district) = person
print(f"姓名：{name}，年龄：{age}，城市：{city}，区域：{district}")

# 函数参数解包
def process_student(name, age, score):
    return f"{name}（{age}岁）得分：{score}"

student_data = ("张三", 18, 95)
result = process_student(*student_data)
print(result)  # 张三（18岁）得分：95

# 函数返回值解包
def get_name_age():
    return "李四", 20

name, age = get_name_age()
print(f"姓名：{name}，年龄：{age}")  # 姓名：李四，年龄：20
```

### 元组的用途

```python
# 1. 作为字典的键（因为元组是不可变的）
locations = {
    (0, 0): "起点",
    (10, 20): "商店",
    (30, 40): "终点"
}

print(locations[(10, 20)])  # 商店

# 2. 返回多个值
def divide_with_remainder(dividend, divisor):
    quotient = dividend // divisor
    remainder = dividend % divisor
    return quotient, remainder

quotient, remainder = divide_with_remainder(17, 5)
print(f"17 ÷ 5 = {quotient} 余 {remainder}")  # 17 ÷ 5 = 3 余 2

# 3. 交换变量值
a, b = 10, 20
print(f"交换前：a={a}, b={b}")  # 交换前：a=10, b=20
a, b = b, a
print(f"交换后：a={a}, b={b}")  # 交换后：a=20, b=10

# 4. 遍历字典的键值对
person = {"name": "Alice", "age": 25, "city": "Beijing"}
for key, value in person.items():
    print(f"{key}: {value}")

# 5. 作为不可变数据结构
student_record = ("张三", 18, 95, "2023-12-06")
print(f"学生记录：{student_record}")

# 6. 元组推导式（实际上是生成器表达式）
squares_tuple = tuple(x**2 for x in range(5))
print(f"平方元组：{squares_tuple}")  # (0, 1, 4, 9, 16)

# 7. 元组的命名访问（使用namedtuple）
from collections import namedtuple

# 创建命名元组类
Point = namedtuple('Point', ['x', 'y'])
Student = namedtuple('Student', ['name', 'age', 'score'])

# 创建命名元组实例
point = Point(10, 20)
student = Student("王五", 19, 88)

print(f"点坐标：({point.x}, {point.y})")  # 点坐标：(10, 20)
print(f"学生信息：{student.name}，{student.age}岁，{student.score}分")

# 命名元组也支持索引访问
print(f"点坐标：({point[0]}, {point[1]})")  # 点坐标：(10, 20)

# 命名元组是不可变的
try:
    point.x = 30  # TypeError: can't set attribute
except AttributeError as e:
    print(f"错误：{e}")

# 命名元组支持解包
x, y = point
print(f"x={x}, y={y}")  # x=10, y=20

# 命名元组的其他方法
print(point._fields)  # ('x', 'y')  # 字段名
new_point = point._replace(x=30)  # 创建替换某些字段的新实例
print(f"新点：{new_point}")  # 新点：Point(x=30, y=20)

# 从字典创建命名元组
point_dict = {"x": 15, "y": 25}
point_from_dict = Point(**point_dict)
print(f"从字典创建的点：{point_from_dict}")  # 从字典创建的点：Point(x=15, y=25)
```

### 元组与列表的比较

```python
# 创建相同的序列数据
list_data = [1, 2, 3, 4, 5]
tuple_data = (1, 2, 3, 4, 5)

# 性能对比
import time
import sys

# 1. 内存使用对比
print(f"列表内存：{sys.getsizeof(list_data)}字节")
print(f"元组内存：{sys.getsizeof(tuple_data)}字节")

# 2. 创建性能对比
start = time.time()
for _ in range(1000000):
    list_temp = [1, 2, 3, 4, 5]
list_creation_time = time.time() - start

start = time.time()
for _ in range(1000000):
    tuple_temp = (1, 2, 3, 4, 5)
tuple_creation_time = time.time() - start

print(f"列表创建耗时：{list_creation_time:.6f}秒")
print(f"元组创建耗时：{tuple_creation_time:.6f}秒")

# 3. 迭代性能对比
start = time.time()
for _ in range(1000000):
    for item in list_data:
        pass
list_iteration_time = time.time() - start

start = time.time()
for _ in range(1000000):
    for item in tuple_data:
        pass
tuple_iteration_time = time.time() - start

print(f"列表迭代耗时：{list_iteration_time:.6f}秒")
print(f"元组迭代耗时：{tuple_iteration_time:.6f}秒")

# 4. 作为字典键的能力
try:
    dict_with_list_key = {[1, 2, 3]: "value"}  # TypeError
except TypeError as e:
    print(f"列表不能作为字典键：{e}")

# 元组可以作为字典键
dict_with_tuple_key = {(1, 2, 3): "value"}
print(f"元组作为字典键：{dict_with_tuple_key}")

# 5. 可变性对比
list_data[0] = 100
print(f"修改后的列表：{list_data}")  # [100, 2, 3, 4, 5]

try:
    tuple_data[0] = 100  # TypeError
except TypeError as e:
    print(f"元组不能修改：{e}")

# 6. 方法对比
list_methods = [method for method in dir(list) if not method.startswith('_')]
tuple_methods = [method for method in dir(tuple) if not method.startswith('_')]

print(f"列表方法数：{len(list_methods)}")
print(f"元组方法数：{len(tuple_methods)}")
print(f"列表特有方法：{set(list_methods) - set(tuple_methods)}")
print(f"元组特有方法：{set(tuple_methods) - set(list_methods)}")
```

### 元组的应用场景

```python
# 1. 函数返回多个值
def get_user_info(user_id):
    # 模拟数据库查询
    return ("张三", 25, "北京", "zhangsan@example.com")

name, age, city, email = get_user_info(123)
print(f"用户信息：{name}，{age}岁，{city}，{email}")

# 2. 配置信息
DATABASE_CONFIG = ("localhost", 5432, "mydb", "user", "password")
HOST, PORT, DATABASE, USER, PASSWORD = DATABASE_CONFIG
print(f"数据库配置：主机={HOST}，端口={PORT}，数据库={DATABASE}")

# 3. 坐标和几何数据
points = [(0, 0), (1, 1), (2, 4), (3, 9)]
for x, y in points:
    print(f"点({x}, {y})")

# 4. 不可变的数据记录
EMPLOYEE_RECORDS = [
    ("张三", "开发部", 50000),
    ("李四", "测试部", 45000),
    ("王五", "设计部", 48000)
]

for name, department, salary in EMPLOYEE_RECORDS:
    print(f"{name}在{department}，薪资{salary}")

# 5. 元组作为哈希表的键
matrix = {}
for i in range(3):
    for j in range(3):
        matrix[(i, j)] = i * 3 + j + 1

print("3x3矩阵：")
for i in range(3):
    row = [matrix[(i, j)] for j in range(3)]
    print(row)
```

## 集合（Set）

集合是Python中的一种无序不重复元素序列，使用花括号 {} 或 set() 函数创建。集合支持数学集合操作如并集、交集、差集等。

### 集合的创建

```python
# 基本创建方式
empty_set = set()           # 空集合（只能用set()创建）
numbers = {1, 2, 3, 4, 5}   # 使用花括号创建集合
fruits = {"apple", "banana", "cherry"}  # 字符串集合

# 注意：不能用{}创建空集合（会被认为是空字典）
empty_dict = {}             # 这是空字典
empty_set_correct = set()   # 这才是空集合
print(type(empty_dict))     # <class 'dict'>
print(type(empty_set_correct))  # <class 'set'>

# 使用set()构造函数
set_from_list = set([1, 2, 2, 3, 3, 4, 5])
print(set_from_list)  # {1, 2, 3, 4, 5}（重复元素被去除）

set_from_string = set("hello")
print(set_from_string)  # {'e', 'h', 'o', 'l'}（顺序不确定）

# 集合推导式
squares = {x**2 for x in range(10)}
print(f"平方集合：{squares}")  # {0, 1, 4, 9, 16, 25, 36, 49, 64, 81}

# 条件集合推导式
even_squares = {x**2 for x in range(10) if x % 2 == 0}
print(f"偶数平方集合：{even_squares}")  # {0, 4, 16, 36, 64}

# 从其他可迭代对象创建
set_from_tuple = set((1, 2, 2, 3, 3, 4))
set_from_range = set(range(5))

print(f"元组转集合：{set_from_tuple}")  # {1, 2, 3, 4}
print(f"范围转集合：{set_from_range}")  # {0, 1, 2, 3, 4}

# 不可变集合（frozenset）
frozen = frozenset([1, 2, 3, 4, 5])
print(f"不可变集合：{frozen}")

# 不可变集合可以作为字典的键
dict_with_frozenset_key = {frozen: "value"}
print(f"字典：{dict_with_frozenset_key}")

# 尝试修改frozenset会出错
try:
    frozen.add(6)  # AttributeError
except AttributeError as e:
    print(f"frozenset不可变：{e}")

# 集合的类型转换
list_data = [1, 2, 2, 3, 3, 4, 5, 5]
set_data = set(list_data)
back_to_list = list(set_data)
print(f"去重后：{back_to_list}")  # [1, 2, 3, 4, 5]（顺序可能不同）
```

### 集合的基本操作

```python
# 创建测试集合
set_a = {1, 2, 3, 4, 5}
set_b = {4, 5, 6, 7, 8}
set_c = {1, 2}
set_d = {9, 10}

# 成员关系测试
print(f"1是否在set_a中：{1 in set_a}")  # True
print(f"6是否在set_a中：{6 in set_a}")  # False
print(f"1是否不在set_a中：{1 not in set_a}")  # False

# 集合的长度
print(f"set_a的长度：{len(set_a)}")  # 5
print(f"set_b的长度：{len(set_b)}")  # 5

# 获取最大值和最小值
numbers = {3, 1, 4, 1, 5, 9, 2, 6}
print(f"最大值：{max(numbers)}")  # 9
print(f"最小值：{min(numbers)}")  # 1

# 集合的比较操作
print(f"set_a是否等于set_b：{set_a == set_b}")  # False
print(f"set_c是否是set_a的子集：{set_c <= set_a}")  # True
print(f"set_a是否是set_c的超集：{set_a >= set_c}")  # True
print(f"set_a是否是set_c的真超集：{set_a > set_c}")  # True
print(f"set_c是否是set_a的真子集：{set_c < set_a}")  # True

# 不相交集合
print(f"set_a和set_d是否不相交：{set_a.isdisjoint(set_d)}")  # True
print(f"set_a和set_b是否不相交：{set_a.isdisjoint(set_b)}")  # False

# 集合的深拷贝和浅拷贝
shallow_copy = set_a.copy()
print(f"浅拷贝：{shallow_copy}")

# 修改拷贝不影响原集合
# 集合是不可变元素的集合，所以深拷贝和浅拷贝效果相同
import copy
deep_copy = copy.deepcopy(set_a)
print(f"深拷贝：{deep_copy}")

# 集合的遍历
print("遍历集合并显示索引：")
for i, item in enumerate(set_a):
    print(f"索引{i}：{item}")

# 由于集合无序，索引只是遍历顺序，不代表集合中的位置
```

### 集合的增删操作

```python
# 创建测试集合
my_set = {1, 2, 3}

# add()方法添加单个元素
my_set.add(4)
print(f"添加4后：{my_set}")  # {1, 2, 3, 4}

# 添加已存在的元素不会改变集合
my_set.add(4)
print(f"再次添加4：{my_set}")  # {1, 2, 3, 4}

# update()方法添加多个元素
my_set.update([5, 6, 7])
print(f"更新后：{my_set}")  # {1, 2, 3, 4, 5, 6, 7}

# update()可以接受多个参数
my_set.update([8, 9], (10, 11), {12, 13})
print(f"多参数更新：{my_set}")  # {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}

# update()也可以接受字符串
my_set.update("abc")
print(f"添加字符串：{my_set}")  # {'1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c'}

# remove()方法删除元素（元素不存在会抛出KeyError）
try:
    my_set.remove('a')
    print(f"删除'a'后：{my_set}")

    my_set.remove('z')  # KeyError
except KeyError:
    print("'z'不存在于集合中")

# discard()方法删除元素（元素不存在不会抛出异常）
my_set.discard('b')
print(f"丢弃'b'后：{my_set}")

my_set.discard('z')  # 不会报错
print(f"丢弃不存在的'z'：{my_set}")

# pop()方法随机删除并返回一个元素
popped = my_set.pop()
print(f"弹出元素：{popped}")  # 随机弹出
print(f"弹出后：{my_set}")

# clear()方法清空集合
my_set.clear()
print(f"清空后：{my_set}")  # set()

# difference_update()方法就地差集操作
set1 = {1, 2, 3, 4, 5}
set2 = {3, 4, 5, 6, 7}
set1.difference_update(set2)
print(f"差集更新：{set1}")  # {1, 2}

# intersection_update()方法就地交集操作
set1 = {1, 2, 3, 4, 5}
set2 = {3, 4, 5, 6, 7}
set1.intersection_update(set2)
print(f"交集更新：{set1}")  # {3, 4, 5}

# symmetric_difference_update()方法就地对称差集操作
set1 = {1, 2, 3, 4, 5}
set2 = {3, 4, 5, 6, 7}
set1.symmetric_difference_update(set2)
print(f"对称差集更新：{set1}")  # {1, 2, 6, 7}

# union_update()方法就地并集操作（Python 3.9+）
set1 = {1, 2, 3, 4, 5}
set2 = {3, 4, 5, 6, 7}
# set1 |= set2  # Python 3.9+
# print(f"并集更新：{set1}")  # {1, 2, 3, 4, 5, 6, 7}
```

### 集合的查询操作

```python
# 创建测试集合
set_a = {1, 2, 3, 4, 5}
set_b = {4, 5, 6, 7, 8}

# in运算符检查元素是否存在
print(f"1是否在set_a中：{1 in set_a}")  # True
print(f"9是否在set_a中：{9 in set_a}")  # False

# not in运算符检查元素是否不存在
print(f"9是否不在set_a中：{9 not in set_a}")  # True

# isdisjoint()方法检查是否不相交
set_c = {9, 10}
set_d = {4, 5}
print(f"set_a和set_c是否不相交：{set_a.isdisjoint(set_c)}")  # True
print(f"set_a和set_d是否不相交：{set_a.isdisjoint(set_d)}")  # False

# issuperset()和issubset()方法检查超集和子集关系
set_e = {1, 2, 3}
print(f"set_a是否是set_e的超集：{set_a.issuperset(set_e)}")  # True
print(f"set_e是否是set_a的子集：{set_e.issubset(set_a)}")  # True

# >、<、>=、<=运算符检查真超集、真子集、超集和子集关系
print(f"set_a是否是set_e的真超集：{set_a > set_e}")  # True
print(f"set_e是否是set_a的真子集：{set_e < set_a}")  # True
print(f"set_a是否是set_e的超集：{set_a >= set_e}")  # True
print(f"set_e是否是set_a的子集：{set_e <= set_a}")  # True

# 获取集合长度
print(f"set_a的长度：{len(set_a)}")  # 5

# 获取最大值和最小值
print(f"set_a的最大值：{max(set_a)}")  # 5
print(f"set_a的最小值：{min(set_a)}")  # 1

# any()和all()函数检查集合元素
bool_set = {True, True, False}
print(f"是否存在True元素：{any(bool_set)}")  # True
print(f"是否所有元素都是True：{all(bool_set)}")  # False

# 使用集合进行去重统计
numbers = [1, 2, 2, 3, 3, 4, 5, 5, 6]
unique_count = len(set(numbers))
print(f"不重复元素数量：{unique_count}")  # 6
```

### 集合的数学运算

```python
# 创建测试集合
set_a = {1, 2, 3, 4, 5}
set_b = {4, 5, 6, 7, 8}

# 并集（union）
union_set1 = set_a | set_b  # 使用操作符
union_set2 = set_a.union(set_b)  # 使用方法
union_set3 = set_a.union([9, 10], (11, 12))  # 传入多个可迭代对象
print(f"并集：{union_set1}")  # {1, 2, 3, 4, 5, 6, 7, 8}
print(f"并集：{union_set2}")  # {1, 2, 3, 4, 5, 6, 7, 8}
print(f"多集合并集：{union_set3}")  # {1, 2, 3, 4, 5, 9, 10, 11, 12}

# 交集（intersection）
intersection_set1 = set_a & set_b  # 使用操作符
intersection_set2 = set_a.intersection(set_b)  # 使用方法
intersection_set3 = set_a.intersection([4, 5, 9], (5, 10))  # 多个交集
print(f"交集：{intersection_set1}")  # {4, 5}
print(f"交集：{intersection_set2}")  # {4, 5}
print(f"多集合交集：{intersection_set3}")  # {5}

# 差集（difference）
difference_set1 = set_a - set_b  # 使用操作符
difference_set2 = set_a.difference(set_b)  # 使用方法
print(f"set_a - set_b：{difference_set1}")  # {1, 2, 3}
print(f"set_a差集set_b：{difference_set2}")  # {1, 2, 3}

# 对称差集（symmetric_difference）
symmetric_diff1 = set_a ^ set_b  # 使用操作符
symmetric_diff2 = set_a.symmetric_difference(set_b)  # 使用方法
print(f"对称差集：{symmetric_diff1}")  # {1, 2, 3, 6, 7, 8}
print(f"对称差集：{symmetric_diff2}")  # {1, 2, 3, 6, 7, 8}

# 子集和超集检查
set_c = {1, 2}
set_d = {1, 2, 3, 4, 5}

print(f"set_c是set_d的子集：{set_c <= set_d}")  # True
print(f"set_d是set_c的超集：{set_d >= set_c}")  # True
print(f"set_c是set_d的真子集：{set_c < set_d}")  # True
print(f"set_d是set_c的真超集：{set_d > set_c}")  # True
print(f"set_c是set_c的真子集：{set_c < set_c}")  # False

# 不相交集合
set_e = {1, 2, 3}
set_f = {4, 5, 6}
set_g = {3, 4, 5}

print(f"set_e和set_f不相交：{set_e.isdisjoint(set_f)}")  # True
print(f"set_e和set_g不相交：{set_e.isdisjoint(set_g)}")  # False

# 集合的子集生成
def get_all_subsets(s):
    """生成集合的所有子集（幂集）"""
    subsets = []
    elements = list(s)
    n = len(elements)

    # 使用位运算生成所有子集
    for i in range(2**n):
        subset = set()
        for j in range(n):
            if i & (1 << j):
                subset.add(elements[j])
        subsets.append(subset)

    return subsets

original_set = {1, 2, 3}
all_subsets = get_all_subsets(original_set)
print(f"集合{original_set}的所有子集：")
for i, subset in enumerate(all_subsets):
    print(f"  {i+1}: {subset}")

# 集合的笛卡尔积
from itertools import product

set_x = {1, 2}
set_y = {'a', 'b'}
cartesian_product = set(product(set_x, set_y))
print(f"笛卡尔积：{cartesian_product}")  # {(1, 'b'), (2, 'b'), (1, 'a'), (2, 'a')}
```

### 集合的高级应用

```python
# 集合去重应用
duplicate_list = [1, 2, 2, 3, 3, 4, 5, 5, 6]
unique_list = list(set(duplicate_list))
print(f"去重后：{unique_list}")  # [1, 2, 3, 4, 5, 6]（顺序可能不同）

# 保持原顺序的去重
def deduplicate_preserve_order(seq):
    """保持顺序去重"""
    seen = set()
    result = []
    for item in seq:
        if item not in seen:
            seen.add(item)
            result.append(item)
    return result

duplicate_list = [1, 2, 2, 3, 3, 4, 5, 5, 6]
unique_ordered = deduplicate_preserve_order(duplicate_list)
print(f"有序去重：{unique_ordered}")  # [1, 2, 3, 4, 5, 6]

# 集合交集应用 - 查找共同元素
set1 = {1, 2, 3, 4, 5}
set2 = {3, 4, 5, 6, 7}
set3 = {5, 6, 7, 8, 9}

# 两个集合的交集
common_two = set1 & set2
print(f"两个集合的交集：{common_two}")  # {3, 4, 5}

# 多个集合的交集
common_multiple = set1 & set2 & set3
print(f"三个集合的交集：{common_multiple}")  # {5}

# 使用intersection方法
common_method = set1.intersection(set2, set3)
print(f"方法求交集：{common_method}")  # {5}

# 集合并集应用 - 合并所有元素
all_elements = set1 | set2 | set3
print(f"所有元素：{all_elements}")  # {1, 2, 3, 4, 5, 6, 7, 8, 9}

# 使用union方法
all_elements_method = set1.union(set2, set3)
print(f"方法求并集：{all_elements_method}")  # {1, 2, 3, 4, 5, 6, 7, 8, 9}

# 集合差集应用 - 找出不同元素
only_in_first = set1 - set2  # 只在第一个集合中的元素
only_in_second = set2 - set1  # 只在第二个集合中的元素
print(f"只在set1中：{only_in_first}")  # {1, 2}
print(f"只在set2中：{only_in_second}")  # {6, 7}

# 集合对称差集应用 - 找出不同时存在于两个集合中的元素
symmetric_diff = set1 ^ set2
print(f"对称差集：{symmetric_diff}")  # {1, 2, 6, 7}

# 集合在数据处理中的应用
# 查找唯一访客
visitors_day1 = {"user1", "user2", "user3", "user4"}
visitors_day2 = {"user3", "user4", "user5", "user6"}
visitors_day3 = {"user1", "user5", "user7", "user8"}

# 三天总访客数
all_visitors = visitors_day1 | visitors_day2 | visitors_day3
print(f"三天总访客：{len(all_visitors)}人")  # 8人

# 每天都访问的访客
daily_visitors = visitors_day1 & visitors_day2 & visitors_day3
print(f"每天访问：{daily_visitors}")  # set()

# 只访问一天的访客
only_day1 = visitors_day1 - (visitors_day2 | visitors_day3)
only_day2 = visitors_day2 - (visitors_day1 | visitors_day3)
only_day3 = visitors_day3 - (visitors_day1 | visitors_day2)
print(f"只访问第一天：{only_day1}")  # {'user2'}
print(f"只访问第二天：{only_day2}")  # {'user6'}
print(f"只访问第三天：{only_day3}")  # {'user7', 'user8'}

# 至少访问两天的访客
at_least_two_days = (visitors_day1 & visitors_day2) | \
                   (visitors_day1 & visitors_day3) | \
                   (visitors_day2 & visitors_day3)
print(f"至少访问两天：{at_least_two_days}")  # {'user3', 'user4', 'user1', 'user5'}

# 集合在权限管理中的应用
permissions_admin = {"read", "write", "delete", "manage"}
permissions_editor = {"read", "write"}
permissions_viewer = {"read"}

# 检查权限
user_permissions = {"read", "write"}
print(f"用户有管理员权限：{permissions_admin <= user_permissions}")  # False
print(f"用户有编辑权限：{permissions_editor <= user_permissions}")  # True
print(f"用户有查看权限：{permissions_viewer <= user_permissions}")  # True

# 权限升级
user_permissions |= {"delete"}
print(f"升级后有管理员权限：{permissions_admin <= user_permissions}")  # False
user_permissions.add("manage")
print(f"完全授权后有管理员权限：{permissions_admin <= user_permissions}")  # True

# 权限降级
user_permissions -= {"manage", "delete"}
print(f"降级后权限：{user_permissions}")  # {'read', 'write'}

# 集合在去重统计中的应用
# 统计一篇文章中不同单词的数量
article = """
Python is a great programming language. Python is easy to learn.
Python is widely used in data science, web development, and automation.
Many companies use Python for their projects because Python is versatile.
"""

# 处理文本
import re
words = re.findall(r'\b\w+\b', article.lower())
unique_words = set(words)
print(f"文章单词总数：{len(words)}个")
print(f"不重复单词：{len(unique_words)}个")
print(f"重复率：{(len(words) - len(unique_words)) / len(words) * 100:.1f}%")

# 集合在数据验证中的应用
required_fields = {"name", "age", "email"}
provided_fields = {"name", "age", "email", "phone"}

# 验证必填字段是否齐全
missing_fields = required_fields - provided_fields
extra_fields = provided_fields - required_fields

print(f"缺少字段：{missing_fields}")  # set()
print(f"额外字段：{extra_fields}")  # {'phone'}
print(f"必填字段齐全：{len(missing_fields) == 0}")  # True

# 集合推导式的应用
# 生成平方数集合
squares = {x**2 for x in range(10)}
print(f"平方数集合：{squares}")  # {0, 1, 4, 9, 16, 25, 36, 49, 64, 81}

# 生成质数集合（埃拉托斯特尼筛法）
def sieve_of_eratosthenes(n):
    """埃拉托斯特尼筛法生成质数"""
    primes = set(range(2, n+1))
    for i in range(2, int(n**0.5) + 1):
        if i in primes:
            # 删除i的所有倍数
            multiples = set(range(i*i, n+1, i))
            primes -= multiples
    return primes

primes = sieve_of_eratosthenes(30)
print(f"30以内质数：{sorted(primes)}")  # [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]

# 集合在密码学中的应用（简单示例）
def caesar_cipher_encrypt(text, shift):
    """凯撒密码加密"""
    alphabet = set("abcdefghijklmnopqrstuvwxyz")
    encrypted_chars = set()

    for char in text.lower():
        if char in alphabet:
            shifted_char = chr((ord(char) - ord('a') + shift) % 26 + ord('a'))
            encrypted_chars.add(shifted_char)

    return encrypted_chars

encrypted = caesar_cipher_encrypt("hello world", 3)
print(f"加密字符集合：{sorted(encrypted)}")  # ['d', 'h', 'o', 'r', 'w']

# 集合在去重和唯一性约束中的应用
# 模拟数据库唯一性约束
class UniqueConstraintSimulation:
    def __init__(self):
        self.stored_values = set()

    def add_value(self, value):
        """添加值，如果已存在则抛出异常"""
        if value in self.stored_values:
            raise ValueError(f"值 {value} 已存在")
        self.stored_values.add(value)
        return f"成功添加 {value}"

    def remove_value(self, value):
        """删除值"""
        if value in self.stored_values:
            self.stored_values.discard(value)
            return f"成功删除 {value}"
        return f"值 {value} 不存在"

    def get_values(self):
        """获取所有值"""
        return self.stored_values.copy()

# 模拟使用
simulator = UniqueConstraintSimulation()
print(simulator.add_value("user1"))
print(simulator.add_value("user2"))
try:
    print(simulator.add_value("user1"))  # 会抛出异常
except ValueError as e:
    print(f"错误：{e}")
print(simulator.get_values())
```

### 集合的性能优化

```python
import time
import sys

# 性能对比：列表 vs 集合
# 创建大数据集
large_list = list(range(100000))
large_set = set(range(100000))

# 成员关系测试性能对比
test_element = 99999

# 列表成员关系测试（O(n)）
start = time.time()
found_in_list = test_element in large_list
list_time = time.time() - start

# 集合成员关系测试（O(1)）
start = time.time()
found_in_set = test_element in large_set
set_time = time.time() - start

print(f"列表查找耗时：{list_time:.8f}秒")
print(f"集合查找耗时：{set_time:.8f}秒")
print(f"集合比列表快：{list_time/set_time:.2f}倍")

# 内存使用对比
print(f"列表内存：{sys.getsizeof(large_list)}字节")
print(f"集合内存：{sys.getsizeof(large_set)}字节")

# 去重性能对比
duplicate_list = [i % 10000 for i in range(100000)]

# 列表去重（低效）
start = time.time()
unique_list_slow = []
for item in duplicate_list:
    if item not in unique_list:  # O(n)操作
        unique_list_slow.append(item)
list_dedupe_time = time.time() - start

# 集合去重（高效）
start = time.time()
unique_set = list(set(duplicate_list))
set_dedupe_time = time.time() - start

print(f"列表去重耗时：{list_dedupe_time:.6f}秒")
print(f"集合去重耗时：{set_dedupe_time:.6f}秒")
print(f"集合去重比列表快：{list_dedupe_time/set_dedupe_time:.2f}倍")

# 集合操作性能对比
set_a = set(range(50000))
set_b = set(range(25000, 75000))

# 交集操作
start = time.time()
intersection = set_a & set_b
intersection_time = time.time() - start

# 并集操作
start = time.time()
union = set_a | set_b
union_time = time.time() - start

# 差集操作
start = time.time()
difference = set_a - set_b
difference_time = time.time() - start

print(f"交集操作耗时：{intersection_time:.6f}秒")
print(f"并集操作耗时：{union_time:.6f}秒")
print(f"差集操作耗时：{difference_time:.6f}秒")

# 集合操作的优化技巧
# 当一个集合很小的时候，可以优化检查
small_set = {1, 2, 3}
large_set = set(range(1000000))

# 优化技巧：检查小集合中的每个元素是否在大集合中
start = time.time()
are_all_in_large = all(item in large_set for item in small_set)
optimized_time = time.time() - start

print(f"优化检查耗时：{optimized_time:.8f}秒")

# 集合推导式的性能
start = time.time()
squares_comprehension = {x**2 for x in range(100000)}
comprehension_time = time.time() - start

start = time.time()
squares_loop = set()
for x in range(100000):
    squares_loop.add(x**2)
loop_time = time.time() - start

print(f"集合推导式耗时：{comprehension_time:.6f}秒")
print(f"循环添加耗时：{loop_time:.6f}秒")
print(f"推导式比循环快：{loop_time/comprehension_time:.2f}倍")

# 集合与列表的内存效率对比
large_list = list(range(100000))
large_set = set(range(100000))
large_range = range(100000)

print(f"列表内存：{sys.getsizeof(large_list)}字节")
print(f"集合内存：{sys.getsizeof(large_set)}字节")
print(f"range对象内存：{sys.getsizeof(large_range)}字节")

# 集合在大数据处理中的应用
def find_unique_elements(lists):
    """找出在所有列表中都唯一的元素"""
    if not lists:
        return set()

    # 使用集合操作找出所有列表的交集
    common_elements = set(lists[0])
    for lst in lists[1:]:
        common_elements &= set(lst)

    return common_elements

# 测试
list1 = [1, 2, 3, 4, 5]
list2 = [3, 4, 5, 6, 7]
list3 = [5, 6, 7, 8, 9]

unique_across_all = find_unique_elements([list1, list2, list3])
print(f"在所有列表中都存在的元素：{unique_across_all}")  # {5}

# 集合在缓存中的应用
class SimpleCache:
    """简单缓存实现"""

    def __init__(self, max_size=100):
        self.cache = {}
        self.access_order = []  # 记录访问顺序
        self.max_size = max_size

    def get(self, key):
        """获取缓存值"""
        if key in self.cache:
            # 更新访问顺序
            self.access_order.remove(key)
            self.access_order.append(key)
            return self.cache[key]
        return None

    def put(self, key, value):
        """放入缓存值"""
        if key in self.cache:
            # 更新已存在的值
            self.cache[key] = value
            self.access_order.remove(key)
            self.access_order.append(key)
        else:
            # 添加新值
            if len(self.cache) >= self.max_size:
                # 移除最少使用的项
                oldest = self.access_order.pop(0)
                del self.cache[oldest]

            self.cache[key] = value
            self.access_order.append(key)

    def get_cache_info(self):
        """获取缓存信息"""
        return {
            "缓存大小": len(self.cache),
            "最大容量": self.max_size,
            "访问顺序": self.access_order
        }

# 测试缓存
cache = SimpleCache(max_size=3)
for i in range(5):
    cache.put(f"key{i}", f"value{i}")

print(cache.get_cache_info())
print(f"key2值：{cache.get('key2')}")  # value2
print(f"key0值：{cache.get('key0')}")  # None（已被淘汰）

# 生成器在集合中的应用
def generate_primes(limit):
    """生成质数集合的生成器"""
    primes = set()
    for num in range(2, limit + 1):
        if all(num % prime != 0 for prime in primes if prime * prime <= num):
            primes.add(num)
            yield num

# 使用质数生成器
primes_gen = generate_primes(30)
primes_set = set(primes_gen)
print(f"30以内质数集合：{sorted(primes_set)}")  # [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]

# 集合在爬虫中的应用（模拟）
def crawl_pages(start_url, max_pages):
    """模拟网页爬虫集合应用"""
    visited = set()
    to_visit = [start_url]

    while to_visit and len(visited) < max_pages:
        url = to_visit.pop(0)
        if url not in visited:
            visited.add(url)

            # 模拟页面内容和链接
            page_content = f"内容来自：{url}"
            yield page_content

            # 模拟发现新链接
            new_links = [f"{url}/link{i}" for i in range(1, 4)]
            to_visit.extend(new_links)

# 使用爬虫生成器
# crawler = crawl_pages("http://example.com", 5)
# for page in crawler:
#     print(page)

# 集合的冻结应用
# frozenset在需要不可变集合时非常有用
config_options = frozenset(["debug", "verbose", "quiet"])
valid_options = {"debug", "verbose", "quiet", "silent"}

# 检查配置选项是否有效
invalid_options = config_options - valid_options
print(f"无效配置选项：{invalid_options}")  # set()

# frozenset可以作为字典的键
option_descriptions = {
    frozenset(["debug"]): "启用调试模式",
    frozenset(["verbose"]): "启用详细输出",
    frozenset(["quiet"]): "启用静默模式"
}

print(f"调试模式描述：{option_descriptions.get(frozenset(['debug']), '未知选项')}")

# 集合的布尔运算
set_a = {1, 2, 3, 4, 5}
set_b = {4, 5, 6, 7, 8}

# 使用all()和any()进行集合布尔运算
print(f"set_a中所有元素都大于0：{all(x > 0 for x in set_a)}")  # True
print(f"set_a中存在元素大于4：{any(x > 4 for x in set_a)}")  # True

# 集合的过滤应用
numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
even_numbers = {x for x in numbers if x % 2 == 0}
odd_numbers = {x for x in numbers if x % 2 == 1}

print(f"偶数集合：{even_numbers}")  # {2, 4, 6, 8, 10}
print(f"奇数集合：{odd_numbers}")   # {1, 3, 5, 7, 9}

# 集合的映射应用
numbers = {1, 2, 3, 4, 5}
squares = {x**2 for x in numbers}
print(f"平方集合：{squares}")  # {1, 4, 9, 16, 25}

# 集合的reduce应用（使用functools.reduce）
import functools

numbers = {1, 2, 3, 4, 5}
product = functools.reduce(lambda x, y: x * y, numbers)
print(f"所有数的乘积：{product}")  # 120

# 集合的函数式编程应用
numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

# map函数应用（集合推导式更常用）
squares_map = set(map(lambda x: x**2, numbers))
print(f"map生成的平方集合：{squares_map}")  # {1, 4, 9, 16, 25, 36, 49, 64, 81, 100}

# filter函数应用（集合推导式更常用）
even_filter = set(filter(lambda x: x % 2 == 0, numbers))
print(f"filter生成的偶数集合：{even_filter}")  # {2, 4, 6, 8, 10}

# 集合的性能监控
import timeit

# 性能测试：集合 vs 列表成员关系测试
def list_membership_test():
    large_list = list(range(10000))
    return 9999 in large_list

def set_membership_test():
    large_set = set(range(10000))
    return 9999 in large_set

list_time = timeit.timeit(list_membership_test, number=1000)
set_time = timeit.timeit(set_membership_test, number=1000)

print(f"列表成员关系测试耗时：{list_time:.6f}秒")
print(f"集合成员关系测试耗时：{set_time:.6f}秒")
print(f"集合比列表快：{list_time/set_time:.2f}倍")

# 集合的内存监控
import tracemalloc

# 启动内存跟踪
tracemalloc.start()

# 创建大列表
large_list = list(range(100000))
list_current, list_peak = tracemalloc.get_traced_memory()

# 创建大集合
large_set = set(range(100000))
set_current, set_peak = tracemalloc.get_traced_memory()

tracemalloc.stop()

print(f"列表内存使用：当前 {list_current/1024:.2f}KB，峰值 {list_peak/1024:.2f}KB")
print(f"集合内存使用：当前 {set_current/1024:.2f}KB，峰值 {set_peak/1024:.2f}KB")
```

