## 异常处理

异常处理是Python中处理错误和异常情况的重要机制，它允许程序在遇到错误时优雅地处理，而不是直接崩溃。

### 基本异常结构

Python使用`try-except`结构来捕获和处理异常，使得程序在出现错误时能够优雅地恢复而不是崩溃。

```python
# try-except基本结构
try:
    # 可能引发异常的代码
    num1 = int(input("请输入第一个数字："))  # 可能引发ValueError
    num2 = int(input("请输入第二个数字："))  # 可能引发ValueError
    result = num1 / num2                     # 可能引发ZeroDivisionError
    print(f"结果是：{result}")
except ValueError:
    # 处理特定异常：当输入无法转换为整数时触发
    print("请输入有效的数字！")
except ZeroDivisionError:
    # 处理除零错误：当除数为0时触发
    print("不能除以零！")
except Exception as e:
    # 处理所有其他异常：作为最后的保障
    print(f"发生未知错误：{e}")
else:
    # 没有异常时执行：当try块中没有异常时执行
    print("计算成功完成！")
finally:
    # 无论是否有异常都会执行：常用于资源清理
    print("程序执行完毕。")

# 单个except处理多种异常
try:
    # 一些可能产生多种异常的代码
    x = int("abc")      # ValueError：字符串无法转换为整数
    # y = 10 / 0        # ZeroDivisionError（被上一行阻止）
except (ValueError, ZeroDivisionError) as e:
    # 一个except块可以捕获多种异常类型
    print(f"发生了错误：{e}")
    print(f"错误类型：{type(e).__name__}")

# 没有异常类名（捕获所有异常，不推荐）
try:
    risky_operation()  # 假设这是一个可能失败的操作
except:
    # 裸露的except会捕获所有异常，隐藏了错误信息，难以调试
    print("发生了某种异常")
```

### 异常处理实践

1. **具体异常优先**：先捕获具体的异常类型，再捕获通用异常
2. **避免裸露`except`**：不要使用没有指定异常类型的`except`块
3. **合理使用`else`和`finally`**：`else`用于无异常时执行，`finally`用于清理资源
4. **记录异常信息**：使用logging模块记录异常详情便于调试
5. **自定义异常**：为特定业务场景创建自定义异常类

**实际应用示例**

```python
# Web请求异常处理示例
import random
import time

def simulate_web_request(url, timeout=5):
    """模拟Web请求"""
    try:
        print(f"请求URL: {url}")

        # 模拟网络延迟
        time.sleep(random.uniform(0.1, 1.0))

        # 模拟不同类型的响应
        responses = [
            {"status": 200, "data": "成功响应"},
            {"status": 404, "error": "页面未找到"},
            {"status": 500, "error": "服务器内部错误"},
            None  # 模拟超时或连接失败
        ]

        response = random.choice(responses)

        if response is None:
            raise TimeoutError("请求超时")
        elif response["status"] == 404:
            raise FileNotFoundError("资源未找到")
        elif response["status"] == 500:
            raise ConnectionError("服务器错误")
        else:
            return response["data"]

    except TimeoutError as e:
        print(f"超时错误: {e}")
        raise  # 重新抛出异常
    except FileNotFoundError as e:
        print(f"资源错误: {e}")
        return None
    except ConnectionError as e:
        print(f"连接错误: {e}")
        # 尝试重试
        print("尝试重新连接...")
        time.sleep(1)
        return simulate_web_request(url, timeout)
    except Exception as e:
        print(f"未预期错误: {e}")
        raise

# 数据库操作异常处理示例
class DatabaseError(Exception):
    """数据库操作异常"""
    pass

class ConnectionError(DatabaseError):
    """数据库连接异常"""
    pass

class QueryError(DatabaseError):
    """查询执行异常"""
    pass

def database_operation(operation_type):
    """模拟数据库操作"""
    try:
        if operation_type == "connect":
            # 模拟连接操作
            if random.random() < 0.3:  # 30%概率失败
                raise ConnectionError("无法连接到数据库服务器")
            print("数据库连接成功")
            return True
        elif operation_type == "query":
            # 模拟查询操作
            if random.random() < 0.2:  # 20%概率失败
                raise QueryError("SQL语法错误或表不存在")
            print("查询执行成功")
            return [{"id": 1, "name": "示例数据"}]
        else:
            raise ValueError(f"不支持的操作类型: {operation_type}")

    except ConnectionError as e:
        print(f"数据库连接失败: {e}")
        # 可以在这里实现重连逻辑
        return False
    except QueryError as e:
        print(f"查询执行失败: {e}")
        # 可以记录错误日志
        return None
    except ValueError as e:
        print(f"参数错误: {e}")
        raise  # 重新抛出，因为这是调用者的问题

# 示例调用
try:
    result = simulate_web_request("https://api.example.com/data")
    if result:
        print(f"请求结果: {result}")

    # 数据库操作示例
    if database_operation("connect"):
        data = database_operation("query")
        if data:
            print(f"查询数据: {data}")

except Exception as e:
    print(f"程序执行过程中发生严重错误: {e}")
```

**注意事项**

> **重要提醒**：
> 1. 不要忽略异常处理，即使是"不可能"出现的错误
> 2. 避免空的`except`块，至少应该记录日志
> 3. 对于重要操作，考虑实现重试机制
> 4. 敏感信息（如数据库密码）不要直接暴露在异常信息中
> 5. 异常处理会影响程序性能，不要过度使用

### 常见内置异常类型

Python提供了多种内置异常类型，用于表示不同种类的错误情况。了解这些异常类型有助于编写更健壮的程序，并进行适当的错误处理。

#### 基础异常类型示例

以下代码展示了Python中最常见的内置异常类型及其使用场景：

```python
# ValueError - 值错误
# 当函数接收到类型正确但值不合适的参数时引发
try:
    num = int("abc")  # "abc"是字符串类型，但内容无法转换为整数
except ValueError as e:
    print(f"ValueError: {e}")

# TypeError - 类型错误
# 当操作或函数应用于不适当类型的对象时引发
try:
    result = "5" + 3  # 字符串不能与数字直接相加
except TypeError as e:
    print(f"TypeError: {e}")

# IndexError - 索引错误
# 当使用超出序列范围的索引时引发
try:
    items = [1, 2, 3]
    item = items[5]  # 列表只有3个元素，索引5超出范围
except IndexError as e:
    print(f"IndexError: {e}")

# KeyError - 键错误
# 当使用字典中不存在的键时引发
try:
    data = {"name": "Alice", "age": 25}
    value = data["salary"]  # "salary"键不存在
except KeyError as e:
    print(f"KeyError: {e}")

# AttributeError - 属性错误
# 当试图访问对象不存在的属性或方法时引发
try:
    text = "hello"
    length = text.len()  # 字符串对象没有len方法，应该是len(text)
except AttributeError as e:
    print(f"AttributeError: {e}")

# FileNotFoundError - 文件未找到错误
# 当试图打开不存在的文件时引发
try:
    with open("nonexistent.txt", "r") as file:
        content = file.read()
except FileNotFoundError as e:
    print(f"FileNotFoundError: {e}")

# PermissionError - 权限错误
# 当试图执行没有足够权限的操作时引发
try:
    # 尝试访问可能没有权限的文件
    with open("/etc/passwd", "r") as file:  # Linux系统上的系统文件
        content = file.read()
except PermissionError as e:
    print(f"PermissionError: {e}")
except FileNotFoundError:
    print("文件不存在")

# ZeroDivisionError - 除零错误
# 当除数为零时引发
try:
    result = 10 / 0  # 除数为零
except ZeroDivisionError as e:
    print(f"ZeroDivisionError: {e}")

# ImportError - 导入错误
# 当import语句找不到模块或无法加载模块时引发
try:
    import nonexistent_module  # 不存在的模块
except ImportError as e:
    print(f"ImportError: {e}")

# MemoryError - 内存错误（模拟）
# 当操作需要内存超过可用内存时引发
try:
    # 尝试分配大量内存（注意：这可能会导致系统问题）
    # large_list = [0] * 10**10  # 可能导致MemoryError
    print("跳过内存分配测试")
except MemoryError as e:
    print(f"MemoryError: {e}")

# OverflowError - 溢出错误
# 当数值运算结果太大而无法表示时引发
import math
try:
    result = math.exp(1000)  # e的1000次方，超出浮点数表示范围
except OverflowError as e:
    print(f"OverflowError: {e}")

# StopIteration - 迭代器耗尽
# 当迭代器没有更多元素可提供时引发
iterator = iter([1, 2, 3])
try:
    while True:
        item = next(iterator)
        print(item)
    next(iterator)  # 迭代器已耗尽，再次调用会引发StopIteration
except StopIteration as e:
    print(f"StopIteration: 迭代器已耗尽")
```

#### 自定义异常

在实际开发中，我们经常需要定义自己的异常类型来处理特定的业务逻辑错误。自定义异常可以让错误处理更加精确和有意义。

```python
# 定义自定义异常类
class InvalidAgeError(Exception):
    """年龄无效异常"""
    def __init__(self, age):
        self.age = age
        self.message = f"无效的年龄：{age}。年龄必须在0-120之间"
        super().__init__(self.message)

class DuplicateUserError(Exception):
    """用户重复异常"""
    def __init__(self, username):
        self.username = username
        super().__init__(f"用户名'{username}'已存在")

# 使用自定义异常
def validate_age(age):
    """验证年龄
    Args:
        age (int/float): 要验证的年龄

    Returns:
        bool: 年龄有效返回True

    Raises:
        TypeError: 当年龄不是数字类型时引发
        InvalidAgeError: 当年龄不在有效范围内时引发
    """
    if not isinstance(age, (int, float)):
        raise TypeError("年龄必须是数字")
    if age < 0 or age > 120:
        raise InvalidAgeError(age)
    return True

# 测试自定义异常
try:
    validate_age(-5)
except InvalidAgeError as e:
    print(f"捕获到自定义异常：{e}")

try:
    validate_age("abc")
except TypeError as e:
    print(f"捕获到类型错误：{e}")

# 更复杂的自定义异常类
class DatabaseError(Exception):
    """数据库错误基类"""
    def __init__(self, message, error_code=None):
        super().__init__(message)
        self.error_code = error_code

class ConnectionError(DatabaseError):
    """连接错误"""
    pass

class QueryError(DatabaseError):
    """查询错误"""
    def __init__(self, message, query=None, error_code=None):
        super().__init__(message, error_code)
        self.query = query

# 使用数据库异常类
def execute_query(query):
    """模拟执行数据库查询
    Args:
        query (str): SQL查询语句

    Returns:
        str: 查询结果

    Raises:
        QueryError: 当查询为空或包含非法操作时引发
    """
    if not query:
        raise QueryError("查询不能为空", query=query, error_code=1001)
    if query.upper().startswith("DROP"):
        raise QueryError("不允许的查询操作", query=query, error_code=1002)
    return f"查询结果：{query}"

# 测试数据库异常
try:
    execute_query("")
except QueryError as e:
    print(f"查询错误：{e}")
    print(f"错误代码：{e.error_code}")
    print(f"执行的查询：{e.query}")

try:
    execute_query("DROP TABLE users")
except QueryError as e:
    print(f"查询错误：{e}")
    print(f"错误代码：{e.error_code}")
```

#### 异常链

异常链允许我们将一个异常作为另一个异常的原因，这样可以保留原始错误信息，便于调试和问题追踪。

```python
# 使用raise...from...创建异常链
def read_config_file(filename):
    """读取配置文件
    Args:
        filename (str): 配置文件名

    Returns:
        str: 配置文件内容

    Raises:
        ConfigurationError: 当配置文件不存在时引发，原始FileNotFoundError作为原因
    """
    try:
        with open(filename, "r") as file:
            return file.read()
    except FileNotFoundError as e:
        # 创建新异常并保持原始异常信息
        raise ConfigurationError(f"配置文件 {filename} 不存在") from e

class ConfigurationError(Exception):
    """配置错误"""
    pass

# 测试异常链
try:
    read_config_file("nonexistent_config.ini")
except ConfigurationError as e:
    print(f"捕获到配置错误：{e}")
    print(f"原始异常：{e.__cause__}")
    # 打印完整的异常链
    import traceback
    traceback.print_exc()

# 显式抑制异常链
def suppressed_example():
    """演示如何抑制异常链"""
    try:
        raise ValueError("原始错误")
    except ValueError as e:
        # 使用None抑制异常链
        raise RuntimeError("新错误") from None

try:
    suppressed_example()
except RuntimeError as e:
    print(f"捕获到运行时错误：{e}")
    print(f"是否还有原始异常：{e.__cause__ is None}")  # True

# 自定义异常链
class BusinessLogicError(Exception):
    """业务逻辑错误"""
    def __init__(self, message, underlying_error=None):
        super().__init__(message)
        self.underlying_error = underlying_error

def process_data(data):
    """处理数据
    Args:
        data: 要处理的数据

    Returns:
        str: 处理后的数据

    Raises:
        BusinessLogicError: 当数据处理失败时引发，包含底层错误信息
    """
    try:
        # 假设这里有一些可能失败的处理
        if data is None:
            raise ValueError("数据不能为空")
        return data.upper()
    except Exception as e:
        raise BusinessLogicError("数据处理失败", e)

try:
    process_data(None)
except BusinessLogicError as e:
    print(f"业务逻辑错误：{e}")
    print(f"底层错误：{e.underlying_error}")
```

#### 异常处理的高级技巧

掌握异常处理的高级技巧可以帮助我们编写更高效、更易维护的代码。

```python
# 使用traceback模块获取详细的异常信息
import traceback

def detailed_exception_handling():
    """详细的异常处理示例，展示如何获取完整的异常信息"""
    try:
        # 一些复杂的操作
        data = {"name": "Alice", "age": "twenty-five"}  # 字符串形式的年龄
        age = data["age"] * 2  # 这会失败，因为字符串不能乘2
        return age
    except KeyError as e:
        print(f"键错误：{e}")
        traceback.print_exc()  # 打印堆栈跟踪
    except TypeError as e:
        print(f"类型错误：{e}")
        # 获取详细的异常信息
        exc_type, exc_value, exc_traceback = sys.exc_info()
        print(f"异常类型：{exc_type}")
        print(f"异常值：{exc_value}")
        traceback.print_tb(exc_traceback)
    finally:
        print("清理资源")

import sys
detailed_exception_handling()

# 异常处理中的上下文管理
class DatabaseConnection:
    """模拟数据库连接，演示如何在上下文管理器中处理异常"""
    def __init__(self, db_name):
        """初始化数据库连接
        Args:
            db_name (str): 数据库名称
        """
        self.db_name = db_name
        self.connected = False

    def connect(self):
        """建立数据库连接"""
        print(f"连接到数据库 {self.db_name}")
        self.connected = True
        # 模拟连接失败
        if "bad" in self.db_name:
            raise ConnectionError("无法连接到数据库")

    def disconnect(self):
        """断开数据库连接"""
        if self.connected:
            print(f"断开与数据库 {self.db_name} 的连接")
            self.connected = False

    def __enter__(self):
        """进入上下文管理器"""
        self.connect()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """退出上下文管理器
        Args:
            exc_type: 异常类型
            exc_val: 异常值
            exc_tb: 异常 traceback

        Returns:
            bool: 如果返回True，则抑制异常；返回False（默认）则继续传播异常
        """
        self.disconnect()
        # 如果返回True，则抑制异常
        # return False（默认）则继续传播异常
        return False

# 使用上下文管理器
try:
    with DatabaseConnection("good_db") as conn:
        print("执行数据库操作")
except ConnectionError as e:
    print(f"连接错误：{e}")

# 使用上下文管理器处理异常
try:
    with DatabaseConnection("bad_db") as conn:
        print("执行数据库操作")
except ConnectionError as e:
    print(f"连接错误：{e}")

# 异常处理的性能考虑
import time

def exception_vs_conditional(n):
    """比较异常处理和条件判断的性能
    Args:
        n (int): 循环次数
    """
    # 方法1：使用条件判断
    start = time.time()
    for i in range(n):
        d = {"key": "value"}
        if "key" in d:
            value = d["key"]
    conditional_time = time.time() - start

    # 方法2：使用异常处理
    start = time.time()
    for i in range(n):
        d = {"key": "value"}
        try:
            value = d["key"]
        except KeyError:
            value = None
    exception_time = time.time() - start

    print(f"条件判断时间：{conditional_time:.6f}秒")
    print(f"异常处理时间：{exception_time:.6f}秒")
    print(f"性能差异：{exception_time/conditional_time:.2f}倍")

exception_vs_conditional(100000)

# 异常处理的最佳实践
def best_practice_example():
    """异常处理最佳实践示例，演示良好的异常处理模式"""
    try:
        # 1. 尽量精确地捕获特定异常
        file_path = "example.txt"
        with open(file_path, "r") as file:
            content = file.read()

        # 2. 使用finally或with语句确保资源清理
        # 3. 在except块中执行恢复操作
        print("文件读取成功")

    except FileNotFoundError:
        # 4. 为每种异常类型提供特定的处理
        print(f"文件 {file_path} 不存在，将创建新文件")
        with open(file_path, "w") as file:
            file.write("默认内容")

    except PermissionError:
        print(f"没有权限访问文件 {file_path}")

    except Exception as e:
        # 5. 捕获通用异常作为最后的保障
        print(f"读取文件时发生未知错误：{e}")
        # 记录错误日志
        import logging
        logging.exception("文件读取失败")

    else:
        # 6. 使用else块处理无异常的情况
        print(f"文件内容长度：{len(content)}")

    finally:
        # 7. 使用finally块执行必要的清理
        print("文件操作完成")

best_practice_example()

# 异常重试机制
import random
import time

def retry_on_exception(max_retries=3, delay=1):
    """重试装饰器，用于为可能失败的操作添加重试机制
    Args:
        max_retries (int): 最大重试次数，默认为3次
        delay (int): 重试间隔时间（秒），默认为1秒

    Returns:
        function: 装饰器函数
    """
    def decorator(func):
        def wrapper(*args, **kwargs):
            last_exception = None

            for attempt in range(max_retries):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    last_exception = e
                    if attempt < max_retries - 1:
                        print(f"操作失败（尝试 {attempt + 1}/{max_retries}）：{e}")
                        print(f"{delay}秒后重试...")
                        time.sleep(delay)
                    else:
                        print(f"所有 {max_retries} 次尝试都失败了")

            # 如果所有尝试都失败，重新抛出最后一个异常
            raise last_exception
        return wrapper
    return decorator

# 使用重试装饰器
@retry_on_exception(max_retries=3, delay=1)
def unreliable_operation():
    """不可靠的操作（有概率失败）
    Returns:
        str: 操作成功时返回结果

    Raises:
        ConnectionError: 当操作失败时引发
    """
    if random.random() < 0.7:  # 70%的失败率
        raise ConnectionError("连接超时")
    return "操作成功"

try:
    result = unreliable_operation()
    print(f"最终结果：{result}")
except Exception as e:
    print(f"操作彻底失败：{e}")
```

