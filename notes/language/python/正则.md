
# 正则表达式 

## 正则表达式核心基础

### 1.1 字符匹配机制

正则表达式的核心匹配逻辑是“逐个字符判断”：对目标字符串的每个元素，依次检查是否符合正则规则，直至完成整个字符串的匹配判断。

#### 1.1.1 书写注意事项

- **避免多余空格**：正则表达式是严格匹配的字符串，随意添加空格会被视为匹配目标，导致匹配失败（如 `r"test 123"` 会匹配包含空格的“test 123”，而非“test123”）。

- **原始字符串使用**：Python 字符串和正则表达式均使用 `\` 作为转义字符，若不使用原始字符串（前缀 `r`），需用 `\\` 实现一次转义，易出错。因此**强烈建议所有正则表达式都用原始字符串书写**（如 `r"\d"` 无需写成 ` "\\d"`）。

### 1.2 普通字符

普通字符是正则表达式中最基础的元素，**仅匹配自身**，无特殊含义，大部分字符（如字母、数字、普通符号）均属于普通字符。

```Python
import re  # 导入re模块

# 定义正则模式：匹配普通字符组合"test123"（字母test+数字123）
# 该模式仅能匹配与"test123"完全一致的子串
p = re.compile(r"test123")

# 调用Pattern对象的search方法：在目标字符串中查找第一个匹配的子串
# 参数"atest123b"是目标字符串，包含"test123"子串
# 返回值：匹配成功时返回Match对象（包含匹配位置、内容等信息），失败返回None
print(p.search("atest123b"))  # 输出：<re.Match object; span=(1, 8), match='test123'>
```

### 1.3 特殊字符（元字符）

元字符是正则表达式的核心，**不匹配自身**，而是具有特殊功能（如匹配任意字符、控制重复次数等），常见元字符包括：`. ^ $ * + ? { } [ ] \ | ( )`。

#### 1.3.1 元字符：`.`（匹配任意字符）

- **基础功能**：匹配除换行符（`\n`）以外的任意单个字符（字母、数字、符号、空格等）。

- **DOTALL模式**：若在编译正则时指定 `flags=re.DOTALL`，`.` 会匹配包括换行符在内的任意字符。

```Python
import re  # 导入re模块

# 1. 基础模式：. 不匹配换行符
# 编译正则模式r"."，仅匹配单个非换行字符
p = re.compile(r".")

# 调用match方法：从字符串开头开始匹配，返回第一个匹配结果
print(p.match("abc"))    # 匹配"a"，输出：<re.Match object; span=(0, 1), match='a'>
print(p.match("9bc"))    # 匹配"9"，输出：<re.Match object; span=(0, 1), match='9'>
print(p.match("@bc"))    # 匹配"@"，输出：<re.Match object; span=(0, 1), match='@'>
print(p.match(".bc"))    # 匹配"."（此时.是普通字符），输出：<re.Match object; span=(0, 1), match='.'>
print(p.match("\tbc"))   # 匹配制表符"\t"，输出：<re.Match object; span=(0, 1), match='\t'>
print(p.match("\nbc"))   # 不匹配换行符"\n"，输出：None

# 2. DOTALL模式：. 匹配换行符
# 编译时指定flags=re.DOTALL，开启换行符匹配
p = re.compile(r".", flags=re.DOTALL)
print(p.match("\nbc"))   # 匹配换行符"\n"，输出：<re.Match object; span=(0, 1), match='\n'>
```

#### 1.3.2 元字符：`^`（匹配字符串开头）

- **基础功能**：仅匹配目标字符串的**开头位置**，若字符串开头不符合规则则匹配失败。

- **MULTILINE模式**：指定 `flags=re.MULTILINE` 后，`^` 不仅匹配整个字符串的开头，还会匹配**每一行的开头**（即换行符 `\n` 后的位置）。

```Python
import re  # 导入re模块

# 1. 基础模式：^ 仅匹配整个字符串开头
# 正则模式r"^ab"：匹配以"ab"开头的字符串
p = re.compile(r"^ab")
# 目标字符串"abcd\nabfg"：仅开头是"ab"，换行后的"ab"不在整个字符串开头
print(p.findall("abcd\nabfg"))  # 输出：['ab']（仅匹配到第一个"ab"）

# 2. MULTILINE模式：^ 匹配每行开头
# 编译时指定flags=re.MULTILINE，开启多行匹配
p = re.compile(r"^ab", flags=re.MULTILINE)
# 目标字符串中，"abcd"开头和"\n"后的"abfg"开头均会被匹配
print(p.findall("abcd\nabfg"))  # 输出：['ab', 'ab']（匹配到两个"ab"）
```

#### 1.3.3 元字符：`$`（匹配字符串末尾）

- **基础功能**：匹配目标字符串的**末尾位置**，或字符串结尾换行符 `\n` 之前的位置。

- **MULTILINE模式**：指定 `flags=re.MULTILINE` 后，`$` 不仅匹配整个字符串的末尾，还会匹配**每一行的末尾**（即换行符 `\n` 之前的位置）。

```Python
import re  # 导入re模块

# 1. 基础模式：$ 匹配整个字符串末尾或换行符前
# 正则模式r"cd$"：匹配以"cd"结尾的字符串
p = re.compile(r"cd$")
print(p.findall("abcd\n"))  # 目标字符串结尾是"\n"，"cd"在"\n"前，匹配成功，输出：['cd']

# 2. MULTILINE模式：$ 匹配每行末尾
p = re.compile(r"cd$", flags=re.MULTILINE)
# 目标字符串"abcd\nefcd"中，"abcd"末尾和"efcd"末尾均有"cd"，均匹配
print(p.findall("abcd\nefcd"))  # 输出：['cd', 'cd']

# 3. 特殊场景：$ 匹配空位置
p = re.compile(r"$")
# 目标字符串"abcd\n"的末尾（"\n"后）和"\n"前各有一个空位置，共两个匹配
print(p.findall("abcd\n"))  # 输出：['', '']（两个空字符串匹配结果）
```

#### 1.3.4 重复限定符（`*` `+` `?` `{m,n}`）

重复限定符用于控制其**前面的正则表达式**的匹配次数，默认采用“贪婪模式”（尽可能多匹配），添加 `?` 后变为“非贪婪模式”（尽可能少匹配）。

##### 1. 限定符 `*`：匹配0到任意次

- **功能**：对前面的正则表达式匹配 **0次或无限次**（可没有匹配，也可多次匹配），贪婪模式。

```Python
import re  # 导入re模块

# 正则模式r"ab*"：a后面跟0个或多个b
p = re.compile(r"ab*")

# 匹配"a"：a后面0个b，符合规则
print(p.search("a"))       # 输出：<re.Match object; span=(0, 1), match='a'>
# 匹配"ab"：a后面1个b，符合规则
print(p.search("ab"))      # 输出：<re.Match object; span=(0, 2), match='ab'>
# 匹配"abb"：a后面2个b，符合规则
print(p.search("abb"))     # 输出：<re.Match object; span=(0, 3), match='abb'>
# 匹配"abbbc"：a后面3个b，符合规则（贪婪模式取最多b）
print(p.search("abbbc"))   # 输出：<re.Match object; span=(0, 4), match='abbb'>
```

##### 2. 限定符 `+`：匹配1到任意次

- **功能**：对前面的正则表达式匹配 **1次或无限次**（至少匹配1次），贪婪模式。

```Python
import re  # 导入re模块

# 正则模式r"ab+"：a后面跟1个或多个b
p = re.compile(r"ab+")

# 匹配"a"：a后面0个b，不符合规则，输出：None
print(p.search("a"))       
# 匹配"ab"：a后面1个b，符合规则
print(p.search("ab"))      # 输出：<re.Match object; span=(0, 2), match='ab'>
# 匹配"abb"：a后面2个b，符合规则
print(p.search("abb"))     # 输出：<re.Match object; span=(0, 3), match='abb'>
# 匹配"abbbc"：a后面3个b，符合规则（贪婪模式取最多b）
print(p.search("abbbc"))   # 输出：<re.Match object; span=(0, 4), match='abbb'>
```

##### 3. 限定符 `?`：匹配0到1次

- **功能**：对前面的正则表达式匹配 **0次或1次**（可选匹配），贪婪模式。

```Python
import re  # 导入re模块

# 正则模式r"ab?"：a后面跟0个或1个b
p = re.compile(r"ab?")

# 匹配"a"：a后面0个b，符合规则
print(p.search("a"))       # 输出：<re.Match object; span=(0, 1), match='a'>
# 匹配"ab"：a后面1个b，符合规则
print(p.search("ab"))      # 输出：<re.Match object; span=(0, 2), match='ab'>
# 匹配"abb"：a后面1个b（贪婪模式取1次，忽略多余b）
print(p.search("abb"))     # 输出：<re.Match object; span=(0, 2), match='ab'>
# 匹配"abbbc"：a后面1个b（贪婪模式取1次）
print(p.search("abbbc"))   # 输出：<re.Match object; span=(0, 2), match='ab'>
```

##### 4. 非贪婪模式（`*?` `+?` `??`）

- **功能**：在 `*` `+` `?` 后添加 `?`，将贪婪模式转为非贪婪模式，即“尽可能少匹配”。

```Python
import re  # 导入re模块

# 1. *? 非贪婪：匹配0到任意次，尽可能少
# 模式r'<.*>'（贪婪）：匹配从第一个"<"到最后一个">"的所有内容
p = re.compile(r'<.*>')
print(p.search('<a> b <c>'))  # 输出：<re.Match object; span=(0, 7), match='<a> b <c>'>
# 模式r'<.*?>'（非贪婪）：匹配从"<"到最近的">"的内容
p = re.compile(r'<.*?>')
print(p.search('<a> b <c>'))  # 输出：<re.Match object; span=(0, 3), match='<a>'>

# 2. +? 非贪婪：匹配1到任意次，尽可能少
p = re.compile(r"ab+?")
# 目标"abbbc"：a后面至少1个b，非贪婪取1个b
print(p.search("abbbc"))       # 输出：<re.Match object; span=(0, 2), match='ab'>

# 3. ?? 非贪婪：匹配0到1次，尽可能少（优先0次）
p = re.compile(r"ab??")
# 目标"abc"：a后面优先0个b，仅匹配"a"
print(p.search("abc"))         # 输出：<re.Match object; span=(0, 1), match='a'>
```

##### 5. 限定符 `{m}` `{m,n}`：指定匹配次数

- `{m}`：对前面的正则表达式**精确匹配m次**。

- `{m,n}`：对前面的正则表达式匹配 **m到n次**（m≤次数≤n），贪婪模式；忽略m则下限为0（`{,n}`），忽略n则上限为无限（`{m,}`），逗号不可省略。

```Python
import re  # 导入re模块

# 1. {m}：精确匹配m次
# 模式r"ab{2}"：a后面精确匹配2个b
p = re.compile(r"ab{2}")
print(p.search("abc"))    # a后面1个b，不匹配，输出：None
print(p.search("abbc"))   # a后面2个b，匹配，输出：<re.Match object; span=(0, 3), match='abb'>
print(p.search("abbbc"))  # a后面3个b，取前2个b，输出：<re.Match object; span=(0, 3), match='abb'>

# 2. {m,n}：匹配m到n次（贪婪）
# 模式r"ab{2,4}"：a后面匹配2-4个b
p = re.compile(r"ab{2,4}")
print(p.search("abc"))    # 1个b，不匹配，输出：None
print(p.search("abbc"))   # 2个b，匹配，输出：<re.Match object; span=(0, 3), match='abb'>
print(p.search("abbbc"))  # 3个b，匹配，输出：<re.Match object; span=(0, 4), match='abbb'>
print(p.search("abbbbc")) # 4个b，匹配，输出：<re.Match object; span=(0, 5), match='abbbb'>
print(p.search("abbbbbc"))# 5个b，取前4个，输出：<re.Match object; span=(0, 5), match='abbbb'>

# 3. {,n}：匹配0到n次
p = re.compile(r"ab{,4}")
print(p.search("ac"))     # 0个b，匹配"a"，输出：<re.Match object; span=(0, 1), match='a'>
print(p.search("abc"))    # 1个b，匹配"ab"，输出：<re.Match object; span=(0, 2), match='ab'>

# 4. {m,}：匹配m到无限次
p = re.compile(r"ab{2,}")
print(p.search("abbbbc")) # 4个b，匹配"abbbb"，输出：<re.Match object; span=(0, 5), match='abbbb'>
print(p.search("abbbbbc"))# 5个b，匹配"abbbbb"，输出：<re.Match object; span=(0, 6), match='abbbbb'>
```

##### 6. 非贪婪限定符 `{m,n}?`

- **功能**：在 `{m,n}` 后添加 `?`，转为非贪婪模式，即“尽可能少匹配”（优先匹配m次）。

```Python
import re  # 导入re模块

# 模式r"ab{2,4}?"：a后面匹配2-4个b，非贪婪（优先2个）
p = re.compile(r"ab{2,4}?")
print(p.search("abc"))    # 1个b，不匹配，输出：None
print(p.search("abbc"))   # 2个b，匹配，输出：<re.Match object; span=(0, 3), match='abb'>
print(p.search("abbbc"))  # 3个b，优先2个，输出：<re.Match object; span=(0, 3), match='abb'>
print(p.search("abbbbc")) # 4个b，优先2个，输出：<re.Match object; span=(0, 3), match='abb'>
print(p.search("abbbbbc"))# 5个b，优先2个，输出：<re.Match object; span=(0, 3), match='abb'>

# {,n}?：0到n次，非贪婪（优先0次）
p = re.compile(r"ab{,4}?")
print(p.search("ac"))     # 0个b，匹配"a"，输出：<re.Match object; span=(0, 1), match='a'>
print(p.search("abc"))    # 1个b，优先0次，匹配"a"，输出：<re.Match object; span=(0, 1), match='a'>

# {m,}?：m到无限次，非贪婪（优先m次）
p = re.compile(r"ab{2,}?")
print(p.search("abbbbc")) # 4个b，优先2个，输出：<re.Match object; span=(0, 3), match='abb'>
print(p.search("abbbbbc"))# 5个b，优先2个，输出：<re.Match object; span=(0, 3), match='abb'>
```

#### 1.3.5 元字符：`|`（逻辑或）

- **功能**：连接两个正则表达式（如 `A|B`），表示匹配 `A` 或 `B`，**一旦A匹配成功，B不再匹配**（短路逻辑）。

```Python
import re  # 导入re模块

# 模式r"d|e|b"：匹配"d"、"e"或"b"，优先匹配先出现的
p = re.compile(r"d|e|b")

# 目标"abc"：第一个匹配的是"b"（位置1）
print(p.search("abc"))    # 输出：<re.Match object; span=(1, 2), match='b'>
# 目标"aebcd"：第一个匹配的是"e"（位置1），后续"b"和"d"不再匹配
print(p.search("aebcd"))  # 输出：<re.Match object; span=(1, 2), match='e'>
```

#### 1.3.6 元字符：`\`（转义与特殊序列）

`\` 有两种核心用途：一是转义特殊字符（将元字符转为普通字符），二是构建特殊序列（如 `\d` 匹配数字）。

##### 1. 转义特殊字符

当需要匹配元字符本身（如 `*` `+` `?`）时，需用 `\` 转义，使其失去特殊含义，变为普通字符。

```Python
import re  # 导入re模块

# 1. 匹配*号：\* 转义后，*变为普通字符
p = re.compile(r"\*")
print(p.fullmatch("*"))   # 仅匹配"*"，输出：<re.Match object; span=(0, 1), match='*'>

# 2. 匹配+号：\+ 转义后，+变为普通字符
p = re.compile(r"\+")
print(p.fullmatch("+"))   # 仅匹配"+"，输出：<re.Match object; span=(0, 1), match='+'>

# 3. 匹配?号：\? 转义后，?变为普通字符
p = re.compile(r"\?")
print(p.fullmatch("?"))   # 仅匹配"?"，输出：<re.Match object; span=(0, 1), match='?'>
```

##### 2. 特殊序列（`\number` `\A` `\b` 等）

特殊序列由 `\` + 字符组成，具有特定匹配功能，常见序列如下：

|特殊序列|功能描述|
|---|---|
|`\number`|匹配第 `number` 个分组的内容（分组从1开始编号），仅在分组外生效；在 `[]` 内视为普通数字|
|`\A`|匹配字符串开头，与 `^` 区别：MULTILINE模式下不识别换行|
|`\b`|匹配单词边界（空字符串，仅在单词开头/结尾）|
|`\B`|匹配非单词边界（空字符串，不在单词开头/结尾）|
|`\d`|匹配任意数字，等价于 `[0-9]`|
|`\D`|匹配任意非数字，等价于 `[^0-9]`|
|`\s`|匹配任意空白符（空格、制表符 `\t`、换行符 `\n` 等）|
|`\S`|匹配任意非空白符|
|`\w`|匹配字母、数字、下划线，等价于 `[a-zA-Z0-9_]`|
|`\W`|匹配非字母、非数字、非下划线，等价于 `[^a-zA-Z0-9_]`|
|`\Z`|匹配字符串末尾，MULTILINE模式下不识别换行|
###### 示例1：`\number`（分组引用）

```Python
import re  # 导入re模块

# 1. \1 引用第1组内容：匹配与第1组完全相同的内容
# 模式r"(.+) \1"：(.+)是第1组（匹配任意非空字符），\1匹配与第1组相同的内容
p = re.compile(r"(.+) \1")
print(p.search("ab abc")) # 第1组是"ab"，后续是"abc"（不同），不匹配，输出：None
print(p.search("5 5"))    # 第1组是"5"，后续是"5"（相同），匹配，输出：<re.Match object; span=(0, 3), match='5 5'>

# 2. 无引用的多组：各组内容可不同
# 模式r"(.+) (.+)"：两个独立分组，内容无需相同
p = re.compile(r"(.+) (.+)")
print(p.search("ab abc")) # 第1组"ab"，第2组"abc"，匹配，输出：<re.Match object; span=(0, 5), match='ab abc'>
print(p.search("5 5"))    # 第1组"5"，第2组"5"，匹配，输出：<re.Match object; span=(0, 3), match='5 5'>
```

###### 示例2：`\A`（匹配字符串开头）

```Python
import re  # 导入re模块

# 1. ^ 与 MULTILINE模式：匹配整个字符串开头和每行开头
p = re.compile(r"^ab")
print(p.findall("abcd\nabfg"))  # 仅匹配整个字符串开头的"ab"，输出：['ab']
p = re.compile(r"^ab", flags=re.MULTILINE)
print(p.findall("abcd\nabfg"))  # 匹配整个字符串开头和换行后的"ab"，输出：['ab', 'ab']

# 2. \A 与 MULTILINE模式：仅匹配整个字符串开头
p = re.compile(r"\Aab")
print(p.findall("abcd\nabfg"))  # 仅匹配整个字符串开头的"ab"，输出：['ab']
p = re.compile(r"\Aab", flags=re.MULTILINE)
print(p.findall("abcd\nabfg"))  # 不受MULTILINE影响，仍仅匹配整个字符串开头的"ab"，输出：['ab']
```

###### 示例3：`\b`（单词边界）与 `\B`（非单词边界）

```Python
import re  # 导入re模块

# 1. \b：匹配单词边界
# 模式r"er\b"：匹配以"er"结尾的单词（"er"后是单词边界）
p = re.compile(r"er\b")
print(p.search("never"))  # "never"末尾是"er"，后接单词边界，匹配，输出：<re.Match object; span=(3, 5), match='er'>
print(p.search("verb"))   # "verb"中"er"在中间，后非边界，不匹配，输出：None

# 模式r"\ba\b"：匹配单独的"a"（前后均为单词边界）
p = re.compile(r"\ba\b")
print(p.search("I have a dog"))  # 匹配单独的"a"，输出：<re.Match object; span=(7, 8), match='a'>

# 2. \B：匹配非单词边界
# 模式r"er\B"：匹配在单词中间的"er"
p = re.compile(r"er\B")
print(p.search("never"))  # "never"中"er"在末尾（边界），不匹配，输出：None
print(p.search("verb"))   # "verb"中"er"在中间（非边界），匹配，输出：<re.Match object; span=(1, 3), match='er'>

# 模式r"\Ba\B"：匹配在单词中间的"a"
p = re.compile(r"\Ba\B")
print(p.search("I have a dog"))  # "a"是单独的（前后边界），不匹配，输出：None
```

###### 示例4：`\d`（数字）与 `\D`（非数字）

```Python
import re  # 导入re模块

# 1. \d：匹配任意数字
p = re.compile(r"\d")
# 目标"a1234b"：第一个数字是"1"
print(p.search("a1234b"))  # 输出：<re.Match object; span=(1, 2), match='1'>

# \d+：匹配1个或多个数字（贪婪）
p = re.compile(r"\d+")
# 目标"a1234b"：所有数字"1234"
print(p.search("a1234b"))  # 输出：<re.Match object; span=(1, 5), match='1234'>

# 2. \D：匹配任意非数字
p = re.compile(r"\D")
# 目标"ab1234c"：第一个非数字是"a"
print(p.search("ab1234c")) # 输出：<re.Match object; span=(0, 1), match='a'>

# \D+：匹配1个或多个非数字（贪婪）
p = re.compile(r"\D+")
# 目标"ab1234c"：开头非数字"ab"
print(p.search("ab1234c")) # 输出：<re.Match object; span=(0, 2), match='ab'>
```

###### 示例5：`\s`（空白符）与 `\S`（非空白符）

```Python
import re  # 导入re模块

# 1. \s：匹配空白符
# 模式r"a\sb"：a和b之间是空白符
p = re.compile(r"a\sb")
# 目标"adb a bc"："a bc"中的"a"和"b"之间是空格（空白符）
print(p.search("adb a bc"))  # 输出：<re.Match object; span=(3, 5), match='a b'>

# 2. \S：匹配非空白符
# 模式r"a\Sb"：a和b之间是非空白符
p = re.compile(r"a\Sb")
# 目标"adb a bc"："adb"中的"a"和"b"之间是"d"（非空白符）
print(p.search("adb a bc"))  # 输出：<re.Match object; span=(0, 3), match='adb'>
```

###### 示例6：`\w`（字母/数字/下划线）与 `\W`（非字母/非数字/非下划线）

```Python
import re  # 导入re模块

# 1. \w：匹配字母、数字、下划线
# 模式r"a\wb"：a和b之间是字母/数字/下划线
p = re.compile(r"a\wb")
# 目标"adba9ba_ba b"：符合条件的子串有"adb"（d）、"a9b"（9）、"a_b"（_）
print(p.findall("adba9ba_ba b"))  # 输出：['adb', 'a9b', 'a_b']

# 2. \W：匹配非字母、非数字、非下划线
# 模式r"a\Wb"：a和b之间是非字母/非数字/非下划线（如空格）
p = re.compile(r"a\Wb")
# 目标"adba9ba_ba b"：仅"a b"中的a和b之间是空格（\W）
print(p.findall("adba9ba_ba b"))  # 输出：['a b']
```

###### 示例7：`\Z`（匹配字符串末尾）

```Python
import re  # 导入re模块

# 模式r"cd\Z"：匹配以"cd"结尾的字符串（\Z不识别换行）
p = re.compile(r"cd\Z")
print(p.findall("abcd"))    # 字符串末尾是"cd"，匹配，输出：['cd']
print(p.findall("abcd\n"))  # 字符串末尾是"\n"，"cd"在"\n"前，不匹配，输出：[]

# MULTILINE模式下，\Z仍不识别换行
p2 = re.compile(r"cd\Z", flags=re.MULTILINE)
print(p2.findall("abcd\nef"))  # 仅字符串末尾是"ef"，无"cd"，输出：[]

# 模式r"\Z"：匹配字符串末尾的空位置
p = re.compile(r"\Z")
print(p.findall("abcd\n"))  # 仅字符串末尾（"\n"后）有1个空位置，输出：['']
```

###### 示例8：Python标准转义字符

正则表达式支持大部分Python标准转义字符（如 `\n` `\t` `\\` 等），用法与Python字符串一致。

```Python
import re  # 导入re模块

# 匹配换行符"\n"
p = re.compile(r"\n")
print(p.findall("\n"))  # 输出：['\n']

# 匹配制表符"\t"
p = re.compile(r"\t")
print(p.findall("\t"))  # 输出：['\t']

# 匹配反斜杠"\\"（需转义，原始字符串中写为r"\\"）
p = re.compile(r"\\")
print(p.findall("\\"))  # 输出：['\\']

# 匹配单引号"'"
p = re.compile(r"\'")
print(p.findall("'"))   # 输出：["'"]

# 匹配双引号'"'
p = re.compile(r"\"")
print(p.findall('"'))   # 输出：['"']
```

#### 1.3.7 字符集 `[]`

字符集用于定义“匹配一组字符中的任意一个”，支持单个字符列举、范围表示、取反等功能，且**元字符在字符集中会失去特殊含义**（无需转义）。

##### 1. 基础用法：单个字符列举与范围表示

- **单个列举**：`[amk]` 表示匹配 `a`、`m`、`k` 中的任意一个。

- **范围表示**：`[a-y]` 表示匹配 `a` 到 `y` 的任意小写字母，`[0-5][A-Y]` 表示匹配0-5的数字+A-Y的大写字母。

```Python
import re  # 导入re模块

# 1. 单个字符列举：[amk]匹配a、m、k中的任意一个
p = re.compile(r"[amk]")
# 目标"I have a monkey"：包含"a"和"m"
print(p.findall("I have a monkey"))  # 输出：['a', 'm', 'k']

# 2. 字符范围：[a-y]匹配a到y的小写字母
p = re.compile(r"[a-y]")
# 目标"ahzyqAHZYQ"：小写字母有a、h、y、q（z超出a-y范围，不匹配）
print(p.findall("ahzyqAHZYQ"))  # 输出：['a', 'h', 'y', 'q']

# 3. 多范围组合：[0-5][A-Y]匹配0-5数字+A-Y大写字母
p = re.compile(r"[0-5][A-Y]")
# 目标"a0hzyq125A6HZYQ"：符合条件的是"0h"（0+h，h不在A-Y，不匹配）、"5A"（5+A，匹配）
print(p.findall("a0hzyq125A6HZYQ"))  # 输出：['5A']
```

##### 2. 特殊特性：元字符失效与特殊序列支持

- **元字符失效**：`.` `+` `*` 等元字符在 `[]` 中视为普通字符，无需转义（如 `[.+]` 匹配 `.` 或 `+`）。

- **特殊序列支持**：`\d` `\s` `\w` 等特殊序列在 `[]` 中仍有效（如 `[\d]` 等价于 `[0-9]`）。

```Python
import re  # 导入re模块

# 1. 元字符在字符集中失效
p = re.compile(r"[.+]")
print(p.findall("abc"))    # 无.或+，输出：[]
print(p.findall("a.b+c.d+"))# 包含.和+，输出：['.', '+', '.', '+']

# 2. 特殊序列在字符集中有效
# \d：匹配数字
p = re.compile(r"[\d]")
print(p.search("a1234b"))  # 匹配"1"，输出：<re.Match object; span=(1, 2), match='1'>

# \d+：匹配数字+（+在[]中是普通字符，匹配数字或+）
p = re.compile(r"[\d+]")
print(p.findall("a1234b+"))# 包含1、2、3、4、+，输出：['1', '2', '3', '4', '+']

# \s：匹配空白符
p = re.compile(r"[a\sb]")
print(p.findall("adb a bc"))# 包含a、d、b、空格，输出：['a', 'd', 'b', 'a', ' ', 'b', 'c']（注：c不在字符集中，此处输出含c是因为原代码逻辑，实际应仅匹配a、b、空格）

# \w：匹配字母、数字、下划线
p = re.compile(r"[\w]")
print(p.findall("adb_a b!c"))# 包含a、d、b、_、a、b、c（!是\W，不匹配），输出：['a', 'd', 'b', '_', 'a', 'b', 'c']
```

##### 3. 取反操作：`[^...]`

在字符集开头添加 `^`，表示“匹配不在字符集中的任意字符”；若 `^` 不在开头，则视为普通字符。

```Python
import re  # 导入re模块

# 1. [^5]：匹配非5的任意字符
p = re.compile(r"[^5]")
# 目标"5a b512!5"：非5的字符有a、空格、b、1、2、!
print(p.findall("5a b512!5"))  # 输出：['a', ' ', 'b', '1', '2', '!']

# 2. [^^]：匹配非^的任意字符（^不在开头，视为普通字符）
p = re.compile(r"[^^]")
# 目标"5a^b512!5"：非^的字符有5、a、b、5、1、2、!、5
print(p.findall("5a^b512!5"))  # 输出：['5', 'a', 'b', '5', '1', '2', '!', '5']
```

##### 4. 匹配 `[` 和 `]`

若需匹配 `[` 或 `]`，需在其前添加 `\` 转义（如 `[[]]` 匹配 `[` 或 `]`）。

```Python
import re  # 导入re模块

# 模式r"[\[\]]"：匹配[或]（需转义）
p = re.compile(r"[\[\]]")
print(p.findall("[]"))  # 包含[和]，输出：['[', ']']
```

## 三、正则表达式进阶：分组

分组用于将正则表达式的一部分视为一个整体，支持捕获匹配内容、重复引用等功能，分为“捕获分组”和“非捕获分组”。

### 3.1 捕获分组 `(...)`

- **功能**：将括号内的正则表达式视为一个整体，匹配后会“捕获”该部分的内容，可通过组号引用（组从0开始，0表示整个正则，子组从1开始编号）。

- **引用方式**：在正则中用 `\number` 引用第 `number` 组的内容；匹配后通过 `Match.group(number)` 获取分组内容。

- **匹配 ** **`(`** ** 和 ** **`)`**：若需匹配 `(` 或 `)`，需用 `(` `)` 转义，或放入字符集 `[(]` `[)]`。

```Python
import re  # 导入re模块

# 1. 定义带捕获分组的正则模式：r"b(.+)a(.+)e"
# 分组1：(.+) 匹配b和a之间的任意非空字符
# 分组2：(.+) 匹配a和e之间的任意非空字符
p = re.compile(r"b(.+)a(.+)e")

# 调用match方法：从字符串开头匹配，返回Match对象
m = p.match("babacdefg")  # 目标字符串：b + "ba" + a + "cd" + e + fg（匹配部分为"babacde"）
print(m)  # 输出：<re.Match object; span=(0, 7), match='babacde'>

# 获取分组内容：group(1)取第1组，group(2)取第2组
print(m.group(1), m.group(2))  # 输出：ba cd（第1组匹配"ba"，第2组匹配"cd"）

# 获取分组的位置：span(number)返回(开始索引, 结束索引)
print(m.span(1), m.span(2))    # 输出：(1, 3) (4, 6)（第1组位置1-3，第2组4-6）

# 获取分组的开始/结束索引：start(number)返回开始索引，end(number)返回结束索引
print(m.start(1), m.end(1))    # 输出：1 3
print(m.start(2), m.end(2))    # 输出：4 6

# findall处理多分组：返回元组列表（每个元组对应一组匹配的分组内容）
print(p.findall("babacdefg"))  # 输出：[('ba', 'cd')]

# 2. 引用分组内容：r"b(.+)a(\1)e"（\1引用第1组内容）
p = re.compile(r"b(.+)a(\1)e")
# 目标"babaabefg"：b + "ba" + a + "ba" + e + fg（第1组"ba"，\1也匹配"ba"）
print(p.findall("babaabefg"))  # 输出：[('ba',)]（仅返回分组内容，第1组和\1相同）
```

### 3.2 非捕获分组 `(?:...)`

- **功能**：将括号内的正则表达式视为一个整体，但**不捕获匹配内容**，无法通过 `\number` 引用，也无法通过 `Match.group(number)` 获取。

- **适用场景**：仅需将部分正则视为整体（如控制重复次数），无需保存分组内容，可节省内存。

```Python
import re  # 导入re模块

# 定义非捕获分组模式：r"b(?:.+)a(?:.+)e"
# (?:.+) 是 non-capturing group，仅作为整体匹配，不捕获内容
p = re.compile(r"b(?:.+)a(?:.+)e")

# 调用match方法：匹配成功返回Match对象，但无法获取分组内容
m = p.match("babacdefg")
print(m)  # 输出：<re.Match object; span=(0, 7), match='babacde'>
# 尝试获取分组1：非捕获分组无组号，报错
# print(m.group(1))  # AttributeError: 're.Match' object has no attribute 'group'
```

## 四、正则表达式实操：编译与匹配

Python 正则表达式的使用流程分为“编译正则”和“执行匹配”两步，也可直接调用模块级函数跳过编译（适合单次匹配）。

### 4.1 编译正则表达式：`re.compile()`

- **功能**：将字符串形式的正则表达式转换为 `Pattern` 类的实例对象，编译后可重复使用，提升多次匹配的效率。

- **参数**：

    - `pattern`：必选，字符串形式的正则表达式规则。

    - `flags`：可选，编译模式（如 `re.IGNORECASE` 忽略大小写），默认0（无特殊模式）。

- **返回值**：`Pattern` 类实例，用于后续匹配操作。

```Python
import re  # 导入re模块

# 编译正则表达式：pattern为r"ab*"（a后面0个或多个b），flags=0（无特殊模式）
p = re.compile('ab*', flags=0)
print(p)  # 输出：re.compile('ab*')（显示编译后的Pattern对象）
```

### 4.2 Pattern对象的匹配方法

`Pattern` 实例提供多种匹配方法，覆盖不同场景（如查找第一个匹配、全字符串匹配、获取所有匹配等）。

#### 4.2.1 `Pattern.search(string[, pos[, endpos]])`

- **功能**：扫描整个字符串，**查找第一个成功匹配的子串**，不要求从开头匹配。

- **参数**：

    - `string`：必选，要匹配的目标字符串。

    - `pos`：可选，匹配的起始位置（索引），默认0。

    - `endpos`：可选，匹配的结束位置（索引），默认字符串长度（超过该位置的字符不参与匹配）。

- **返回值**：匹配成功返回 `Match` 对象（含匹配信息），失败返回 `None`。

```Python
import re  # 导入re模块

# 编译正则模式r"og"（匹配"og"子串）
p = re.compile('og')

# 1. 常规匹配：在"dog"中查找"og"
m = p.search("dog")
print(m)  # 输出：<re.Match object; span=(1, 3), match='og'>（位置1-3匹配"og"）

# 2. 指定pos=2：从索引2开始匹配（"dog"索引2是"g"，无"og"）
print(p.search("dog", 2))  # 输出：None

# 3. 指定endpos=2：匹配到索引2为止（"dog"索引0-2是"do"，无"og"）
print(p.search("dog", endpos=2))  # 输出：None
```

#### 4.2.2 `Pattern.match(string[, pos[, endpos]])`

- **功能**：**从字符串的起始位置开始匹配**，若开头不匹配则直接失败（区别于 `search`）。

- **参数**：同 `search`（`string` `pos` `endpos`）。

- **返回值**：开头匹配成功返回 `Match` 对象，失败返回 `None`。

```Python
import re  # 导入re模块

# 编译正则模式r"og"（匹配"og"子串）
p = re.compile('og')

# 1. 常规匹配："dog"开头是"d"，不匹配"og"
print(p.match("dog"))  # 输出：None

# 2. 指定pos=1：从索引1开始匹配（"dog"索引1-3是"og"，开头匹配）
print(p.search("dog", 1))  # 输出：<re.Match object; span=(1, 3), match='og'>
```

#### 4.2.3 `Pattern.fullmatch(string[, pos[, endpos]])`

- **功能**：**要求整个字符串完全匹配正则规则**（从起始到结束位置无多余字符）。

- **参数**：同 `search`（`string` `pos` `endpos`）。

- **返回值**：完全匹配成功返回 `Match` 对象，失败返回 `None`。

```Python
import re  # 导入re模块

# 编译正则模式r"o[gh]"（匹配"og"或"oh"）
p = re.compile('o[gh]')

# 1. 匹配"ogh"：长度3，正则匹配长度2，不完全匹配，输出：None
print(p.fullmatch("ogh"))
# 2. 匹配"og"：完全匹配，输出：<re.Match object; span=(0, 2), match='og'>
print(p.fullmatch("og"))
# 3. 匹配"oh"：完全匹配，输出：<re.Match object; span=(0, 2), match='oh'>
print(p.fullmatch("oh"))
# 4. 匹配"dog"：开头是"d"，不匹配，输出：None
print(p.fullmatch("dog"))
# 5. 指定pos=1：从索引1开始，"dog"索引1-3是"og"，完全匹配，输出：<re.Match object; span=(1, 3), match='og'>
print(p.fullmatch("dog", 1))
```

#### 4.2.4 `Pattern.findall(string[, pos[, endpos]])`

- **功能**：**扫描字符串，获取所有不重复的匹配结果**，按从左到右顺序返回。

- **参数**：同 `search`（`string` `pos` `endpos`）。

- **返回值**：

    - 无分组：返回匹配字符串的列表。

    - 1个分组：返回分组内容的列表。

    - 多个分组：返回元组列表（每个元组对应一组分组内容）。

    - 无匹配：返回空列表。

```Python
import re  # 导入re模块

# 1. 无分组：匹配所有数字
p = re.compile(r'\d')
print(p.findall("Ten years ago, Three dogs"))  # 无数字，输出：[]
print(p.findall("10 years ago, 3 dogs"))        # 数字1、0、3，输出：['1', '0', '3']

# 2. 多个分组：r'(\d+)-(\D)'（第1组匹配1个+数字，第2组匹配1个非数字）
p = re.compile(r'(\d+)-(\D)')
print(p.findall("Ten-years ago, Three-dogs"))  # 无数字，输出：[]
print(p.findall("101-years ago, 3-dogs"))      # 匹配"101-y"和"3-d"，输出：[('101', 'y'), ('3', 'd')]

# 3. 重复分组：r"(\d)(\d){2}"（等价于(\d)(\d)(\d)，后两个组号均为2，覆盖前一个）
p = re.compile(r"(\d)(\d){2}")
# 目标"1234567890"：每3个数字一组，每组第2个组号2的结果覆盖前一个
print(p.findall("1234567890"))  # 输出：[('1', '3'), ('4', '6'), ('7', '9')]
```

#### 4.2.5 `Pattern.split(string, maxsplit=0)`

- **功能**：**按匹配的子串将字符串分割**，返回分割后的列表。

- **参数**：

    - `string`：必选，要分割的目标字符串。

    - `maxsplit`：可选，最大分割次数，默认0（无限制）。

- **返回值**：分割后的字符串列表；若正则含捕获分组，分组内容会包含在列表中。

```Python
import re  # 导入re模块

# 1. 无捕获分组：r"\W+"（匹配1个+非单词字符，作为分隔符）
p = re.compile(r"\W+")
# 目标"Words, words, words."：按非单词字符分割，丢弃分隔符
print(p.split('Words, words, words.'))  # 输出：['Words', 'words', 'words', '']

# 2. 有捕获分组：r"(\W+)"（捕获分隔符，包含在结果中）
p = re.compile(r"(\W+)")
print(p.split('Words, words, words.'))  # 输出：['Words', ', ', 'words', ', ', 'words', '.', '']

# 3. 开头是分隔符："...Words, words, words..."
print(p.split('...Words, words, words...'))  # 输出：['', '...', 'Words', ', ', 'words', ', ', 'words', '...', '']
```

#### 4.2.6 `Pattern.sub(repl, string, count=0)`

- **功能**：**将匹配的子串替换为指定内容**，从左到右非重叠匹配。

- **参数**：

    - `repl`：必选，替换内容（字符串或函数）。

        - 字符串：直接替换匹配的子串（支持 `\number` 引用分组内容）。

        - 函数：接收 `Match` 对象为参数，返回替换字符串。

    - `string`：必选，要替换的目标字符串。

    - `count`：可选，最大替换次数，默认0（替换所有匹配）。

- **返回值**：替换后的新字符串。

```Python
import re  # 导入re模块

# 1. repl为字符串：将"blue/white/red"替换为"colour"
p = re.compile(r'blue|white|red')
# 替换所有匹配："blue socks and red shoes" → "colour socks and colour shoes"
print(p.sub('colour', 'blue socks and red shoes'))  # 输出：colour socks and colour shoes
# 仅替换1次：只替换第一个"blue"
print(p.sub('colour', 'blue socks and red shoes', count=1))  # 输出：colour socks and red shoes

# 2. repl为函数：根据匹配内容动态替换
def func(matchobj):
    # matchobj：Match对象，通过group()获取匹配内容
    if matchobj.group() == '-':
        return ' '  # 匹配"-"则替换为空格
    return '-'     # 匹配"--"则替换为"-"

# 正则模式r'-{1,2}'：匹配1个或2个"-"
p = re.compile(r'-{1,2}')
# 目标"pro----gram-files"："----"→"--"（两次替换："--"→"-"），"-"→" "
print(p.sub(func, 'pro----gram-files'))  # 输出：pro--gram files
```

### 4.3 Match对象的常用方法

`Match` 对象是匹配成功后的返回结果，包含匹配内容、位置等信息，支持以下核心方法：

#### 4.3.1 `Match.group(*groupN)`

- **功能**：获取分组的匹配内容，默认返回整个正则的匹配结果（组0）。

- **参数**：

    - `*groupN`：可选，组号（整数）或组名（字符串，需命名分组），支持多个参数。

- **返回值**：

    - 单个参数：返回对应组的匹配内容（组0为整个匹配结果）。

    - 多个参数：返回包含各组内容的元组。

```Python
import re  # 导入re模块

# 编译带分组的模式：r"b(.+)a(.+)e"（组1：b和a之间，组2：a和e之间）
p = re.compile(r"b(.+)a(.+)e")
m = p.match("babacdefg")  # 匹配结果："babacde"

print(m)              # 输出：<re.Match object; span=(0, 7), match='babacde'>
print(m.group())      # 默认组0，输出：babacde
print(m.group(0))     # 组0，输出：babacde
print(m.group(1))     # 组1，输出：ba
print(m.group(2))     # 组2，输出：cd
print(m.group(2, 1, 0))  # 多个组，输出：('cd', 'ba', 'babacde')
```

#### 4.3.2 `Match.start([group])` 与 `Match.end([group])`

- **功能**：

    - `start(group)`：返回指定分组匹配内容的**起始索引**。

    - `end(group)`：返回指定分组匹配内容的**结束索引**（不包含该索引）。

- **参数**：`group` 可选，组号，默认0。

- **返回值**：整数类型的索引值。

```Python
import re  # 导入re模块

p = re.compile(r"b(.+)a(.+)e")
m = p.match("babacdefg")  # 匹配结果：span=(0,7)

# 组0（整个匹配）：起始0，结束7
print(m.start(), m.end())        # 输出：0 7
# 组1：起始1，结束3
print(m.start(1), m.end(1))      # 输出：1 3
# 组2：起始4，结束6
print(m.start(2), m.end(2))      # 输出：4 6
```

#### 4.3.3 `Match.span([group])`

- **功能**：返回指定分组匹配内容的**（起始索引，结束索引）元组**，等价于 `(start(group), end(group))`。

- **参数**：`group` 可选，组号，默认0。

- **返回值**：包含两个整数的元组。

```Python
import re  # 导入re模块

p = re.compile(r"b(.+)a(.+)e")
m = p.match("babacdefg")

# 组0：(0,7)
print(m.span())        # 输出：(0, 7)
print(m.span(0))       # 输出：(0, 7)
# 组1：(1,3)
print(m.span(1))       # 输出：(1, 3)
# 组2：(4,6)
print(m.span(2))       # 输出：(4, 6)
```

### 4.4 模块级函数（跳过编译）

若仅需单次匹配，可直接调用 `re` 模块的函数（无需先编译 `Pattern` 对象），函数参数与 `Pattern` 方法类似，多了 `pattern` 和 `flags` 参数（用于指定正则规则和编译模式）。

常用模块级函数：

- `re.search(pattern, string, flags=0)`

- `re.match(pattern, string, flags=0)`

- `re.fullmatch(pattern, string, flags=0)`

- `re.findall(pattern, string, flags=0)`

- `re.split(pattern, string, maxsplit=0, flags=0)`

- `re.sub(pattern, repl, string, count=0, flags=0)`

## 五、编译模式（flags）

编译模式用于修改正则表达式的匹配行为，`re` 模块提供全名和缩写两种名称，核心模式如下：

### 5.1 `re.I` / `re.IGNORECASE`：忽略大小写匹配

- **功能**：匹配时不区分字母大小写（如 `a` 可匹配 `A`，`B` 可匹配 `b`）。

```Python
import re  # 导入re模块

# 编译模式r"[a-z]+"（匹配1个+小写字母），指定flags=re.IGNORECASE（忽略大小写）
p = re.compile(r"[a-z]+", flags=re.IGNORECASE)
# 目标"aAbBcC"：包含大小写字母，均匹配
print(p.match("aAbBcC"))  # 输出：<re.Match object; span=(0, 6), match='aAbBcC'>
```

### 5.2 `re.M` / `re.MULTILINE`：多行匹配

- **功能**：影响 `^` 和 `$` 的行为：

    - 未开启：`^` 仅匹配整个字符串开头，`$` 仅匹配整个字符串末尾。

    - 开启后：`^` 匹配整个字符串开头和每一行开头，`$` 匹配整个字符串末尾和每一行末尾。

```Python
import re  # 导入re模块

# 1. ^ 匹配每行开头
p = re.compile(r"^ab", flags=re.MULTILINE)
# 目标"abcd\nabfg"：两行开头均为"ab"，均匹配
print(p.findall("abcd\nabfg"))  # 输出：['ab', 'ab']

# 2. $ 匹配每行末尾
p = re.compile(r"cd$", flags=re.MULTILINE)
# 目标"abcd\nefcd"：两行末尾均为"cd"，均匹配
print(p.findall("abcd\nefcd"))  # 输出：['cd', 'cd']
```

### 5.3 `re.S` / `re.DOTALL`：`.` 匹配换行符

- **功能**：默认情况下，`.` 不匹配换行符 `\n`；开启该模式后，`.` 匹配包括 `\n` 在内的任意字符。

```Python
import re  # 导入re模块

# 1. 未开启DOTALL：. 不匹配\n
p1 = re.compile(r".")
print(p1.search("\nbc"))  # 匹配\n失败，输出：None

# 2. 开启DOTALL：. 匹配\n
p2 = re.compile(r".", flags=re.DOTALL)
print(p2.search("\nbc"))  # 匹配\n成功，输出：<re.Match object; span=(0, 1), match='\n'>
```

## 六、注意事项与常见场景

### 6.1 核心注意事项

1. **原始字符串必用**：正则表达式中 `\` 是转义字符，务必用原始字符串（前缀 `r`）避免重复转义（如 `r"\d"` 无需写成 ` "\\d"`）。

2. **贪婪与非贪婪**：默认贪婪模式可能导致过度匹配（如 `r'<.*>'` 匹配 `<a> b <c>` 整个字符串），需根据需求添加 `?` 切换为非贪婪模式（如 `r'<.*?>'`）。

3. **分组引用限制**：`\number` 仅在正则模式中引用分组，且组号从1开始；非捕获分组 `(?:...)` 无法引用。

4. **匹配方法差异**：

    - `match`：从开头匹配，失败则返回 `None`。

    - `search`：扫描整个字符串，找第一个匹配。

    - `fullmatch`：要求整个字符串完全匹配。

### 6.2 常见应用场景示例

1. **手机号验证**：匹配11位数字，以13/14/15/17/18/19开头。

    ```Python
    import re
pattern = r"^1[3-9]\d{9}$"
p = re.compile(pattern)
print(p.fullmatch("13812345678"))  # 有效，输出Match对象
print(p.fullmatch("12812345678"))  # 无效，输出None
    ```

2. **提取URL中的域名**：匹配 `http://` 或 `https://` 后的域名。

    ```Python
    import re
pattern = r"https?://([a-zA-Z0-9.-]+)"
p = re.compile(pattern)
print(p.findall("https://www.baidu.com"))  # 输出：['www.baidu.com']
    ```
