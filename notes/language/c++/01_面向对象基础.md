# 面向对象基础

## 1. 核心概念

### 定义
- **面向对象编程(OOP)**：以对象为核心的编程范式
- **对象**：具有状态和行为的实体
- **类**：创建对象的蓝图或模板
- **封装**：将数据和操作数据的方法捆绑在一起

### 关键特性
- **抽象**：隐藏复杂实现，只暴露必要接口
- **封装**：数据保护，控制访问权限
- **继承**：代码复用，建立类之间的关系
- **多态**：同一接口，不同实现

## 2. 语法规则

### 基本语法
```cpp
class 类名 {
访问修饰符:
    // 数据成员（属性）
    数据类型 成员变量;
    
    // 成员函数（方法）
    返回类型 函数名(参数列表);
};
```

### 代码示例
```cpp
#include <iostream>
#include <string>
using namespace std;

// 简单的类定义
class Person {
public:  // 公有访问权限
    // 数据成员
    string name;
    int age;
    
    // 成员函数
    void introduce() {
        cout << "我叫" << name << ", 今年" << age << "岁。" << endl;
    }
    
    void setAge(int newAge) {
        if (newAge > 0 && newAge < 150) {
            age = newAge;
        }
    }
};

int main() {
    // 创建对象
    Person person1;
    
    // 访问公有成员
    person1.name = "张三";
    person1.setAge(25);
    
    // 调用成员函数
    person1.introduce();
    
    // 创建另一个对象
    Person person2;
    person2.name = "李四";
    person2.setAge(30);
    person2.introduce();
    
    return 0;
}
```

### 注意事项
- 类定义以分号结尾
- 访问修饰符控制成员的可访问性
- 对象是类的实例，每个对象有独立的内存空间
- 成员函数可以访问同一对象的所有成员

## 3. 常见用法

### 场景1：简单的银行账户类
```cpp
class BankAccount {
private:  // 私有成员，外部不能直接访问
    string accountNumber;
    double balance;
    
public:
    // 构造函数
    BankAccount(string accNum, double initialBalance) {
        accountNumber = accNum;
        balance = initialBalance;
    }
    
    // 存款方法
    void deposit(double amount) {
        if (amount > 0) {
            balance += amount;
            cout << "存款成功，当前余额: " << balance << endl;
        }
    }
    
    // 取款方法
    bool withdraw(double amount) {
        if (amount > 0 && amount <= balance) {
            balance -= amount;
            cout << "取款成功，当前余额: " << balance << endl;
            return true;
        } else {
            cout << "取款失败，余额不足" << endl;
            return false;
        }
    }
    
    // 查看余额
    double getBalance() {
        return balance;
    }
};
```

### 场景2：学生信息管理系统
```cpp
class Student {
private:
    string name;
    int studentId;
    double gpa;
    
public:
    // 设置学生信息
    void setInfo(string n, int id, double g) {
        name = n;
        studentId = id;
        if (g >= 0 && g <= 4.0) {
            gpa = g;
        }
    }
    
    // 显示学生信息
    void displayInfo() {
        cout << "学生ID: " << studentId << endl;
        cout << "姓名: " << name << endl;
        cout << "GPA: " << gpa << endl;
    }
    
    // 判断是否优秀
    bool isExcellent() {
        return gpa >= 3.5;
    }
};
```

## 4. 易错点/坑

### 错误示例1：忘记类定义的分号
```cpp
class MyClass {
    // 类内容
}  // 错误：缺少分号

int main() {
    MyClass obj;  // 编译错误
    return 0;
}
```
**原因**：C++类定义必须以分号结尾
**修正方案**：
```cpp
class MyClass {
    // 类内容
};  // 正确：添加分号
```

### 错误示例2：直接访问私有成员
```cpp
class MyClass {
private:
    int secret;
};

int main() {
    MyClass obj;
    obj.secret = 10;  // 错误：私有成员不能直接访问
    return 0;
}
```
**原因**：私有成员只能在类内部访问
**修正方案**：
```cpp
class MyClass {
private:
    int secret;
public:
    void setSecret(int value) {
        secret = value;  // 通过公有方法访问
    }
};
```

### 错误示例3：对象未初始化就使用
```cpp
class Person {
public:
    string name;
    void speak() {
        cout << "我叫" << name << endl;  // name可能包含垃圾值
    }
};

int main() {
    Person p;
    p.speak();  // 未定义行为
    return 0;
}
```
**原因**：未初始化的成员变量包含随机值
**修正方案**：
```cpp
class Person {
public:
    string name = "未知";  // 提供默认值
    void speak() {
        cout << "我叫" << name << endl;
    }
};
```

## 5. 拓展补充

### 关联知识点
- **结构体(struct)**：默认公有访问权限的类
- **联合体(union)**：所有成员共享内存的特殊类
- **友元函数**：可以访问私有成员的非成员函数
- **静态成员**：属于类而不是对象的成员

### 进阶延伸
- **设计模式**：面向对象设计的经典解决方案
- **SOLID原则**：面向对象设计的五个基本原则
- **RAII**：资源获取即初始化，C++重要编程习惯
- **移动语义**：C++11引入的对象资源转移机制

# 类与对象（封装）

## 1. 核心概念

### 定义
- **封装**：将数据和对数据的操作捆绑在一起，并隐藏实现细节
- **访问控制**：通过访问修饰符控制成员的可见性
- **数据隐藏**：保护数据不被外部直接访问和修改

### 关键特性
- **信息隐藏**：只暴露必要的接口，隐藏实现细节
- **数据保护**：防止意外修改数据，确保数据完整性
- **接口与实现分离**：使用者只关心接口，不关心实现
- **模块化设计**：提高代码的可维护性和可重用性

## 2. 语法规则

### 基本语法
```cpp
class 类名 {
private:    // 私有成员，只能在类内部访问
    数据类型 私有变量;
    
protected:  // 保护成员，类内部和派生类可以访问
    数据类型 保护变量;
    
public:     // 公有成员，任何地方都可以访问
    // 公有接口函数
    返回类型 函数名(参数列表);
};
```

### 代码示例
```cpp
#include <iostream>
#include <string>
using namespace std;

class BankAccount {
private:    // 私有数据成员，外部不能直接访问
    string accountNumber;
    string ownerName;
    double balance;
    
public:     // 公有接口，外部可以访问
    // 构造函数
    BankAccount(string accNum, string name, double initialBalance) {
        accountNumber = accNum;
        ownerName = name;
        if (initialBalance >= 0) {
            balance = initialBalance;
        } else {
            balance = 0;
        }
    }
    
    // 存款方法
    bool deposit(double amount) {
        if (amount > 0) {
            balance += amount;
            cout << "存款成功，当前余额: " << balance << endl;
            return true;
        }
        cout << "存款金额必须大于0" << endl;
        return false;
    }
    
    // 取款方法
    bool withdraw(double amount) {
        if (amount > 0 && amount <= balance) {
            balance -= amount;
            cout << "取款成功，当前余额: " << balance << endl;
            return true;
        }
        cout << "取款失败，余额不足或金额无效" << endl;
        return false;
    }
    
    // 获取余额（只读访问）
    double getBalance() const {
        return balance;
    }
    
    // 获取账户信息（只读）
    void displayInfo() const {
        cout << "账户号: " << accountNumber << endl;
        cout << "户主: " << ownerName << endl;
        cout << "余额: " << balance << endl;
    }
};

int main() {
    // 创建银行账户对象
    BankAccount myAccount("123456789", "张三", 1000.0);
    
    // 使用公有接口操作账户
    myAccount.displayInfo();
    myAccount.deposit(500.0);
    myAccount.withdraw(200.0);
    
    // 无法直接访问私有成员
    // myAccount.balance = 10000;  // 错误：私有成员不能访问
    
    cout << "当前余额: " << myAccount.getBalance() << endl;
    
    return 0;
}
```

### 注意事项
- 私有成员只能通过公有成员函数访问
- const成员函数不能修改对象状态
- 良好的封装应该提供完整的接口
- 构造函数用于对象初始化

## 3. 常见用法

### 场景1：完整的日期类封装
```cpp
class Date {
private:
    int year, month, day;
    
    // 私有辅助函数，检查日期有效性
    bool isValidDate(int y, int m, int d) {
        if (y < 1900 || y > 2100) return false;
        if (m < 1 || m > 12) return false;
        
        int daysInMonth;
        if (m == 2) {
            // 闰年判断
            bool isLeap = (y % 4 == 0 && y % 100 != 0) || (y % 400 == 0);
            daysInMonth = isLeap ? 29 : 28;
        } else if (m == 4 || m == 6 || m == 9 || m == 11) {
            daysInMonth = 30;
        } else {
            daysInMonth = 31;
        }
        
        return d >= 1 && d <= daysInMonth;
    }
    
public:
    // 构造函数
    Date(int y, int m, int d) {
        if (isValidDate(y, m, d)) {
            year = y;
            month = m;
            day = d;
        } else {
            year = 2000;
            month = 1;
            day = 1;  // 默认日期
        }
    }
    
    // 设置日期
    bool setDate(int y, int m, int d) {
        if (isValidDate(y, m, d)) {
            year = y;
            month = m;
            day = d;
            return true;
        }
        return false;
    }
    
    // 获取日期信息
    void getDate(int &y, int &m, int &d) const {
        y = year;
        m = month;
        d = day;
    }
    
    // 显示日期
    void display() const {
        cout << year << "年" << month << "月" << day << "日" << endl;
    }
    
    // 计算明天日期
    Date tomorrow() const {
        Date nextDay = *this;  // 复制当前对象
        nextDay.day++;
        
        // 处理月份和年份的进位
        if (!isValidDate(nextDay.year, nextDay.month, nextDay.day)) {
            nextDay.day = 1;
            nextDay.month++;
            if (nextDay.month > 12) {
                nextDay.month = 1;
                nextDay.year++;
            }
        }
        
        return nextDay;
    }
};
```

### 场景2：购物车系统封装
```cpp
class ShoppingCart {
private:
    static const int MAX_ITEMS = 100;
    string items[MAX_ITEMS];
    double prices[MAX_ITEMS];
    int quantities[MAX_ITEMS];
    int itemCount;
    
public:
    ShoppingCart() : itemCount(0) {}
    
    // 添加商品
    bool addItem(const string &itemName, double price, int quantity = 1) {
        if (itemCount >= MAX_ITEMS || price < 0 || quantity <= 0) {
            return false;
        }
        
        items[itemCount] = itemName;
        prices[itemCount] = price;
        quantities[itemCount] = quantity;
        itemCount++;
        return true;
    }
    
    // 移除商品
    bool removeItem(const string &itemName) {
        for (int i = 0; i < itemCount; i++) {
            if (items[i] == itemName) {
                // 将后面的元素前移
                for (int j = i; j < itemCount - 1; j++) {
                    items[j] = items[j + 1];
                    prices[j] = prices[j + 1];
                    quantities[j] = quantities[j + 1];
                }
                itemCount--;
                return true;
            }
        }
        return false;
    }
    
    // 计算总价
    double getTotalPrice() const {
        double total = 0.0;
        for (int i = 0; i < itemCount; i++) {
            total += prices[i] * quantities[i];
        }
        return total;
    }
    
    // 显示购物车内容
    void displayCart() const {
        cout << "购物车内容:" << endl;
        for (int i = 0; i < itemCount; i++) {
            cout << items[i] << " x" << quantities[i] 
                 << " - ￥" << prices[i] * quantities[i] << endl;
        }
        cout << "总计: ￥" << getTotalPrice() << endl;
    }
    
    // 清空购物车
    void clearCart() {
        itemCount = 0;
    }
};
```

## 4. 易错点/坑

### 错误示例1：违反封装原则
```cpp
class BadAccount {
public:  // 所有成员都是公有的
    double balance;
    
    void withdraw(double amount) {
        balance -= amount;  // 外部可以直接修改balance，导致数据不一致
    }
};

int main() {
    BadAccount acc;
    acc.balance = 1000;
    acc.balance = -500;  // 可以直接设置为负值，违反业务规则
    return 0;
}
```
**原因**：数据成员公有，外部可以直接修改，破坏了数据完整性
**修正方案**：
```cpp
class GoodAccount {
private:
    double balance;
    
public:
    void withdraw(double amount) {
        if (amount > 0 && amount <= balance) {
            balance -= amount;  // 通过方法控制修改
        }
    }
    
    double getBalance() const {
        return balance;  // 只提供只读访问
    }
};
```

### 错误示例2：不完整的接口
```cpp
class IncompleteAccount {
private:
    double balance;
    
public:
    // 只有存款方法，没有取款方法
    void deposit(double amount) {
        balance += amount;
    }
    
    // 缺少获取余额的方法
};

int main() {
    IncompleteAccount acc;
    acc.deposit(1000);
    // 无法获取余额，也无法取款
    return 0;
}
```
**原因**：接口不完整，无法完成基本操作
**修正方案**：
```cpp
class CompleteAccount {
private:
    double balance;
    
public:
    void deposit(double amount) {
        if (amount > 0) balance += amount;
    }
    
    bool withdraw(double amount) {
        if (amount > 0 && amount <= balance) {
            balance -= amount;
            return true;
        }
        return false;
    }
    
    double getBalance() const {
        return balance;
    }
};
```

### 错误示例3：const成员函数修改数据
```cpp
class ConstError {
private:
    int value;
    
public:
    int getValue() const {
        value = 10;  // 错误：const函数不能修改成员
        return value;
    }
};
```
**原因**：const成员函数承诺不修改对象状态
**修正方案**：
```cpp
class ConstCorrect {
private:
    int value;
    
public:
    int getValue() const {
        return value;  // 正确：只读访问
    }
    
    void setValue(int v) {
        value = v;     // 非const函数可以修改
    }
};
```

## 5. 拓展补充

### 关联知识点
- **this指针**：指向当前对象的指针
- **友元函数**：可以访问私有成员的非成员函数
- **静态成员**：属于类而不是对象的成员
- **const对象**：只能调用const成员函数的对象

### 进阶延伸
- **设计模式**：单例模式、工厂模式等封装技巧
- **RAII模式**：资源管理的封装技术
- **PIMPL模式**：实现接口与实现的完全分离
- **移动语义**：C++11引入的高效对象传递

# 类与对象：封装性深度解析

## 类定义示例：数据抽象与信息隐藏

**封装原理：** 类将数据（成员变量）和操作（成员函数）捆绑在一起，通过访问控制（`public`/`private`/`protected`）实现信息隐藏。这种设计保护了内部状态的一致性，提供了清晰的接口。

```cpp
class BankAccount {
private:    // 私有成员：实现细节，外部不能直接访问
    std::string account_number;  // 内部状态：账户号码
    double balance;              // 内部状态：余额
    
    // 私有方法：内部辅助函数
    void log_transaction(const std::string &type, double amount) {
        // 记录交易日志（实现细节）
    }
    
public:     // 公有接口：对外提供的服务
    // 构造函数：对象初始化
    BankAccount(const std::string &acc_num, double initial_balance)
        : account_number(acc_num), balance(initial_balance) {
        // 成员初始化列表：直接在对象内存中初始化
        // 比在构造函数体内赋值更高效
    }
    
    // 成员函数：业务逻辑封装
    void deposit(double amount) {
        if (amount > 0) {
            balance += amount;          // 修改内部状态
            log_transaction("存款", amount);  // 内部操作
        }
    }
    
    bool withdraw(double amount) {
        if (amount > 0 && amount <= balance) {
            balance -= amount;
            log_transaction("取款", amount);
            return true;
        }
        return false;  // 业务规则验证
    }
    
    double get_balance() const {  // const成员函数：不修改对象状态的承诺
        return balance;  // const函数内只能调用其他const成员函数
    }
    
    // 拷贝控制（Rule of Three/Five）
    BankAccount(const BankAccount&) = delete;            // 禁用拷贝构造
    BankAccount& operator=(const BankAccount&) = delete; // 禁用拷贝赋值
    BankAccount(BankAccount&&) = default;                // 允许移动构造
    BankAccount& operator=(BankAccount&&) = default;     // 允许移动赋值
};

// 类的内存布局（简化）
// BankAccount对象包含：
// - std::string account_number（通常是24字节，包含指向堆内存的指针）
// - double balance（8字节）
// - 可能的填充字节（内存对齐）
// 总大小：通常32-40字节（取决于实现）
```

**使用类：对象生命周期与成员函数调用**

**对象创建与使用：** 对象在栈上或堆上创建，通过点运算符（`.`）或箭头运算符（`->`）访问成员。成员函数调用隐含传递`this`指针，指向当前对象。

```cpp
// 栈上对象：自动生命周期管理
BankAccount my_account("123456", 1000.0);  // 调用构造函数
// 对象在栈上分配，包含account_number和balance的完整内存

// 成员函数调用：隐含this指针
my_account.deposit(500.0);  // 等价于：BankAccount::deposit(&my_account, 500.0)
// this指针指向my_account对象，允许函数访问对象的成员变量

my_account.withdraw(200.0);
std::cout << "余额: " << my_account.get_balance() << std::endl;

// 堆上对象：手动生命周期管理
BankAccount *heap_account = new BankAccount("789012", 2000.0);
heap_account->deposit(300.0);  // 使用箭头运算符
delete heap_account;  // 必须手动释放

// 自动存储期对象的析构
{
    BankAccount temp_account("temp", 100.0);
    // 使用temp_account...
} // 离开作用域时，temp_account的析构函数自动调用

// const对象的使用
const BankAccount const_account("const", 500.0);
// const_account.deposit(100.0);  // 错误：const对象只能调用const成员函数
std::cout << const_account.get_balance() << std::endl;  // 正确：get_balance是const

// 对象数组
BankAccount accounts[3] = {
    BankAccount("acc1", 1000.0),
    BankAccount("acc2", 2000.0),
    BankAccount("acc3", 3000.0)
};
// 每个元素都是完整的BankAccount对象
```

**对比Python的class：**
```python
class BankAccount:
    def __init__(self, acc_num, initial_balance):
        self.account_number = acc_num
        self.balance = initial_balance
    
    def deposit(self, amount):
        if amount > 0:
            self.balance += amount
    
    def withdraw(self, amount):
        if 0 < amount <= self.balance:
            self.balance -= amount
            return True
        return False
```

# 构造与析构函数：对象生命周期管理

**构造函数类型：对象初始化与资源获取**

**构造函数作用：** 构造函数在对象创建时自动调用，负责初始化对象状态和获取所需资源。C++提供了多种构造函数来满足不同的初始化需求。

```cpp
class Person {
private:
    std::string name;
    int age;
    
public:
    // 默认构造函数：无参初始化
    Person() : name("Unknown"), age(0) {
        // 成员初始化列表：在构造函数体执行前完成初始化
        // 比在构造函数体内赋值更高效（避免默认构造+赋值）
    }
    
    // 参数化构造函数：带参数的初始化
    Person(const std::string &n, int a) : name(n), age(a) {
        // 直接构造成员，避免不必要的拷贝
    }
    
    // 委托构造函数（C++11）：重用其他构造函数的代码
    Person(const std::string &n) : Person(n, 0) {}  // 委托给双参数构造函数
    
    // 拷贝构造函数：创建对象的副本
    Person(const Person &other) : name(other.name), age(other.age) {
        // 深拷贝：复制所有成员（包括动态分配的资源）
        // 默认拷贝构造执行浅拷贝，对于包含指针的类需要自定义
    }
    
    // 移动构造函数（C++11）：资源转移
    Person(Person &&other) noexcept 
        : name(std::move(other.name)), age(other.age) {
        // 转移资源所有权，避免不必要的拷贝
        other.age = 0;  // 使源对象处于有效但未定义状态
    }
    
    // 析构函数：资源释放与清理
    ~Person() {
        // 自动调用：对象销毁时（离开作用域、delete等）
        std::cout << name << "对象被销毁" << std::endl;
        // 析构顺序：与构造顺序相反（成员变量、基类）
    }
    
    void display() const {
        std::cout << "姓名: " << name << ", 年龄: " << age << std::endl;
    }
    
    // 赋值运算符（Rule of Three/Five）
    Person& operator=(const Person &other) {  // 拷贝赋值
        if (this != &other) {  // 自赋值检查
            name = other.name;
            age = other.age;
        }
        return *this;
    }
    
    Person& operator=(Person &&other) noexcept {  // 移动赋值
        if (this != &other) {
            name = std::move(other.name);
            age = other.age;
            other.age = 0;
        }
        return *this;
    }
};

// 构造函数调用场景
Person p1;                     // 默认构造
Person p2("Alice", 25);        // 参数化构造
Person p3 = p2;                // 拷贝构造
Person p4 = std::move(p3);     // 移动构造
Person p5{"Bob"};              // 统一初始化语法
```

**对比Python的__init__和__del__：**
```python
class Person:
    def __init__(self, name="Unknown", age=0):
        self.name = name
        self.age = age
    
    def __del__(self):
        print(f"{self.name}对象被销毁")
```

# 继承与多态：代码复用与运行时灵活性

**继承示例：类型层次与代码复用**

**继承原理：** 继承建立了类型之间的"is-a"关系，派生类自动获得基类的成员（根据访问控制）。C++支持单继承和多继承，提供了强大的代码复用机制。

```cpp
// 基类：抽象形状定义
class Shape {
protected:  // 保护成员：派生类可访问，外部不可访问
    std::string color;
    
public:
    // 构造函数：初始化基类部分
    Shape(const std::string &c) : color(c) {}
    
    // 虚函数（支持多态）：运行时动态绑定
    virtual double area() const = 0;  // 纯虚函数，使Shape成为抽象类
    // 抽象类不能实例化，只能作为基类
    
    virtual void display() const {
        std::cout << "形状颜色: " << color << std::endl;
    }
    
    // 虚析构函数（重要！确保正确调用派生类析构函数）
    virtual ~Shape() {}
    // 如果基类析构函数不是虚的，通过基类指针删除派生类对象会导致未定义行为
};

// 派生类：具体形状实现
class Circle : public Shape {  // public继承：is-a关系
private:
    double radius;
    
public:
    // 派生类构造函数：先初始化基类部分
    Circle(const std::string &c, double r) : Shape(c), radius(r) {}
    
    // 重写虚函数：override关键字确保正确重写（C++11）
    double area() const override {
        return 3.14159 * radius * radius;
    }
    
    void display() const override {
        Shape::display();  // 调用基类方法
        std::cout << "圆形半径: " << radius << std::endl;
    }
    
    // 新增功能：派生类特有方法
    double circumference() const {
        return 2 * 3.14159 * radius;
    }
};

class Rectangle : public Shape {
private:
    double width, height;
    
public:
    Rectangle(const std::string &c, double w, double h) 
        : Shape(c), width(w), height(h) {}
    
    double area() const override {
        return width * height;
    }
    
    void display() const override {
        Shape::display();
        std::cout << "矩形宽高: " << width << " × " << height << std::endl;
    }
};

// 虚函数表（vtable）实现原理（简化）
// 每个有虚函数的类都有一个虚函数表
// Shape的vtable: [&Shape::area, &Shape::display, &Shape::~Shape]
// Circle的vtable: [&Circle::area, &Circle::display, &Circle::~Circle]
// 对象包含指向vtable的指针，实现动态绑定
```

**多态使用：运行时类型识别与动态绑定**

**多态机制：** 多态允许通过基类接口操作派生类对象，在运行时根据实际对象类型调用正确的函数。这是通过虚函数表和动态绑定实现的。

```cpp
// 多态示例：统一接口，不同实现
void print_area(const Shape &shape) {  // 接收基类引用
    std::cout << "面积: " << shape.area() << std::endl;  // 动态绑定
    // 编译时：只知道shape是Shape引用
    // 运行时：根据实际对象类型调用正确的area()实现
}

int main() {
    Circle circle("红色", 5.0);       // 具体Circle对象
    Rectangle rectangle("蓝色", 4.0, 6.0);  // 具体Rectangle对象
    
    // 多态调用：静态类型 vs 动态类型
    print_area(circle);     // 静态类型：const Shape&，动态类型：Circle
    // 运行时调用Circle::area()
    
    print_area(rectangle);  // 静态类型：const Shape&，动态类型：Rectangle  
    // 运行时调用Rectangle::area()
    
    // 通过基类指针/引用调用：动态绑定的核心应用
    Shape *shapes[] = {&circle, &rectangle};  // 基类指针数组
    for (Shape *shape : shapes) {
        shape->display();  // 动态绑定到具体类型的display()
        // shape指向Circle时：调用Circle::display()
        // shape指向Rectangle时：调用Rectangle::display()
    }
    
    // 动态内存中的多态
    std::vector<std::unique_ptr<Shape>> shape_list;
    shape_list.push_back(std::make_unique<Circle>("绿色", 3.0));
    shape_list.push_back(std::make_unique<Rectangle>("黄色", 2.0, 4.0));
    
    for (const auto &shape : shape_list) {
        shape->display();  // 多态调用，无需知道具体类型
    }
    
    // 类型识别：dynamic_cast（运行时类型检查）
    Shape *unknown_shape = &circle;
    if (Circle *circle_ptr = dynamic_cast<Circle*>(unknown_shape)) {
        // 转换成功：unknown_shape确实指向Circle
        std::cout << "周长: " << circle_ptr->circumference() << std::endl;
    }
    
    return 0;
}

// 多态的性能考虑
// 虚函数调用有轻微开销：通过vtable间接调用
// 但对于大多数应用，这种开销可以忽略
// 编译器可能进行去虚拟化优化（devirtualization）

// 多态的设计优势
// 1. 可扩展性：添加新形状无需修改现有代码
// 2. 可维护性：统一接口，减少重复代码
// 3. 灵活性：运行时决定具体行为
```

# 访问控制与静态成员

**访问控制：**
```cpp
class AccessExample {
private:    // 仅类内部可访问
    int private_var;
    
protected:  // 类内部和派生类可访问
    int protected_var;
    
public:     // 任何地方都可访问
    int public_var;
    
    void set_private(int value) {
        private_var = value;  // 类内部可以访问private
    }
};

class Derived : public AccessExample {
public:
    void access_members() {
        // public_var = 10;     // 可以访问
        // protected_var = 20;  // 可以访问（派生类）
        // private_var = 30;    // 错误！不能访问基类private
    }
};
```

**静态成员：类级别的共享数据**

**静态成员原理：** 静态成员属于类本身而非对象实例，所有对象共享同一份静态成员。静态成员在程序生命周期内存在，提供类级别的状态管理和工具函数。

```cpp
class Counter {
private:
    static int count;  // 静态成员变量：类级别，所有对象共享
    int id;            // 普通成员变量：每个对象独立
    
public:
    Counter() {
        id = ++count;  // 访问静态成员：无需对象实例
        // count在所有Counter对象间共享，提供全局计数
    }
    
    // 静态成员函数：属于类而非对象
    static int get_count() {
        return count;  // 只能访问静态成员，没有this指针
    }
    
    // 静态函数可以作为工具函数
    static void reset_counter() {
        count = 0;     // 重置全局计数
    }
    
    int get_id() const {
        return id;     // 普通成员函数：访问对象特定数据
    }
    
    // 析构函数：减少计数
    ~Counter() {
        --count;       // 对象销毁时更新共享计数
    }
};

// 静态成员变量定义：必须在类外定义（分配存储空间）
int Counter::count = 0;  // 在全局数据区分配内存
// 定义提供了变量的实际存储，链接器需要这个定义

// 使用静态成员：类名作用域
Counter c1, c2, c3;
std::cout << "对象数量: " << Counter::get_count() << std::endl;  // 3
// 通过类名直接访问，无需对象实例

std::cout << "c2的ID: " << c2.get_id() << std::endl;           // 2
// 普通成员函数需要通过对象调用

// 静态成员的初始化时机
class Logger {
private:
    static std::string log_file;  // 静态字符串
    
public:
    static void set_log_file(const std::string &filename) {
        log_file = filename;
    }
    
    static void log(const std::string &message) {
        // 使用log_file记录日志
    }
};

// 静态成员初始化（C++17内联静态变量）
// C++17之前：需要在.cpp文件中定义
// std::string Logger::log_file = "default.log";

// C++17内联静态变量（推荐）
class ModernLogger {
private:
    inline static std::string log_file = "default.log";  // 类内初始化
    
public:
    static void set_log_file(const std::string &filename) {
        log_file = filename;
    }
};

// 静态常量成员（可以在类内初始化）
class MathConstants {
public:
    static constexpr double PI = 3.141592653589793;  // 类内初始化
    static constexpr int MAX_ITERATIONS = 1000;
    
    // 对于整数类型，甚至可以在类内定义
    static const int DEFAULT_SIZE = 64;  // 声明+定义
};

// 使用静态常量
double circle_area(double r) {
    return MathConstants::PI * r * r;  // 编译时常量，无运行时开销
}

// 静态成员的单例模式应用
class Singleton {
private:
    static Singleton* instance;  // 静态实例指针
    Singleton() {}  // 私有构造函数
    
public:
    static Singleton* get_instance() {
        if (!instance) {
            instance = new Singleton();
        }
        return instance;
    }
    
    // 禁用拷贝
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
};

// 静态成员变量定义
Singleton* Singleton::instance = nullptr;
```

# 纯虚函数与抽象类：接口与实现的分离

**纯虚函数设计原理：** 纯虚函数通过`= 0`语法强制派生类实现特定接口，实现真正的多态和接口分离。抽象类不能实例化，专门用于定义接口规范。

```cpp
#include <iostream>
#include <vector>
#include <memory>
using namespace std;

// 抽象基类：图形接口
class Shape {
public:
    // 纯虚函数：强制派生类实现
    virtual double area() const = 0;
    virtual double perimeter() const = 0;
    virtual void draw() const = 0;
    
    // 虚析构函数：确保正确释放派生类对象
    virtual ~Shape() {
        cout << "Shape析构函数调用" << endl;
    }
    
    // 普通成员函数：提供通用功能
    void printInfo() const {
        cout << "面积: " << area() << ", 周长: " << perimeter() << endl;
    }
    
    // 静态成员函数：类级别操作
    static void describe() {
        cout << "这是一个图形抽象类" << endl;
    }
};

// 具体派生类：圆形
class Circle : public Shape {
private:
    double radius;
    
public:
    Circle(double r) : radius(r) {
        if (radius <= 0) {
            throw invalid_argument("半径必须大于0");
        }
    }
    
    // 实现纯虚函数
    double area() const override {
        return 3.14159 * radius * radius;
    }
    
    double perimeter() const override {
        return 2 * 3.14159 * radius;
    }
    
    void draw() const override {
        cout << "绘制圆形 (半径: " << radius << ")" << endl;
    }
    
    // 特有方法
    double getRadius() const { return radius; }
    void setRadius(double r) { 
        if (r > 0) radius = r; 
    }
};

// 具体派生类：矩形
class Rectangle : public Shape {
private:
    double width, height;
    
public:
    Rectangle(double w, double h) : width(w), height(h) {
        if (width <= 0 || height <= 0) {
            throw invalid_argument("宽高必须大于0");
        }
    }
    
    // 实现纯虚函数
    double area() const override {
        return width * height;
    }
    
    double perimeter() const override {
        return 2 * (width + height);
    }
    
    void draw() const override {
        cout << "绘制矩形 (" << width << " × " << height << ")" << endl;
    }
    
    // 特有方法
    double getWidth() const { return width; }
    double getHeight() const { return height; }
    bool isSquare() const { return width == height; }
};

// 图形管理器：使用抽象类实现多态
class ShapeManager {
private:
    vector<unique_ptr<Shape>> shapes;
    
public:
    // 添加图形
    void addShape(unique_ptr<Shape> shape) {
        shapes.push_back(move(shape));
    }
    
    // 计算总面积
    double totalArea() const {
        double total = 0;
        for (const auto& shape : shapes) {
            total += shape->area();
        }
        return total;
    }
    
    // 计算总周长
    double totalPerimeter() const {
        double total = 0;
        for (const auto& shape : shapes) {
            total += shape->perimeter();
        }
        return total;
    }
    
    // 绘制所有图形
    void drawAll() const {
        for (const auto& shape : shapes) {
            shape->draw();
            shape->printInfo();
            cout << "---" << endl;
        }
    }
    
    // 查找最大面积的图形
    const Shape* findLargest() const {
        if (shapes.empty()) return nullptr;
        
        const Shape* largest = shapes[0].get();
        for (const auto& shape : shapes) {
            if (shape->area() > largest->area()) {
                largest = shape.get();
            }
        }
        return largest;
    }
};

// 接口继承示例：可绘制接口
class Drawable {
public:
    virtual void draw() const = 0;
    virtual ~Drawable() = default;
};

// 多重接口继承
class DrawableShape : public Shape, public Drawable {
    // Shape已经实现了draw()，所以不需要重复实现
};

int main() {
    // 抽象类不能实例化
    // Shape shape;  // 错误：不能实例化抽象类
    
    Shape::describe();  // 调用静态方法
    
    ShapeManager manager;
    
    // 添加各种图形（多态）
    manager.addShape(make_unique<Circle>(5.0));
    manager.addShape(make_unique<Rectangle>(4.0, 6.0));
    
    cout << "=== 所有图形信息 ===" << endl;
    manager.drawAll();
    
    cout << "=== 统计信息 ===" << endl;
    cout << "总面积: " << manager.totalArea() << endl;
    cout << "总周长: " << manager.totalPerimeter() << endl;
    
    const Shape* largest = manager.findLargest();
    if (largest) {
        cout << "最大面积的图形信息:" << endl;
        largest->printInfo();
    }
    
    // 多态测试：基类指针指向派生类对象
    cout << "\n=== 多态测试 ===" << endl;
    vector<unique_ptr<Shape>> polymorphicShapes;
    polymorphicShapes.push_back(make_unique<Circle>(3.0));
    polymorphicShapes.push_back(make_unique<Rectangle>(2.0, 4.0));
    
    for (const auto& shape : polymorphicShapes) {
        // 运行时多态：根据实际对象类型调用相应方法
        cout << "类型: " << typeid(*shape).name() << endl;
        shape->draw();
        cout << "面积: " << shape->area() << endl;
        cout << "---" << endl;
    }
    
    return 0;
}
```

**纯虚函数与抽象类的关键特性：**

| 特性 | 作用 | 语法 | 注意事项 |
|------|------|------|----------|
| **纯虚函数** | 强制派生类实现 | `virtual 返回类型 函数名() = 0;` | 没有函数体 |
| **抽象类** | 定义接口规范 | 包含纯虚函数的类 | 不能实例化 |
| **虚析构函数** | 正确释放派生类 | `virtual ~类名() {}` | 多态基类必须 |
| **接口分离** | 解耦接口与实现 | 纯虚函数定义接口 | 提高灵活性 |

# 深拷贝与浅拷贝：对象拷贝的内存管理

**拷贝语义设计原理：** C++默认提供浅拷贝，对于包含动态资源的类需要实现深拷贝来避免内存问题和资源冲突。

```cpp
#include <iostream>
#include <cstring>
#include <memory>
using namespace std;

// 浅拷贝问题演示类
class ShallowString {
private:
    char* data;
    int length;
    
public:
    // 构造函数
    ShallowString(const char* str = "") {
        length = strlen(str);
        data = new char[length + 1];
        strcpy(data, str);
        cout << "构造ShallowString: " << data << endl;
    }
    
    // 默认拷贝构造函数（浅拷贝）
    ShallowString(const ShallowString& other) 
        : data(other.data), length(other.length) {  // 危险：共享内存！
        cout << "浅拷贝构造: " << data << endl;
    }
    
    // 默认赋值运算符（浅拷贝）
    ShallowString& operator=(const ShallowString& other) {
        if (this != &other) {
            delete[] data;  // 释放原有内存
            data = other.data;    // 共享内存
            length = other.length;
        }
        cout << "浅拷贝赋值: " << data << endl;
        return *this;
    }
    
    ~ShallowString() {
        cout << "析构ShallowString: " << (data ? data : "null") << endl;
        delete[] data;  // 可能导致双重释放！
    }
    
    const char* getData() const { return data; }
    int getLength() const { return length; }
};

// 深拷贝实现类
class DeepString {
private:
    char* data;
    int length;
    
public:
    // 构造函数
    DeepString(const char* str = "") {
        length = strlen(str);
        data = new char[length + 1];
        strcpy(data, str);
        cout << "构造DeepString: " << data << " (地址: " << (void*)data << ")" << endl;
    }
    
    // 深拷贝构造函数
    DeepString(const DeepString& other) {
        length = other.length;
        data = new char[length + 1];  // 分配新内存
        strcpy(data, other.data);     // 复制内容
        cout << "深拷贝构造: " << data << " (地址: " << (void*)data << ")" << endl;
    }
    
    // 深拷贝赋值运算符
    DeepString& operator=(const DeepString& other) {
        if (this != &other) {  // 防止自赋值
            // 先分配新内存再释放旧内存（异常安全）
            char* newData = new char[other.length + 1];
            strcpy(newData, other.data);
            
            delete[] data;  // 释放旧内存
            data = newData; // 指向新内存
            length = other.length;
        }
        cout << "深拷贝赋值: " << data << " (地址: " << (void*)data << ")" << endl;
        return *this;
    }
    
    // 移动构造函数（C++11）
    DeepString(DeepString&& other) noexcept 
        : data(other.data), length(other.length) {
        other.data = nullptr;  // 置空源对象
        other.length = 0;
        cout << "移动构造: " << data << " (地址: " << (void*)data << ")" << endl;
    }
    
    // 移动赋值运算符（C++11）
    DeepString& operator=(DeepString&& other) noexcept {
        if (this != &other) {
            delete[] data;     // 释放当前资源
            data = other.data; // 转移资源
            length = other.length;
            
            other.data = nullptr;  // 置空源对象
            other.length = 0;
        }
        cout << "移动赋值: " << data << " (地址: " << (void*)data << ")" << endl;
        return *this;
    }
    
    ~DeepString() {
        cout << "析构DeepString: " << (data ? data : "null") 
             << " (地址: " << (void*)data << ")" << endl;
        delete[] data;
    }
    
    // 下标运算符重载
    char& operator[](int index) {
        if (index < 0 || index >= length) {
            throw out_of_range("索引越界");
        }
        return data[index];
    }
    
    const char& operator[](int index) const {
        if (index < 0 || index >= length) {
            throw out_of_range("索引越界");
        }
        return data[index];
    }
    
    // 字符串连接运算符
    DeepString operator+(const DeepString& other) const {
        DeepString result;
        delete[] result.data;  // 释放默认构造的内存
        
        result.length = length + other.length;
        result.data = new char[result.length + 1];
        strcpy(result.data, data);
        strcat(result.data, other.data);
        
        return result;  // 可能触发移动语义
    }
    
    const char* getData() const { return data; }
    int getLength() const { return length; }
    
    // 流输出运算符（友元）
    friend ostream& operator<<(ostream& os, const DeepString& str);
};

ostream& operator<<(ostream& os, const DeepString& str) {
    os << str.data;
    return os;
}

void demonstrateShallowCopyProblems() {
    cout << "=== 浅拷贝问题演示 ===" << endl;
    
    // 浅拷贝导致的问题
    ShallowString str1("Hello");
    {
        ShallowString str2 = str1;  // 浅拷贝
        cout << "str1: " << str1.getData() << endl;
        cout << "str2: " << str2.getData() << endl;
        
        // str2离开作用域时释放内存，str1成为悬空指针
    }  // str2析构，释放共享内存
    
    // 危险：str1现在指向已释放的内存
    // cout << str1.getData() << endl;  // 未定义行为！
}

void demonstrateDeepCopy() {
    cout << "\n=== 深拷贝解决方案 ===" << endl;
    
    DeepString str1("Hello");
    {
        DeepString str2 = str1;  // 深拷贝
        cout << "str1: " << str1 << " (地址: " << (void*)str1.getData() << ")" << endl;
        cout << "str2: " << str2 << " (地址: " << (void*)str2.getData() << ")" << endl;
        
        // 修改str2不影响str1
        str2[0] = 'J';  // 使用下标运算符
        cout << "修改后 str1: " << str1 << endl;
        cout << "修改后 str2: " << str2 << endl;
        
        // 字符串连接测试
        DeepString str3 = str1 + str2;
        cout << "连接结果: " << str3 << endl;
    }  // str2, str3正常析构
    
    cout << "str1仍然有效: " << str1 << endl;
}

int main() {
    demonstrateShallowCopyProblems();
    demonstrateDeepCopy();
    return 0;
}
```

**拷贝语义实现指南：**

| 拷贝类型 | 实现方式 | 适用场景 | 性能特点 |
|----------|----------|----------|----------|
| **浅拷贝** | 默认行为 | 无动态资源的类 | O(1)最快 |
| **深拷贝** | 自定义实现 | 有动态资源的类 | O(n)较慢 |
| **禁用拷贝** | `= delete` | 不可复制资源 | 避免意外拷贝 |
| **移动语义** | 移动构造/赋值 | 临时对象转移 | O(1)高效 |

**Rule of Three/Five法则：**
- **三法则**：如果需要自定义析构函数，通常也需要自定义拷贝构造函数和拷贝赋值运算符
- **五法则**：C++11后，还需要考虑移动构造函数和移动赋值运算符

通过纯虚函数、抽象类和深拷贝机制的学习，可以设计出更加安全、灵活和高效的面向对象系统，这是高质量C++编程的重要基础。