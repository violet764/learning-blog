## 流程控制语句

### 条件语句

#### `if-else`语句  

**编程最佳实践：** C++的`if`语句在条件判断时，编译器会进行短路求值优化。合理的条件顺序可以显著提升性能。同时要注意作用域和变量生命周期问题。

语法：
```cpp
if (条件表达式1) {
    // 条件1为真时执行
} else if (条件表达式2) {
    // 条件1为假、条件2为真时执行
} else if (条件表达式3) {
    // 条件1/2为假、条件3为真时执行
}
// 可添加更多 else if 分支...
else {
    // 所有条件都为假时执行（可选）
}
```

示例：

```cpp
#include <iostream>
using namespace std;

int main() {
    // if-else语句示例
    int score = 85;
    
    // 基本if-else结构
    if (score >= 90) {
        cout << "优秀" << endl;
    } else if (score >= 80) {  // 只有在第一个条件为false时才检查
        cout << "良好" << endl;
    } else if (score >= 60) {
        cout << "及格" << endl;
    } else {
        cout << "不及格" << endl;
    }
    
    // 短路求值优化示例
    int* ptr = nullptr;
    if (ptr != nullptr && ptr->isValid()) {
        // 如果ptr为nullptr，第二个条件不会执行，避免空指针访问
    }
    
    // 作用域问题：if语句内声明的变量只在块内有效
    if (bool found = searchFunction()) {  // C++17: if with initializer
        // found变量在此块内有效
        cout << "Found: " << found << endl;
    }
    // found变量在此处不可访问
    
    return 0;
}
```

#### `switch-case`语句  
C++ 的 `switch-case` 语句是多分支选择结构，用于替代多个嵌套的 `if-else`，尤其适合 "变量等于多个离散值" 的分支判断场景，语法简洁且执行效率更高（基于跳转表实现）。

语法：
```cpp
switch (表达式) {
    case 常量表达式1:
        // 分支1代码
        [break;] // 可选，跳出switch
    case 常量表达式2:
        // 分支2代码
        [break;] // 若省略，会触发 "case 穿透"（执行完当前 case 后，继续执行后续 case 代码）
    // 更多case分支...
    default: // 可选，所有case不匹配时执行
        // 默认分支代码
        [break;]
}
```

示例：
```cpp
#include <iostream>
using namespace std;

int main() {
    // switch语句示例
    char grade = 'B';
    switch (grade) {
        case 'A':
            cout << "优秀" << endl;
            break;
        case 'B':
            cout << "良好" << endl;
            break;
        case 'C':
            cout << "及格" << endl;
            break;
        default:
            cout << "不及格" << endl;
    }
    
    return 0;
}
```

> **注意**：Python没有`switch`语句，通常用`if-elif`或字典映射实现类似功能

#### 三元运算符
三元运算符是C++中的一种简洁的条件表达式，它可以在一行代码中完成简单的条件判断和赋值操作。其语法形式为：`condition ? value_if_true : value_if_false;`

其中：

- condition 是一个布尔表达式，用于判断条件是否成立。
- value_if_true 是当条件为真时返回的值。
- value_if_false 是当条件为假时返回的值。

示例：
```cpp
int score = 85;
string result = (score >= 60) ? "及格" : "不及格";
cout << "成绩结果: " << result << endl;

// 嵌套条件运算符
int a = 10, b = 20, c = 15;
int max = (a > b) ? (a > c ? a : c) : (b > c ? b : c);
cout << "最大值: " << max << endl;
```


### 循环结构

#### `for`循环

**底层机制：** C++的传统`for`循环实际上是一个语法糖，编译器会将其转换为基于条件判断的循环结构。循环变量在每次迭代时都会进行条件检查和增量操作，这种机制在底层被优化为高效的机器代码。

语法：
```cpp
for (初始化表达式; 条件表达式; 更新表达式) {
    // 循环体：条件为真时执行的代码
}
```

示例：
```cpp
#include <iostream>
using namespace std;

int main() {
    // 传统for循环：初始化-条件-增量三部分
    for (int i = 0; i < 5; i++) {  // 等价于：
        cout << i << " ";           // int i = 0;
    }                               // while (i < 5) {
    // 输出: 0 1 2 3 4              //     cout << i << " ";
                                    //     i++;
                                    // }
    
    return 0;
}
```

#### 范围for循环

遍历数组 / 容器（无需手动控制索引）
```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> numbers = {1, 2, 3, 4, 5};

    // 范围for循环（类似Python的for-in）
    for (int num : numbers) {
        cout << num << " ";
    }
    // 输出: 1 2 3 4 5
    
    return 0;
}
```

#### `while`循环

语法：
```cpp
while (条件表达式) {
    // 循环体：条件为真时执行
}
```

示例：

```cpp
#include <iostream>
using namespace std;

int main() {
    int count = 0;
    while (count < 5) {
        cout << count << " ";
        count++;
    }
    // 与Python的while语法相同
    
    return 0;
}
```

#### `do-while`循环

语法：
```cpp
do {
    // 循环体：至少执行一次
} while (条件表达式); // 末尾必须加分号
```

示例：
```cpp
#include <iostream>
using namespace std;

int main() {
    int input;
    do {
        cout << "请输入正数: ";
        cin >> input;
    } while (input <= 0);  // 至少执行一次
    
    return 0;
}
```


## 数组与字符串

### 基本语法
```cpp
数据类型 数组名[大小];                    // 数组声明
数据类型 数组名[大小] = {初始值列表};     // 数组初始化

char 字符串名[大小];                      // C风格字符串
string 字符串对象名;                      // C++字符串对象
```

**示例：**
```cpp
#include <iostream>
#include <string>  // 包含string头文件
using namespace std;

int main() {
    // 数组声明和初始化
    int numbers[5] = {1, 2, 3, 4, 5};          // 整型数组
    double scores[] = {85.5, 90.0, 78.5};      // 自动推断大小
    char vowels[5] = {'a', 'e', 'i', 'o', 'u'};
    
    // 访问数组元素
    cout << "第一个数字: " << numbers[0] << endl;     // 输出1
    cout << "第三个分数: " << scores[2] << endl;      // 输出78.5
    
    // 修改数组元素
    numbers[0] = 10;
    cout << "修改后第一个数字: " << numbers[0] << endl;
    
    // C风格字符串
    char greeting[20] = "Hello, World!";
    cout << "C风格字符串: " << greeting << endl;
    
    // C++字符串对象
    string message = "Welcome to C++";
    cout << "C++字符串: " << message << endl;
    
    // 字符串操作
    string name = "Alice";
    string welcome = "Hello, " + name + "!";
    cout << welcome << endl;
    
    return 0;
}
```

**注意事项**
- 数组下标从0开始，不是1
- 数组大小必须是常量表达式
- 字符串以空字符`'\0'`结尾
- 防止数组越界访问

**常见用法**

**数组遍历**
```cpp
// 使用for循环遍历数组
int arr[] = {10, 20, 30, 40, 50};
int size = sizeof(arr) / sizeof(arr[0]);  // 计算数组大小

cout << "数组元素: ";
for (int i = 0; i < size; i++) {
    cout << arr[i] << " ";
}
cout << endl;

// 使用范围for循环（C++11）
cout << "范围for循环: ";
for (int num : arr) {
    cout << num << " ";
}
cout << endl;
```

**多维数组**
```cpp
// 二维数组：3行4列
int matrix[3][4] = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12}
};

// 遍历二维数组
cout << "二维数组:" << endl;
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 4; j++) {
        cout << matrix[i][j] << "\t";
    }
    cout << endl;
}
```

**字符串操作**
```cpp
string str1 = "Hello";
string str2 = "World";

// 字符串连接
string combined = str1 + " " + str2;
cout << "连接结果: " << combined << endl;

// 字符串长度
cout << "字符串长度: " << combined.length() << endl;

// 子字符串
string sub = combined.substr(0, 5);  // 从位置0开始，取5个字符
cout << "子字符串: " << sub << endl;

// 查找
size_t pos = combined.find("World");
if (pos != string::npos) {
    cout << "找到'World'在位置: " << pos << endl;
}

// 替换
combined.replace(6, 5, "C++");  // 从位置6开始，替换5个字符
cout << "替换后: " << combined << endl;
```


### 原生数组与`std::array`

**原生数组（C风格）：连续内存布局与性能优势**

**内存布局原理：** C风格数组在内存中是连续分配的固定大小块。这种连续布局使得CPU缓存预取更加高效，是现代处理器优化的重要基础。数组名实际上是首元素的指针，编译器在编译时就知道数组的大小和类型信息。

```cpp
#include <iostream>
using namespace std;

// 静态数组声明：在栈上分配连续内存块
int numbers[5] = {1, 2, 3, 4, 5};  // 固定大小，编译时确定

// 内存布局：地址连续，元素类型相同
// numbers[0] -> 0x1000: 值1
// numbers[1] -> 0x1004: 值2（int通常4字节）
// numbers[2] -> 0x1008: 值3
// numbers[3] -> 0x100C: 值4
// numbers[4] -> 0x1010: 值5

// 访问元素：编译器转换为指针算术
cout << numbers[0] << endl;  // 等价于 *(numbers + 0)
cout << numbers[4] << endl;  // 等价于 *(numbers + 4)

// 计算数组长度：利用编译时类型信息
int length = sizeof(numbers) / sizeof(numbers[0]);  // 20 / 4 = 5
// sizeof(numbers)返回整个数组的大小（5*4=20字节）
// sizeof(numbers[0])返回单个元素的大小（4字节）

// 遍历数组：连续内存访问，缓存友好
for (int i = 0; i < length; i++) {
    cout << numbers[i] << " ";  // 顺序访问，预取高效
}
cout << endl;

// 安全性问题：无边界检查
// numbers[5] = 100;  // 未定义行为：越界访问
```

**`std::array`：类型安全的现代数组**

**设计理念：** `std::array`是对C风格数组的封装，提供了类型安全的接口而不牺牲性能。它在编译时知道大小，因此可以内联优化，同时提供了边界检查、迭代器支持等现代C++特性。

```cpp
#include <array>

// std::array声明：模板参数指定类型和大小
std::array<int, 5> arr = {1, 2, 3, 4, 5};
// 底层实现：内部包含一个C风格数组，但提供安全的接口

// 更安全的访问方式：编译时和运行时安全检查
cout << arr.at(0) << endl;    // 边界检查，越界抛出std::out_of_range
cout << arr.size() << endl;   // 编译时常量：5

// 与C风格数组的性能对比
cout << arr[0] << endl;       // 无检查，性能与C数组相同
cout << arr.at(0) << endl;    // 有检查，轻微性能开销

// 范围for循环支持：基于迭代器协议
for (int num : arr) {  // 等价于：for(auto it = arr.begin(); it != arr.end(); ++it)
    cout << num << " ";
}
cout << endl;

// 迭代器支持（STL兼容）
auto it = arr.begin();
while (it != arr.end()) {
    cout << *it << " ";
    ++it;
}

// 编译时大小检查（模板元编程）
static_assert(arr.size() == 5, "数组大小必须是5");
```

**对比Python的`list`：**
```python
# Python列表（动态数组）
numbers = [1, 2, 3, 4, 5]
print(numbers[0])      # 1
print(len(numbers))    # 5

# Python列表可以动态调整大小
numbers.append(6)      # 添加元素
numbers.pop()          # 移除元素
```

> **关键差异**：C++数组大小固定，Python列表动态调整；`std::array`提供类型安全和边界检查

### C风格字符串 vs `std::string`

**C风格字符串：以空字符结尾的字符数组**

**底层表示：** C风格字符串实际上是字符数组，以空字符`'\0'`作为结束标志。这种设计简单高效，但安全性较差，容易出现缓冲区溢出等问题。字符串长度需要运行时计算，每次操作都需要遍历整个字符串。

```cpp
#include <cstring>

// C风格字符串声明：字符数组 + 空终止符
char cstr1[] = "Hello";           // 编译器自动添加'\0'，实际大小6字节
char cstr2[10] = "World";         // 指定大小，剩余空间填充'\0'

// 内存布局分析：
// cstr1: ['H','e','l','l','o','\0']
// cstr2: ['W','o','r','l','d','\0','\0','\0','\0','\0']

// 字符串操作：基于指针算术的函数
cout << strlen(cstr1) << endl;  // 遍历直到'\0'，返回5
strcpy(cstr2, "C++");                     // 复制：['C','+','+','\0','d','\0',...]
strcat(cstr1, " World");                  // 连接：需要足够空间

// 安全性问题分析
char buffer[5] = "test";
// strcpy(buffer, "overflow");  // 缓冲区溢出：写入超出分配空间
// 后果：可能覆盖相邻内存，导致程序崩溃或安全漏洞

// 安全替代函数（C11）
strncpy(cstr2, "C++", sizeof(cstr2));      // 指定最大复制长度
strncat(cstr1, " World", remaining_space); // 限制连接长度

// 性能考虑：O(n)时间复杂度
// strlen()需要遍历整个字符串
// strcpy()需要遍历源字符串
// strcat()需要先找到目标字符串结尾
```

**`std::string`：动态内存管理的安全字符串**

**设计原理：** `std::string`是一个类模板，内部管理动态分配的字符数组。它实现了RAII原则，自动处理内存分配和释放，提供了丰富的成员函数和安全的操作接口。现代实现通常使用小字符串优化（SSO）来避免小型字符串的动态分配。

```cpp
#include <string>

// std::string构造：多种初始化方式
string str1 = "Hello";           // 从C字符串构造
string str2("World");            // 直接构造
string str3(10, 'x');            // 重复字符构造
string str4(str1);               // 拷贝构造

// 内部实现原理（简化）
// class string {
// private:
//     char *data;        // 动态分配的字符数组
//     size_t length;     // 当前长度
//     size_t capacity;   // 分配的空间大小
//     // 可能包含小字符串优化（SSO）的缓冲区
// };

// 安全的字符串操作：自动内存管理
cout << str1.length() << endl;  // O(1)复杂度，直接返回长度
str1 += " C++";                          // 自动检查空间，必要时重新分配
str1.append("!");                        // 成员函数，类型安全

// 查找和子字符串：丰富的算法支持
size_t pos = str1.find("C++");           // 线性搜索，返回位置或npos
if (pos != string::npos) {  // string::npos专门用于表示「查找操作未找到目标」的状态
    string sub = str1.substr(pos, 3);  // 创建子字符串拷贝
}

// 现代C++特性支持
string_view sv = str1;             // C++17：非拥有字符串视图
auto result = str1.starts_with("Hello"); // C++20：前缀检查

// 性能优化：预留空间减少重新分配
string large_str;
large_str.reserve(1000);                // 预留空间，避免多次分配
for (int i = 0; i < 1000; i++) {
    large_str += 'x';                   // 在预留空间内操作，高效
}

// 与C字符串互操作
const char* c_str = str1.c_str();       // 获取C风格字符串（只读）
char buffer[100];
str1.copy(buffer, sizeof(buffer));      // 安全拷贝到缓冲区
```

**对比Python的`str`：**
```python
# Python字符串操作
s = "Hello"
print(len(s))           # 5
s += " World"          # 连接
print(s.find("World")) # 6
print(s[6:11])         # World
```

> **注意**：C++的`std::string`与Python的`str`在使用上非常相似，都是安全的字符串类型

### 多维数组的内存布局

**二维数组内存布局：**
```cpp
// 二维数组（连续内存块）
int matrix[3][3] = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};

// 内存布局：1,2,3,4,5,6,7,8,9（连续存储）
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        cout << &matrix[i][j] << " ";  // 打印地址
    }
    cout << endl;
}
```

**动态多维数组：**
```cpp
#include <vector>

// 使用vector的vector（不连续内存）
vector<vector<int>> dynamic_matrix(3, vector<int>(3));

// 每个内层vector是独立的内存块
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        dynamic_matrix[i][j] = i * 3 + j + 1;
    }
}
```

