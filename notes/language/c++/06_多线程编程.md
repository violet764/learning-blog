# 多线程编程

## 1. 核心概念

### 定义
- **线程**：程序执行的最小单位，多个线程可以并发执行
- **并发**：多个任务在重叠的时间段内执行
- **同步**：协调多个线程对共享资源的访问
- **互斥**：防止多个线程同时访问共享资源

### 关键特性
- **性能提升**：利用多核处理器提高程序性能
- **响应性**：避免UI线程阻塞，提高用户体验
- **资源竞争**：需要处理数据竞争和死锁问题
- **内存模型**：理解内存可见性和执行顺序

## 2. 语法规则

### 基本语法
```cpp
#include <thread>
#include <mutex>
#include <atomic>

// 创建线程
std::thread t(函数, 参数...);

// 互斥锁
std::mutex mtx;
mtx.lock();   // 加锁
mtx.unlock(); // 解锁

// 原子操作
std::atomic<int> counter(0);
counter.fetch_add(1); // 原子加1
```

### 代码示例
```cpp
#include <iostream>
#include <thread>
#include <vector>
#include <mutex>
#include <atomic>
#include <chrono>
using namespace std;

// 基本线程创建和运行
void basicThreadDemo() {
    cout << "=== 基本线程演示 ===" << endl;
    
    // 线程函数
    auto threadFunc = [](int id) {
        cout << "线程 " << id << " 开始执行" << endl;
        this_thread::sleep_for(chrono::milliseconds(100));
        cout << "线程 " << id << " 结束执行" << endl;
    };
    
    // 创建多个线程
    vector<thread> threads;
    for (int i = 0; i < 3; ++i) {
        threads.emplace_back(threadFunc, i + 1);
    }
    
    // 等待所有线程完成
    for (auto& t : threads) {
        t.join();
    }
    
    cout << "所有线程执行完毕" << endl;
}

// 数据竞争问题演示
void dataRaceDemo() {
    cout << "\\n=== 数据竞争问题 ===" << endl;
    
    int unsafeCounter = 0;
    atomic<int> safeCounter(0);
    
    auto incrementUnsafe = [&unsafeCounter]() {
        for (int i = 0; i < 10000; ++i) {
            unsafeCounter++;  // 数据竞争！
        }
    };
    
    auto incrementSafe = [&safeCounter]() {
        for (int i = 0; i < 10000; ++i) {
            safeCounter++;  // 原子操作，安全
        }
    };
    
    vector<thread> unsafeThreads;
    vector<thread> safeThreads;
    
    // 不安全的计数器
    for (int i = 0; i < 10; ++i) {
        unsafeThreads.emplace_back(incrementUnsafe);
    }
    
    // 安全的计数器
    for (int i = 0; i < 10; ++i) {
        safeThreads.emplace_back(incrementSafe);
    }
    
    // 等待线程完成
    for (auto& t : unsafeThreads) t.join();
    for (auto& t : safeThreads) t.join();
    
    cout << "不安全计数器结果: " << unsafeCounter << " (应该为100000)" << endl;
    cout << "安全计数器结果: " << safeCounter << " (正确)" << endl;
}

// 互斥锁使用
void mutexDemo() {
    cout << "\\n=== 互斥锁演示 ===" << endl;
    
    mutex mtx;
    int sharedData = 0;
    
    auto lockedIncrement = [&sharedData, &mtx]() {
        for (int i = 0; i < 1000; ++i) {
            {
                lock_guard<mutex> lock(mtx);  // RAII锁
                sharedData++;
            }
            this_thread::sleep_for(chrono::microseconds(1));
        }
    };
    
    vector<thread> threads;
    for (int i = 0; i < 5; ++i) {
        threads.emplace_back(lockedIncrement);
    }
    
    for (auto& t : threads) {
        t.join();
    }
    
    cout << "使用互斥锁的共享数据: " << sharedData << " (正确)" << endl;
}

int main() {
    basicThreadDemo();
    dataRaceDemo();
    mutexDemo();
    
    return 0;
}
```

### 注意事项
- 线程创建后需要join或detach
- 避免数据竞争，使用同步机制
- 理解RAII在资源管理中的应用
- 注意死锁和活锁问题

## 3. 常见用法

### 场景1：生产者-消费者模式
```cpp
#include <queue>
#include <condition_variable>

template<typename T>
class ThreadSafeQueue {
private:
    queue<T> data;
    mutable mutex mtx;
    condition_variable cond;
    
public:
    void push(T value) {
        lock_guard<mutex> lock(mtx);
        data.push(move(value));
        cond.notify_one();  // 通知等待的消费者
    }
    
    T pop() {
        unique_lock<mutex> lock(mtx);
        
        // 等待队列不为空
        cond.wait(lock, [this] { return !data.empty(); });
        
        T value = move(data.front());
        data.pop();
        return value;
    }
    
    bool try_pop(T& value) {
        lock_guard<mutex> lock(mtx);
        if (data.empty()) return false;
        
        value = move(data.front());
        data.pop();
        return true;
    }
    
    size_t size() const {
        lock_guard<mutex> lock(mtx);
        return data.size();
    }
};

void producerConsumerDemo() {
    ThreadSafeQueue<int> queue;
    
    // 生产者线程
    thread producer([&queue]() {
        for (int i = 0; i < 10; ++i) {
            queue.push(i);
            this_thread::sleep_for(chrono::milliseconds(100));
            cout << "生产: " << i << endl;
        }
    });
    
    // 消费者线程
    thread consumer([&queue]() {
        for (int i = 0; i < 10; ++i) {
            int value = queue.pop();
            cout << "消费: " << value << endl;
        }
    });
    
    producer.join();
    consumer.join();
}
```

### 场景2：读写锁模式（C++17）
```cpp
#include <shared_mutex>

template<typename T>
class ThreadSafeData {
private:
    T data;
    mutable shared_mutex mtx;  // 读写锁
    
public:
    // 写操作（独占锁）
    void write(const T& newValue) {
        unique_lock<shared_mutex> lock(mtx);
        data = newValue;
    }
    
    // 读操作（共享锁）
    T read() const {
        shared_lock<shared_mutex> lock(mtx);
        return data;
    }
    
    // 原子更新
    void update(function<void(T&)> updater) {
        unique_lock<shared_mutex> lock(mtx);
        updater(data);
    }
};

void readWriteLockDemo() {
    ThreadSafeData<vector<int>> sharedData;
    
    // 初始化数据
    sharedData.write({1, 2, 3, 4, 5});
    
    vector<thread> readers;
    for (int i = 0; i < 3; ++i) {
        readers.emplace_back([&sharedData, i]() {
            for (int j = 0; j < 5; ++j) {
                auto data = sharedData.read();
                cout << "读者" << i << "读到: " << data.size() << "个元素" << endl;
                this_thread::sleep_for(chrono::milliseconds(50));
            }
        });
    }
    
    // 写线程
    thread writer([&sharedData]() {
        for (int i = 0; i < 3; ++i) {
            sharedData.update([](vector<int>& data) {
                data.push_back(data.size() + 1);
                cout << "写入新元素，总数: " << data.size() << endl;
            });
            this_thread::sleep_for(chrono::milliseconds(200));
        }
    });
    
    for (auto& t : readers) t.join();
    writer.join();
}
```

### 场景3：异步编程与Future
```cpp
#include <future>

int computeFactorial(int n) {
    if (n <= 1) return 1;
    
    int result = 1;
    for (int i = 2; i <= n; ++i) {
        result *= i;
        this_thread::sleep_for(chrono::milliseconds(10));  // 模拟计算时间
    }
    return result;
}

void asyncFutureDemo() {
    cout << "\\n=== 异步编程演示 ===" << endl;
    
    // 异步计算多个阶乘
    auto future1 = async(launch::async, computeFactorial, 10);
    auto future2 = async(launch::async, computeFactorial, 15);
    auto future3 = async(launch::async, computeFactorial, 20);
    
    // 主线程继续执行其他任务
    cout << "等待异步计算结果..." << endl;
    
    // 获取结果（阻塞等待）
    int result1 = future1.get();
    int result2 = future2.get();
    int result3 = future3.get();
    
    cout << "10! = " << result1 << endl;
    cout << "15! = " << result2 << endl;
    cout << "20! = " << result3 << endl;
}

// 使用packaged_task
void packagedTaskDemo() {
    cout << "\\n=== packaged_task演示 ===" << endl;
    
    // 创建任务包装器
    packaged_task<int(int)> task(computeFactorial);
    future<int> result = task.get_future();
    
    // 在单独线程中执行任务
    thread worker(move(task), 8);
    
    // 获取结果
    cout << "8! = " << result.get() << endl;
    
    worker.join();
}
```
```cpp
#include <queue>
#include <condition_variable>

template<typename T>
class ThreadSafeQueue {
private:
    queue<T> data;
    mutable mutex mtx;
    condition_variable cond;
    bool stopped = false;
    
public:
    void push(T value) {
        lock_guard<mutex> lock(mtx);
        data.push(move(value));
        cond.notify_one();
    }
    
    optional<T> pop() {
        unique_lock<mutex> lock(mtx);
        cond.wait(lock, [this] { 
            return !data.empty() || stopped; 
        });
        
        if (data.empty()) return nullopt;
        
        T value = move(data.front());
        data.pop();
        return value;
    }
    
    void stop() {
        lock_guard<mutex> lock(mtx);
        stopped = true;
        cond.notify_all();
    }
    
    bool empty() const {
        lock_guard<mutex> lock(mtx);
        return data.empty();
    }
};

void producerConsumerDemo() {
    cout << "\\n=== 生产者-消费者模式 ===" << endl;
    
    ThreadSafeQueue<int> queue;
    
    // 生产者线程
    thread producer([&queue]() {
        for (int i = 0; i < 10; ++i) {
            queue.push(i);
            this_thread::sleep_for(chrono::milliseconds(100));
            cout << "生产: " << i << endl;
        }
        queue.stop();
    });
    
    // 消费者线程
    thread consumer([&queue]() {
        while (auto value = queue.pop()) {
            cout << "消费: " << *value << endl;
        }
        cout << "消费者结束" << endl;
    });
    
    producer.join();
    consumer.join();
}
```

### 场景2：并行计算
```cpp
#include <future>
#include <numeric>

void parallelComputationDemo() {
    cout << "\\n=== 并行计算 ===" << endl;
    
    vector<int> data(1000000);
    iota(data.begin(), data.end(), 1);
    
    // 串行计算基准
    auto start = chrono::high_resolution_clock::now();
    long long serialSum = accumulate(data.begin(), data.end(), 0LL);
    auto serialTime = chrono::high_resolution_clock::now() - start;
    
    // 并行计算
    start = chrono::high_resolution_clock::now();
    
    const size_t numThreads = thread::hardware_concurrency();
    vector<future<long long>> futures;
    size_t chunkSize = data.size() / numThreads;
    
    for (size_t i = 0; i < numThreads; ++i) {
        auto begin = data.begin() + i * chunkSize;
        auto end = (i == numThreads - 1) ? data.end() : begin + chunkSize;
        
        futures.push_back(async(launch::async, [begin, end]() {
            return accumulate(begin, end, 0LL);
        }));
    }
    
    long long parallelSum = 0;
    for (auto& future : futures) {
        parallelSum += future.get();
    }
    
    auto parallelTime = chrono::high_resolution_clock::now() - start;
    
    cout << "串行结果: " << serialSum << ", 时间: " 
         << chrono::duration_cast<chrono::milliseconds>(serialTime).count() << "ms" << endl;
    cout << "并行结果: " << parallelSum << ", 时间: " 
         << chrono::duration_cast<chrono::milliseconds>(parallelTime).count() << "ms" << endl;
    cout << "加速比: " << static_cast<double>(serialTime.count()) / parallelTime.count() << endl;
}
```

### 场景3：读写锁（C++17）
```cpp
#include <shared_mutex>

template<typename T>
class ThreadSafeValue {
private:
    mutable shared_mutex mtx;
    T value;
    
public:
    ThreadSafeValue(T val = T{}) : value(move(val)) {}
    
    // 读操作（共享锁）
    T get() const {
        shared_lock<shared_mutex> lock(mtx);
        return value;
    }
    
    // 写操作（独占锁）
    void set(T newValue) {
        unique_lock<shared_mutex> lock(mtx);
        value = move(newValue);
    }
    
    // 原子更新
    template<typename Func>
    void update(Func&& func) {
        unique_lock<shared_mutex> lock(mtx);
        func(value);
    }
};

void readWriteLockDemo() {
    cout << "\\n=== 读写锁演示 ===" << endl;
    
    ThreadSafeValue<int> sharedValue(0);
    
    // 多个读者线程
    vector<thread> readers;
    for (int i = 0; i < 5; ++i) {
        readers.emplace_back([&sharedValue, i]() {
            for (int j = 0; j < 10; ++j) {
                int value = sharedValue.get();
                cout << "读者" << i << "读到: " << value << endl;
                this_thread::sleep_for(chrono::milliseconds(50));
            }
        });
    }
    
    // 写者线程
    thread writer([&sharedValue]() {
        for (int i = 1; i <= 5; ++i) {
            sharedValue.set(i * 10);
            cout << "写入: " << i * 10 << endl;
            this_thread::sleep_for(chrono::milliseconds(200));
        }
    });
    
    for (auto& t : readers) t.join();
    writer.join();
}
```

## 4. 易错点/坑

### 错误示例1：数据竞争
```cpp
void dataRaceError() {
    int counter = 0;
    
    thread t1([&counter]() {
        for (int i = 0; i < 10000; ++i) {
            counter++;  // 数据竞争！
        }
    });
    
    thread t2([&counter]() {
        for (int i = 0; i < 10000; ++i) {
            counter++;  // 数据竞争！
        }
    });
    
    t1.join();
    t2.join();
    
    cout << "计数器: " << counter << " (应该为20000)" << endl;
}
```

### 错误示例2：死锁
```cpp
void deadlockError() {
    mutex mtx1, mtx2;
    
    thread t1([&mtx1, &mtx2]() {
        lock_guard<mutex> lock1(mtx1);
        this_thread::sleep_for(chrono::milliseconds(100));
        lock_guard<mutex> lock2(mtx2);  // 可能死锁
    });
    
    thread t2([&mtx1, &mtx2]() {
        lock_guard<mutex> lock2(mtx2);
        this_thread::sleep_for(chrono::milliseconds(100));
        lock_guard<mutex> lock1(mtx1);  // 可能死锁
    });
    
    t1.join();
    t2.join();
}

// 修正：按固定顺序获取锁
void deadlockFixed() {
    mutex mtx1, mtx2;
    
    auto worker = [&mtx1, &mtx2](int id) {
        lock_guard<mutex> lock1(mtx1);  // 总是先获取mtx1
        lock_guard<mutex> lock2(mtx2);  // 然后获取mtx2
        cout << "线程" << id << "获得锁" << endl;
    };
    
    thread t1(worker, 1);
    thread t2(worker, 2);
    
    t1.join();
    t2.join();
}
```

### 错误示例3：忘记join
```cpp
void forgottenJoinError() {
    thread t([]() {
        cout << "线程运行中" << endl;
    });
    
    // 忘记t.join()，程序终止时未定义行为
    
    // 修正：使用RAII包装器
    class ScopedThread {
        thread t;
    public:
        template<typename... Args>
        ScopedThread(Args&&... args) : t(forward<Args>(args)...) {}
        
        ~ScopedThread() {
            if (t.joinable()) t.join();
        }
        
        // 禁用拷贝
        ScopedThread(const ScopedThread&) = delete;
        ScopedThread& operator=(const ScopedThread&) = delete;
    };
    
    ScopedThread safeThread([]() {
        cout << "安全线程运行" << endl;
    });
}
```

### 错误示例4：虚假唤醒
```cpp
void spuriousWakeupError() {
    mutex mtx;
    condition_variable cv;
    bool ready = false;
    
    thread consumer([&]() {
        unique_lock<mutex> lock(mtx);
        
        // 错误：可能虚假唤醒
        // cv.wait(lock);
        
        // 正确：使用条件检查
        cv.wait(lock, [&ready] { return ready; });
        
        cout << "条件满足" << endl;
    });
    
    this_thread::sleep_for(chrono::milliseconds(100));
    
    {
        lock_guard<mutex> lock(mtx);
        ready = true;
    }
    cv.notify_one();
    
    consumer.join();
}
```

## 5. 拓展补充

### 关联知识点

#### 线程局部存储
```cpp
thread_local int threadSpecificValue = 0;

void threadLocalDemo() {
    vector<thread> threads;
    
    for (int i = 0; i < 3; ++i) {
        threads.emplace_back([i]() {
            threadSpecificValue = i + 1;
            this_thread::sleep_for(chrono::milliseconds(100));
            cout << "线程" << i << "的值: " << threadSpecificValue << endl;
        });
    }
    
    for (auto& t : threads) t.join();
}
```

#### 原子操作内存顺序
```cpp
void memoryOrderDemo() {
    atomic<int> x(0), y(0);
    
    thread t1([&]() {
        x.store(1, memory_order_relaxed);
        y.store(1, memory_order_release);
    });
    
    thread t2([&]() {
        while (y.load(memory_order_acquire) != 1) {
            // 自旋等待
        }
        cout << "x = " << x.load(memory_order_relaxed) << endl;  // 保证看到x=1
    });
    
    t1.join();
    t2.join();
}
```

### 进阶延伸

#### 线程池实现
```cpp
class SimpleThreadPool {
    vector<thread> workers;
    queue<function<void()>> tasks;
    mutex queueMutex;
    condition_variable condition;
    bool stop = false;
    
public:
    SimpleThreadPool(size_t threads) {
        for (size_t i = 0; i < threads; ++i) {
            workers.emplace_back([this] {
                while (true) {
                    function<void()> task;
                    {
                        unique_lock<mutex> lock(queueMutex);
                        condition.wait(lock, [this] {
                            return stop || !tasks.empty();
                        });
                        
                        if (stop && tasks.empty()) return;
                        
                        task = move(tasks.front());
                        tasks.pop();
                    }
                    task();
                }
            });
        }
    }
    
    template<class F>
    void enqueue(F&& f) {
        {
            lock_guard<mutex> lock(queueMutex);
            tasks.emplace(forward<F>(f));
        }
        condition.notify_one();
    }
    
    ~SimpleThreadPool() {
        {
            lock_guard<mutex> lock(queueMutex);
            stop = true;
        }
        condition.notify_all();
        for (thread& worker : workers) {
            worker.join();
        }
    }
};
```

#### 并行算法（C++17）
```cpp
void parallelAlgorithmsDemo() {
    vector<int> data(1000000);
    generate(data.begin(), data.end(), []() {
        return rand() % 1000;
    });
    
    // 并行排序
    sort(execution::par, data.begin(), data.end());
    
    // 并行查找
    auto it = find(execution::par, data.begin(), data.end(), 42);
    
    // 并行累加
    int sum = reduce(execution::par, data.begin(), data.end());
    
    cout << "并行算法演示完成" << endl;
}
```

#### 协程（C++20）概念
```cpp
// C++20协程示例（概念性）
/*
generator<int> fibonacci() {
    int a = 0, b = 1;
    while (true) {
        co_yield a;
        tie(a, b) = make_pair(b, a + b);
    }
}

void coroutineDemo() {
    auto gen = fibonacci();
    for (int i = 0; i < 10; ++i) {
        cout << gen() << " ";
    }
    cout << endl;
}
*/
```

### 性能优化技巧

1. **减少锁竞争**：使用细粒度锁或无锁数据结构
2. **合理线程数量**：根据硬件并发数调整
3. **避免虚假共享**：对齐关键数据到缓存行
4. **使用线程局部存储**：减少同步开销
5. **批处理任务**：减少线程创建销毁开销

## 总结

多线程编程是现代C++高性能应用的关键技术：

1. **理解线程基础**：线程创建、同步、通信
2. **掌握同步机制**：互斥锁、条件变量、原子操作
3. **避免常见错误**：数据竞争、死锁、忘记join
4. **使用现代特性**：读写锁、并行算法、线程池
5. **注重性能优化**：减少锁竞争，合理利用硬件

通过合理的多线程设计，可以充分利用多核处理器性能，构建高并发、高性能的应用程序。


# 内存管理

## 1. 核心概念

### 定义
- **内存管理**：程序运行时内存的分配、使用和释放
- **堆内存**：动态分配的内存区域，需要手动管理
- **栈内存**：自动分配和释放的内存区域
- **内存泄漏**：分配的内存未被正确释放

### 关键特性
- **RAII模式**：资源获取即初始化，自动管理资源生命周期
- **智能指针**：自动内存管理的指针类型
- **内存池**：预分配内存块提高分配效率
- **对齐要求**：数据在内存中的对齐规则

## 2. 语法规则

### 基本语法
```cpp
// 动态内存分配
类型* ptr = new 类型(参数);
类型* arr = new 类型[大小];

// 内存释放
delete ptr;
delete[] arr;

// 智能指针
unique_ptr<类型> ptr = make_unique<类型>(参数);
shared_ptr<类型> ptr = make_shared<类型>(参数);
```

### 代码示例
```cpp
#include <iostream>
#include <memory>
#include <vector>
using namespace std;

class Resource {
private:
    string name;
    
public:
    Resource(const string& n) : name(n) {
        cout << "分配资源: " << name << endl;
    }
    
    ~Resource() {
        cout << "释放资源: " << name << endl;
    }
    
    void use() {
        cout << "使用资源: " << name << endl;
    }
};

void rawMemoryDemo() {
    cout << "=== 原始内存管理 ===" << endl;
    
    // 单个对象
    Resource* res1 = new Resource("原始指针对象");
    res1->use();
    delete res1;  // 必须手动释放
    
    // 对象数组
    Resource* resArray = new Resource[3]{
        Resource("数组元素1"),
        Resource("数组元素2"), 
        Resource("数组元素3")
    };
    delete[] resArray;  // 数组释放
}

void smartPointerDemo() {
    cout << "\\n=== 智能指针管理 ===" << endl;
    
    // unique_ptr：独占所有权
    auto uniqueRes = make_unique<Resource>("unique_ptr对象");
    uniqueRes->use();
    // 自动释放，无需delete
    
    // shared_ptr：共享所有权
    auto sharedRes1 = make_shared<Resource>("shared_ptr对象");
    {
        auto sharedRes2 = sharedRes1;  // 共享所有权
        cout << "引用计数: " << sharedRes1.use_count() << endl;
    }
    cout << "引用计数: " << sharedRes1.use_count() << endl;
    // 最后一个shared_ptr离开作用域时自动释放
}

void memoryLayoutDemo() {
    cout << "\\n=== 内存布局演示 ===" << endl;
    
    struct Data {
        char c;     // 1字节
        int i;      // 4字节  
        double d;   // 8字节
        short s;    // 2字节
    };
    
    Data data;
    cout << "结构体大小: " << sizeof(Data) << " 字节" << endl;
    cout << "成员偏移: c=" << offsetof(Data, c)
         << ", i=" << offsetof(Data, i)
         << ", d=" << offsetof(Data, d)
         << ", s=" << offsetof(Data, s) << endl;
}

int main() {
    rawMemoryDemo();
    smartPointerDemo();
    memoryLayoutDemo();
    
    return 0;
}
```

### 注意事项
- 每个new必须对应一个delete
- 数组使用new[]和delete[]配对
- 智能指针自动管理内存生命周期
- 理解RAII模式确保资源正确释放

## 3. 常见用法

### 场景1：智能指针高级用法
```cpp
#include <memory>

void advancedSmartPointerDemo() {
    cout << "=== 智能指针高级用法 ===" << endl;
    
    // weak_ptr观察共享对象
    shared_ptr<Resource> shared = make_shared<Resource>("共享资源");
    weak_ptr<Resource> weak = shared;
    
    cout << "共享引用计数: " << shared.use_count() << endl;  // 1
    
    // 检查资源是否存在
    if (auto locked = weak.lock()) {
        cout << "资源存在: " << locked->use() << endl;
    }
    
    // 释放共享所有权
    shared.reset();
    
    if (auto locked = weak.lock()) {
        cout << "资源仍存在" << endl;
    } else {
        cout << "资源已被释放" << endl;
    }
    
    // 自定义删除器
    auto customDeleter = [](Resource* res) {
        cout << "自定义删除器释放资源" << endl;
        delete res;
    };
    
    unique_ptr<Resource, decltype(customDeleter)> 
        customPtr(new Resource("自定义删除"), customDeleter);
}
```

### 场景2：RAII资源管理
```cpp
#include <fstream>
#include <mutex>

// RAII文件资源管理
class FileHandler {
private:
    ofstream file;
    
public:
    FileHandler(const string& filename) : file(filename) {
        if (!file.is_open()) {
            throw runtime_error("文件打开失败");
        }
        cout << "文件打开: " << filename << endl;
    }
    
    ~FileHandler() {
        if (file.is_open()) {
            file.close();
            cout << "文件关闭" << endl;
        }
    }
    
    void write(const string& content) {
        file << content << endl;
    }
    
    // 禁用拷贝
    FileHandler(const FileHandler&) = delete;
    FileHandler& operator=(const FileHandler&) = delete;
    
    // 允许移动
    FileHandler(FileHandler&& other) noexcept : file(move(other.file)) {}
    FileHandler& operator=(FileHandler&& other) noexcept {
        if (this != &other) {
            file = move(other.file);
        }
        return *this;
    }
};

void raiiResourceDemo() {
    cout << "\\n=== RAII资源管理 ===" << endl;
    
    try {
        FileHandler file("test.txt");
        file.write("Hello, RAII!");
        
        // 即使发生异常，文件也会正确关闭
        throw runtime_error("测试异常");
        
    } catch (const exception& e) {
        cout << "异常捕获: " << e.what() << endl;
    }
    // 文件自动关闭
}
```

### 场景3：内存池优化
```cpp
template<typename T>
class SimpleMemoryPool {
private:
    struct Block {
        T* memory;
        Block* next;
    };
    
    Block* freeList = nullptr;
    size_t blockSize;
    
public:
    SimpleMemoryPool(size_t size = 100) : blockSize(size) {}
    
    T* allocate() {
        if (!freeList) {
            // 分配新块
            Block* newBlock = new Block;
            newBlock->memory = new T[blockSize];
            newBlock->next = nullptr;
            
            // 将新块加入空闲列表
            for (size_t i = 0; i < blockSize; ++i) {
                Block* item = new Block;
                item->memory = &newBlock->memory[i];
                item->next = freeList;
                freeList = item;
            }
        }
        
        Block* block = freeList;
        freeList = freeList->next;
        
        return block->memory;
    }
    
    void deallocate(T* ptr) {
        Block* block = new Block;
        block->memory = ptr;
        block->next = freeList;
        freeList = block;
    }
    
    ~SimpleMemoryPool() {
        while (freeList) {
            Block* next = freeList->next;
            delete freeList;
            freeList = next;
        }
    }
};

void memoryPoolDemo() {
    cout << "\\n=== 内存池优化 ===" << endl;
    
    SimpleMemoryPool<int> pool;
    
    vector<int*> allocated;
    for (int i = 0; i < 10; ++i) {
        int* ptr = pool.allocate();
        *ptr = i;
        allocated.push_back(ptr);
        cout << "分配: " << *ptr << endl;
    }
    
    // 释放部分内存
    for (int i = 0; i < 5; ++i) {
        pool.deallocate(allocated[i]);
        cout << "释放: " << i << endl;
    }
    
    // 重新分配
    for (int i = 0; i < 3; ++i) {
        int* ptr = pool.allocate();
        *ptr = i + 100;
        cout << "重新分配: " << *ptr << endl;
    }
}
```

## 4. 易错点/坑

### 错误示例1：内存泄漏
```cpp
void memoryLeakError() {
    // 忘记释放内存
    Resource* res = new Resource("泄漏对象");
    res->use();
    // 忘记delete res;
    
    // 修正：使用智能指针
    auto safeRes = make_shared<Resource>("安全对象");
    safeRes->use();
    // 自动释放
}
```

### 错误示例2：双重释放
```cpp
void doubleFreeError() {
    Resource* res = new Resource("测试对象");
    
    delete res;  // 第一次释放
    // delete res;  // 错误：双重释放
    
    res = nullptr;  // 安全做法
    
    // 修正：使用智能指针
    auto ptr = make_unique<Resource>("智能指针对象");
    // 自动管理，不会双重释放
}
```

### 错误示例3：错误的new/delete配对
```cpp
void wrongPairError() {
    // 单个对象使用new[]
    Resource* single = new Resource("单个");
    // delete[] single;  // 错误：应该用delete
    
    // 数组使用new
    Resource* array = new Resource[3];
    // delete array;     // 错误：应该用delete[]
    
    // 修正：正确配对
    delete single;      // 正确
    delete[] array;     // 正确
}
```

### 错误示例4：循环引用
```cpp
class Node {
public:
    shared_ptr<Node> next;
    shared_ptr<Node> prev;  // 循环引用！
    
    ~Node() { cout << "节点析构" << endl; }
};

void circularReferenceError() {
    auto node1 = make_shared<Node>();
    auto node2 = make_shared<Node>();
    
    node1->next = node2;
    node2->prev = node1;  // 循环引用，内存泄漏
    
    // 修正：使用weak_ptr
    // weak_ptr<Node> prev;  // 打破循环引用
}
```

## 5. 拓展补充

### 关联知识点

#### placement new
```cpp
void placementNewDemo() {
    cout << "\\n=== placement new ===" << endl;
    
    // 预分配内存
    alignas(Resource) char buffer[sizeof(Resource)];
    
    // 在指定内存位置构造对象
    Resource* res = new (buffer) Resource("placement构造");
    res->use();
    
    // 手动调用析构函数
    res->~Resource();
    
    cout << "placement new完成" << endl;
}
```

#### 内存对齐
```cpp
void memoryAlignmentDemo() {
    cout << "\\n=== 内存对齐 ===" << endl;
    
    struct AlignedData {
        alignas(16) char data[13];  // 16字节对齐
        int value;
    };
    
    AlignedData aligned;
    cout << "对齐后大小: " << sizeof(AlignedData) << endl;
    cout << "对齐要求: " << alignof(AlignedData) << endl;
}
```

### 进阶延伸

#### 自定义分配器
```cpp
template<typename T>
class CustomAllocator {
public:
    using value_type = T;
    
    CustomAllocator() = default;
    
    template<typename U>
    CustomAllocator(const CustomAllocator<U>&) {}
    
    T* allocate(size_t n) {
        cout << "分配 " << n << " 个 " << typeid(T).name() << " 对象" << endl;
        return static_cast<T*>(::operator new(n * sizeof(T)));
    }
    
    void deallocate(T* p, size_t n) {
        cout << "释放 " << n << " 个 " << typeid(T).name() << " 对象" << endl;
        ::operator delete(p);
    }
};

void customAllocatorDemo() {
    cout << "\\n=== 自定义分配器 ===" << endl;
    
    vector<int, CustomAllocator<int>> numbers;
    numbers.reserve(5);
    
    for (int i = 0; i < 5; ++i) {
        numbers.push_back(i);
    }
    
    // vector析构时自动调用分配器的deallocate
}
```

#### 垃圾收集概念
```cpp
// 引用计数垃圾收集（简化版）
class GCObject {
    int refCount = 0;
    
public:
    void addRef() { ++refCount; }
    void release() {
        if (--refCount == 0) {
            delete this;
        }
    }
    
protected:
    virtual ~GCObject() = default;
};

template<typename T>
class GCptr {
    T* ptr;
    
public:
    GCptr(T* p = nullptr) : ptr(p) {
        if (ptr) static_cast<GCObject*>(ptr)->addRef();
    }
    
    ~GCptr() {
        if (ptr) static_cast<GCObject*>(ptr)->release();
    }
    
    // 拷贝构造、赋值操作等...
};
```

### 性能优化建议

1. **优先使用栈内存**：自动管理，性能最优
2. **合理使用智能指针**：避免手动内存管理错误
3. **预分配内存**：减少动态分配开销
4. **考虑内存池**：对小对象提高分配效率
5. **注意缓存友好**：优化数据布局提高缓存命中率

## 总结

现代C++内存管理技术提供了强大的工具来避免常见的内存错误：

1. **理解内存模型**：栈、堆、静态存储区的区别
2. **掌握智能指针**：unique_ptr、shared_ptr、weak_ptr的适用场景
3. **应用RAII模式**：确保资源正确释放
4. **避免常见错误**：内存泄漏、双重释放、循环引用
5. **性能优化**：合理使用内存池和自定义分配器

通过正确使用这些技术，可以构建安全、高效、可维护的C++应用程序。

## 3. 常见用法

### 场景：自定义内存分配器
```cpp
template<typename T>
class SimpleAllocator {
public:
    using value_type = T;
    
    SimpleAllocator() = default;
    
    template<typename U>
    SimpleAllocator(const SimpleAllocator<U>&) {}
    
    T* allocate(size_t n) {
        cout << "分配 " << n << " 个 " << typeid(T).name() << " 对象" << endl;
        return static_cast<T*>(::operator new(n * sizeof(T)));
    }
    
    void deallocate(T* p, size_t n) {
        cout << "释放 " << n << " 个 " << typeid(T).name() << " 对象" << endl;
        ::operator delete(p);
    }
};

void customAllocatorDemo() {
    cout << "\\n=== 自定义分配器 ===" << endl;
    
    vector<int, SimpleAllocator<int>> numbers;
    numbers.reserve(5);
    
    for (int i = 0; i < 5; ++i) {
        numbers.push_back(i);
    }
    
    // vector析构时自动释放内存
    cout << "使用自定义分配器的vector大小: " << numbers.size() << endl;
}
```

### 场景2：对象池模式
```cpp
template<typename T>
class ObjectPool {
private:
    queue<unique_ptr<T>> pool;
    mutex mtx;
    
public:
    template<typename... Args>
    unique_ptr<T> acquire(Args&&... args) {
        lock_guard<mutex> lock(mtx);
        
        if (!pool.empty()) {
            auto obj = move(pool.front());
            pool.pop();
            return obj;
        }
        
        return make_unique<T>(forward<Args>(args)...);
    }
    
    void release(unique_ptr<T> obj) {
        lock_guard<mutex> lock(mtx);
        if (obj) {
            pool.push(move(obj));
        }
    }
    
    size_t size() const {
        lock_guard<mutex> lock(mtx);
        return pool.size();
    }
};

class DatabaseConnection {
    string connectionString;
public:
    DatabaseConnection(const string& connStr) : connectionString(connStr) {
        cout << "创建数据库连接: " << connStr << endl;
    }
    
    ~DatabaseConnection() {
        cout << "关闭数据库连接" << endl;
    }
    
    void execute(const string& query) {
        cout << "执行查询: " << query << endl;
    }
    
    void reset() {
        // 重置连接状态
        cout << "重置连接" << endl;
    }
};

void objectPoolDemo() {
    cout << "\\n=== 对象池模式 ===" << endl;
    
    ObjectPool<DatabaseConnection> pool;
    
    // 从池中获取连接
    auto conn1 = pool.acquire("server=db1;database=test");
    auto conn2 = pool.acquire("server=db2;database=test");
    
    conn1->execute("SELECT * FROM users");
    conn2->execute("UPDATE accounts SET balance = 100");
    
    // 使用后放回池中
    conn1->reset();
    pool.release(move(conn1));
    
    cout << "池中对象数量: " << pool.size() << endl;
}
```

### 场景3：循环引用解决方案
```cpp
class Node {
public:
    string name;
    shared_ptr<Node> next;
    weak_ptr<Node> prev;  // 使用weak_ptr避免循环引用
    
    Node(const string& n) : name(n) {
        cout << "创建节点: " << name << endl;
    }
    
    ~Node() {
        cout << "销毁节点: " << name << endl;
    }
    
    void setNext(shared_ptr<Node> node) {
        next = node;
        if (node) {
            node->prev = weak_ptr<Node>(shared_from_this());
        }
    }
};

void circularReferenceDemo() {
    cout << "\\n=== 循环引用解决方案 ===" << endl;
    
    auto node1 = make_shared<Node>("节点1");
    auto node2 = make_shared<Node>("节点2");
    auto node3 = make_shared<Node>("节点3");
    
    // 形成循环引用
    node1->setNext(node2);
    node2->setNext(node3);
    node3->setNext(node1);  // 循环引用，但使用weak_ptr不会泄漏
    
    cout << "节点1引用计数: " << node1.use_count() << endl;  // 1
    cout << "节点2引用计数: " << node2.use_count() << endl;  // 1
    cout << "节点3引用计数: " << node3.use_count() << endl;  // 1
    
    // 所有节点都能正确销毁
}
```

### 场景4：RAII资源管理器
```cpp
class FileResource {
private:
    unique_ptr<FILE, decltype(&fclose)> file;
    
public:
    FileResource(const char* filename, const char* mode)
        : file(fopen(filename, mode), &fclose) {
        if (!file) throw runtime_error("文件打开失败");
        cout << "打开文件: " << filename << endl;
    }
    
    // 移动构造函数
    FileResource(FileResource&& other) noexcept
        : file(move(other.file)) {}
    
    // 移动赋值运算符
    FileResource& operator=(FileResource&& other) noexcept {
        if (this != &other) {
            file = move(other.file);
        }
        return *this;
    }
    
    void write(const string& content) {
        if (file) {
            fwrite(content.c_str(), 1, content.size(), file.get());
        }
    }
    
    // 禁用拷贝
    FileResource(const FileResource&) = delete;
    FileResource& operator=(const FileResource&) = delete;
    
    ~FileResource() {
        if (file) {
            cout << "关闭文件" << endl;
        }
    }
};

void raiiResourceDemo() {
    cout << "\\n=== RAII资源管理器 ===" << endl;
    
    try {
        FileResource file("test.txt", "w");
        file.write("Hello, RAII!");
        
        // 即使抛出异常，文件也会正确关闭
        throw runtime_error("测试异常");
        
    } catch (const exception& e) {
        cout << "捕获异常: " << e.what() << endl;
    }
    
    // 文件资源已自动释放
}
```

## 4. 易错点/坑

### 错误示例1：内存泄漏
```cpp
void memoryLeakError() {
    // 错误：忘记释放内存
    int* data = new int[1000];
    // 使用data...
    // 忘记 delete[] data;  // 内存泄漏！
    
    // 修正：使用智能指针
    auto safeData = make_unique<int[]>(1000);
    // 自动释放
}
```

### 错误示例2：循环引用
```cpp
void circularReferenceError() {
    class BadNode {
    public:
        shared_ptr<BadNode> next;
        shared_ptr<BadNode> prev;  // 错误：循环引用！
        
        ~BadNode() { cout << "BadNode析构" << endl; }
    };
    
    auto node1 = make_shared<BadNode>();
    auto node2 = make_shared<BadNode>();
    
    node1->next = node2;
    node2->prev = node1;  // 循环引用，内存泄漏！
    
    // node1和node2永远不会被销毁
    cout << "节点1引用计数: " << node1.use_count() << endl;  // 2
    cout << "节点2引用计数: " << node2.use_count() << endl;  // 2
}
```

### 错误示例3：混合使用智能指针和裸指针
```cpp
void mixedPointerError() {
    // 错误：混合使用
    int* rawPtr = new int(42);
    shared_ptr<int> smartPtr1(rawPtr);
    // shared_ptr<int> smartPtr2(rawPtr);  // 错误！双重释放
    
    // 修正：统一使用智能指针
    auto smartPtr = make_shared<int>(42);
    auto anotherPtr = smartPtr;  // 正确：共享所有权
}
```

### 错误示例4：错误的析构顺序
```cpp
void destructionOrderError() {
    class ResourceA {
        shared_ptr<ResourceB> b;
    public:
        ~ResourceA() { cout << "ResourceA析构" << endl; }
    };
    
    class ResourceB {
        shared_ptr<ResourceA> a;  // 可能导致析构顺序问题
    public:
        ~ResourceB() { cout << "ResourceB析构" << endl; }
    };
    
    // 修正：使用weak_ptr或调整设计
    class FixedResourceB {
        weak_ptr<ResourceA> a;  // 使用weak_ptr
    public:
        ~FixedResourceB() { cout << "FixedResourceB析构" << endl; }
    };
}
```

### 错误示例5：过早释放资源
```cpp
void prematureReleaseError() {
    // 错误：过早释放
    auto ptr = make_unique<int>(42);
    int* rawPtr = ptr.get();
    ptr.reset();  // 过早释放
    
    // *rawPtr = 100;  // 未定义行为！
    
    // 修正：确保生命周期正确
    {
        auto safePtr = make_unique<int>(42);
        int* safeRawPtr = safePtr.get();
        *safeRawPtr = 100;  // 安全：ptr仍在作用域内
    }
    // safePtr自动释放
}
```

## 5. 拓展补充

### 关联知识点

#### placement new
```cpp
void placementNewDemo() {
    cout << "\\n=== placement new ===" << endl;
    
    // 预分配内存
    alignas(string) char buffer[sizeof(string) * 3];
    
    // 在指定位置构造对象
    string* str1 = new(buffer) string("第一个字符串");
    string* str2 = new(buffer + sizeof(string)) string("第二个字符串");
    string* str3 = new(buffer + 2 * sizeof(string)) string("第三个字符串");
    
    cout << *str1 << endl;
    cout << *str2 << endl;
    cout << *str3 << endl;
    
    // 手动调用析构函数
    str1->~string();
    str2->~string();
    str3->~string();
}
```

#### 内存对齐
```cpp
void memoryAlignmentDemo() {
    cout << "\\n=== 内存对齐 ===" << endl;
    
    struct UnalignedData {
        char c;     // 1字节
        int i;      // 4字节
        double d;   // 8字节
    };
    
    struct AlignedData {
        alignas(8) char c;   // 8字节对齐
        alignas(8) int i;    // 8字节对齐  
        double d;             // 8字节对齐
    };
    
    cout << "未对齐结构体大小: " << sizeof(UnalignedData) << endl;
    cout << "对齐结构体大小: " << sizeof(AlignedData) << endl;
    
    // 对齐要求
    cout << "double对齐要求: " << alignof(double) << endl;
    cout << "最大对齐要求: " << alignof(max_align_t) << endl;
}
```

#### 自定义删除器
```cpp
void customDeleterDemo() {
    cout << "\\n=== 自定义删除器 ===" << endl;
    
    // 文件删除器
    auto fileDeleter = [](FILE* file) {
        if (file) {
            fclose(file);
            cout << "文件已关闭" << endl;
        }
    };
    
    unique_ptr<FILE, decltype(fileDeleter)> 
        file(fopen("test.txt", "w"), fileDeleter);
    
    // 带日志的删除器
    auto loggingDeleter = [](int* ptr) {
        cout << "删除整数: " << *ptr << endl;
        delete ptr;
    };
    
    unique_ptr<int, decltype(loggingDeleter)> 
        num(new int(42), loggingDeleter);
}
```

### 进阶延伸

#### 内存池实现
```cpp
class SimpleMemoryPool {
private:
    struct Block {
        Block* next;
    };
    
    Block* freeList = nullptr;
    size_t blockSize;
    
public:
    SimpleMemoryPool(size_t size) : blockSize(size) {}
    
    void* allocate() {
        if (!freeList) {
            // 分配新块
            return ::operator new(blockSize);
        }
        
        Block* block = freeList;
        freeList = freeList->next;
        return block;
    }
    
    void deallocate(void* ptr) {
        if (!ptr) return;
        
        Block* block = static_cast<Block*>(ptr);
        block->next = freeList;
        freeList = block;
    }
    
    ~SimpleMemoryPool() {
        while (freeList) {
            Block* next = freeList->next;
            ::operator delete(freeList);
            freeList = next;
        }
    }
};
```

#### 智能指针性能优化
```cpp
void smartPointerOptimization() {
    cout << "\\n=== 智能指针性能优化 ===" << endl;
    
    // 使用make_shared优化（单次分配）
    auto shared1 = make_shared<vector<int>>(1000, 42);
    
    // 避免不必要的shared_ptr拷贝
    auto processVector = [](const shared_ptr<vector<int>>& vec) {
        // 使用const引用避免引用计数增加
        cout << "向量大小: " << vec->size() << endl;
    };
    
    processVector(shared1);
    
    // 使用unique_ptr移动语义
    auto uniqueVec = make_unique<vector<int>>(1000, 42);
    auto processUnique = [](unique_ptr<vector<int>> vec) {
        // 移动语义，无拷贝开销
        cout << "唯一向量大小: " << vec->size() << endl;
    };
    
    processUnique(move(uniqueVec));
}
```

### 最佳实践总结

1. **优先使用智能指针**：避免手动内存管理错误
2. **理解所有权语义**：明确资源生命周期管理
3. **避免循环引用**：合理使用weak_ptr
4. **异常安全设计**：确保资源在异常时正确释放
5. **性能优化考虑**：根据场景选择合适的内存管理策略
6. **使用现代特性**：充分利用C++11/14/17内存管理特性

## 总结

现代C++内存管理已经从手动管理演进到自动管理：

1. **RAII原则**：资源获取即初始化，自动管理生命周期
2. **智能指针**：unique_ptr、shared_ptr、weak_ptr各有用途
3. **移动语义**：优化大对象传递性能
4. **自定义管理**：分配器、对象池等高级技术
5. **工具支持**：内存分析、调试工具辅助

通过掌握这些技术，可以编写出安全、高效、易维护的C++代码。