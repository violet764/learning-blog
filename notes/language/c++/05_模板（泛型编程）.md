# 模板（泛型编程）

## 1. 核心概念

### 定义
- **模板**：允许编写与数据类型无关的通用代码的C++特性
- **泛型编程**：编写可处理多种数据类型的通用算法和数据结构
- **模板实例化**：编译器根据具体类型生成特定版本的模板代码

### 关键特性
- **类型参数化**：将数据类型作为参数传递
- **编译时多态**：在编译时确定具体类型
- **代码复用**：同一模板可用于多种数据类型
- **性能优化**：避免运行时类型检查的开销

## 2. 语法规则

### 基本语法
```cpp
// 函数模板
template <typename T>
返回类型 函数名(参数列表);

// 类模板
template <typename T>
class 类名 {
    // 类定义
};
```

### 代码示例
```cpp
#include <iostream>
#include <string>
using namespace std;

// 函数模板：交换两个值
template <typename T>
void swapValues(T& a, T& b) {
    T temp = a;
    a = b;
    b = temp;
}

// 函数模板：查找最大值
template <typename T>
T findMax(const T arr[], int size) {
    T maxVal = arr[0];
    for (int i = 1; i < size; i++) {
        if (arr[i] > maxVal) {
            maxVal = arr[i];
        }
    }
    return maxVal;
}

// 类模板：简单的栈
template <typename T, int MAX_SIZE = 100>
class Stack {
private:
    T data[MAX_SIZE];
    int topIndex;
    
public:
    Stack() : topIndex(-1) {}
    
    // 入栈
    bool push(const T& value) {
        if (topIndex < MAX_SIZE - 1) {
            data[++topIndex] = value;
            return true;
        }
        return false;
    }
    
    // 出栈
    bool pop(T& value) {
        if (topIndex >= 0) {
            value = data[topIndex--];
            return true;
        }
        return false;
    }
    
    // 查看栈顶
    T top() const {
        if (topIndex >= 0) {
            return data[topIndex];
        }
        throw out_of_range("栈为空");
    }
    
    // 判断是否为空
    bool isEmpty() const {
        return topIndex == -1;
    }
    
    // 获取大小
    int size() const {
        return topIndex + 1;
    }
};

int main() {
    cout << "=== 函数模板演示 ===" << endl;
    
    // 使用模板函数交换整数
    int x = 10, y = 20;
    cout << "交换前: x=" << x << ", y=" << y << endl;
    swapValues(x, y);
    cout << "交换后: x=" << x << ", y=" << y << endl;
    
    // 使用模板函数交换字符串
    string s1 = "Hello", s2 = "World";
    cout << "交换前: s1=" << s1 << ", s2=" << s2 << endl;
    swapValues(s1, s2);
    cout << "交换后: s1=" << s1 << ", s2=" << s2 << endl;
    
    // 查找不同类型数组的最大值
    int intArr[] = {3, 7, 2, 9, 1};
    double doubleArr[] = {3.5, 7.2, 2.8, 9.1, 1.6};
    
    cout << "整数数组最大值: " << findMax(intArr, 5) << endl;
    cout << "浮点数数组最大值: " << findMax(doubleArr, 5) << endl;
    
    cout << "\\n=== 类模板演示 ===" << endl;
    
    // 使用整数栈
    Stack<int> intStack;
    intStack.push(10);
    intStack.push(20);
    intStack.push(30);
    
    cout << "整数栈大小: " << intStack.size() << endl;
    cout << "栈顶元素: " << intStack.top() << endl;
    
    // 使用字符串栈
    Stack<string> stringStack;
    stringStack.push("C++");
    stringStack.push("模板");
    stringStack.push("编程");
    
    cout << "字符串栈内容: ";
    while (!stringStack.isEmpty()) {
        string value;
        stringStack.pop(value);
        cout << value << " ";
    }
    cout << endl;
    
    // 使用自定义大小的栈
    Stack<double, 5> smallStack;
    for (int i = 0; i < 5; i++) {
        smallStack.push(i * 1.1);
    }
    cout << "小栈大小: " << smallStack.size() << endl;
    
    return 0;
}
```

### 注意事项
- 模板定义通常放在头文件中
- 模板参数可以是类型参数或非类型参数
- 模板在实例化时进行类型检查
- 可以使用多个模板参数

## 3. 常见用法

### 场景1：容器类模板
```cpp
// 简单的动态数组模板
template <typename T>
class DynamicArray {
private:
    T* data;
    int capacity;
    int size;
    
    void resize(int newCapacity) {
        T* newData = new T[newCapacity];
        for (int i = 0; i < size; i++) {
            newData[i] = data[i];
        }
        delete[] data;
        data = newData;
        capacity = newCapacity;
    }
    
public:
    DynamicArray() : data(nullptr), capacity(0), size(0) {}
    
    DynamicArray(int initialCapacity) : capacity(initialCapacity), size(0) {
        data = new T[capacity];
    }
    
    ~DynamicArray() {
        delete[] data;
    }
    
    // 禁止拷贝（简化实现）
    DynamicArray(const DynamicArray&) = delete;
    DynamicArray& operator=(const DynamicArray&) = delete;
    
    void pushBack(const T& value) {
        if (size >= capacity) {
            resize(capacity == 0 ? 1 : capacity * 2);
        }
        data[size++] = value;
    }
    
    T& operator[](int index) {
        if (index < 0 || index >= size) {
            throw out_of_range("索引越界");
        }
        return data[index];
    }
    
    const T& operator[](int index) const {
        if (index < 0 || index >= size) {
            throw out_of_range("索引越界");
        }
        return data[index];
    }
    
    int getSize() const { return size; }
    int getCapacity() const { return capacity; }
};
```

### 场景2：算法模板
```cpp
// 排序算法模板
template <typename T>
void bubbleSort(T arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
            }
        }
    }
}

// 查找算法模板
template <typename T>
int binarySearch(const T arr[], int n, const T& target) {
    int left = 0, right = n - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return -1;  // 未找到
}

// 对容器进行操作的模板函数
template <typename Container, typename Function>
void forEach(const Container& container, Function func) {
    for (const auto& element : container) {
        func(element);
    }
}
```

### 场景3：模板特化
```cpp
// 通用模板
template <typename T>
class TypeInfo {
public:
    static string getName() {
        return "未知类型";
    }
};

// 模板特化：整数类型
template <>
class TypeInfo<int> {
public:
    static string getName() {
        return "整数类型";
    }
};

// 模板特化：双精度浮点数
template <>
class TypeInfo<double> {
public:
    static string getName() {
        return "双精度浮点数";
    }
};

// 模板特化：字符串
template <>
class TypeInfo<string> {
public:
    static string getName() {
        return "字符串类型";
    }
};

// 使用示例
cout << TypeInfo<int>::getName() << endl;     // 输出：整数类型
cout << TypeInfo<double>::getName() << endl;  // 输出：双精度浮点数
cout << TypeInfo<string>::getName() << endl;  // 输出：字符串类型
```

## 4. 易错点/坑

### 错误示例1：模板定义在源文件中
```cpp
// mytemplate.h
template <typename T>
T add(T a, T b) {
    return a + b;
}

// main.cpp
#include "mytemplate.h"

int main() {
    int result = add(5, 3);  // 链接错误！
    return 0;
}
```
**原因**：模板定义必须对使用者可见，通常放在头文件中
**修正方案**：
```cpp
// 将模板定义放在头文件中
// mytemplate.h
template <typename T>
T add(T a, T b) {
    return a + b;
}
```

### 错误示例2：不支持的类型操作
```cpp
template <typename T>
T getAverage(const T arr[], int size) {
    T sum = T();  // 值初始化
    for (int i = 0; i < size; i++) {
        sum += arr[i];  // 要求T支持+=操作
    }
    return sum / size;  // 要求T支持/操作
}

class MyClass {
    // 没有定义+=和/运算符
};

int main() {
    MyClass arr[3];
    getAverage(arr, 3);  // 编译错误！
    return 0;
}
```
**原因**：模板要求类型支持特定操作
**修正方案**：
```cpp
// 使用概念约束（C++20）或静态断言
template <typename T>
T getAverage(const T arr[], int size) {
    static_assert(std::is_arithmetic_v<T>, "T必须是算术类型");
    T sum = T();
    for (int i = 0; i < size; i++) {
        sum += arr[i];
    }
    return sum / size;
}
```

### 错误示例3：模板参数推导失败
```cpp
template <typename T>
void process(T a, T b) {
    // 处理逻辑
}

int main() {
    process(5, 3.14);  // 错误：T无法推导（int vs double）
    return 0;
}
```
**原因**：编译器无法为T推导出唯一类型
**修正方案**：
```cpp
// 方案1：显式指定类型
process<double>(5, 3.14);

// 方案2：使用两个模板参数
template <typename T1, typename T2>
void process(T1 a, T2 b) {
    // 处理逻辑
}

// 方案3：使用通用引用（C++11）
template <typename T>
void process(T&& a, T&& b) {
    // 处理逻辑
}
```

## 5. 拓展补充

### 关联知识点
- **模板参数**：类型参数、非类型参数、模板模板参数
- **可变参数模板**：接受任意数量参数的模板
- **模板元编程**：在编译时进行计算的技术
- **SFINAE**：替换失败不是错误的原则

### 进阶延伸
- **概念（Concepts）**：C++20引入的模板约束机制
- **折叠表达式**：C++17简化可变参数模板的语法
- **CRTP**：奇特的递归模板模式
- **模板特化与偏特化**：为特定类型提供定制实现

# 命名空间与异常处理

## 1. 核心概念

### 定义
- **命名空间**：将代码组织到逻辑组的机制，防止名称冲突
- **异常处理**：处理程序运行时错误的机制，提供错误恢复能力
- **异常安全**：代码在异常发生时仍能保持正确状态的特性

### 关键特性
- **名称隔离**：不同命名空间中的同名标识符不会冲突
- **错误传播**：异常可以从深层函数传播到外层处理程序
- **资源管理**：异常发生时确保资源正确释放
- **代码组织**：使用命名空间实现模块化设计

## 2. 语法规则

### 基本语法
```cpp
// 命名空间定义
namespace 命名空间名 {
    // 类、函数、变量等定义
}

// 异常处理
try {
    // 可能抛出异常的代码
} catch (异常类型1& e) {
    // 处理异常类型1
} catch (异常类型2& e) {
    // 处理异常类型2
} catch (...) {
    // 处理所有其他异常
}
```

### 代码示例
```cpp
#include <iostream>
#include <stdexcept>
#include <string>
using namespace std;

// 自定义命名空间
namespace MathUtils {
    const double PI = 3.14159;
    
    double calculateCircleArea(double radius) {
        if (radius < 0) {
            throw invalid_argument("半径不能为负数");
        }
        return PI * radius * radius;
    }
    
    double divide(double a, double b) {
        if (b == 0) {
            throw runtime_error("除数不能为零");
        }
        return a / b;
    }
}

namespace StringUtils {
    string toUpperCase(const string& str) {
        string result = str;
        for (char& c : result) {
            c = toupper(c);
        }
        return result;
    }
    
    string reverse(const string& str) {
        return string(str.rbegin(), str.rend());
    }
}

// 嵌套命名空间
namespace MyApp {
    namespace Database {
        class Connection {
        public:
            void connect() {
                cout << "数据库连接已建立" << endl;
            }
            
            void disconnect() {
                cout << "数据库连接已关闭" << endl;
            }
        };
    }
    
    namespace UI {
        void showMessage(const string& msg) {
            cout << "UI: " << msg << endl;
        }
    }
}

int main() {
    cout << "=== 命名空间使用演示 ===" << endl;
    
    // 使用命名空间中的函数
    cout << "圆面积: " << MathUtils::calculateCircleArea(5.0) << endl;
    cout << "字符串反转: " << StringUtils::reverse("Hello") << endl;
    
    // 使用嵌套命名空间
    MyApp::Database::Connection db;
    db.connect();
    MyApp::UI::showMessage("欢迎使用应用程序");
    
    cout << "\\n=== 异常处理演示 ===" << endl;
    
    // 异常处理示例
    try {
        double result1 = MathUtils::divide(10.0, 2.0);
        cout << "10.0 / 2.0 = " << result1 << endl;
        
        double result2 = MathUtils::divide(10.0, 0.0);  // 会抛出异常
        cout << "这行代码不会执行" << endl;
        
    } catch (const invalid_argument& e) {
        cout << "无效参数异常: " << e.what() << endl;
    } catch (const runtime_error& e) {
        cout << "运行时异常: " << e.what() << endl;
    } catch (...) {
        cout << "未知异常发生" << endl;
    }
    
    // 多级异常处理演示
    try {
        try {
            // 内部try块
            throw logic_error("逻辑错误示例");
        } catch (const logic_error& e) {
            cout << "内部捕获: " << e.what() << endl;
            throw;  // 重新抛出异常
        }
    } catch (const logic_error& e) {
        cout << "外部捕获: " << e.what() << endl;
    }
    
    cout << "=== 程序正常结束 ===" << endl;
    return 0;
}
```

### 注意事项
- 使用`using namespace`可以引入整个命名空间
- 使用`using 命名空间::成员`可以引入特定成员
- 异常应该按从具体到一般的顺序捕获
- 使用引用捕获异常以避免对象切片

## 3. 常见用法

### 场景1：自定义异常类
```cpp
#include <iostream>
#include <exception>
#include <string>

// 自定义异常基类
class MyException : public std::exception {
protected:
    std::string message;
    
public:
    MyException(const std::string& msg) : message(msg) {}
    
    const char* what() const noexcept override {
        return message.c_str();
    }
};

// 具体的异常类
class FileNotFoundException : public MyException {
public:
    FileNotFoundException(const std::string& filename) 
        : MyException("文件未找到: " + filename) {}
};

class DatabaseException : public MyException {
public:
    DatabaseException(const std::string& operation) 
        : MyException("数据库操作失败: " + operation) {}
};

class NetworkException : public MyException {
private:
    int errorCode;
    
public:
    NetworkException(const std::string& msg, int code) 
        : MyException(msg), errorCode(code) {}
    
    int getErrorCode() const { return errorCode; }
};

// 使用自定义异常
void readFile(const std::string& filename) {
    // 模拟文件不存在
    throw FileNotFoundException(filename);
}

void connectToDatabase() {
    // 模拟数据库连接失败
    throw DatabaseException("连接数据库");
}

int main() {
    try {
        readFile("data.txt");
        connectToDatabase();
    } catch (const FileNotFoundException& e) {
        std::cout << "文件异常: " << e.what() << std::endl;
    } catch (const DatabaseException& e) {
        std::cout << "数据库异常: " << e.what() << std::endl;
    } catch (const MyException& e) {
        std::cout << "我的异常: " << e.what() << std::endl;
    } catch (const std::exception& e) {
        std::cout << "标准异常: " << e.what() << std::endl;
    }
    
    return 0;
}
```

### 场景2：RAII与异常安全
```cpp
#include <iostream>
#include <memory>

// RAII资源管理类
class FileHandler {
private:
    FILE* file;
    
public:
    FileHandler(const char* filename, const char* mode) {
        file = fopen(filename, mode);
        if (!file) {
            throw std::runtime_error("无法打开文件");
        }
        std::cout << "文件已打开" << std::endl;
    }
    
    ~FileHandler() {
        if (file) {
            fclose(file);
            std::cout << "文件已关闭" << std::endl;
        }
    }
    
    // 禁止拷贝
    FileHandler(const FileHandler&) = delete;
    FileHandler& operator=(const FileHandler&) = delete;
    
    void write(const std::string& data) {
        if (fprintf(file, "%s\n", data.c_str()) < 0) {
            throw std::runtime_error("写入文件失败");
        }
    }
};

// 使用智能指针的RAII
class DatabaseConnection {
private:
    std::unique_ptr<void*> connection;  // 模拟数据库连接
    
public:
    DatabaseConnection() {
        // 模拟数据库连接（可能失败）
        connection = std::make_unique<void*>((void*)0x12345678);
        if (!connection) {
            throw std::runtime_error("数据库连接失败");
        }
        std::cout << "数据库已连接" << std::endl;
    }
    
    ~DatabaseConnection() {
        if (connection) {
            std::cout << "数据库连接已关闭" << std::endl;
        }
    }
    
    void executeQuery(const std::string& query) {
        // 模拟查询执行（可能失败）
        if (query.empty()) {
            throw std::runtime_error("查询不能为空");
        }
        std::cout << "执行查询: " << query << std::endl;
    }
};

// 异常安全的函数
void processData() {
    // 使用RAII对象，异常安全
    FileHandler file("data.txt", "w");
    DatabaseConnection db;
    
    file.write("开始处理数据");
    db.executeQuery("SELECT * FROM users");
    
    // 可能抛出异常的操作
    throw std::runtime_error("处理数据时发生错误");
    
    file.write("数据处理完成");  // 这行不会执行
    // 但file和db的析构函数会自动调用，确保资源释放
}

int main() {
    try {
        processData();
    } catch (const std::exception& e) {
        std::cout << "捕获异常: " << e.what() << std::endl;
    }
    
    return 0;
}
```

### 场景3：命名空间别名和using声明
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

// 很长的命名空间
namespace VeryLongNamespaceName {
    void function1() {
        std::cout << "函数1" << std::endl;
    }
    
    void function2() {
        std::cout << "函数2" << std::endl;
    }
    
    class MyClass {
    public:
        void method() {
            std::cout << "类方法" << std::endl;
        }
    };
}

// 使用命名空间别名
namespace VLN = VeryLongNamespaceName;

// 使用using声明
using std::cout;
using std::endl;
using std::vector;

// 使用using引入特定成员
using VeryLongNamespaceName::function1;
using VeryLongNamespaceName::MyClass;

int main() {
    // 使用别名
    VLN::function1();
    VLN::function2();
    
    // 使用using引入的成员
    function1();  // 可以直接使用，不需要命名空间前缀
    
    MyClass obj;
    obj.method();
    
    // 使用using引入的标准库成员
    vector<int> numbers = {3, 1, 4, 1, 5, 9};
    std::sort(numbers.begin(), numbers.end());
    
    for (int num : numbers) {
        cout << num << " ";  // 可以直接使用cout和endl
    }
    cout << endl;
    
    // 注意：避免在头文件中使用using namespace
    // 在实现文件中局部使用是可以的
    
    return 0;
}
```

## 4. 易错点/坑

### 错误示例1：异常对象切片
```cpp
class MyException : public std::exception {
    std::string msg;
public:
    MyException(const std::string& m) : msg(m) {}
    const char* what() const noexcept override {
        return msg.c_str();
    }
};

void problematicCatch() {
    try {
        throw MyException("我的异常");
    } catch (std::exception e) {  // 错误：按值捕获，发生切片
        std::cout << e.what() << std::endl;  // 可能丢失信息
    }
}
```
**原因**：按值捕获异常导致对象切片，派生类特有信息丢失
**修正方案**：
```cpp
void correctCatch() {
    try {
        throw MyException("我的异常");
    } catch (const std::exception& e) {  // 正确：按引用捕获
        std::cout << e.what() << std::endl;  // 保持完整信息
    }
}
```

### 错误示例2：异常吞噬
```cpp
void dangerousFunction() {
    FileHandler* file = new FileHandler("data.txt", "w");
    
    try {
        // 可能抛出异常的操作
        file->write("一些数据");
        throw std::runtime_error("操作失败");
        
    } catch (...) {
        // 捕获异常但不处理，导致内存泄漏
        std::cout << "发生异常" << std::endl;
        // 忘记delete file!
    }
    
    delete file;  // 这行不会执行
}
```
**原因**：异常处理中忘记释放资源
**修正方案**：
```cpp
void safeFunction() {
    // 使用RAII，自动管理资源
    FileHandler file("data.txt", "w");
    
    try {
        file.write("一些数据");
        throw std::runtime_error("操作失败");
        
    } catch (const std::exception& e) {
        std::cout << "异常: " << e.what() << std::endl;
        // file的析构函数会自动调用，确保资源释放
    }
}
```

### 错误示例3：命名空间污染
```cpp
// 头文件 myheader.h
using namespace std;  // 错误：在头文件中使用using namespace

class MyClass {
    // 类定义
};

// 其他文件包含此头文件时，会引入整个std命名空间
// 可能导致名称冲突
```
**原因**：头文件中的using namespace会污染包含该头文件的所有文件
**修正方案**：
```cpp
// 头文件 myheader.h
// 不使用using namespace

class MyClass {
    // 类定义
};

// 实现文件 myclass.cpp
#include "myheader.h"
#include <iostream>
#include <vector>

// 在实现文件中局部使用是可以的
using std::cout;
using std::endl;

void MyClass::someMethod() {
    cout << "Hello" << endl;  // 在实现文件中使用
}
```

## 5. 拓展补充

### 关联知识点
- **noexcept说明符**：声明函数不会抛出异常
- **异常规格**：C++98的异常规范机制（已弃用）
- **栈展开**：异常发生时调用栈的清理过程
- **terminate处理**：未捕获异常时的处理机制

### 进阶延伸
- **异常安全等级**：基本保证、强保证、不抛异常保证
- **移动语义与异常**：移动操作通常声明为noexcept
- **协程异常**：C++20协程中的异常处理
- **系统特定异常**：平台相关的异常类型

# 指针与引用

## 1. 核心概念

### 定义
- **指针**：存储内存地址的变量，提供对内存的直接操作能力
- **引用**：变量的别名机制，编译时绑定到对象

### 关键特性
- **指针算术**：指针运算基于所指类型的大小进行
- **空指针安全**：C++11引入nullptr作为安全的空指针字面量
- **引用安全**：引用必须绑定到有效对象，无空引用问题

## 2. 语法规则

### 代码示例

**指针基础：内存地址的间接访问机制**

```cpp
#include <iostream>
using namespace std;

int number = 42;
int *ptr = &number;  // ptr存储number的内存地址

// 内存布局分析：
// number变量：在栈上分配4字节，存储值42
// ptr指针：在栈上分配8字节（64位），存储number的地址

cout << "变量值: " << number << endl;      // 42（直接访问）
cout << "变量地址: " << &number << endl;   // 如0x7ffe1234（实际地址）
cout << "指针值: " << ptr << endl;         // 与&number相同（存储的地址）
cout << "指针指向的值: " << *ptr << endl;  // 42（间接访问，解引用）

// 通过指针修改变量：间接写入内存
*ptr = 100;  // 等价于：在ptr存储的地址处写入100
cout << "修改后: " << number << endl;      // 100（原变量被修改）

// 指针类型的重要性
double d = 3.14;
double *d_ptr = &d;
// d_ptr + 1 会移动8字节（double大小）
// ptr + 1 会移动4字节（int大小）

// 空指针安全
int *null_ptr = nullptr;  // C++11空指针字面量
// *null_ptr = 10;        // 运行时错误：空指针解引用
if (null_ptr != nullptr) {
    *null_ptr = 10;       // 安全检查
}
```

**指针与数组：数组名的指针语义**

```cpp
int arr[] = {10, 20, 30, 40, 50};
int *p = arr;  // 数组名退化为指针，指向首元素

// 等价关系分析：
// arr[i] 等价于 *(arr + i)
// &arr[i] 等价于 arr + i

// 通过指针访问数组：指针算术
for (int i = 0; i < 5; i++) {
    cout << *(p + i) << " ";  // 10 20 30 40 50
    // p + i 实际地址：p + i * sizeof(int)
}
cout << endl;

// 指针算术：基于类型的地址计算
p++;  // 地址增加sizeof(int)=4字节，指向arr[1]
cout << *p << endl;  // 20（arr[1]的值）

// 数组指针与指针数组的区别
int (*array_ptr)[5] = &arr;    // 指向整个数组的指针
int *pointer_array[5];         // 包含5个int指针的数组

// 多维数组的指针表示
int matrix[2][3] = {{1,2,3},{4,5,6}};
int (*row_ptr)[3] = matrix;    // 指向包含3个int的数组的指针
cout << (*row_ptr)[1] << endl;  // 2
cout << (*(row_ptr + 1))[1] << endl;  // 5
```

**引用基础：编译时的名称绑定**

```cpp
int original = 42;
int &ref = original;  // ref是original的引用（编译时别名绑定）

// 引用与指针的底层关系：
// 编译器通常将引用实现为自动解引用的指针
// 但语法上更安全，避免了空指针和悬空引用问题

cout << "原始值: " << original << endl;  // 42
cout << "引用值: " << ref << endl;       // 42（访问同一内存）

// 通过引用修改：直接操作原变量
ref = 100;  // 等价于 original = 100
cout << "修改后原始值: " << original << endl;  // 100

// 引用必须在声明时初始化（语言强制要求）
// int &invalid_ref;  // 编译错误：引用必须初始化

// 引用与const的关系
const int &const_ref = original;  // 只读引用，不能通过它修改原变量
// const_ref = 200;  // 错误：const引用不能修改

// 临时对象的生命周期延长
const int &temp_ref = 42;  // 临时对象42的生命周期被延长
// 普通引用不能绑定到临时对象：int &bad_ref = 42;  // 错误
```

**引用作为函数参数**

```cpp
// 引用参数：直接操作调用者的变量
void swap(int &a, int &b) {  // a和b是调用者变量的引用
    int temp = a;    // 读取a指向的内存
    a = b;           // 将b的值写入a指向的内存
    b = temp;        // 将temp写入b指向的内存
}

// 调用过程分析：
int x = 5, y = 10;
swap(x, y);  // 编译器传递x和y的引用，而不是拷贝值
// 函数内部直接操作x和y的内存
cout << "x = " << x << ", y = " << y << endl;  // x=10, y=5

// 与值传递的对比
void swap_by_value(int a, int b) {  // 接收值的拷贝
    int temp = a;
    a = b;
    b = temp;
    // 只修改了局部拷贝，不影响原变量
}

// 与指针传递的对比
void swap_by_pointer(int *a, int *b) {  // 接收指针
    int temp = *a;
    *a = *b;
    *b = temp;
}
swap_by_pointer(&x, &y);  // 需要取地址操作，语法不够直观

// 常量引用：只读访问，避免拷贝
void print_large_object(const vector<int> &vec) {
    // 可以读取vec，但不能修改
    for (const auto &item : vec) {
        cout << item << " ";
    }
}

// 右值引用（C++11）：移动语义
void take_ownership(vector<int> &&vec) {
    // vec是右值引用，可以"窃取"其资源
    vector<int> local = std::move(vec);  // 移动而非拷贝
}
```

## 3. 常见用法

### 指针vs引用：使用场景与区别

| 特性 | 指针 | 引用 |
|------|------|------|
| **语法** | `int *p = &var;` | `int &r = var;` |
| **重新赋值** | 可以指向不同变量 | 一旦绑定，不能更改 |
| **空值** | 可以是`nullptr` | 必须绑定到有效对象 |
| **多级间接** | 支持多级指针 | 只有一级引用 |
| **内存占用** | 存储地址（通常4/8字节） | 通常是优化掉的（无额外内存） |

**使用场景建议：**
- **指针**：需要重新指向、可选参数、动态内存管理
- **引用**：函数参数、返回值、避免拷贝大对象

### 智能指针简介

**unique_ptr（独占所有权）：**
```cpp
#include <memory>

// 创建unique_ptr
std::unique_ptr<int> ptr1 = std::make_unique<int>(42);
std::unique_ptr<int[]> arr_ptr = std::make_unique<int[]>(5);

// 使用智能指针
cout << *ptr1 << endl;  // 42
arr_ptr[0] = 10;

// 所有权转移（不能复制）
std::unique_ptr<int> ptr2 = std::move(ptr1);  // ptr1变为nullptr
```

**shared_ptr（共享所有权）：**
```cpp
std::shared_ptr<int> shared1 = std::make_shared<int>(100);
std::shared_ptr<int> shared2 = shared1;  // 共享所有权

cout << "引用计数: " << shared1.use_count() << endl;  // 2
cout << *shared1 << endl;  // 100
cout << *shared2 << endl;  // 100
```

## 4. 易错点/坑

### 错误示例1：悬空指针
```cpp
int* danglingPointer() {
    int local_var = 50;        // 栈上分配局部变量
    return &local_var;        // 危险！返回局部变量的地址
    // 函数结束时，local_var的栈内存被回收
}

void useAfterFree() {
    int *ptr = new int(100);
    delete ptr;     // 释放内存
    *ptr = 200;     // 错误！使用已释放的内存
}
```
**修正方案**：使用智能指针避免悬空指针

### 错误示例2：空指针解引用
```cpp
void nullPointerDereference() {
    int *ptr = nullptr;
    *ptr = 10;  // 运行时错误：空指针解引用
}
```
**修正方案**：使用智能指针或进行检查

### 错误示例3：引用未初始化
```cpp
void uninitializedReference() {
    int &ref;  // 编译错误：引用必须初始化
}
```

## 5. 拓展补充

### 关联知识点
- **智能指针**：自动内存管理的现代C++方案
- **移动语义**：C++11引入的所有权转移机制
- **RAII**：资源获取即初始化的资源管理模式

### 进阶延伸
- **指向指针的指针**：多级间接寻址
- **函数指针**：指向函数的指针
- **lambda表达式**：匿名函数对象
- **完美转发**：std::forward保持参数类型属性

# 智能指针（C++11+）

## 1. 核心概念

### 定义
- **智能指针**：C++11引入的自动管理动态内存的模板类
- **RAII模式**：资源获取即初始化，利用对象生命周期管理资源
- **所有权语义**：明确指针的所有权关系，防止内存泄漏

### 关键特性
- **自动内存管理**：对象销毁时自动释放内存
- **所有权转移**：明确指针所有权的转移语义
- **异常安全**：异常发生时确保资源正确释放
- **避免悬空指针**：防止访问已释放的内存

## 2. 语法规则

### 基本语法
```cpp
#include <memory>

// unique_ptr：独占所有权
std::unique_ptr<类型> ptr = std::make_unique<类型>(参数);

// shared_ptr：共享所有权  
std::shared_ptr<类型> ptr = std::make_shared<类型>(参数);

// weak_ptr：弱引用，不增加引用计数
std::weak_ptr<类型> weakPtr = sharedPtr;
```

### 代码示例
```cpp
#include <iostream>
#include <memory>
#include <vector>
using namespace std;

class MyClass {
private:
    string name;
    
public:
    MyClass(const string& n) : name(n) {
        cout << "MyClass构造: " << name << endl;
    }
    
    ~MyClass() {
        cout << "MyClass析构: " << name << endl;
    }
    
    void doSomething() {
        cout << "MyClass操作: " << name << endl;
    }
    
    string getName() const { return name; }
};

// 演示unique_ptr的独占所有权
void uniquePtrDemo() {
    cout << "=== unique_ptr演示 ===" << endl;
    
    // 创建unique_ptr
    unique_ptr<MyClass> ptr1 = make_unique<MyClass>("对象1");
    ptr1->doSomething();
    
    // 转移所有权
    unique_ptr<MyClass> ptr2 = move(ptr1);  // ptr1变为nullptr
    if (ptr1 == nullptr) {
        cout << "ptr1所有权已转移" << endl;
    }
    
    ptr2->doSomething();
    
    // 自动释放：当ptr2离开作用域时，对象自动销毁
}

// 演示shared_ptr的共享所有权
void sharedPtrDemo() {
    cout << "\\n=== shared_ptr演示 ===" << endl;
    
    // 创建shared_ptr
    shared_ptr<MyClass> ptr1 = make_shared<MyClass>("共享对象");
    cout << "引用计数: " << ptr1.use_count() << endl;  // 1
    
    {
        // 共享所有权
        shared_ptr<MyClass> ptr2 = ptr1;
        cout << "引用计数: " << ptr1.use_count() << endl;  // 2
        
        ptr2->doSomething();
        
        // ptr2离开作用域，引用计数减1
    }
    
    cout << "引用计数: " << ptr1.use_count() << endl;  // 1
    ptr1->doSomething();
    
    // 当ptr1离开作用域，引用计数为0时，对象自动销毁
}

// 演示weak_ptr解决循环引用
void weakPtrDemo() {
    cout << "\\n=== weak_ptr演示 ===" << endl;
    
    struct Node {
        string name;
        shared_ptr<Node> next;
        weak_ptr<Node> prev;  // 使用weak_ptr避免循环引用
        
        Node(const string& n) : name(n) {
            cout << "Node构造: " << name << endl;
        }
        
        ~Node() {
            cout << "Node析构: " << name << endl;
        }
    };
    
    // 创建双向链表节点
    shared_ptr<Node> node1 = make_shared<Node>("节点1");
    shared_ptr<Node> node2 = make_shared<Node>("节点2");
    
    // 建立连接
    node1->next = node2;
    node2->prev = node1;  // weak_ptr不增加引用计数
    
    cout << "node1引用计数: " << node1.use_count() << endl;  // 1
    cout << "node2引用计数: " << node2.use_count() << endl;  // 2（node1->next持有）
    
    // 检查weak_ptr是否有效
    if (auto sharedPrev = node2->prev.lock()) {
        cout << "通过weak_ptr访问: " << sharedPrev->name << endl;
    }
    
    // 节点自动释放，不会出现循环引用导致的内存泄漏
}

// 智能指针与STL容器
void smartPtrWithContainers() {
    cout << "\\n=== 智能指针与容器 ===" << endl;
    
    // vector存储unique_ptr（需要移动语义）
    vector<unique_ptr<MyClass>> objects;
    
    objects.push_back(make_unique<MyClass>("容器对象1"));
    objects.push_back(make_unique<MyClass>("容器对象2"));
    objects.emplace_back(new MyClass("容器对象3"));
    
    cout << "容器中有 " << objects.size() << " 个对象" << endl;
    
    // 遍历和访问
    for (const auto& obj : objects) {
        obj->doSomething();
    }
    
    // 容器析构时，所有unique_ptr会自动释放管理的对象
}

int main() {
    uniquePtrDemo();
    sharedPtrDemo();
    weakPtrDemo();
    smartPtrWithContainers();
    
    cout << "\\n=== 程序结束，所有资源自动释放 ===" << endl;
    return 0;
}
```

### 注意事项
- 优先使用`make_unique`和`make_shared`创建智能指针
- `unique_ptr`不支持拷贝，只能移动
- `shared_ptr`有引用计数开销
- `weak_ptr`需要先调用`lock()`转换为`shared_ptr`才能使用

## 3. 常见用法

### 场景1：工厂模式与智能指针
```cpp
#include <memory>
#include <iostream>

// 抽象产品类
class Product {
public:
    virtual ~Product() = default;
    virtual void use() = 0;
};

// 具体产品类
class ConcreteProductA : public Product {
public:
    void use() override {
        std::cout << "使用产品A" << std::endl;
    }
};

class ConcreteProductB : public Product {
public:
    void use() override {
        std::cout << "使用产品B" << std::endl;
    }
};

// 工厂类
class ProductFactory {
public:
    enum ProductType { TYPE_A, TYPE_B };
    
    static std::unique_ptr<Product> createProduct(ProductType type) {
        switch (type) {
            case TYPE_A:
                return std::make_unique<ConcreteProductA>();
            case TYPE_B:
                return std::make_unique<ConcreteProductB>();
            default:
                return nullptr;
        }
    }
};

// 使用工厂
void factoryDemo() {
    auto productA = ProductFactory::createProduct(ProductFactory::TYPE_A);
    auto productB = ProductFactory::createProduct(ProductFactory::TYPE_B);
    
    if (productA) productA->use();
    if (productB) productB->use();
    
    // 智能指针自动管理生命周期
}
```

### 场景2：资源管理类
```cpp
#include <memory>
#include <fstream>
#include <vector>

// 使用unique_ptr管理文件资源
class FileManager {
private:
    std::unique_ptr<std::fstream> file;
    
public:
    bool open(const std::string& filename) {
        file = std::make_unique<std::fstream>(filename, std::ios::in | std::ios::out);
        return file->is_open();
    }
    
    void write(const std::string& data) {
        if (file && file->is_open()) {
            *file << data << std::endl;
        }
    }
    
    // 不需要显式关闭文件，unique_ptr析构时会自动关闭
};

// 使用shared_ptr管理共享资源
class ResourcePool {
private:
    std::vector<std::shared_ptr<int>> resources;
    
public:
    std::shared_ptr<int> acquire() {
        auto resource = std::make_shared<int>(42);
        resources.push_back(resource);
        return resource;
    }
    
    void release(const std::shared_ptr<int>& resource) {
        // 从池中移除（简化实现）
        resources.erase(
            std::remove(resources.begin(), resources.end(), resource),
            resources.end()
        );
    }
    
    // 当ResourcePool销毁时，所有shared_ptr会自动释放
};
```

### 场景3：自定义删除器
```cpp
#include <memory>
#include <iostream>

// C风格资源
struct CFile {
    FILE* handle;
    
    CFile(const char* filename, const char* mode) {
        handle = fopen(filename, mode);
    }
    
    ~CFile() {
        if (handle) fclose(handle);
    }
};

// 自定义删除器
struct FileDeleter {
    void operator()(FILE* file) const {
        if (file) {
            fclose(file);
            std::cout << "文件已关闭（自定义删除器）" << std::endl;
        }
    }
};

// 数组删除器
struct ArrayDeleter {
    void operator()(int* arr) const {
        delete[] arr;
        std::cout << "数组已释放" << std::endl;
    }
};

void customDeleterDemo() {
    // 使用自定义删除器管理C风格文件
    std::unique_ptr<FILE, FileDeleter> file(fopen("test.txt", "w"));
    if (file) {
        fprintf(file.get(), "Hello, World!");
    }
    
    // 使用自定义删除器管理动态数组
    std::unique_ptr<int[], ArrayDeleter> arr(new int[10]);
    for (int i = 0; i < 10; i++) {
        arr[i] = i * i;
    }
    
    // 使用lambda表达式作为删除器
    auto lambdaDeleter = [](int* p) {
        delete p;
        std::cout << "Lambda删除器调用" << std::endl;
    };
    
    std::unique_ptr<int, decltype(lambdaDeleter)> ptr(new int(100), lambdaDeleter);
}
```

## 4. 易错点/坑

### 错误示例1：错误的所有权共享
```cpp
class BadDesign {
private:
    std::shared_ptr<BadDesign> self;  // 循环引用！
    
public:
    void setSelf() {
        self = std::shared_ptr<BadDesign>(this);  // 严重错误！
    }
    
    ~BadDesign() {
        std::cout << "BadDesign析构" << std::endl;
    }
};

void problematicUsage() {
    BadDesign* rawPtr = new BadDesign();
    rawPtr->setSelf();  // 创建多个控制块！
    
    // 内存泄漏：对象永远不会被释放
    // 因为self和外部指针创建了不同的控制块
}
```
**原因**：同一个对象被多个独立的shared_ptr管理
**修正方案**：
```cpp
class GoodDesign {
private:
    std::shared_ptr<GoodDesign> self;
    
public:
    static std::shared_ptr<GoodDesign> create() {
        // 使用工厂方法确保正确的shared_ptr管理
        auto ptr = std::shared_ptr<GoodDesign>(new GoodDesign());
        ptr->self = ptr;  // 正确的自引用
        return ptr;
    }
    
    ~GoodDesign() {
        std::cout << "GoodDesign正常析构" << std::endl;
    }
};
```

### 错误示例2：错误的unique_ptr使用
```cpp
void problematicUniquePtr() {
    std::unique_ptr<int> ptr1(new int(42));
    
    // std::unique_ptr<int> ptr2 = ptr1;  // 错误：不能拷贝
    
    // 正确的方式：转移所有权
    std::unique_ptr<int> ptr2 = std::move(ptr1);
    
    if (ptr1 == nullptr) {
        std::cout << "ptr1已失效" << std::endl;
    }
    
    // 访问已转移的指针
    // *ptr1 = 100;  // 未定义行为！
}
```
**原因**：unique_ptr不支持拷贝，只能移动
**修正方案**：
```cpp
void correctUniquePtrUsage() {
    auto ptr1 = std::make_unique<int>(42);
    
    // 转移所有权
    auto ptr2 = std::move(ptr1);
    
    // 检查指针有效性
    if (!ptr1) {
        std::cout << "ptr1已转移，使用ptr2" << std::endl;
        *ptr2 = 100;  // 安全访问
    }
}
```

### 错误示例3：悬空weak_ptr
```cpp
void danglingWeakPtr() {
    std::weak_ptr<int> weak;
    
    {
        auto shared = std::make_shared<int>(42);
        weak = shared;
        
        // shared离开作用域，对象被销毁
    }
    
    // weak指向的对象已销毁
    if (auto shared = weak.lock()) {
        // 这行代码不会执行
        *shared = 100;
    } else {
        std::cout << "weak_ptr已失效" << std::endl;
    }
}
```
**原因**：weak_ptr不保证对象的生命周期
**修正方案**：
```cpp
void safeWeakPtrUsage() {
    std::weak_ptr<int> weak;
    
    {
        auto shared = std::make_shared<int>(42);
        weak = shared;
        
        // 在使用前检查
        if (auto temp = weak.lock()) {
            *temp = 100;  // 安全使用
        }
    }
    
    // 对象已销毁，但这是预期的
    if (!weak.lock()) {
        std::cout << "对象已销毁，weak_ptr正确失效" << std::endl;
    }
}
```

## 5. 拓展补充

### 关联知识点
- **RAII模式**：资源管理的基本理念
- **移动语义**：unique_ptr所有权转移的基础
- **引用计数**：shared_ptr的实现机制
- **控制块**：shared_ptr管理的内存块

### 进阶延伸
- **enable_shared_from_this**：从this指针创建shared_ptr
- **allocate_shared**：自定义内存分配的shared_ptr
- **polymorphic_allocator**：C++17的多态分配器
- **out_ptr**：C++23的智能指针与C API互操作

# 模板特化与偏特化

## 1. 核心概念

### 定义
- **模板特化**：为特定类型提供特殊实现
- **偏特化**：为部分类型参数提供特殊实现
- **SFINAE**：替换失败不是错误的原则

### 关键特性
- **编译时多态**：根据类型选择不同实现
- **类型特定优化**：针对特定类型进行优化
- **条件编译**：根据类型特性启用/禁用代码

## 2. 语法规则

### 代码示例

```cpp
#include <iostream>
#include <type_traits>
#include <vector>
#include <string>
using namespace std;

// 通用模板版本
template<typename T>
class TypeTraits {
public:
    static const char* name() {
        return "unknown type";
    }
    
    static bool is_numeric() {
        return false;
    }
    
    static T zero() {
        return T();
    }
};

// 模板特化：为int类型
template<>
class TypeTraits<int> {
public:
    static const char* name() {
        return "int";
    }
    
    static bool is_numeric() {
        return true;
    }
    
    static int zero() {
        return 0;
    }
};

// 模板特化：为double类型
template<>
class TypeTraits<double> {
public:
    static const char* name() {
        return "double";
    }
    
    static bool is_numeric() {
        return true;
    }
    
    static double zero() {
        return 0.0;
    }
};

// 模板特化：为string类型
template<>
class TypeTraits<string> {
public:
    static const char* name() {
        return "string";
    }
    
    static bool is_numeric() {
        return false;
    }
    
    static string zero() {
        return "";
    }
};

// 偏特化：指针类型的通用特化
template<typename T>
class TypeTraits<T*> {
public:
    static const char* name() {
        return "pointer";
    }
    
    static bool is_numeric() {
        return false;
    }
    
    static T* zero() {
        return nullptr;
    }
};

// 函数模板特化示例
template<typename T>
void process(const T& value) {
    cout << "通用处理: " << value << endl;
}

// 函数模板特化：为string类型
template<>
void process<string>(const string& value) {
    cout << "字符串处理: '" << value << "' (长度: " << value.length() << ")" << endl;
}

// 函数模板特化：为vector类型
template<typename T>
void process<vector<T>>(const vector<T>& vec) {
    cout << "向量处理: [";
    for (size_t i = 0; i < vec.size(); i++) {
        cout << vec[i];
        if (i < vec.size() - 1) cout << ", ";
    }
    cout << "] (大小: " << vec.size() << ")" << endl;
}

// 使用SFINAE（替换失败不是错误）实现条件编译
template<typename T>
typename enable_if<is_arithmetic<T>::value, T>::type
safe_divide(T a, T b) {
    if (b == 0) throw invalid_argument("除数不能为零");
    return a / b;
}

template<typename T>
typename enable_if<!is_arithmetic<T>::value, T>::type
safe_divide(T a, T b) {
    throw invalid_argument("非算术类型不支持除法");
}

// 可变参数模板与完美转发
template<typename... Args>
void log_all(Args&&... args) {
    // 使用折叠表达式（C++17）
    (cout << ... << forward<Args>(args)) << endl;
}

template<typename T, typename... Rest>
void print_with_separator(const T& first, const Rest&... rest) {
    cout << first;
    // 递归展开参数包
    ((cout << ", " << rest), ...);
    cout << endl;
}

// 模板元编程：编译时计算
template<int N>
struct Fibonacci {
    static constexpr int value = Fibonacci<N-1>::value + Fibonacci<N-2>::value;
};

template<>
struct Fibonacci<0> {
    static constexpr int value = 0;
};

template<>
struct Fibonacci<1> {
    static constexpr int value = 1;
};

// 编译时字符串处理
template<char... Chars>
struct CharSequence {
    static constexpr char value[] = {Chars..., '\0'};
    static constexpr size_t size = sizeof...(Chars);
};

// 使用用户定义字面量创建编译时字符串
template<typename T, T... Chars>
constexpr CharSequence<Chars...> operator""_cs() {
    return {};
}

int main() {
    cout << "=== 模板特化演示 ===" << endl;
    
    // 类型特性测试
    cout << "int类型: " << TypeTraits<int>::name() 
         << ", 数值类型: " << (TypeTraits<int>::is_numeric() ? "是" : "否") 
         << ", 零值: " << TypeTraits<int>::zero() << endl;
    
    cout << "string类型: " << TypeTraits<string>::name() 
         << ", 数值类型: " << (TypeTraits<string>::is_numeric() ? "是" : "否") 
         << ", 零值: '" << TypeTraits<string>::zero() << "'" << endl;
    
    int* ptr = nullptr;
    cout << "int*类型: " << TypeTraits<decltype(ptr)>::name() << endl;
    
    // 函数模板特化测试
    process(42);
    process(3.14);
    process(string("Hello"));
    process(vector<int>{1, 2, 3, 4, 5});
    
    // SFINAE测试
    cout << "10 / 2 = " << safe_divide(10, 2) << endl;
    // cout << safe_divide(string("a"), string("b")) << endl;  // 编译错误
    
    // 可变参数模板测试
    log_all("日志", ": ", "值=", 42, ", 时间=", 3.14);
    print_with_separator(1, 2, 3, "a", "b", "c");
    
    // 模板元编程测试
    cout << "斐波那契数列:" << endl;
    cout << "F(0) = " << Fibonacci<0>::value << endl;
    cout << "F(1) = " << Fibonacci<1>::value << endl;
    cout << "F(5) = " << Fibonacci<5>::value << endl;
    cout << "F(10) = " << Fibonacci<10>::value << endl;
    
    // 编译时常量
    constexpr auto seq = "hello"_cs;
    cout << "编译时字符串: " << decltype(seq)::value 
         << " (长度: " << decltype(seq)::size << ")" << endl;
    
    return 0;
}
```

## 3. 常见用法

### 场景1：类型特性检测
```cpp
#include <type_traits>

// 使用std::is_arithmetic检测类型
template<typename T>
void numericOperation(T a, T b) {
    if constexpr (std::is_arithmetic_v<T>) {
        cout << "算术类型: " << a + b << endl;
    } else {
        cout << "非算术类型，不支持加法" << endl;
    }
}

// 使用std::is_same检测类型
template<typename T>
void typeCheck() {
    if (std::is_same_v<T, int>) {
        cout << "类型是int" << endl;
    } else if (std::is_same_v<T, double>) {
        cout << "类型是double" << endl;
    }
}
```

### 场景2：条件启用函数
```cpp
#include <enable_if>

// 使用SFINAE条件启用
template<typename T>
typename std::enable_if<std::is_integral<T>::value, T>::type
square(T n) {
    return n * n;
}

template<typename T>
typename std::enable_if<std::is_floating_point<T>::value, T>::type
square(T n) {
    return n * n;
}
```

## 4. 易错点/坑

### 错误示例1：函数模板特化歧义
```cpp
template<typename T>
void process(T a) {          // 主模板
    cout << "主模板" << endl;
}

template<>
void process<int>(int a) {  // int特化
    cout << "int特化" << endl;
}

// 偏特化（类模板支持，函数模板不支持）
// template<typename T>
// void process<T*>(T* a) { }  // 错误：函数模板不支持偏特化
```
**说明**：函数模板不支持偏特化，可以使用函数重载替代

### 错误示例2：SFINAE使用不当
```cpp
template<typename T>
typename T::type foo(T t) {  // 如果T没有type成员，编译失败
    return t.type();
}
```
**修正方案**：使用std::void_t或enable_if
```cpp
template<typename T, typename = void>
struct has_type : std::false_type {};

template<typename T>
struct has_type<T, std::void_t<typename T::type>> : std::true_type {};
```

## 5. 拓展补充

### 关联知识点
- **C++20概念**：更优雅的模板约束机制
- **类型推导**：模板参数推导规则
- **折叠表达式**：C++17的可变参数模板简化语法

### 进阶延伸
- **模板模板参数**：接受模板作为参数
- **变体模板**：std::variant类型联合
- **requires子句**：C++20的概念约束语法

# RAII与异常安全

## 1. 核心概念

### 定义
- **RAII**：资源获取即初始化（Resource Acquisition Is Initialization）
- **异常安全**：代码在异常发生时保持正确状态
- **栈展开**：异常传播过程中销毁局部对象的过程

### 关键特性
- **资源绑定生命周期**：资源管理与对象生命周期绑定
- **自动释放**：析构函数确保资源释放
- **异常保证级别**：基本保证、强保证、不抛异常保证

## 2. 语法规则

### 代码示例

```cpp
#include <iostream>
#include <fstream>
#include <memory>
#include <stdexcept>
using namespace std;

class FileHandler {
private:
    unique_ptr<fstream> file;
    
public:
    FileHandler(const string& filename) {
        file = make_unique<fstream>(filename);
        if (!file->is_open()) {
            throw runtime_error("无法打开文件: " + filename);
        }
    }
    
    // 自动关闭文件（RAII）
    ~FileHandler() = default;
    
    void write(const string& data) {
        *file << data;
        if (file->fail()) {
            throw runtime_error("写入文件失败");
        }
    }
};

// 使用RAII确保资源安全
void safeFileOperation() {
    FileHandler handler("data.txt"); // 资源自动管理
    handler.write("Hello, RAII!");
    // 文件自动关闭，即使抛出异常
}

// 异常安全保证示例
class ResourceManager {
    unique_ptr<int> resource;
public:
    // 基本保证：不泄漏资源
    void basicGuarantee(int value) {
        auto temp = make_unique<int>(value);
        
        // 可能抛出异常的操作
        if (value < 0) {
            throw invalid_argument("值不能为负数");
        }
        
        // 提交操作（无异常）
        resource = move(temp);
    }
    
    // 强保证：操作具有原子性
    void strongGuarantee(int value) {
        auto oldResource = move(resource);
        
        try {
            auto temp = make_unique<int>(value);
            
            if (value < 0) {
                throw invalid_argument("值不能为负数");
            }
            
            resource = move(temp);
        } catch (...) {
            // 回滚操作
            resource = move(oldResource);
            throw; // 重新抛出异常
        }
    }
    
    // 不抛出保证
    int noThrowGuarantee() noexcept {
        return resource ? *resource : 0;
    }
};

int main() {
    cout << "=== RAII与异常安全演示 ===" << endl;
    
    // RAII资源管理
    try {
        FileHandler handler("test.txt");
        handler.write("Hello World");
        cout << "文件操作成功" << endl;
    } catch (const exception& e) {
        cout << "异常: " << e.what() << endl;
    }
    
    // 异常安全保证
    ResourceManager mgr;
    try {
        mgr.basicGuarantee(10);
        cout << "基本保证: 操作成功" << endl;
    } catch (const exception& e) {
        cout << "异常: " << e.what() << endl;
    }
    
    return 0;
}
```

## 3. 常见用法

### 场景1：构造函数中的异常处理
```cpp
class Application {
private:
    unique_ptr<Database> db;
    
public:
    // 使用函数try块处理构造函数异常
    Application() try : db(make_unique<Database>()) {
        db->connect();
    } catch (const exception& e) {
        cerr << "应用初始化失败: " << e.what() << endl;
        throw; // 重新抛出
    }
};
```

### 场景2：析构函数中的异常处理
```cpp
class Resource {
    ~Resource() noexcept {
        try {
            // 清理资源
            closeConnection();
        } catch (...) {
            // 记录日志，但不抛出异常
            cerr << "析构函数中发生异常，已忽略" << endl;
        }
    }
};
```

### 场景3：智能指针管理资源
```cpp
void processData() {
    auto data = make_unique<vector<int>>();
    data->push_back(1);
    data->push_back(2);
    
    // 即使这里抛出异常，data也会自动释放
    if (data->size() > 10) {
        throw runtime_error("数据量过大");
    }
}
```

## 4. 易错点/坑

### 错误示例1：构造函数中抛出异常导致内存泄漏
```cpp
class BadResource {
    int* data;
public:
    BadResource() {
        data = new int[100];
        // 如果后续操作抛出异常，data会泄漏
        throw runtime_error("初始化失败");
    }
    
    ~BadResource() {
        delete[] data;
    }
};
```
**修正方案**：使用智能指针
```cpp
class GoodResource {
    unique_ptr<int[]> data;
public:
    GoodResource() : data(make_unique<int[]>(100)) {
        // 即使抛出异常，智能指针也会自动清理
    }
};
```

### 错误示例2：异常吞噬
```cpp
void dangerousFunction() {
    try {
        // 可能抛出异常的操作
        throw runtime_error("错误");
    } catch (...) {
        // 捕获异常但不处理
        cout << "发生异常" << endl;
        // 忘记记录或重新抛出
    }
}
```

### 错误示例3：析构函数中抛出异常
```cpp
class Dangerous {
    ~Dangerous() throw() {  // 旧式写法
        throw runtime_error("析构函数中抛出异常");
    }
};
```
**修正方案**：在析构函数中捕获所有异常
```cpp
class Safe {
    ~Safe() noexcept {
        try {
            // 可能抛出异常的操作
        } catch (...) {
            // 记录日志，但不抛出
        }
    }
};
```

## 5. 拓展补充

### 关联知识点
- **noexcept说明符**：声明函数不会抛出异常
- **栈展开过程**：异常传播时的对象销毁机制
- **异常规格**：C++98的异常规范机制（已弃用）

### 进阶延伸
- **异常安全等级**：基本保证、强保证、不抛异常保证
- **移动语义与异常**：移动操作通常声明为noexcept
- **协程异常**：C++20协程中的异常处理