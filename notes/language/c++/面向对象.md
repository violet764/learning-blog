# C++内存管理与面向对象

## 1. 数组与字符串

### 1.1 原生数组与std::array

**原生数组（C风格）：**
```cpp
// 静态数组声明
int numbers[5] = {1, 2, 3, 4, 5};  // 固定大小

// 访问元素
std::cout << numbers[0] << std::endl;  // 1
std::cout << numbers[4] << std::endl;  // 5

// 计算数组长度
int length = sizeof(numbers) / sizeof(numbers[0]);  // 5

// 遍历数组
for (int i = 0; i < length; i++) {
    std::cout << numbers[i] << " ";
}
std::cout << std::endl;
```

**std::array（C++11，推荐使用）：**
```cpp
#include <array>

std::array<int, 5> arr = {1, 2, 3, 4, 5};

// 更安全的访问方式
std::cout << arr.at(0) << std::endl;    // 边界检查
std::cout << arr.size() << std::endl;   // 5

// 范围for循环支持
for (int num : arr) {
    std::cout << num << " ";
}
std::cout << std::endl;
```

**对比Python的list：**
```python
# Python列表（动态数组）
numbers = [1, 2, 3, 4, 5]
print(numbers[0])      # 1
print(len(numbers))    # 5

# Python列表可以动态调整大小
numbers.append(6)      # 添加元素
numbers.pop()          # 移除元素
```

> **关键差异**：C++数组大小固定，Python列表动态调整；std::array提供类型安全和边界检查

### 1.2 C风格字符串 vs std::string

**C风格字符串：**
```cpp
#include <cstring>

char cstr1[] = "Hello";           // 自动添加'\0'
char cstr2[10] = "World";         // 指定大小

// 字符串操作
std::cout << strlen(cstr1) << std::endl;  // 5
strcpy(cstr2, "C++");                     // 复制字符串
strcat(cstr1, " World");                  // 连接字符串

// 危险操作（可能导致缓冲区溢出）
// strcpy(cstr2, "This string is too long!");  // 危险！
```

**std::string（推荐使用）：**
```cpp
#include <string>

std::string str1 = "Hello";
std::string str2("World");

// 安全的字符串操作
std::cout << str1.length() << std::endl;  // 5
str1 += " C++";                          // 安全连接
str1.append("!");                        // 添加内容

// 查找和子字符串
size_t pos = str1.find("C++");
if (pos != std::string::npos) {
    std::string sub = str1.substr(pos, 3);  // "C++"
}
```

**对比Python的str：**
```python
# Python字符串操作
s = "Hello"
print(len(s))           # 5
s += " World"          # 连接
print(s.find("World")) # 6
print(s[6:11])         # World
```

> **注意**：C++的std::string与Python的str在使用上非常相似，都是安全的字符串类型

### 1.3 多维数组的内存布局

**二维数组内存布局：**
```cpp
// 二维数组（连续内存块）
int matrix[3][3] = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};

// 内存布局：1,2,3,4,5,6,7,8,9（连续存储）
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        std::cout << &matrix[i][j] << " ";  // 打印地址
    }
    std::cout << std::endl;
}
```

**动态多维数组：**
```cpp
// 使用vector的vector（不连续内存）
std::vector<std::vector<int>> dynamic_matrix(3, std::vector<int>(3));

// 每个内层vector是独立的内存块
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        dynamic_matrix[i][j] = i * 3 + j + 1;
    }
}
```

## 2. 指针与引用

### 2.1 指针概念：内存地址的直接操作

**指针基础：**
```cpp
int number = 42;
int *ptr = &number;  // ptr指向number的地址

std::cout << "变量值: " << number << std::endl;      // 42
std::cout << "变量地址: " << &number << std::endl;   // 0x7ffe...
std::cout << "指针值: " << ptr << std::endl;         // 与&number相同
std::cout << "指针指向的值: " << *ptr << std::endl;  // 42

// 通过指针修改变量
*ptr = 100;
std::cout << "修改后: " << number << std::endl;      // 100
```

**指针与数组：**
```cpp
int arr[] = {10, 20, 30, 40, 50};
int *p = arr;  // 数组名就是首元素地址

// 通过指针访问数组
for (int i = 0; i < 5; i++) {
    std::cout << *(p + i) << " ";  // 10 20 30 40 50
}
std::cout << std::endl;

// 指针算术
p++;  // 指向下一个元素（地址增加sizeof(int)）
std::cout << *p << std::endl;  // 20
```

### 2.2 引用：安全的别名机制

**引用基础：**
```cpp
int original = 42;
int &ref = original;  // ref是original的引用（别名）

std::cout << "原始值: " << original << std::endl;  // 42
std::cout << "引用值: " << ref << std::endl;       // 42

// 通过引用修改
ref = 100;
std::cout << "修改后原始值: " << original << std::endl;  // 100

// 引用必须在声明时初始化
// int &invalid_ref;  // 错误！引用必须初始化
```

**引用作为函数参数：**
```cpp
void swap(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
}

int x = 5, y = 10;
swap(x, y);
std::cout << "x = " << x << ", y = " << y << std::endl;  // x=10, y=5
```

### 2.3 指针vs引用：使用场景与区别

**关键差异对比表：**

| 特性 | 指针 | 引用 |
|------|------|------|
| **语法** | `int *p = &var;` | `int &r = var;` |
| **重新赋值** | 可以指向不同变量 | 一旦绑定，不能更改 |
| **空值** | 可以是nullptr | 必须绑定到有效对象 |
| **多级间接** | 支持多级指针 | 只有一级引用 |
| **内存占用** | 存储地址（通常4/8字节） | 通常是优化掉的（无额外内存） |

**使用场景建议：**
- **指针**：需要重新指向、可选参数、动态内存管理
- **引用**：函数参数、返回值、避免拷贝大对象

### 2.4 智能指针简介（C++11）

**unique_ptr（独占所有权）：**
```cpp
#include <memory>

// 创建unique_ptr
std::unique_ptr<int> ptr1 = std::make_unique<int>(42);
std::unique_ptr<int[]> arr_ptr = std::make_unique<int[]>(5);

// 使用智能指针
std::cout << *ptr1 << std::endl;  // 42
arr_ptr[0] = 10;

// 所有权转移（不能复制）
std::unique_ptr<int> ptr2 = std::move(ptr1);  // ptr1变为nullptr
```

**shared_ptr（共享所有权）：**
```cpp
std::shared_ptr<int> shared1 = std::make_shared<int>(100);
std::shared_ptr<int> shared2 = shared1;  // 共享所有权

std::cout << "引用计数: " << shared1.use_count() << std::endl;  // 2
std::cout << *shared1 << std::endl;  // 100
std::cout << *shared2 << std::endl;  // 100
```

**对比Python的引用计数：**
```python
# Python使用引用计数自动管理内存
a = [1, 2, 3]  # 引用计数=1
b = a          # 引用计数=2
del a          # 引用计数=1
# 当引用计数为0时，内存自动回收
```

> **关键理解**：C++智能指针模拟了Python的自动内存管理，但提供了更精细的控制

## 3. 动态内存管理

### 3.1 new/delete操作符

**动态内存分配：**
```cpp
// 动态分配单个对象
int *dynamic_int = new int(42);
std::cout << *dynamic_int << std::endl;  // 42

// 动态分配数组
int *dynamic_array = new int[5];
for (int i = 0; i < 5; i++) {
    dynamic_array[i] = i * 10;
}

// 必须手动释放内存
delete dynamic_int;        // 释放单个对象
delete[] dynamic_array;    // 释放数组
```

**对比Python的自动垃圾回收：**
```python
# Python自动管理内存
a = [1, 2, 3]  # 自动分配
# 不需要手动释放，垃圾回收器自动处理
del a          # 只是减少引用计数
```

### 3.2 内存泄漏与悬空指针问题

**内存泄漏示例：**
```cpp
void memory_leak() {
    int *leak = new int(100);
    // 忘记delete，内存泄漏！
    // 应该: delete leak;
}
```

**悬空指针示例：**
```cpp
int *dangling_pointer() {
    int local_var = 50;
    return &local_var;  // 危险！返回局部变量的地址
}

int main() {
    int *ptr = dangling_pointer();
    // ptr指向已销毁的栈内存，行为未定义
    return 0;
}
```

### 3.3 RAII（资源获取即初始化）原则

**RAII示例：**
```cpp
#include <fstream>

// 文件资源自动管理
void read_file_raii(const std::string &filename) {
    std::ifstream file(filename);  // 获取资源
    
    if (file.is_open()) {
        std::string line;
        while (std::getline(file, line)) {
            std::cout << line << std::endl;
        }
        // 文件自动关闭（析构函数调用）
    }
}

// 对比非RAII方式（容易忘记关闭）
void read_file_manual(const std::string &filename) {
    FILE *file = fopen(filename.c_str(), "r");
    if (file) {
        // 读取文件...
        fclose(file);  // 必须手动关闭！
    }
}
```

> **RAII核心思想**：在构造函数中获取资源，在析构函数中释放资源

## 4. 面向对象编程

### 4.1 类与对象：封装性

**类定义示例：**
```cpp
class BankAccount {
private:    // 私有成员，外部不能直接访问
    std::string account_number;
    double balance;
    
public:     // 公有接口，外部可以访问
    // 构造函数
    BankAccount(const std::string &acc_num, double initial_balance)
        : account_number(acc_num), balance(initial_balance) {}
    
    // 成员函数
    void deposit(double amount) {
        if (amount > 0) {
            balance += amount;
        }
    }
    
    bool withdraw(double amount) {
        if (amount > 0 && amount <= balance) {
            balance -= amount;
            return true;
        }
        return false;
    }
    
    double get_balance() const {  // const成员函数，不修改对象状态
        return balance;
    }
};
```

**使用类：**
```cpp
BankAccount my_account("123456", 1000.0);
my_account.deposit(500.0);
my_account.withdraw(200.0);
std::cout << "余额: " << my_account.get_balance() << std::endl;
```

**对比Python的class：**
```python
class BankAccount:
    def __init__(self, acc_num, initial_balance):
        self.account_number = acc_num
        self.balance = initial_balance
    
    def deposit(self, amount):
        if amount > 0:
            self.balance += amount
    
    def withdraw(self, amount):
        if 0 < amount <= self.balance:
            self.balance -= amount
            return True
        return False
```

### 4.2 构造函数与析构函数

**构造函数类型：**
```cpp
class Person {
private:
    std::string name;
    int age;
    
public:
    // 默认构造函数
    Person() : name("Unknown"), age(0) {}
    
    // 参数化构造函数
    Person(const std::string &n, int a) : name(n), age(a) {}
    
    // 拷贝构造函数
    Person(const Person &other) : name(other.name), age(other.age) {}
    
    // 析构函数
    ~Person() {
        std::cout << name << "对象被销毁" << std::endl;
    }
    
    void display() const {
        std::cout << "姓名: " << name << ", 年龄: " << age << std::endl;
    }
};
```

**对比Python的__init__和__del__：**
```python
class Person:
    def __init__(self, name="Unknown", age=0):
        self.name = name
        self.age = age
    
    def __del__(self):
        print(f"{self.name}对象被销毁")
```

### 4.3 继承与多态

**继承示例：**
```cpp
// 基类
class Shape {
protected:
    std::string color;
    
public:
    Shape(const std::string &c) : color(c) {}
    
    // 虚函数（支持多态）
    virtual double area() const = 0;  // 纯虚函数，抽象类
    
    virtual void display() const {
        std::cout << "形状颜色: " << color << std::endl;
    }
    
    // 虚析构函数（重要！）
    virtual ~Shape() {}
};

// 派生类
class Circle : public Shape {
private:
    double radius;
    
public:
    Circle(const std::string &c, double r) : Shape(c), radius(r) {}
    
    // 重写虚函数
    double area() const override {
        return 3.14159 * radius * radius;
    }
    
    void display() const override {
        Shape::display();  // 调用基类方法
        std::cout << "圆形半径: " << radius << std::endl;
    }
};

class Rectangle : public Shape {
private:
    double width, height;
    
public:
    Rectangle(const std::string &c, double w, double h) 
        : Shape(c), width(w), height(h) {}
    
    double area() const override {
        return width * height;
    }
    
    void display() const override {
        Shape::display();
        std::cout << "矩形宽高: " << width << " × " << height << std::endl;
    }
};
```

**多态使用：**
```cpp
// 多态示例
void print_area(const Shape &shape) {
    std::cout << "面积: " << shape.area() << std::endl;
}

int main() {
    Circle circle("红色", 5.0);
    Rectangle rectangle("蓝色", 4.0, 6.0);
    
    // 多态调用
    print_area(circle);     // 调用Circle::area()
    print_area(rectangle);  // 调用Rectangle::area()
    
    // 通过基类指针/引用调用
    Shape *shapes[] = {&circle, &rectangle};
    for (Shape *shape : shapes) {
        shape->display();  // 动态绑定到具体类型的display()
    }
    
    return 0;
}
```

### 4.4 访问控制与静态成员

**访问控制：**
```cpp
class AccessExample {
private:    // 仅类内部可访问
    int private_var;
    
protected:  // 类内部和派生类可访问
    int protected_var;
    
public:     // 任何地方都可访问
    int public_var;
    
    void set_private(int value) {
        private_var = value;  // 类内部可以访问private
    }
};

class Derived : public AccessExample {
public:
    void access_members() {
        // public_var = 10;     // 可以访问
        // protected_var = 20;  // 可以访问（派生类）
        // private_var = 30;    // 错误！不能访问基类private
    }
};
```

**静态成员：**
```cpp
class Counter {
private:
    static int count;  // 静态成员变量（类级别）
    int id;
    
public:
    Counter() {
        id = ++count;  // 每个对象有唯一ID
    }
    
    // 静态成员函数（只能访问静态成员）
    static int get_count() {
        return count;
    }
    
    int get_id() const {
        return id;
    }
};

// 静态成员变量定义（必须在类外定义）
int Counter::count = 0;

// 使用静态成员
Counter c1, c2, c3;
std::cout << "对象数量: " << Counter::get_count() << std::endl;  // 3
std::cout << "c2的ID: " << c2.get_id() << std::endl;           // 2
```

**const成员函数：**
```cpp
class ConstExample {
private:
    mutable int cache;  // mutable可以在const函数中修改
    int value;
    
public:
    // const成员函数：承诺不修改对象状态
    int get_value() const {
        // value = 10;  // 错误！const函数不能修改非mutable成员
        cache++;        // 可以修改mutable成员
        return value;
    }
    
    // 非const成员函数
    void set_value(int v) {
        value = v;
    }
};
```

---

**本章总结：**
- C++的内存管理需要手动控制，但智能指针提供了自动管理选项
- 指针和引用是C++的核心概念，理解它们的区别至关重要
- RAII原则是C++资源管理的核心思想
- 面向对象特性（封装、继承、多态）提供了强大的抽象能力
- 访问控制和const正确性保证了代码的安全性和稳定性

下一章将探讨C++的高级特性和实战应用。