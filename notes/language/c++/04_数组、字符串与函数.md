# 与函数


## 4. 函数基础

### 函数声明与定义

**函数基本结构：**
```cpp
// 函数定义形式一般如下
return_type function_name( parameter list )
{
   body of the function
}

// 函数声明（通常在头文件中）
int add(int a, int b);

// 函数定义
int add(int a, int b) {
    return a + b;
}

```

**函数声明与定义分离：**

`ifndef` 是 "`if not defined`" 的缩写，意为「检查某个宏是否未被定义」。这里检查 `MATH_UTILS_H` 这个宏是否从未被编译器定义过，若未定义，则执行后续代码（直到 `#endif`）；若已定义，则直接跳过后续代码（直到 `#endif`）。

```cpp
// math_utils.h（头文件）
#ifndef MATH_UTILS_H
#define MATH_UTILS_H

int multiply(int x, int y);
double power(double base, int exponent);

#endif

// math_utils.cpp（源文件）
#include "math_utils.h"

int multiply(int x, int y) {
    return x * y;
}

double power(double base, int exponent) {
    double result = 1.0;
    for (int i = 0; i < exponent; i++) {
        result *= base;
    }
    return result;
}
```

### 参数传递机制

**值传递（默认）：内存拷贝机制**

**底层原理：** 值传递会在函数调用时创建参数的完整副本。对于基本类型（如`int`、`double`），这通常很高效；但对于大型对象（如`std::vector`、自定义类），会产生不必要的内存拷贝开销。

```cpp
// 值传递：创建参数的完整副本
void modifyValue(int x) {  // x是a的副本，占用独立内存空间
    x = 100;  // 只修改副本，不影响原变量
    // 函数结束时，x的副本被销毁
}

int main() {
    int a = 10;           // a在栈上分配内存
    modifyValue(a);       // 调用时：将a的值拷贝给x
    cout << a << endl;  // 输出: 10（原值未改变）
    return 0;
}

// 大型对象的值传递（可能产生性能问题）
void processVector(vector<int> vec) {  // 拷贝整个vector
    // 处理vector...
}  // 函数结束时，vec的副本被销毁（可能触发析构函数）
```

**引用传递：别名机制与性能优化**

**底层原理：** 引用本质上是变量的别名，不占用额外内存空间。编译器在内部将引用实现为指针，但语法上更安全，避免了空指针和野指针问题。引用传递避免了不必要的拷贝，是C++中高效传递大型对象的首选方式。

语法：
```cpp
返回值类型 函数名(参数列表) {
    // 函数体：执行逻辑
    [return 返回值;] // 非void类型必须返回对应类型值
}
```

示例：
```cpp
// 引用传递：创建变量的别名（不拷贝数据）
void modifyReference(int &x) {  // x是a的引用（别名）
    x = 100;  // 通过引用直接修改原变量
    // x和a实际上是同一块内存的两个名称
}

int main() {
    int a = 10;
    modifyReference(a);       // 传递a的引用，无数据拷贝
    cout << a << endl;  // 输出: 100（原值被修改）
    return 0;
}

// 常量引用：只读访问，避免拷贝（最佳实践）
void readOnly(const vector<int> &vec) {  // 不拷贝，只读访问
    // 可以读取vec的内容，但不能修改
    cout << "Size: " << vec.size() << endl;
}

// 右值引用（C++11）：移动语义，避免不必要的拷贝
void takeOwnership(vector<int> &&vec) {  // 接收即将销毁的对象
    // 可以"窃取"vec的资源，避免拷贝
}
```

**指针传递：**
```cpp
void modifyPointer(int *x) {
    *x = 100;  // 通过指针修改原变量
}

int main() {
    int a = 10;
    modifyPointer(&a);
    cout << a << endl;  // 输出: 100
    return 0;
}
```

> **注意**：Python中所有参数传递都是"对象引用传递"，与C++的引用传递概念不同

**三种参数传递方式的对比分析：**

```cpp
#include <iostream>
#include <string>
using namespace std;

// 1. 值传递：创建实参的完整副本
void incrementByValue(int num) {
    num++;  // 只修改副本，不影响原变量
    cout << "函数内（值传递）：" << num << endl;
}

// 2. 引用传递：传递实参的别名
void incrementByReference(int &num) {
    num++;  // 直接修改原变量
    cout << "函数内（引用传递）：" << num << endl;
}

// 3. 指针传递：传递实参的地址
void incrementByPointer(int *num) {
    (*num)++;  // 通过指针修改原变量
    cout << "函数内（指针传递）：" << *num << endl;
}

// 复杂对象的值传递（性能问题演示）
void processLargeObject(string str) {
    cout << "处理字符串（值传递）：" << str << endl;
    // 这里会创建str的完整副本，对于大型字符串可能影响性能
}

// 复杂对象的常量引用传递（最佳实践）
void processLargeObjectEfficiently(const string &str) {
    cout << "处理字符串（引用传递）：" << str << endl;
    // 不创建副本，只读访问，性能最佳
}

int main() {
    int x = 10;
    
    cout << "初始值：" << x << endl;
    
    // 值传递演示
    incrementByValue(x);
    cout << "值传递后：" << x << endl;  // 仍然是10
    
    // 引用传递演示
    incrementByReference(x);
    cout << "引用传递后：" << x << endl;  // 变为11
    
    // 指针传递演示
    incrementByPointer(&x);
    cout << "指针传递后：" << x << endl;  // 变为12
    
    // 大型对象处理演示
    string largeString = "这是一个很长的字符串，用于演示不同传递方式的性能差异...";
    
    processLargeObject(largeString);           // 会产生内存拷贝
    processLargeObjectEfficiently(largeString); // 无拷贝，性能更好
    
    return 0;
}
```

**参数传递机制总结：**

| 传递方式 | 内存开销 | 是否修改原变量 | 适用场景 |
|----------|----------|----------------|----------|
| **值传递** | 创建完整副本 | 否 | 基本类型、小型对象、不需要修改原变量时 |
| **引用传递** | 仅传递别名 | 是 | 需要修改原变量、大型对象 |
| **常量引用** | 仅传递别名 | 否 | 只读访问大型对象，性能最佳 |
| **指针传递** | 传递地址值 | 是 | 需要修改原变量，C风格兼容 |

### 函数重载

**设计原理：** 函数重载是 C++ 特性，指同一作用域内同名、参数列表不同的函数，编译器自动匹配调用。根据参数个数、参数类型、参数顺序（类型不同时）来进行函数重载，返回值不参与区分。

```cpp
// 重载解析示例：编译器如何选择
void process(int x) { cout << "process(int): " << x << endl; }
void process(double x) { cout << "process(double): " << x << endl; }
void process(const string& x) { cout << "process(string): " << x << endl; }

// 调用时的重载解析
process(10);        // 精确匹配：process(int)
process(10.5);      // 精确匹配：process(double)  
process(10);        // 标准转换：int→double，但精确匹配优先
process("hello");   // 需要转换：const char*→string，用户定义转换
```

**默认参数与重载的交互：**
```cpp
// 计算矩形面积，默认宽度为1
int calculateArea(int length, int width = 1) {
    return length * width;
}

// 打印消息，默认次数为1
void printMessage(string message, int times = 1) {
    for (int i = 0; i < times; i++) {
        cout << message << endl;
    }
}

int main() {
    cout << "面积1：" << calculateArea(5) << endl;      // 使用默认宽度
    cout << "面积2：" << calculateArea(5, 3) << endl;    // 指定宽度
    
    printMessage("Hello");     // 使用默认次数
    printMessage("World", 3);  // 指定次数
    
    return 0;
}
```

**默认参数规则：**
- 默认参数必须从右向左定义
- 默认参数在函数声明中指定
- 调用时可以省略有默认值的参数

```cpp
// 同名函数，不同参数列表（函数签名不同）
int add(int a, int b) {           // 版本1：整数加法
    return a + b;
}

double add(double a, double b) {   // 版本2：浮点数加法
    return a + b;
}

string add(const string &a, const string &b) {  // 版本3：字符串连接
    return a + b;
}

// 重载解析过程：编译器根据实参类型选择最合适的版本
cout << add(5, 3) << endl;               // 调用版本1：int add(int, int)
cout << add(2.5, 3.7) << endl;           // 调用版本2：double add(double, double)
cout << add("Hello", " World") << endl;  // 调用版本3：string add(const string&, const string&)

// 类型转换与重载解析
cout << add(5, 3.14) << endl;  // 可能产生歧义：int+double
// 编译器需要决定：将5转换为double，还是将3.14转换为int

// 重载规则：返回值类型不同不能构成重载
// int process();        // ✅
// double process();     // ❌ 错误：仅返回值不同

// 默认参数与重载的交互
void print(int a, int b = 10);     // 版本A
void print(int a);                 // 版本B

print(5);  // 歧义：可以调用版本A（使用默认参数）或版本B
```

**函数重载的重要规则：**
1. **参数类型或数量不同**：函数名相同，但参数列表必须不同
2. **返回值类型不能作为重载依据**
3. **const成员函数与非const成员函数可以重载**
4. **默认参数可能引起重载歧义**

### 内联函数

内联函数是一种编译器优化手段，核心目的是消除函数调用的开销，提升程序运行效率，同时保留函数封装的优点。**本质是**编译器在编译阶段，将内联函数的函数体代码，直接 "嵌入"（替换）到每一处函数调用的位置，而不是像普通函数那样进行跳转到函数地址的调用操作。

**内联函数：**
```cpp
// 建议编译器将函数体直接插入调用处
inline int square(int x) {
    return x * x;
}

// 使用内联函数（可能被优化为直接计算）
int result = square(5);  // 可能被优化为: int result = 5 * 5;
```

**constexpr函数：**
```cpp
// 编译时可计算的函数
constexpr int factorial(int n) {
    return (n <= 1) ? 1 : n * factorial(n - 1);
}

// 编译时计算
constexpr int fact_5 = factorial(5);  // 在编译时计算出120
```

**函数优化技术总结：**

1. **内联函数**：减少函数调用开销，适合小型、频繁调用的函数
2. **constexpr函数**：编译时计算，提高运行时性能
3. **编译器优化**：现代编译器会自动进行内联优化

### 递归函数

**设计原理：** 递归是一种将复杂问题分解为相似子问题的编程技术，通过函数自我调用来实现。递归包含两个关键要素：递归终止条件和递归步骤。

**阶乘计算：基础递归示例**
```cpp
#include <iostream>
#include <chrono>
using namespace std;
using namespace std::chrono;

// 递归计算阶乘
int factorial(int n) {
    if (n == 0) {
        return 1;  // 递归基
    }
    return n * factorial(n - 1);  // 递归步骤
}

// 迭代计算阶乘（性能对比）
int factorial_iterative(int n) {
    int result = 1;
    for (int i = 1; i <= n; i++) {
        result *= i;
    }
    return result;
}

void performance_comparison() {
    const int n = 20;
    const int iterations = 1000000;
    
    // 递归版本性能测试
    auto start = high_resolution_clock::now();
    int recursive_result = 0;
    for (int i = 0; i < iterations; i++) {
        recursive_result += factorial(n);
    }
    auto recursive_time = duration_cast<microseconds>(high_resolution_clock::now() - start);
    
    // 迭代版本性能测试
    start = high_resolution_clock::now();
    int iterative_result = 0;
    for (int i = 0; i < iterations; i++) {
        iterative_result += factorial_iterative(n);
    }
    auto iterative_time = duration_cast<microseconds>(high_resolution_clock::now() - start);
    
    cout << "递归版本耗时：" << recursive_time.count() << "微秒" << endl;
    cout << "迭代版本耗时：" << iterative_time.count() << "微秒" << endl;
    cout << "性能差异：" << (recursive_time.count() - iterative_time.count()) * 100.0 / iterative_time.count() << "%" << endl;
}

int main() {
    cout << "5! = " << factorial(5) << endl;
    performance_comparison();
    return 0;
}
```

**递归过程分析：**
```
factorial(5)
= 5 × factorial(4)
= 5 × 4 × factorial(3)
= 5 × 4 × 3 × factorial(2)
= 5 × 4 × 3 × 2 × factorial(1)
= 5 × 4 × 3 × 2 × 1 × factorial(0)
= 5 × 4 × 3 × 2 × 1 × 1
= 120
```

## 5. 易错点/坑

### 错误示例1：数组越界
```cpp
int arr[5] = {1, 2, 3, 4, 5};
cout << arr[5] << endl;  // 越界访问！
```
**原因**：数组下标从0到4，arr[5]访问了无效内存
**修正方案**：
```cpp
int arr[5] = {1, 2, 3, 4, 5};
for (int i = 0; i < 5; i++) {  // 确保下标在有效范围内
    cout << arr[i] << " ";
}
```

### 错误示例2：字符串未正确终止
```cpp
char str[5] = {'H', 'e', 'l', 'l', 'o'};  // 没有空间放'\0'
cout << str << endl;  // 可能输出乱码
```
**原因**：C风格字符串必须以'\0'结尾
**修正方案**：
```cpp
char str[6] = {'H', 'e', 'l', 'l', 'o', '\0'};
// 或者更简单的方式
char str2[] = "Hello";  // 编译器自动添加'\0'
cout << str2 << endl;
```

### 错误示例3：字符串比较错误
```cpp
char str1[] = "hello";
char str2[] = "hello";
if (str1 == str2) {  // 比较的是地址，不是内容
    cout << "相等" << endl;
} else {
    cout << "不相等" << endl;  // 总是输出这个
}
```
**原因**：数组名是地址，直接比较的是内存地址
**修正方案**：
```cpp
char str1[] = "hello";
char str2[] = "hello";
// 使用strcmp函数比较内容
if (strcmp(str1, str2) == 0) {
    cout << "相等" << endl;
}

// 或者使用C++字符串
string s1 = "hello";
string s2 = "hello";
if (s1 == s2) {  // string类重载了==运算符
    cout << "相等" << endl;
}
```

### 错误示例4：参数传递误解
```cpp
void swap(int a, int b) {  // 值传递
    int temp = a;
    a = b;
    b = temp;
}

int main() {
    int x = 5, y = 10;
    swap(x, y);
    cout << "x=" << x << ", y=" << y << endl;  // 仍然是5,10
    return 0;
}
```
**原因**：值传递只传递副本，不改变原变量
**修正方案**：
```cpp
// 使用引用传递
void swap(int &a, int &b) {  // 引用传递
    int temp = a;
    a = b;
    b = temp;
}

int main() {
    int x = 5, y = 10;
    swap(x, y);
    cout << "x=" << x << ", y=" << y << endl;  // 10,5
    return 0;
}
```

### 错误示例5：无限递归
```cpp
int badRecursion(int n) {
    return n + badRecursion(n - 1);  // 没有终止条件！
}
```
**原因**：递归函数缺少基本情况（终止条件）
**修正方案**：
```cpp
int goodRecursion(int n) {
    if (n <= 0) {  // 添加终止条件
        return 0;
    }
    return n + goodRecursion(n - 1);
}
```

## 6. 拓展补充

### 关联知识点
- **指针**：数组名本质是指向第一个元素的指针
- **动态数组**：使用new和delete的动态内存分配
- **向量(vector)**：C++标准库的动态数组容器
- **字符编码**：ASCII、UTF-8等字符表示方式
- **作用域**：局部变量、全局变量、静态变量
- **存储类别**：auto、register、static、extern
- **函数指针**：指向函数的指针变量

### 进阶延伸
- **std::array**：C++11引入的现代固定大小数组
- **std::vector**：动态大小的数组容器
- **字符串流**：使用stringstream进行字符串处理
- **正则表达式**：C++11引入的复杂模式匹配
- **函数模板**：泛型编程的基础
- **lambda表达式**：C++11引入的匿名函数
- **std::function**：通用的函数包装器
- **函数式编程**：C++中的函数式编程特性

## 7. 总结

本章详细介绍了C++中的数组、字符串和函数三个核心概念。通过本章学习，你应该能够：

**数组方面：**
- 理解数组的内存布局和连续存储特性
- 掌握C风格数组和`std::array`的使用
- 了解多维数组的内存组织方式
- 避免数组越界等常见错误

**字符串方面：**
- 区分C风格字符串和`std::string`的差异
- 掌握字符串的各种操作（连接、查找、替换等）
- 理解字符串的内存管理机制
- 使用现代C++字符串特性

**函数方面：**
- 理解三种参数传递机制及其适用场景
- 掌握函数重载和默认参数的使用
- 了解内联函数和递归函数的实现原理
- 避免常见的函数使用错误

这些基础知识是编写高效、安全C++程序的基础，为后续学习面向对象编程、模板编程等高级特性打下坚实基础。