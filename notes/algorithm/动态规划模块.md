# 动态规划模块

**前置知识**：数据结构基础总览、基础数据结构、递归思想

**后续关联模块**：字符串算法模块

## 📌 核心定义

动态规划（Dynamic Programming，DP）是通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。它将问题的解存储起来，避免重复计算，是算法竞赛中的重要思想。

## 🔑 DP基本要素

### 状态定义
DP的核心是状态定义，好的状态定义应该满足：
- **无后效性**：未来状态只与当前状态有关，与到达方式无关
- **最优子结构**：整体最优可以由子问题最优构成

### 状态转移
从已知状态推导未知状态的过程，通常有递推式表示：
$$dp[i] = f(dp[j], dp[k], ...)$$

### 边界条件
DP的初始状态，通常是最小子问题的解。

---

## 🎒 背包DP

### 0-1背包

#### 📌 问题描述
有n个物品，每个物品重量为w[i]，价值为v[i]，背包容量为W，求能装入的最大价值。

#### 🔧 状态定义
`dp[i][j]`：前i个物品中，容量为j时的最大价值

#### 💻 状态转移
```cpp
// 二维数组实现
for (int i = 1; i <= n; i++) {
    for (int j = 0; j <= W; j++) {
        if (j >= w[i]) {
            dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i]);
        } else {
            dp[i][j] = dp[i-1][j];
        }
    }
}

// 一维数组优化（倒序遍历）
for (int i = 1; i <= n; i++) {
    for (int j = W; j >= w[i]; j--) {
        dp[j] = max(dp[j], dp[j-w[i]] + v[i]);
    }
}

# Python实现
# 二维数组
dp = [[0] * (W + 1) for _ in range(n + 1)]
for i in range(1, n + 1):
    for j in range(W + 1):
        if j >= w[i]:
            dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])
        else:
            dp[i][j] = dp[i-1][j]

# 一维数组优化
dp = [0] * (W + 1)
for i in range(1, n + 1):
    for j in range(W, w[i] - 1, -1):
        dp[j] = max(dp[j], dp[j-w[i]] + v[i])
```

#### ⏱️ 复杂度分析
- 时间复杂度：O(nW)
- 空间复杂度：O(W)（一维优化后）

---

### 完全背包

#### 📌 问题描述
物品有无限多个，其他条件同0-1背包。

#### 🔧 状态转移
```cpp
// 正序遍历（关键区别）
for (int i = 1; i <= n; i++) {
    for (int j = w[i]; j <= W; j++) {
        dp[j] = max(dp[j], dp[j-w[i]] + v[i]);
    }
}

# Python实现
dp = [0] * (W + 1)
for i in range(1, n + 1):
    for j in range(w[i], W + 1):  # 正序遍历
        dp[j] = max(dp[j], dp[j-w[i]] + v[i])
```

---

### 多重背包

#### 📌 问题描述
每个物品有数量限制，第i个物品最多有cnt[i]个。

#### 🔧 朴素实现
```cpp
for (int i = 1; i <= n; i++) {
    for (int weight = W; weight >= w[i]; weight--) {
        for (int k = 1; k * w[i] <= weight && k <= cnt[i]; k++) {
            dp[weight] = max(dp[weight], dp[weight - k * w[i]] + k * v[i]);
        }
    }
}
```

#### 💡 二进制分组优化
```cpp
// 将多重背包转化为多个0-1背包
struct Item {
    int weight, value;
};

vector<Item> items;

for (int i = 1; i <= n; i++) {
    int c = 1, p = w[i], h = v[i], k = cnt[i];
    while (k > 0) {
        int use = min(c, k);
        items.push_back({use * p, use * h});
        k -= use;
        c *= 2;
    }
}

// 转化为0-1背包
for (auto& item : items) {
    for (int j = W; j >= item.weight; j--) {
        dp[j] = max(dp[j], dp[j - item.weight] + item.value);
    }
}

# Python实现
items = []
for i in range(1, n + 1):
    c, p, h, k = 1, w[i], v[i], cnt[i]
    while k > 0:
        use = min(c, k)
        items.append((use * p, use * h))
        k -= use
        c *= 2

# 转化为0-1背包
dp = [0] * (W + 1)
for weight, value in items:
    for j in range(W, weight - 1, -1):
        dp[j] = max(dp[j], dp[j - weight] + value)
```

---

### 混合背包

#### 📌 问题描述
包含0-1、完全、多重背包的混合问题。

#### 💻 实现代码
```cpp
for (int i = 1; i <= n; i++) {
    if (cnt[i] == 0) {  // 完全背包
        for (int weight = w[i]; weight <= W; weight++) {
            dp[weight] = max(dp[weight], dp[weight - w[i]] + v[i]);
        }
    } else {  // 多重背包（包括0-1背包）
        for (int weight = W; weight >= w[i]; weight--) {
            for (int k = 1; k * w[i] <= weight && k <= cnt[i]; k++) {
                dp[weight] = max(dp[weight], dp[weight - k * w[i]] + k * v[i]);
            }
        }
    }
}
```

---

### 二维费用背包

#### 📌 问题描述
物品有两种消耗（如重量和时间），求在两种限制下的最大价值。

#### 💻 状态转移
```cpp
// dp[weight][time]：重量限制为weight，时间限制为time时的最大价值
for (int k = 1; k <= n; k++) {
    for (int i = m; i >= w[k]; i--) {
        for (int j = t; j >= time[k]; j--) {
            dp[i][j] = max(dp[i][j], dp[i - w[k]][j - time[k]] + v[k]);
        }
    }
}

# Python实现
dp = [[0] * (t + 1) for _ in range(m + 1)]
for k in range(1, n + 1):
    for i in range(m, w[k] - 1, -1):
        for j in range(t, time[k] - 1, -1):
            dp[i][j] = max(dp[i][j], dp[i - w[k]][j - time[k]] + v[k])
```

---

### 分组背包

#### 📌 问题描述
物品分为若干组，每组最多选择一个物品。

#### 💻 状态转移
```cpp
// group[i][j]：第i组第j个物品的信息
for (int k = 1; k <= groupCount; k++) {
    for (int capacity = W; capacity >= 0; capacity--) {
        for (int item = 1; item <= itemCount[k]; item++) {
            if (capacity >= weight[k][item]) {
                dp[capacity] = max(dp[capacity], 
                                 dp[capacity - weight[k][item]] + value[k][item]);
            }
        }
    }
}

# Python实现
dp = [0] * (W + 1)
for k in range(1, group_count + 1):
    for capacity in range(W, -1, -1):
        for item in range(1, item_count[k] + 1):
            if capacity >= weight[k][item]:
                dp[capacity] = max(dp[capacity], 
                                 dp[capacity - weight[k][item]] + value[k][item])
```

---

## 📐 区间DP

### 📌 基本思想
区间DP是指状态表示为区间[l, r]的DP，通常通过枚举区间端点和分割点来转移状态。

### 💻 基本模板
```cpp
// 区间长度递增
for (int len = 1; len <= n; len++) {
    for (int l = 1; l + len - 1 <= n; l++) {
        int r = l + len - 1;
        for (int k = l; k < r; k++) {
            dp[l][r] = max(dp[l][r], dp[l][k] + dp[k+1][r] + cost(l, r, k));
        }
    }
}

# Python实现
for length in range(1, n + 1):
    for l in range(1, n - length + 2):
        r = l + length - 1
        for k in range(l, r):
            dp[l][r] = max(dp[l][r], dp[l][k] + dp[k+1][r] + cost(l, r, k))
```

---

### 石子合并问题

#### 📌 问题描述
一排石子，每次只能合并相邻的两堆，求合并成一堆的最小代价。

#### 💻 状态转移
```cpp
// dp[l][r]：合并[l, r]区间的最小代价
int dp[N][N], sum[N][N];

for (int len = 2; len <= n; len++) {
    for (int l = 1; l + len - 1 <= n; l++) {
        int r = l + len - 1;
        dp[l][r] = INT_MAX;
        for (int k = l; k < r; k++) {
            dp[l][r] = min(dp[l][r], dp[l][k] + dp[k+1][r] + sum[l][r]);
        }
    }
}

# Python实现
dp = [[0] * (n + 1) for _ in range(n + 1)]
sum_prefix = [0] * (n + 1)

# 计算前缀和
for i in range(1, n + 1):
    sum_prefix[i] = sum_prefix[i-1] + stones[i]

for length in range(2, n + 1):
    for l in range(1, n - length + 2):
        r = l + length - 1
        dp[l][r] = float('inf')
        total = sum_prefix[r] - sum_prefix[l-1]
        for k in range(l, r):
            dp[l][r] = min(dp[l][r], dp[l][k] + dp[k+1][r] + total)
```

---

### 回文串分割问题

#### 📌 问题描述
将字符串分割成回文串，求最少分割次数。

#### 💻 状态转移
```cpp
// isPalindrome[l][r]：判断[l, r]是否为回文串
// dp[i]：前i个字符的最少分割次数

// 预处理回文信息
for (int len = 1; len <= n; len++) {
    for (int l = 1; l + len - 1 <= n; l++) {
        int r = l + len - 1;
        if (s[l] == s[r] && (r - l <= 2 || isPalindrome[l+1][r-1])) {
            isPalindrome[l][r] = true;
        }
    }
}

// DP计算最少分割
for (int i = 1; i <= n; i++) {
    if (isPalindrome[1][i]) {
        dp[i] = 0;
    } else {
        for (int j = 1; j < i; j++) {
            if (isPalindrome[j+1][i]) {
                dp[i] = min(dp[i], dp[j] + 1);
            }
        }
    }
}

# Python实现
def min_palindrome_cuts(s):
    n = len(s)
    is_pal = [[False] * n for _ in range(n)]
    
    # 预处理回文信息
    for length in range(1, n + 1):
        for l in range(n - length + 1):
            r = l + length - 1
            if s[l] == s[r] and (length <= 2 or is_pal[l+1][r-1]):
                is_pal[l][r] = True
    
    # DP计算最少分割
    dp = [float('inf')] * n
    for i in range(n):
        if is_pal[0][i]:
            dp[i] = 0
        else:
            for j in range(i):
                if is_pal[j+1][i]:
                    dp[i] = min(dp[i], dp[j] + 1)
    
    return dp[n-1]
```

---

## 🌳 树形DP

### 📌 基本思想
在树结构上进行动态规划，通常以节点为状态，考虑父子关系进行状态转移。

### 💻 基本模板
```cpp
void dfs(int u, int parent) {
    // 处理子节点
    for (int v : children[u]) {
        if (v != parent) {
            dfs(v, u);
            // 状态转移
            dp[u] = combine(dp[u], dp[v]);
        }
    }
    // 处理当前节点
    dp[u] = processNode(dp[u], u);
}

# Python实现
def dfs(u, parent):
    # 处理子节点
    for v in tree[u]:
        if v != parent:
            dfs(v, u)
            # 状态转移
            dp[u] = combine(dp[u], dp[v])
    # 处理当前节点
    dp[u] = process_node(dp[u], u)
```

---

### 树的独立集问题

#### 📌 问题描述
在树上选择一些点，使得相邻点不能同时被选择，求最大权值和。

#### 💻 状态转移
```cpp
// dp[u][0]：不选择u节点时，以u为根的子树的最大权值
// dp[u][1]：选择u节点时，以u为根的子树的最大权值

void dfs(int u, int parent) {
    dp[u][0] = 0;  // 不选u
    dp[u][1] = weight[u];  // 选u
    
    for (int v : children[u]) {
        if (v != parent) {
            dfs(v, u);
            dp[u][0] += max(dp[v][0], dp[v][1]);  // u不选，v可选可不选
            dp[u][1] += dp[v][0];  // u选，v不能选
        }
    }
}

# Python实现
def tree_independent_set():
    dp = [[0, 0] for _ in range(n + 1)]
    
    def dfs(u, parent):
        dp[u][0] = 0  # 不选u
        dp[u][1] = weight[u]  # 选u
        
        for v in tree[u]:
            if v != parent:
                dfs(v, u)
                dp[u][0] += max(dp[v][0], dp[v][1])  # u不选，v可选可不选
                dp[u][1] += dp[v][0]  # u选，v不能选
    
    dfs(1, 0)  # 假设1为根
    return max(dp[1][0], dp[1][1])
```

---

## 🔢 状态压缩DP

### 📌 基本思想
将复杂的状态用二进制表示，适用于状态数量有限但转移复杂的情况。

### 🎯 旅行商问题(TSP)

#### 💻 状态转移
```cpp
// dp[mask][i]：当前访问状态为mask，当前在i点的最短路径
// mask的二进制表示哪些点已经被访问

int dp[1 << N][N];
memset(dp, 0x3f, sizeof(dp));
dp[1][0] = 0;  // 从起点0开始

for (int mask = 1; mask < (1 << N); mask++) {
    for (int u = 0; u < N; u++) {
        if (!(mask & (1 << u))) continue;  // u不在当前状态中
        
        for (int v = 0; v < N; v++) {
            if (mask & (1 << v)) continue;  // v已经在当前状态中
            
            int nextMask = mask | (1 << v);
            dp[nextMask][v] = min(dp[nextMask][v], 
                                 dp[mask][u] + dist[u][v]);
        }
    }
}

int answer = INF;
for (int i = 0; i < N; i++) {
    answer = min(answer, dp[(1 << N) - 1][i] + dist[i][0]);
}

# Python实现
def traveling_salesman():
    n = len(dist)
    dp = [[float('inf')] * n for _ in range(1 << n)]
    dp[1][0] = 0  # 从起点0开始
    
    for mask in range(1, 1 << n):
        for u in range(n):
            if not (mask & (1 << u)):  # u不在当前状态中
                continue
            
            for v in range(n):
                if mask & (1 << v):  # v已经在当前状态中
                    continue
                
                next_mask = mask | (1 << v)
                dp[next_mask][v] = min(dp[next_mask][v], 
                                      dp[mask][u] + dist[u][v])
    
    answer = float('inf')
    for i in range(n):
        answer = min(answer, dp[(1 << n) - 1][i] + dist[i][0])
    
    return answer
```

---

## 💡 DP优化技巧

### 单调队列优化

#### 📌 适用场景
形如 `dp[i] = max/min(dp[j] + value)` 的状态转移，其中j的范围与i线性相关。

#### 💻 实现代码
```cpp
// 单调队列模板
struct MonotoneQueue {
    deque<pair<int, int>> dq;  // (index, value)
    
    void push(int idx, int val) {
        while (!dq.empty() && dq.back().second >= val) {
            dq.pop_back();
        }
        dq.push_back({idx, val});
    }
    
    void pop(int idx) {
        while (!dq.empty() && dq.front().first <= idx) {
            dq.pop_front();
        }
    }
    
    int front() {
        return dq.front().second;
    }
};

# Python实现
from collections import deque

class MonotoneQueue:
    def __init__(self):
        self.dq = deque()
    
    def push(self, idx, val):
        while self.dq and self.dq[-1][1] >= val:
            self.dq.pop()
        self.dq.append((idx, val))
    
    def pop(self, idx):
        while self.dq and self.dq[0][0] <= idx:
            self.dq.popleft()
    
    def front(self):
        return self.dq[0][1] if self.dq else 0
```

---

### 斜率优化

#### 📌 适用场景
形如 `dp[i] = min(dp[j] + a[i] * b[j] + c[i] + d[j])` 的状态转移。

#### 💻 实现代码
```cpp
// 斜率优化DP模板
struct ConvexHull {
    struct Line {
        long long a, b;  // y = a*x + b
        int id;
    };
    
    deque<Line> hull;
    
    // 判断是否需要删除前一条线
    bool bad(Line l1, Line l2, Line l3) {
        // 叉积判断
        return (l3.b - l1.b) * (l1.a - l2.a) <= 
               (l2.b - l1.b) * (l1.a - l3.a);
    }
    
    void addLine(long long a, long long b, int id) {
        Line cur = {a, b, id};
        
        while (hull.size() >= 2 && 
               bad(hull[hull.size()-2], hull[hull.size()-1], cur)) {
            hull.pop_back();
        }
        
        hull.push_back(cur);
    }
    
    long long query(long long x) {
        if (hull.empty()) return LLONG_MAX;
        
        while (hull.size() >= 2 && 
               hull[0].a * x + hull[0].b >= hull[1].a * x + hull[1].b) {
            hull.pop_front();
        }
        
        return hull[0].a * x + hull[0].b;
    }
};

# Python实现
class ConvexHull:
    def __init__(self):
        self.hull = []
    
    def is_bad(self, l1, l2, l3):
        # 叉积判断
        return (l3[1] - l1[1]) * (l1[0] - l2[0]) <= (l2[1] - l1[1]) * (l1[0] - l3[0])
    
    def add_line(self, a, b, idx):
        cur = (a, b, idx)
        
        while len(self.hull) >= 2 and self.is_bad(self.hull[-2], self.hull[-1], cur):
            self.hull.pop()
        
        self.hull.append(cur)
    
    def query(self, x):
        if not self.hull:
            return float('inf')
        
        while len(self.hull) >= 2:
            val1 = self.hull[0][0] * x + self.hull[0][1]
            val2 = self.hull[1][0] * x + self.hull[1][1]
            if val1 >= val2:
                self.hull.pop(0)
            else:
                break
        
        return self.hull[0][0] * x + self.hull[0][1]
```

---

## 📊 DP问题类型对比

| 类型 | 状态特点 | 适用场景 | 优化方法 | 难度 |
|------|----------|----------|----------|------|
| **线性DP** | 一维序列 | 子数组、序列问题 | 前缀和、单调队列 | 简单 |
| **背包DP** | 价值/重量限制 | 资源分配问题 | 滚动数组、二进制分组 | 中等 |
| **区间DP** | 区间[l,r] | 合并、分割问题 | 预处理、四边形不等式 | 中等 |
| **树形DP** | 树结构节点 | 树上优化问题 | 换根、重链剖分 | 困难 |
| **状态压缩** | 二进制状态 | 小规模组合问题 | 位运算、子集DP | 困难 |
| **数位DP** | 数字位置 | 数字计数问题 | 记忆化、前导零处理 | 困难 |

---

## 📝 核心要点速记

1. DP的核心是状态定义，要满足无后效性和最优子结构
2. 背包DP要注意遍历方向，0-1背包倒序，完全背包正序
3. 区间DP通常按区间长度递增的顺序进行
4. 树形DP要考虑根的选择，可能需要换根DP
5. 状态压缩适用于状态数量有限但转移复杂的情况
6. 单调队列和斜率优化是常见的DP优化技巧

## 📚 模块内自测题

### 问题1
0-1背包问题中，为什么一维数组优化需要倒序遍历？
A. 为了节省时间  
B. 为了避免重复使用物品  
C. 为了代码简洁  
D. 为了减少空间

**解析**：B. 倒序遍历确保每个物品在计算时不会被重复使用，这是0-1背包与完全背包的关键区别。

### 问题2
完全背包问题中，正序遍历的目的是？
A. 允许重复使用物品  
B. 提高程序效率  
C. 减少内存使用  
D. 简化代码逻辑

**解析**：A. 正序遍历允许在计算当前状态时使用刚刚更新过的状态，这样就能实现物品的重复使用。

### 问题3
区间DP的状态表示通常是？
A. dp[i]  
B. dp[i][j]  
C. dp[mask]  
D. dp[i][j][k]

**解析**：B. 区间DP通常用dp[l][r]表示区间[l, r]的最优解，其中l和r是区间的左右端点。

### 问题4
树形DP的状态定义通常基于？
A. 数组索引  
B. 树的节点  
C. 图的边  
D. 层次结构

**解析**：B. 树形DP通常以树的节点作为状态的基本单位，考虑节点及其子树的最优解。

### 问题5
状态压缩DP适用于什么情况？
A. 数据规模很大  
B. 状态数量有限但转移复杂  
C. 需要处理连续区间  
D. 线性结构问题

**解析**：B. 状态压缩DP适用于状态数量相对较小（如n≤20）但状态转移关系复杂的情况，用二进制表示状态。

---

*本笔记基于OI-Wiki动态规划内容整理，适用于算法竞赛学习与复习。*