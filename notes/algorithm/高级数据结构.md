# 高级数据结构

**前置知识**：基础数据结构、树形结构基础、递归思想

**后续关联模块**：数据结构关联算法、效率分析与结构选择、易错点与实战技巧

## 📌 核心定义

高级数据结构是在基础数据结构基础上发展而来的复杂数据组织形式，它们通常具有更高效的特定操作性能，能够解决更加复杂的问题。这些结构是算法竞赛中的关键工具，常常是区分优秀选手的重要标志。

## 🌳 树形高级数据结构

### 线段树 (Segment Tree)

#### 📌 定义
线段树是算法竞赛中常用的用来维护区间信息的数据结构，可以在O(log N)时间复杂度内实现单点修改、区间修改、区间查询等操作。

#### 🔧 存储原理
- **堆式存储**：使用数组模拟完全二叉树结构
- **区间划分**：每个节点表示一个区间，父节点区间是子节点区间的并集
- **懒惰标记**：延迟区间修改操作，减少不必要计算

#### 💻 核心操作

```cpp
class SegmentTree {
private:
    vector<int> tree, lazy;  // 线段树数组和懒惰标记
    int n;
    
    void build(int node, int l, int r, const vector<int>& arr) {
        if (l == r) {
            tree[node] = arr[l];
            return;
        }
        int mid = (l + r) / 2;
        build(node * 2, l, mid, arr);
        build(node * 2 + 1, mid + 1, r, arr);
        tree[node] = tree[node * 2] + tree[node * 2 + 1];
    }
    
    void pushDown(int node, int l, int r) {
        if (lazy[node] != 0) {
            int mid = (l + r) / 2;
            tree[node * 2] += lazy[node] * (mid - l + 1);
            lazy[node * 2] += lazy[node];
            tree[node * 2 + 1] += lazy[node] * (r - mid);
            lazy[node * 2 + 1] += lazy[node];
            lazy[node] = 0;
        }
    }
    
    void update(int node, int l, int r, int ql, int qr, int val) {
        if (ql > r || qr < l) return;
        if (ql <= l && r <= qr) {
            tree[node] += val * (r - l + 1);
            lazy[node] += val;
            return;
        }
        pushDown(node, l, r);
        int mid = (l + r) / 2;
        update(node * 2, l, mid, ql, qr, val);
        update(node * 2 + 1, mid + 1, r, ql, qr, val);
        tree[node] = tree[node * 2] + tree[node * 2 + 1];
    }
    
    int query(int node, int l, int r, int ql, int qr) {
        if (ql > r || qr < l) return 0;
        if (ql <= l && r <= qr) return tree[node];
        pushDown(node, l, r);
        int mid = (l + r) / 2;
        return query(node * 2, l, mid, ql, qr) + 
               query(node * 2 + 1, mid + 1, r, ql, qr);
    }
    
public:
    SegmentTree(const vector<int>& arr) {
        n = arr.size() - 1;  // 假设arr[0]不使用，从1开始
        tree.resize(4 * n);
        lazy.resize(4 * n, 0);
        build(1, 1, n, arr);
    }
    
    void update(int l, int r, int val) {
        update(1, 1, n, l, r, val);
    }
    
    int query(int l, int r) {
        return query(1, 1, n, l, r);
    }
};

# Python实现
class SegmentTree:
    def __init__(self, arr):
        self.n = len(arr) - 1  # 假设arr[0]不使用
        self.tree = [0] * (4 * self.n)
        self.lazy = [0] * (4 * self.n)
        self.build(1, 1, self.n, arr)
    
    def build(self, node, l, r, arr):
        if l == r:
            self.tree[node] = arr[l]
            return
        mid = (l + r) // 2
        self.build(node * 2, l, mid, arr)
        self.build(node * 2 + 1, mid + 1, r, arr)
        self.tree[node] = self.tree[node * 2] + self.tree[node * 2 + 1]
    
    def push_down(self, node, l, r):
        if self.lazy[node] != 0:
            mid = (l + r) // 2
            self.tree[node * 2] += self.lazy[node] * (mid - l + 1)
            self.lazy[node * 2] += self.lazy[node]
            self.tree[node * 2 + 1] += self.lazy[node] * (r - mid)
            self.lazy[node * 2 + 1] += self.lazy[node]
            self.lazy[node] = 0
    
    def update(self, node, l, r, ql, qr, val):
        if ql > r or qr < l:
            return
        if ql <= l and r <= qr:
            self.tree[node] += val * (r - l + 1)
            self.lazy[node] += val
            return
        self.push_down(node, l, r)
        mid = (l + r) // 2
        self.update(node * 2, l, mid, ql, qr, val)
        self.update(node * 2 + 1, mid + 1, r, ql, qr, val)
        self.tree[node] = self.tree[node * 2] + self.tree[node * 2 + 1]
    
    def query(self, node, l, r, ql, qr):
        if ql > r or qr < l:
            return 0
        if ql <= l and r <= qr:
            return self.tree[node]
        self.push_down(node, l, r)
        mid = (l + r) // 2
        return self.query(node * 2, l, mid, ql, qr) + self.query(node * 2 + 1, mid + 1, r, ql, qr)
```

#### ⏱️ 复杂度分析
| 操作 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| 建树 | O(n) | O(n) |
| 区间查询 | O(log n) | - |
| 区间修改 | O(log n) | - |

#### 🎯 适用场景
- 频繁的区间查询和修改操作
- 需要维护区间和、最大值、最小值等
- 区间最值操作与历史最值维护
- 离线算法中处理区间约束

---

### zkw线段树 (zkw Segment Tree)

#### 📌 定义
zkw线段树是一种非递归的线段树实现，由张昆伟提出，具有常数更小、实现简单的特点。

#### 🔧 存储原理
- **非递归实现**：使用迭代代替递归，减少函数调用开销
- **自底向上**：从叶子节点开始向上更新
- **完全二叉树**：利用完全二叉树的性质简化操作

#### 💻 核心操作

```cpp
class ZKWSegmentTree {
private:
    vector<int> tree;
    int M, n;
    
public:
    ZKWSegmentTree(int size) {
        n = size;
        M = 1;
        while (M < n + 2) M <<= 1;  // 计算合适的M值
        tree.assign(2 * M, 0);
    }
    
    void build(const vector<int>& arr) {
        // 建树：从叶子节点开始
        for (int i = 1; i <= n; i++) {
            tree[M + i] = arr[i];
        }
        // 向上更新
        for (int i = M - 1; i; i--) {
            tree[i] = tree[i << 1] + tree[i << 1 | 1];
        }
    }
    
    void update(int pos, int value) {
        // 修改：从叶子节点开始向上更新
        for (tree[pos += M] = value; pos > 1; pos >>= 1) {
            tree[pos >> 1] = tree[pos] + tree[pos ^ 1];
        }
    }
    
    int query(int l, int r) {
        // 查询：非递归实现
        int ans = 0;
        for (l += M, r += M + 1; l < r; l >>= 1, r >>= 1) {
            if (l & 1) ans += tree[l++];
            if (r & 1) ans += tree[--r];
        }
        return ans;
    }
};

# Python实现
class ZKWSegmentTree:
    def __init__(self, size):
        self.n = size
        self.M = 1
        while self.M < size + 2:
            self.M <<= 1
        self.tree = [0] * (2 * self.M)
    
    def build(self, arr):
        # 建树：从叶子节点开始
        for i in range(1, self.n + 1):
            self.tree[self.M + i] = arr[i]
        # 向上更新
        for i in range(self.M - 1, 0, -1):
            self.tree[i] = self.tree[i << 1] + self.tree[i << 1 | 1]
    
    def update(self, pos, value):
        # 修改：从叶子节点开始向上更新
        pos += self.M
        self.tree[pos] = value
        while pos > 1:
            pos >>= 1
            self.tree[pos] = self.tree[pos << 1] + self.tree[pos << 1 | 1]
    
    def query(self, l, r):
        # 查询：非递归实现
        ans = 0
        l += self.M
        r += self.M + 1
        while l < r:
            if l & 1:
                ans += self.tree[l]
                l += 1
            if r & 1:
                r -= 1
                ans += self.tree[r]
            l >>= 1
            r >>= 1
        return ans
```

#### ⏱️ 复杂度分析
| 操作 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| 建树 | O(n) | O(n) |
| 单点修改 | O(log n) | - |
| 区间查询 | O(log n) | - |

#### 💡 优势与普通线段树对比

| 特性 | 普通线段树 | zkw线段树 |
|------|------------|-----------|
| 实现方式 | 递归 | 非递归 |
| 常数大小 | 较大 | 较小 |
| 代码复杂度 | 较复杂 | 较简单 |
| 递归深度 | 可能栈溢出 | 无此问题 |
| 适用场景 | 复杂的线段树操作 | 简单的线段树操作 |

---

### 平衡树 (Balanced Trees)

#### 📌 定义
平衡树是一类自平衡的二叉搜索树，通过旋转等操作确保树的高度保持在O(log n)，从而保证各种操作的高效性。

#### 🔧 存储原理
- **二叉搜索性质**：左子树节点小于根节点，右子树节点大于根节点
- **平衡维护**：通过旋转、分裂、合并等操作保持树的平衡
- **高度控制**：确保树的高度不超过O(log n)

### Treap (树堆)

#### 💻 核心操作

```cpp
class Treap {
private:
    struct Node {
        int key, priority;
        Node *left, *right;
        Node(int k) : key(k), priority(rand()), left(nullptr), right(nullptr) {}
    };
    
    Node* root;
    
    // 右旋
    Node* rotateRight(Node* y) {
        Node* x = y->left;
        y->left = x->right;
        x->right = y;
        return x;
    }
    
    // 左旋
    Node* rotateLeft(Node* x) {
        Node* y = x->right;
        x->right = y->left;
        y->left = x;
        return y;
    }
    
    // 插入
    Node* insert(Node* node, int key) {
        if (!node) return new Node(key);
        
        if (key < node->key) {
            node->left = insert(node->left, key);
            if (node->left->priority > node->priority)
                node = rotateRight(node);
        } else {
            node->right = insert(node->right, key);
            if (node->right->priority > node->priority)
                node = rotateLeft(node);
        }
        return node;
    }
    
    // 删除
    Node* remove(Node* node, int key) {
        if (!node) return nullptr;
        
        if (key < node->key) {
            node->left = remove(node->left, key);
        } else if (key > node->key) {
            node->right = remove(node->right, key);
        } else {
            // 找到要删除的节点
            if (!node->left) return node->right;
            if (!node->right) return node->left;
            
            // 有两个子节点，旋转优先级较高的子节点
            if (node->left->priority > node->right->priority) {
                node = rotateRight(node);
                node->right = remove(node->right, key);
            } else {
                node = rotateLeft(node);
                node->left = remove(node->left, key);
            }
        }
        return node;
    }
    
    // 查找
    bool search(Node* node, int key) {
        if (!node) return false;
        if (key == node->key) return true;
        return key < node->key ? search(node->left, key) : search(node->right, key);
    }
    
public:
    Treap() : root(nullptr) {}
    
    void insert(int key) {
        root = insert(root, key);
    }
    
    void remove(int key) {
        root = remove(root, key);
    }
    
    bool search(int key) {
        return search(root, key);
    }
};
```

#### ⏱️ 复杂度分析
| 操作 | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度 |
|------|----------------|----------------|------------|
| 插入 | O(log n) | O(n) | O(n) |
| 删除 | O(log n) | O(n) | - |
| 查找 | O(log n) | O(n) | - |

---

### 字典树 (Trie)

#### 📌 定义
字典树，又称前缀树，是一种专门用于处理字符串的树形数据结构，能够高效地存储和查找字符串集合。

#### 🔧 存储原理
- **路径存储**：每个边代表一个字符，从根到节点的路径构成字符串
- **前缀共享**：具有相同前缀的字符串共享路径上的节点
- **标记终止**：使用特殊标记表示字符串的结束位置

#### 💻 核心操作

```cpp
class Trie {
private:
    struct TrieNode {
        TrieNode* children[26];
        bool isEnd;
        TrieNode() : isEnd(false) {
            for (int i = 0; i < 26; i++) {
                children[i] = nullptr;
            }
        }
    };
    
    TrieNode* root;
    
public:
    Trie() {
        root = new TrieNode();
    }
    
    void insert(string word) {
        TrieNode* curr = root;
        for (char c : word) {
            int index = c - 'a';
            if (!curr->children[index]) {
                curr->children[index] = new TrieNode();
            }
            curr = curr->children[index];
        }
        curr->isEnd = true;
    }
    
    bool search(string word) {
        TrieNode* curr = root;
        for (char c : word) {
            int index = c - 'a';
            if (!curr->children[index]) {
                return false;
            }
            curr = curr->children[index];
        }
        return curr->isEnd;
    }
    
    bool startsWith(string prefix) {
        TrieNode* curr = root;
        for (char c : prefix) {
            int index = c - 'a';
            if (!curr->children[index]) {
                return false;
            }
            curr = curr->children[index];
        }
        return true;
    }
    
    // 压位Trie优化：使用位压缩减少空间
    class CompressedTrie {
    private:
        struct Node {
            int children[4];  // 使用int存储位图
            bool isEnd;
            Node() : isEnd(false) {
                for (int i = 0; i < 4; i++) {
                    children[i] = -1;
                }
            }
        };
        
        vector<Node> nodes;
        int root;
        
        int getCharIndex(char c) {
            if ('a' <= c && c <= 'z') return 0;
            if ('A' <= c && c <= 'Z') return 1;
            if ('0' <= c && c <= '9') return 2;
            return 3;
        }
        
    public:
        CompressedTrie() {
            nodes.emplace_back();
            root = 0;
        }
        
        void insert(string word) {
            int curr = root;
            for (char c : word) {
                int idx = getCharIndex(c);
                if (nodes[curr].children[idx] == -1) {
                    nodes[curr].children[idx] = nodes.size();
                    nodes.emplace_back();
                }
                curr = nodes[curr].children[idx];
            }
            nodes[curr].isEnd = true;
        }
    };
};

# Python实现
class Trie:
    class TrieNode:
        def __init__(self):
            self.children = {}
            self.is_end = False
    
    def __init__(self):
        self.root = self.TrieNode()
    
    def insert(self, word):
        curr = self.root
        for c in word:
            if c not in curr.children:
                curr.children[c] = self.TrieNode()
            curr = curr.children[c]
        curr.is_end = True
    
    def search(self, word):
        curr = self.root
        for c in word:
            if c not in curr.children:
                return False
            curr = curr.children[c]
        return curr.is_end
    
    def starts_with(self, prefix):
        curr = self.root
        for c in prefix:
            if c not in curr.children:
                return False
            curr = curr.children[c]
        return True
```

#### ⏱️ 复杂度分析
| 操作 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| 插入 | O(m) | O(m) |
| 查找 | O(m) | - |
| 前缀查询 | O(m) | - |

*注：m为字符串长度*

---

## 🔥 可持久化数据结构

### 可持久化线段树

#### 📌 定义
可持久化线段树能够保存历史版本，支持对历史版本的查询，通过共享不变部分来节省空间。

#### 🔧 存储原理
- **版本管理**：每个操作生成新版本，旧版本保留
- **节点共享**：未修改的节点在多个版本间共享
- **动态创建**：只创建被修改的节点及其路径上的节点

#### 💻 核心操作

```cpp
class PersistentSegmentTree {
private:
    struct Node {
        int value;
        Node *left, *right;
        Node(int v = 0, Node* l = nullptr, Node* r = nullptr) 
            : value(v), left(l), right(r) {}
    };
    
    vector<Node*> versions;  // 存储各个版本的根节点
    int n;
    
    Node* build(int l, int r) {
        if (l == r) return new Node(0);
        int mid = (l + r) / 2;
        return new Node(0, build(l, mid), build(mid + 1, r));
    }
    
    Node* update(Node* node, int l, int r, int pos, int val) {
        if (!node) node = new Node();
        if (l == r) {
            return new Node(node->value + val);
        }
        
        int mid = (l + r) / 2;
        Node* newNode = new Node();
        
        if (pos <= mid) {
            newNode->left = update(node->left, l, mid, pos, val);
            newNode->right = node->right;
        } else {
            newNode->left = node->left;
            newNode->right = update(node->right, mid + 1, r, pos, val);
        }
        
        newNode->value = (newNode->left ? newNode->left->value : 0) + 
                         (newNode->right ? newNode->right->value : 0);
        return newNode;
    }
    
    int query(Node* node, int l, int r, int ql, int qr) {
        if (!node || ql > r || qr < l) return 0;
        if (ql <= l && r <= qr) return node->value;
        
        int mid = (l + r) / 2;
        return query(node->left, l, mid, ql, qr) + 
               query(node->right, mid + 1, r, ql, qr);
    }
    
public:
    PersistentSegmentTree(int size) : n(size) {
        versions.push_back(build(1, n));  // 初始版本
    }
    
    void update(int version, int pos, int val) {
        Node* newRoot = update(versions[version], 1, n, pos, val);
        versions.push_back(newRoot);
    }
    
    int query(int version, int l, int r) {
        return query(versions[version], 1, n, l, r);
    }
    
    int getVersionCount() {
        return versions.size() - 1;
    }
};
```

#### ⏱️ 复杂度分析
| 操作 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| 版本更新 | O(log n) | O(log n) |
| 历史查询 | O(log n) | - |
| 总空间消耗 | - | O(n + m log n) |

*注：m为操作次数*

#### 🎯 适用场景
- 需要查询历史状态的场景
- 离线算法中的应用
- 函数式编程中的数据结构
- 区间第k小问题

---

## 🎯 高级结构对比

| 结构类型 | 典型应用 | 时间复杂度 | 优势 | 劣势 |
|----------|----------|------------|------|------|
| 普通线段树 | 区间操作 | O(log n) | 递归直观 | 常数较大 |
| zkw线段树 | 简单区间操作 | O(log n) | 常数小 | 功能有限 |
| Treap | 动态有序集合 | O(log n) | 随机平衡 | 概率算法 |
| Splay树 | 频繁访问局部性 | 均摊O(log n) | 自适应 | 最坏O(n) |
| 可持久化线段树 | 历史版本 | O(log n) | 保留历史 | 空间较大 |
| 字典树 | 字符串处理 | O(m) | 前缀优化 | 空间消耗大 |

---

## 💡 实战应用技巧

### 1. 线段树变体选择
- **普通区间操作** → 普通线段树
- **单点查询多** → zkw线段树  
- **历史版本需求** → 可持久化线段树
- **多重条件查询** → 树套树

### 2. 平衡树选择
- **随机数据** → Treap（实现简单）
- **局部性强** → Splay（自适应优化）
- **确定性要求** → Scapegoat（确定性平衡）
- **序列操作** → Rope/Splay

### 3. 空间优化技巧
- **动态开点** → 按需创建节点
- **标记永久化** → 减少标记下放
- **位压缩** → 优化字典树空间
- **节点复用** → 可持久化中的共享

### 4. 常见陷阱
- **边界处理**：线段树的左右边界易错
- **懒惰标记**：忘记下放导致错误
- **递归深度**：大数据量可能栈溢出
- **内存管理**：动态创建节点需释放

---

## 📝 核心要点速记

1. 线段树适合区间操作，zkw线段树是常数优化的非递归实现
2. 平衡树有多种实现，Treap简单高效，Splay有局部性优势
3. 字典树专门处理字符串，压位Trie可优化空间
4. 可持久化结构保留历史版本，通过节点共享节省空间
5. 不同高级结构各有优劣，需根据具体问题特点选择

## 📚 模块内自测题

### 问题1
下列哪种场景最适合使用zkw线段树而不是普通线段树？
A. 需要复杂的区间下推标记操作  
B. 需要频繁的单点修改和区间查询  
C. 需要历史版本查询功能  
D. 需要处理浮点数区间操作

**解析**：B. zkw线段树在简单的单点修改和区间查询场景下常数更小，性能更好，但对于复杂的懒惰标记操作支持不如普通线段树。

### 问题2
Treap平衡树结合了哪两种数据结构的特性？
A. 二叉搜索树和堆  
B. 线段树和堆  
C. 二叉搜索树和线段树  
D. 堆和哈希表

**解析**：A. Treap结合了二叉搜索树的键值性质和堆的优先级性质，通过随机优先级实现平衡。

### 问题3
关于可持久化数据结构的优势，以下说法正确的是？
A. 时间复杂度比普通数据结构更低  
B. 空间复杂度比普通数据结构更低  
C. 能够查询历史版本的状态  
D. 适用于所有类型的数据结构

**解析**：C. 可持久化数据结构的主要优势是能够保留和查询历史版本状态，但通常会以空间复杂度为代价。

### 问题4
字典树（Trie）相比哈希表在字符串处理中的主要优势是？
A. 时间复杂度更低  
B. 支持前缀匹配查询  
C. 空间复杂度更低  
D. 支持更多的字符类型

**解析**：B. 字典树天然支持前缀匹配查询，这是哈希表难以高效实现的功能。

### 问题5
在算法竞赛中，如果需要一个同时支持区间修改和查询第k小的数据结构，应该选择？
A. 普通线段树  
B. 平衡树  
C. 树状数组  
D. 线段树套平衡树（树套树）

**解析**：D. 树套树结构（如线段树套平衡树）可以同时处理区间修改和查询第k小等复杂操作，虽然实现复杂度较高，但功能强大。

---

*本笔记基于OI-Wiki高级数据结构内容整理，适用于算法竞赛学习与复习。*