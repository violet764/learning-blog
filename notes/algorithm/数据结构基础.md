# 数据结构与算法

**数据结构**是计算机中存储、组织数据的方式。更通俗地说，数据结构是计算机程序中用于组织、管理和存储数据的一种格式，它不仅是数据元素的集合，还包括数据元素之间的关系。

---

***数据结构全体系知识图谱***

```
数据结构体系
├── 基础数据结构
│   ├── 线性结构
│   │   ├── 数组（静态存储）
│   │   ├── 链表（动态存储）
│   │   ├── 栈（后进先出）
│   │   └── 队列（先进先出）
│   └── 非线性基础结构
│       ├── 哈希表（键值映射）
│       └── 并查集（集合操作）
├── 高级数据结构
│   ├── 树形结构
│   │   ├── 二叉树
│   │   ├── 线段树（区间操作）
│   │   ├── 树状数组（前缀和）
│   │   ├── 平衡树（动态有序）
│   │   │   ├── Treap
│   │   │   ├── Splay树
│   │   │   └── 其他平衡树
│   │   ├── 字典树（字符串处理）
│   │   └── 堆（优先队列）
│   ├── 可持久化结构
│   │   ├── 可持久化线段树
│   │   ├── 可持久化字典树
│   │   └── 其他可持久化结构
│   └── 复合结构
│       ├── 树套树
│       ├── 分块结构
│       └── 动态开点结构
└── 特殊结构
    ├── vEB树（整数集合）
    ├── zkw线段树（非递归线段树）
    └── 压位Trie（空间优化）
```

---

## 基础数据结构

### 数组 (Array)

**定义**
数组是最基础的线性数据结构，它存储相同类型的元素，并在内存中连续分配空间。

**存储原理**
- **连续存储**：所有元素在内存中连续存放
- **索引访问**：通过下标直接计算元素地址
- **固定大小**：创建时确定大小，运行时通常不可变

**核心操作**
::: code-group
```cpp
// 数组定义与初始化
int arr[100];                 // 静态数组
vector<int> vec;              // 动态数组

// 访问操作
int value = arr[index];       // O(1)
arr[index] = newValue;        // O(1)

// 容量操作
int size = sizeof(arr) / sizeof(arr[0]);  // O(1)
vec.push_back(x);             // 均摊O(1)
vec.size();                   // O(1)
```
```python
arr = [0] * 100               # 静态数组
arr = []                      # 动态数组
value = arr[index]            # O(1)
arr.append(x)                 # 均摊O(1)
```
:::

**复杂度分析**
| 操作 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| 访问 | O(1) | - |
| 查找 | O(n) | - |
| 插入 | O(n) | - |
| 删除 | O(n) | O(n) |

**适用场景**
- 需要频繁随机访问元素
- 元素数量相对稳定
- 对内存连续性有要求

---

### 链表 (Linked List)

**定义**
链表是一种通过指针连接的线性数据结构，元素在内存中可以不连续存储。

**存储原理**
- **节点结构**：每个节点包含数据域和指针域
- **动态连接**：通过指针将各节点串联起来
- **灵活扩展**：可以动态插入和删除节点

**核心操作**
::: code-group
```cpp
// 链表节点定义
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

// 插入操作
void insert(ListNode* head, int val, int position) {
    ListNode* newNode = new ListNode(val);
    if (position == 0) {
        newNode->next = head;
        return newNode;
    }
    ListNode* current = head;
    for (int i = 0; i < position - 1 && current; i++) {
        current = current->next;
    }
    if (current) {
        newNode->next = current->next;
        current->next = newNode;
    }
}

// 删除操作
void remove(ListNode* head, int position) {
    if (position == 0 && head) {
        ListNode* temp = head;
        head = head->next;
        delete temp;
        return;
    }
    ListNode* current = head;
    for (int i = 0; i < position - 1 && current->next; i++) {
        current = current->next;
    }
    if (current->next) {
        ListNode* temp = current->next;
        current->next = temp->next;
        delete temp;
    }
}
```

```python
# Python实现
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
```
:::
**复杂度分析**
| 操作 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| 访问 | O(n) | - |
| 查找 | O(n) | - |
| 插入 | O(1) | O(n) |
| 删除 | O(1) | O(n) |

**适用场景**
- 需要频繁插入和删除操作
- 元素数量变化较大
- 不需要频繁随机访问

---

### 栈 (Stack)

**定义**
栈是一种后进先出(LIFO)的线性数据结构，只允许在一端进行插入和删除操作。

**存储原理**
- **单端操作**：所有操作都在栈顶进行
- **压栈弹出**：`push`操作添加元素，`pop`操作移除元素
- **层次访问**：只能访问栈顶元素

**核心操作**
::: code-group
```cpp
// 使用数组实现栈
class ArrayStack {
private:
    vector<int> data;

public:
    void push(int x) {         // O(1)
        data.push_back(x);
    }

    int pop() {                // O(1)
        if (empty()) throw runtime_error("Stack is empty");
        int top = data.back();
        data.pop_back();
        return top;
    }

    int top() {                // O(1)
        if (empty()) throw runtime_error("Stack is empty");
        return data.back();
    }

    bool empty() {             // O(1)
        return data.empty();
    }
};

// STL栈使用
stack<int> st;
st.push(1);                    // 入栈
st.top();                      // 获取栈顶
st.pop();                      // 出栈
st.empty();                    // 判空
```

```python
# Python实现
class Stack:
    def __init__(self):
        self.data = []

    def push(self, x):         # O(1)
        self.data.append(x)

    def pop(self):              # O(1)
        if not self.data:
            raise Exception("Stack is empty")
        return self.data.pop()

    def top(self):              # O(1)
        if not self.data:
            raise Exception("Stack is empty")
        return self.data[-1]

    def empty(self):            # O(1)
        return len(self.data) == 0
```
:::
**复杂度分析**
| 操作 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| push | O(1) | O(n) |
| pop | O(1) | - |
| top | O(1) | - |

**适用场景**
- 函数调用栈
- 表达式求值
- 深度优先搜索(DFS)
- 括号匹配检查

---

### 队列 (Queue)

**定义**
队列是一种先进先出(FIFO)的线性数据结构，在队尾插入元素，在队头删除元素。

**存储原理**
- **双端操作**：插入在队尾，删除在队头
- **顺序服务**：按照元素到达的顺序进行处理
- **环形缓冲**：常用循环数组实现提高效率

**核心操作**
::: code-group
```cpp
// 使用数组实现队列
class ArrayQueue {
private:
    vector<int> data;
    int front, rear;

public:
    ArrayQueue(int capacity) : front(0), rear(0) {
        data.resize(capacity);
    }

    void enqueue(int x) {       // O(1)
        data[rear] = x;
        rear = (rear + 1) % data.size();
    }

    int dequeue() {            // O(1)
        if (empty()) throw runtime_error("Queue is empty");
        int result = data[front];
        front = (front + 1) % data.size();
        return result;
    }

    bool empty() {             // O(1)
        return front == rear;
    }
};

// STL队列使用
queue<int> q;
q.push(1);                     // 入队
q.front();                     // 获取队头
q.pop();                       // 出队
q.empty();                     // 判空
```

```python

# Python实现
from collections import deque

queue = deque()
queue.append(1)                # 入队
queue[0]                       # 队头元素
queue.popleft()                # 出队
len(queue) == 0                # 判空
```
:::
**复杂度分析**
| 操作 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| enqueue | O(1) | O(n) |
| dequeue | O(1) | - |
| front | O(1) | - |

**适用场景**
- 广度优先搜索(BFS)
- 任务调度
- 缓冲区管理
- 层次遍历

---

### 哈希表（HashMap）

**定义**
哈希表是基于键值对的存储结构，通过哈希函数将键映射到存储位置，实现o(1)快速查找。

**存储原理**
- **哈希映射**：使用哈希函数计算键的存储地址
- **冲突处理**：解决不同键映射到同一位置的问题
- **动态扩容**：当元素过多时自动扩展容量

**核心操作**
::: code-group
```cpp
// 哈希函数示例
int hashFunction(int key, int tableSize) {
    return key % tableSize;  // 简单取模哈希
}

// STL哈希表使用
unordered_map<string, int> hm;
hm["apple"] = 5;             // 插入/修改
int value = hm["apple"];     // 查找
hm.erase("apple");           // 删除
bool exists = hm.count("apple"); // 检查存在

unordered_set<int> hs;
hs.insert(5);                 // 插入
bool exists = hs.count(5);   // 检查存在
```

```python
# Python实现
# 字典就是哈希表
hm = {}
hm["apple"] = 5              # 插入/修改
value = hm["apple"]          # 查找
del hm["apple"]              # 删除
"apple" in hm                # 检查存在

# 集合也是哈希表
hs = set()
hs.add(5)                    # 插入
5 in hs                      # 检查存在
```
:::
**复杂度分析**
| 操作 | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度 |
|------|----------------|----------------|------------|
| 插入 | O(1) | O(n) | O(n) |
| 删除 | O(1) | O(n) | - |
| 查找 | O(1) | O(n) | - |

**适用场景**
- 需要快速查找、插入和删除
- 键值对存储需求
- 去重和计数问题
- 缓存实现

::: info
- 哈希冲突可能导致性能退化
- 需要选择合适的哈希函数
- 哈希表遍历顺序不确定
:::

---

### 并查集 （Union Set）

**定义**
并查集是一种维护集合的数据结构，支持高效的集合合并和查找操作。

**存储原理**
- **树形结构**：每个集合表示为一棵树
- **路径压缩**：查找时压缩路径减少高度
- **按秩合并**：合并时将小树合并到大树

**核心操作**
::: code-group
```cpp
#include <iostream>
#include <vector>
#include <unordered_map>
#include <algorithm>
using namespace std;

class UnionFind {
private:
    vector<int> parent;  // 父节点数组
    vector<int> rank;    // 秩（树的高度）
    vector<int> size;    // 集合大小
    int count;           // 连通分量数量
    
public:
    // 构造函数
    UnionFind(int n) {
        count = n;
        parent.resize(n);
        rank.resize(n, 0);
        size.resize(n, 1);
        
        // 初始化，每个节点的父节点是自己
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }
    
    // 查找根节点（带路径压缩）
    int find(int x) {
        // 递归版（简洁）
        if (parent[x] != x) {
            parent[x] = find(parent[x]);  // 路径压缩
        }
        return parent[x];
        
        // 迭代版（防止栈溢出）
        // int root = x;
        // while (parent[root] != root) {
        //     root = parent[root];
        // }
        // // 路径压缩
        // while (parent[x] != root) {
        //     int temp = parent[x];
        //     parent[x] = root;
        //     x = temp;
        // }
        // return root;
    }
    
    // 合并两个集合
    bool unionSets(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        
        // 如果已经在同一个集合，直接返回
        if (rootX == rootY) {
            return false;
        }
        
        // 按秩合并
        if (rank[rootX] < rank[rootY]) {
            parent[rootX] = rootY;
            size[rootY] += size[rootX];
        } else if (rank[rootX] > rank[rootY]) {
            parent[rootY] = rootX;
            size[rootX] += size[rootY];
        } else {
            // 秩相等时，任意合并，并增加秩
            parent[rootY] = rootX;
            size[rootX] += size[rootY];
            rank[rootX] += 1;
        }
        
        count--;  // 连通分量减少
        return true;
    }
    
    // 检查两个元素是否连通
    bool connected(int x, int y) {
        return find(x) == find(y);
    }
    
    // 获取连通分量数量
    int getCount() const {
        return count;
    }
    
    // 获取元素所在集合的大小
    int getSize(int x) {
        int root = find(x);
        return size[root];
    }
    
    // 获取所有连通分量
    unordered_map<int, vector<int>> getSets() {
        unordered_map<int, vector<int>> sets;
        for (int i = 0; i < parent.size(); i++) {
            int root = find(i);
            sets[root].push_back(i);
        }
        return sets;
    }
    
    // 打印状态（调试用）
    void printStatus() {
        cout << "索引: ";
        for (int i = 0; i < parent.size(); i++) {
            cout << i << " ";
        }
        cout << endl;
        
        cout << "父节点: ";
        for (int p : parent) {
            cout << p << " ";
        }
        cout << endl;
        
        cout << "秩: ";
        for (int r : rank) {
            cout << r << " ";
        }
        cout << endl;
        
        cout << "集合大小: ";
        for (int s : size) {
            cout << s << " ";
        }
        cout << endl;
        
        cout << "连通分量数量: " << count << endl;
        
        auto sets = getSets();
        cout << "连通分量:" << endl;
        for (const auto& entry : sets) {
            cout << "  集合" << entry.first << ": ";
            for (int elem : entry.second) {
                cout << elem << " ";
            }
            cout << endl;
        }
    }
};

// 测试函数
void testUnionFind() {
    cout << "=== 并查集基本用法 ===" << endl;
    
    // 1. 初始化
    UnionFind uf(10);
    cout << "初始化状态:" << endl;
    uf.printStatus();
    cout << endl;
    
    // 2. 合并操作
    vector<pair<int, int>> operations = {
        {0, 1}, {2, 3}, {4, 5}, {6, 7}, {8, 9},
        {1, 2}, {3, 4}, {5, 6}, {7, 8}
    };
    
    cout << "合并操作:" << endl;
    for (int i = 0; i < operations.size(); i++) {
        int x = operations[i].first;
        int y = operations[i].second;
        uf.unionSets(x, y);
        cout << "  合并 " << x << " 和 " << y 
             << " 后，连通分量: " << uf.getCount() << endl;
    }
    
    cout << "\n最终状态:" << endl;
    uf.printStatus();
    
    // 3. 连通性测试
    cout << "\n=== 连通性测试 ===" << endl;
    vector<pair<int, int>> testPairs = {
        {0, 4}, {1, 7}, {2, 9}, {3, 8}, {0, 9}
    };
    
    for (const auto& p : testPairs) {
        int x = p.first;
        int y = p.second;
        cout << "  " << x << " 和 " << y << " 是否连通: " 
             << (uf.connected(x, y) ? "是" : "否") << endl;
    }
    
    // 4. 集合大小测试
    cout << "\n=== 集合大小测试 ===" << endl;
    for (int i = 0; i < 5; i++) {
        cout << "  元素 " << i << " 所在集合大小: " << uf.getSize(i) << endl;
    }
}

int main() {
    // 运行测试
    testUnionFind();
    return 0;
}

```
```python
class UnionFind:
    """并查集实现（带路径压缩和按秩合并）"""
    
    def __init__(self, n):
        """
        初始化并查集
        :param n: 元素数量，元素编号为 0 到 n-1
        """
        self.parent = list(range(n))  # 父节点数组，初始时每个节点的父节点是自己
        self.rank = [0] * n           # 秩（树的高度），用于按秩合并
        self.count = n                # 连通分量数量
        self.size = [1] * n           # 每个集合的大小
    
    def find(self, x):
        """
        查找元素x的根节点（带路径压缩）
        时间复杂度：近似O(1)（阿克曼函数的反函数）
        """
        # 方法1：递归版（更简洁）
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])  # 路径压缩
        return self.parent[x]
        
        # 方法2：迭代版（防止递归深度过大）
        # root = x
        # # 先找到根节点
        # while self.parent[root] != root:
        #     root = self.parent[root]
        # # 路径压缩
        # while self.parent[x] != root:
        #     temp = self.parent[x]
        #     self.parent[x] = root
        #     x = temp
        # return root
    
    def union(self, x, y):
        """
        合并元素x和y所在的集合
        时间复杂度：近似O(1)
        """
        root_x = self.find(x)
        root_y = self.find(y)
        
        # 如果已经在同一个集合，直接返回
        if root_x == root_y:
            return False
        
        # 按秩合并：将小树合并到大树
        if self.rank[root_x] < self.rank[root_y]:
            self.parent[root_x] = root_y
            self.size[root_y] += self.size[root_x]
        elif self.rank[root_x] > self.rank[root_y]:
            self.parent[root_y] = root_x
            self.size[root_x] += self.size[root_y]
        else:
            # 秩相等时，任意合并，并增加秩
            self.parent[root_y] = root_x
            self.size[root_x] += self.size[root_y]
            self.rank[root_x] += 1
        
        self.count -= 1  # 连通分量减少
        return True
    
    def connected(self, x, y):
        """
        检查元素x和y是否在同一个集合中
        """
        return self.find(x) == self.find(y)
    
    def get_count(self):
        """
        获取连通分量的数量
        """
        return self.count
    
    def get_size(self, x):
        """
        获取元素x所在集合的大小
        """
        root = self.find(x)
        return self.size[root]
    
    def get_sets(self):
        """
        获取所有连通分量
        返回：字典，key为根节点，value为集合中的元素列表
        """
        sets = {}
        for i in range(len(self.parent)):
            root = self.find(i)
            if root not in sets:
                sets[root] = []
            sets[root].append(i)
        return sets
    
    def print_status(self):
        """
        打印当前并查集状态（用于调试）
        """
        print("索引:", list(range(len(self.parent))))
        print("父节点:", self.parent)
        print("秩:", self.rank)
        print("集合大小:", self.size)
        print("连通分量数量:", self.count)
        
        sets = self.get_sets()
        print("连通分量:")
        for root, elements in sets.items():
            print(f"  集合{root}: {elements}")


# 使用示例和测试
if __name__ == "__main__":
    print("=== 并查集基本用法 ===")
    
    # 1. 初始化并查集（10个元素）
    uf = UnionFind(10)
    print("初始化状态:")
    uf.print_status()
    print()
    
    # 2. 进行一些合并操作
    operations = [(0, 1), (2, 3), (4, 5), (6, 7), (8, 9),
                  (1, 2), (3, 4), (5, 6), (7, 8)]
    
    print("合并操作:")
    for i, (x, y) in enumerate(operations):
        uf.union(x, y)
        print(f"  合并 {x} 和 {y} 后，连通分量: {uf.get_count()}")
    
    print("\n最终状态:")
    uf.print_status()
    
    # 3. 测试连通性
    print("\n=== 连通性测试 ===")
    test_pairs = [(0, 4), (1, 7), (2, 9), (3, 8), (0, 9)]
    for x, y in test_pairs:
        print(f"  {x} 和 {y} 是否连通: {uf.connected(x, y)}")
    
    # 4. 测试集合大小
    print("\n=== 集合大小测试 ===")
    for i in range(5):
        print(f"  元素 {i} 所在集合大小: {uf.get_size(i)}")
    
    # 5. 实际应用示例：朋友圈问题
    print("\n=== 实际应用：朋友圈问题 ===")
    print("假设有10个人（0-9），朋友关系如下:")
    friendships = [(0, 1), (1, 2), (3, 4), (4, 5), (6, 7), (7, 8), (8, 9)]
    
    uf_friends = UnionFind(10)
    for a, b in friendships:
        uf_friends.union(a, b)
    
    print(f"朋友圈数量: {uf_friends.get_count()}")
    circles = uf_friends.get_sets()
    print("每个朋友圈的成员:")
    for i, (root, members) in enumerate(circles.items()):
        print(f"  朋友圈{i+1}: {members}")



```
:::

**实际应用：** 

::: code-group
```cpp
// 实际应用：朋友圈问题
void friendCirclesExample() {
    cout << "\n=== 实际应用：朋友圈问题 ===" << endl;
    
    int n = 10;  // 10个人
    vector<pair<int, int>> friendships = {
        {0, 1}, {1, 2}, {3, 4}, {4, 5}, {6, 7}, {7, 8}, {8, 9}
    };
    
    UnionFind uf(n);
    for (const auto& f : friendships) {
        uf.unionSets(f.first, f.second);
    }
    
    cout << "朋友关系:" << endl;
    for (const auto& f : friendships) {
        cout << "  " << f.first << " 和 " << f.second << " 是朋友" << endl;
    }
    
    cout << "\n朋友圈数量: " << uf.getCount() << endl;
    
    auto circles = uf.getSets();
    cout << "每个朋友圈的成员:" << endl;
    int circleNum = 1;
    for (const auto& entry : circles) {
        cout << "  朋友圈" << circleNum++ << ": ";
        for (int member : entry.second) {
            cout << member << " ";
        }
        cout << endl;
    }
}

// 实际应用：岛屿数量问题
int numIslands(vector<vector<char>>& grid) {
    if (grid.empty()) return 0;
    
    int rows = grid.size();
    int cols = grid[0].size();
    
    UnionFind uf(rows * cols);
    int waterCount = 0;
    
    // 方向：右和下
    vector<pair<int, int>> directions = {{0, 1}, {1, 0}};
    
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            if (grid[i][j] == '1') {
                int index = i * cols + j;
                
                // 检查相邻的陆地
                for (const auto& dir : directions) {
                    int ni = i + dir.first;
                    int nj = j + dir.second;
                    
                    if (ni >= 0 && ni < rows && nj >= 0 && nj < cols && grid[ni][nj] == '1') {
                        int neighborIndex = ni * cols + nj;
                        uf.unionSets(index, neighborIndex);
                    }
                }
            } else {
                waterCount++;
            }
        }
    }
    
    return uf.getCount() - waterCount;
}

void islandsExample() {
    cout << "\n=== 岛屿数量问题 ===" << endl;
    
    vector<vector<char>> grid = {
        {'1', '1', '0', '0', '0'},
        {'1', '1', '0', '0', '0'},
        {'0', '0', '1', '0', '0'},
        {'0', '0', '0', '1', '1'}
    };
    
    cout << "网格:" << endl;
    for (const auto& row : grid) {
        cout << "  ";
        for (char cell : row) {
            cout << cell << " ";
        }
        cout << endl;
    }
    
    int islands = numIslands(grid);
    cout << "岛屿数量: " << islands << endl;
}

int main() {
    // 运行测试
    friendCirclesExample();
    islandsExample();
    
    return 0;
}
```

```python
# 高级应用：解决实际问题
def num_islands(grid):
    """
    LeetCode 200：岛屿数量（使用并查集）
    """
    if not grid:
        return 0
    
    rows, cols = len(grid), len(grid[0])
    uf = UnionFind(rows * cols)
    
    # 方向：右和下（避免重复）
    directions = [(0, 1), (1, 0)]
    
    water_count = 0  # 水域数量
    
    for i in range(rows):
        for j in range(cols):
            if grid[i][j] == '1':  # 陆地
                index = i * cols + j
                # 检查右侧和下方的相邻陆地
                for dx, dy in directions:
                    ni, nj = i + dx, j + dy
                    if 0 <= ni < rows and 0 <= nj < cols and grid[ni][nj] == '1':
                        neighbor_index = ni * cols + nj
                        uf.union(index, neighbor_index)
            else:
                water_count += 1
    
    # 岛屿数量 = 连通分量数量 - 水域数量
    return uf.get_count() - water_count


# 测试岛屿数量问题
print("\n=== 岛屿数量问题 ===")
grid = [
    ['1', '1', '0', '0', '0'],
    ['1', '1', '0', '0', '0'],
    ['0', '0', '1', '0', '0'],
    ['0', '0', '0', '1', '1']
]

print("网格:")
for row in grid:
    print(" ", row)

islands = num_islands(grid)
print(f"岛屿数量: {islands}")
```


:::

**复杂度分析**

| 操作 | 普通实现 | 带路径压缩和按秩合并
|-------|----------|------------------|
| 初始化 | O(n) | O(n) |
| 查找 | O(n) | O(α(n))（近似常数） |
| 合并 | O(n) | O(α(n))（近似常数） |

α(n)：阿克曼函数的反函数，增长极慢，对于任何实际n，α(n) < 5

**适用场景**
- 连通性问题
- 最小生成树算法
- 动态连通性检查
- 等价关系维护

---

### STL容器速查表

| 容器类型 | 底层结构 | 时间复杂度(访问) | 时间复杂度(插入) | 适用场景 |
|---------|---------|------------------|------------------|----------|
| vector | 动态数组 | O(1) | 均摊O(1) | 随机访问 |
| list | 双向链表 | O(n) | O(1) | 频繁插入删除 |
| deque | 双端队列 | O(1) | O(1) | 两端操作 |
| stack | 容器适配器 | - | O(1) | LIFO操作 |
| queue | 容器适配器 | - | O(1) | FIFO操作 |
| priority_queue | 堆 | - | O(log n) | 优先级处理 |
| set/map | 平衡树 | O(log n) | O(log n) | 有序集合 |
| unordered_set/map | 哈希表 | O(1) | O(1) | 快速查找 |

---

