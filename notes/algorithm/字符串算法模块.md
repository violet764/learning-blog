# å­—ç¬¦ä¸²ç®—æ³•æ¨¡å—

**å‰ç½®çŸ¥è¯†**ï¼šæ•°æ®ç»“æ„åŸºç¡€æ€»è§ˆã€åŸºç¡€æ•°æ®ç»“æ„ã€æœç´¢ç®—æ³•

**åç»­å…³è”æ¨¡å—**ï¼šç»¼åˆåº”ç”¨ä¸è¿›é˜¶

## ğŸ“Œ æ ¸å¿ƒå®šä¹‰

å­—ç¬¦ä¸²ç®—æ³•æ˜¯å¤„ç†å­—ç¬¦ä¸²æ•°æ®çš„ä¸€ç±»ç®—æ³•ï¼Œåœ¨ç®—æ³•ç«èµ›ä¸­å æ®é‡è¦åœ°ä½ã€‚å¸¸è§çš„å­—ç¬¦ä¸²é—®é¢˜åŒ…æ‹¬æ¨¡å¼åŒ¹é…ã€å­—ç¬¦ä¸²æœç´¢ã€å‰ç¼€/åç¼€å¤„ç†ã€å›æ–‡æ£€æµ‹ç­‰ã€‚OI Wikiæä¾›äº†å®Œæ•´çš„å­—ç¬¦ä¸²ç®—æ³•ä½“ç³»ã€‚

## ğŸ” å­—ç¬¦ä¸²åŒ¹é…ç®—æ³•

### KMPç®—æ³•ï¼ˆKnuth-Morris-Prattï¼‰

#### ğŸ“Œ åŸºæœ¬æ€æƒ³
KMPç®—æ³•é€šè¿‡é¢„å¤„ç†æ¨¡å¼ä¸²ï¼Œæ„å»ºå¤±é…å‡½æ•°ï¼Œåœ¨åŒ¹é…å¤±è´¥æ—¶åˆ©ç”¨å·²åŒ¹é…çš„ä¿¡æ¯ï¼Œé¿å…ä¸»ä¸²æŒ‡é’ˆå›æº¯ã€‚

#### ğŸ”§ å‰ç¼€å‡½æ•°å®šä¹‰
ç»™å®šé•¿åº¦ä¸ºnçš„å­—ç¬¦ä¸²sï¼Œå‰ç¼€å‡½æ•°Ï€æ˜¯ä¸€ä¸ªé•¿åº¦ä¸ºnçš„æ•°ç»„ï¼š
- Ï€[i] = max{k: s[0â€¦kâˆ’1] = s[iâˆ’(kâˆ’1)â€¦i]}
- ç‰¹åˆ«çš„ï¼ŒÏ€[0] = 0

#### ğŸ’» å‰ç¼€å‡½æ•°å®ç°

```cpp
// C++å®ç°å‰ç¼€å‡½æ•°
vector<int> prefix_function(string s) {
    int n = (int)s.length();
    vector<int> pi(n);
    for (int i = 1; i < n; i++) {
        int j = pi[i - 1];
        while (j > 0 && s[i] != s[j]) {
            j = pi[j - 1];
        }
        if (s[i] == s[j]) j++;
        pi[i] = j;
    }
    return pi;
}

// Pythonå®ç°
def prefix_function(s):
    n = len(s)
    pi = [0] * n
    for i in range(1, n):
        j = pi[i - 1]
        while j > 0 and s[i] != s[j]:
            j = pi[j - 1]
        if s[i] == s[j]:
            j += 1
        pi[i] = j
    return pi
```

#### ğŸ’» KMPå­—ç¬¦ä¸²åŒ¹é…

```cpp
// ä½¿ç”¨KMPç®—æ³•æŸ¥æ‰¾æ‰€æœ‰åŒ¹é…ä½ç½®
vector<int> find_occurrences(string text, string pattern) {
    string cur = pattern + '#' + text;
    int sz1 = text.size(), sz2 = pattern.size();
    vector<int> v;
    vector<int> lps = prefix_function(cur);
    
    for (int i = sz2 + 1; i <= sz1 + sz2; i++) {
        if (lps[i] == sz2) {
            v.push_back(i - 2 * sz2);  // åŒ¹é…ä½ç½®
        }
    }
    return v;
}

# Pythonå®ç°
def find_occurrences(text, pattern):
    cur = pattern + '#' + text
    sz1, sz2 = len(text), len(pattern)
    v = []
    lps = prefix_function(cur)
    
    for i in range(sz2 + 1, sz1 + sz2 + 1):
        if lps[i] == sz2:
            v.append(i - 2 * sz2)  # åŒ¹é…ä½ç½®
    
    return v
```

#### â±ï¸ å¤æ‚åº¦åˆ†æ
- **æ—¶é—´å¤æ‚åº¦**ï¼šO(n+m)ï¼Œå…¶ä¸­næ˜¯ä¸»ä¸²é•¿åº¦ï¼Œmæ˜¯æ¨¡å¼ä¸²é•¿åº¦
- **ç©ºé—´å¤æ‚åº¦**ï¼šO(m)ï¼Œå­˜å‚¨å‰ç¼€å‡½æ•°

---

### Zå‡½æ•°ï¼ˆæ‰©å±•KMPï¼‰

#### ğŸ“Œ åŸºæœ¬å®šä¹‰
å¯¹äºå­—ç¬¦ä¸²sï¼ŒZå‡½æ•°z[i]è¡¨ç¤ºså’Œå…¶åç¼€s[i...]çš„æœ€é•¿å…¬å…±å‰ç¼€é•¿åº¦ï¼Œz[0]é€šå¸¸å®šä¹‰ä¸º0æˆ–å­—ç¬¦ä¸²é•¿åº¦ã€‚

#### ğŸ’» Zå‡½æ•°å®ç°

```cpp
vector<int> z_function(string s) {
    int n = (int)s.length();
    vector<int> z(n);
    for (int i = 1, l = 0, r = 0; i < n; ++i) {
        if (i <= r)
            z[i] = min(r - i + 1, z[i - l]);
        while (i + z[i] < n && s[z[i]] == s[i + z[i]])
            ++z[i];
        if (i + z[i] - 1 > r)
            l = i, r = i + z[i] - 1;
    }
    return z;
}

# Pythonå®ç°
def z_function(s):
    n = len(s)
    z = [0] * n
    l = r = 0
    
    for i in range(1, n):
        if i <= r:
            z[i] = min(r - i + 1, z[i - l])
        while i + z[i] < n and s[z[i]] == s[i + z[i]]:
            z[i] += 1
        if i + z[i] - 1 > r:
            l, r = i, i + z[i] - 1
    
    return z
```

#### ğŸ’» å­—ç¬¦ä¸²åŒ¹é…åº”ç”¨

```cpp
vector<int> z_pattern_matching(string text, string pattern) {
    string combined = pattern + '$' + text;
    vector<int> z = z_function(combined);
    vector<int> result;
    
    for (int i = pattern.length() + 1; i < combined.length(); i++) {
        if (z[i] == pattern.length()) {
            result.push_back(i - pattern.length() - 1);
        }
    }
    
    return result;
}
```

---

## ğŸŒ³ å­—å…¸æ ‘ï¼ˆTrieï¼‰

#### ğŸ“Œ åŸºæœ¬æ€æƒ³
å­—å…¸æ ‘ï¼Œåˆç§°å‰ç¼€æ ‘ï¼Œæ˜¯ä¸€ç§ä¸“é—¨ç”¨äºå¤„ç†å­—ç¬¦ä¸²çš„æ ‘å½¢æ•°æ®ç»“æ„ï¼Œèƒ½å¤Ÿé«˜æ•ˆåœ°å­˜å‚¨å’ŒæŸ¥æ‰¾å­—ç¬¦ä¸²é›†åˆã€‚

#### ğŸ”§ å­˜å‚¨åŸç†
- **è·¯å¾„å­˜å‚¨**ï¼šæ¯ä¸ªè¾¹ä»£è¡¨ä¸€ä¸ªå­—ç¬¦ï¼Œä»æ ¹åˆ°èŠ‚ç‚¹çš„è·¯å¾„æ„æˆå­—ç¬¦ä¸²
- **å‰ç¼€å…±äº«**ï¼šå…·æœ‰ç›¸åŒå‰ç¼€çš„å­—ç¬¦ä¸²å…±äº«è·¯å¾„ä¸Šçš„èŠ‚ç‚¹
- **æ ‡è®°ç»ˆæ­¢**ï¼šä½¿ç”¨ç‰¹æ®Šæ ‡è®°è¡¨ç¤ºå­—ç¬¦ä¸²çš„ç»“æŸä½ç½®

#### ğŸ’» åŸºæœ¬å®ç°

```cpp
class Trie {
private:
    struct TrieNode {
        TrieNode* children[26];
        bool isEnd;
        
        TrieNode() : isEnd(false) {
            for (int i = 0; i < 26; i++) {
                children[i] = nullptr;
            }
        }
    };
    
    TrieNode* root;
    
public:
    Trie() {
        root = new TrieNode();
    }
    
    void insert(string word) {
        TrieNode* curr = root;
        for (char c : word) {
            int index = c - 'a';
            if (!curr->children[index]) {
                curr->children[index] = new TrieNode();
            }
            curr = curr->children[index];
        }
        curr->isEnd = true;
    }
    
    bool search(string word) {
        TrieNode* curr = root;
        for (char c : word) {
            int index = c - 'a';
            if (!curr->children[index]) {
                return false;
            }
            curr = curr->children[index];
        }
        return curr->isEnd;
    }
    
    bool startsWith(string prefix) {
        TrieNode* curr = root;
        for (char c : prefix) {
            int index = c - 'a';
            if (!curr->children[index]) {
                return false;
            }
            curr = curr->children[index];
        }
        return true;
    }
};

# Pythonå®ç°
class Trie:
    class TrieNode:
        def __init__(self):
            self.children = {}
            self.is_end = False
    
    def __init__(self):
        self.root = self.TrieNode()
    
    def insert(self, word):
        curr = self.root
        for c in word:
            if c not in curr.children:
                curr.children[c] = self.TrieNode()
            curr = curr.children[c]
        curr.is_end = True
    
    def search(self, word):
        curr = self.root
        for c in word:
            if c not in curr.children:
                return False
            curr = curr.children[c]
        return curr.is_end
    
    def starts_with(self, prefix):
        curr = self.root
        for c in prefix:
            if c not in curr.children:
                return False
            curr = curr.children[c]
        return True
```

#### â±ï¸ å¤æ‚åº¦åˆ†æ
| æ“ä½œ | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ |
|------|------------|------------|
| æ’å…¥ | O(m) | O(m) |
| æŸ¥æ‰¾ | O(m) | - |
| å‰ç¼€æŸ¥è¯¢ | O(m) | - |

*æ³¨ï¼šmä¸ºå­—ç¬¦ä¸²é•¿åº¦*

---

## ğŸ”Œ ACè‡ªåŠ¨æœº

#### ğŸ“Œ åŸºæœ¬æ€æƒ³
ACè‡ªåŠ¨æœºï¼ˆAho-Corasickç®—æ³•ï¼‰æ˜¯KMPç®—æ³•åœ¨å¤šæ¨¡å¼åŒ¹é…ä¸Šçš„æ‰©å±•ï¼Œä½¿ç”¨Trieæ ‘æ„å»ºè‡ªåŠ¨æœºï¼Œå®ç°å¤šæ¨¡å¼ä¸²çš„åŒæ—¶åŒ¹é…ã€‚

#### ğŸ”§ æ„å»ºè¿‡ç¨‹
1. **æ„å»ºTrieæ ‘**ï¼šå°†æ‰€æœ‰æ¨¡å¼ä¸²æ’å…¥Trie
2. **æ„å»ºå¤±é…æŒ‡é’ˆ**ï¼šä½¿ç”¨BFSæ„å»ºå¤±é…å‡½æ•°
3. **è¾“å‡ºæŒ‡é’ˆ**ï¼šæ ‡è®°å¯èƒ½çš„åŒ¹é…ç»“æŸä½ç½®

#### ğŸ’» ACè‡ªåŠ¨æœºå®ç°

```cpp
class AhoCorasick {
private:
    struct Node {
        Node* children[26];
        Node* fail;
        vector<int> outputs;
        
        Node() {
            for (int i = 0; i < 26; i++) {
                children[i] = nullptr;
            }
            fail = nullptr;
        }
    };
    
    Node* root;
    
public:
    AhoCorasick() {
        root = new Node();
    }
    
    void insert(const string& pattern, int id) {
        Node* curr = root;
        for (char c : pattern) {
            int index = c - 'a';
            if (!curr->children[index]) {
                curr->children[index] = new Node();
            }
            curr = curr->children[index];
        }
        curr->outputs.push_back(id);
    }
    
    void build() {
        queue<Node*> q;
        
        // ç¬¬ä¸€å±‚èŠ‚ç‚¹çš„å¤±é…æŒ‡é’ˆæŒ‡å‘æ ¹èŠ‚ç‚¹
        for (int i = 0; i < 26; i++) {
            if (root->children[i]) {
                root->children[i]->fail = root;
                q.push(root->children[i]);
            }
        }
        
        // BFSæ„å»ºå¤±é…æŒ‡é’ˆ
        while (!q.empty()) {
            Node* curr = q.front();
            q.pop();
            
            for (int i = 0; i < 26; i++) {
                Node* child = curr->children[i];
                if (child) {
                    Node* fail = curr->fail;
                    
                    // æ‰¾åˆ°æœ€é•¿çš„å¯åŒ¹é…åç¼€
                    while (fail && !fail->children[i]) {
                        fail = fail->fail;
                    }
                    
                    child->fail = fail ? fail->children[i] : root;
                    child->outputs.insert(child->outputs.end(),
                                       child->fail->outputs.begin(),
                                       child->fail->outputs.end());
                    q.push(child);
                }
            }
        }
    }
    
    vector<int> search(const string& text) {
        vector<int> result;
        Node* curr = root;
        
        for (char c : text) {
            int index = c - 'a';
            
            // å¤±é…æ—¶è·³è½¬
            while (curr && !curr->children[index]) {
                curr = curr->fail;
            }
            
            curr = curr ? curr->children[index] : root;
            
            // è®°å½•æ‰€æœ‰åŒ¹é…çš„æ¨¡å¼ä¸²
            for (int id : curr->outputs) {
                result.push_back(id);
            }
        }
        
        return result;
    }
};

# Pythonå®ç°
from collections import deque

class AhoCorasick:
    class Node:
        def __init__(self):
            self.children = {}
            self.fail = None
            self.outputs = []
    
    def __init__(self):
        self.root = self.Node()
    
    def insert(self, pattern, id):
        curr = self.root
        for c in pattern:
            if c not in curr.children:
                curr.children[c] = self.Node()
            curr = curr.children[c]
        curr.outputs.append(id)
    
    def build(self):
        q = deque()
        
        # ç¬¬ä¸€å±‚èŠ‚ç‚¹çš„å¤±é…æŒ‡é’ˆæŒ‡å‘æ ¹èŠ‚ç‚¹
        for c, child in self.root.children.items():
            child.fail = self.root
            q.append(child)
        
        # BFSæ„å»ºå¤±é…æŒ‡é’ˆ
        while q:
            curr = q.popleft()
            
            for c, child in curr.children.items():
                fail = curr.fail
                
                # æ‰¾åˆ°æœ€é•¿çš„å¯åŒ¹é…åç¼€
                while fail and c not in fail.children:
                    fail = fail.fail
                
                child.fail = fail.children[c] if fail else self.root
                child.outputs.extend(child.fail.outputs)
                q.append(child)
    
    def search(self, text):
        result = []
        curr = self.root
        
        for c in text:
            # å¤±é…æ—¶è·³è½¬
            while curr and c not in curr.children:
                curr = curr.fail
            
            curr = curr.children[c] if curr else self.root
            
            # è®°å½•æ‰€æœ‰åŒ¹é…çš„æ¨¡å¼ä¸²
            result.extend(curr.outputs)
        
        return result
```

#### â±ï¸ å¤æ‚åº¦åˆ†æ
- **æ„å»ºæ—¶é—´**ï¼šO(æ€»æ¨¡å¼ä¸²é•¿åº¦ * å­—ç¬¦é›†å¤§å°)
- **åŒ¹é…æ—¶é—´**ï¼šO(æ–‡æœ¬é•¿åº¦ + åŒ¹é…æ•°)
- **ç©ºé—´å¤æ‚åº¦**ï¼šO(æ€»æ¨¡å¼ä¸²é•¿åº¦)

---

## ğŸ“ åç¼€æ•°ç»„

#### ğŸ“Œ åŸºæœ¬å®šä¹‰
åç¼€æ•°ç»„æ˜¯å­—ç¬¦ä¸²æ‰€æœ‰åç¼€æŒ‰å­—å…¸åºæ’åºåï¼Œæ¯ä¸ªåç¼€çš„èµ·å§‹ä½ç½®ç»„æˆçš„æ•°ç»„ã€‚è¾…åŠ©çš„rankæ•°ç»„è¡¨ç¤ºæ¯ä¸ªåç¼€çš„æ’åã€‚

#### ğŸ’» åç¼€æ•°ç»„å®ç°ï¼ˆO(n log n)å€å¢ç®—æ³•ï¼‰

```cpp
class SuffixArray {
private:
    string s;
    int n;
    vector<int> sa, rank, tmp;
    
public:
    SuffixArray(const string& str) : s(str), n(str.length()) {
        sa.resize(n);
        rank.resize(n);
        tmp.resize(n);
        
        // åˆå§‹æ’åºï¼šæŒ‰å•ä¸ªå­—ç¬¦
        for (int i = 0; i < n; i++) {
            sa[i] = i;
            rank[i] = s[i];
        }
        
        // å€å¢
        for (int k = 1; k < n; k <<= 1) {
            auto cmp = [this, k](int i, int j) {
                if (rank[i] != rank[j]) {
                    return rank[i] < rank[j];
                }
                int ri = (i + k < n) ? rank[i + k] : -1;
                int rj = (j + k < n) ? rank[j + k] : -1;
                return ri < rj;
            };
            
            sort(sa.begin(), sa.end(), cmp);
            
            // é‡æ–°è®¡ç®—rank
            tmp[sa[0]] = 0;
            for (int i = 1; i < n; i++) {
                tmp[sa[i]] = tmp[sa[i-1]] + (cmp(sa[i-1], sa[i]) ? 1 : 0);
            }
            rank = tmp;
            
            if (rank[sa[n-1]] == n-1) break;  // æ‰€æœ‰rankéƒ½ä¸ç›¸åŒ
        }
    }
    
    vector<int> getSA() { return sa; }
    vector<int> getRank() { return rank; }
};

# Pythonå®ç°
class SuffixArray:
    def __init__(self, s):
        self.s = s
        self.n = len(s)
        self.sa = list(range(self.n))
        self.rank = [ord(c) for c in s]
        self.tmp = [0] * self.n
        
        k = 1
        while k < self.n:
            self.sa.sort(key=lambda x: (
                self.rank[x], 
                self.rank[x + k] if x + k < self.n else -1
            ))
            
            self.tmp[self.sa[0]] = 0
            for i in range(1, self.n):
                prev, curr = self.sa[i-1], self.sa[i]
                self.tmp[curr] = self.tmp[prev] + (
                    (self.rank[prev], self.rank[prev + k] if prev + k < self.n else -1) <
                    (self.rank[curr], self.rank[curr + k] if curr + k < self.n else -1)
                )
            
            self.rank = self.tmp[:]
            if self.rank[self.sa[-1]] == self.n - 1:
                break
            k <<= 1
```

#### ğŸ’» Heightæ•°ç»„å®ç°

```cpp
vector<int> buildHeight(const string& s, const vector<int>& sa) {
    int n = s.length();
    vector<int> rank(n), height(n);
    
    // æ„å»ºrankæ•°ç»„
    for (int i = 0; i < n; i++) {
        rank[sa[i]] = i;
    }
    
    // è®¡ç®—heightæ•°ç»„
    int h = 0;
    for (int i = 0; i < n; i++) {
        if (rank[i] > 0) {
            int j = sa[rank[i] - 1];
            while (i + h < n && j + h < n && s[i + h] == s[j + h]) {
                h++;
            }
            height[rank[i]] = h;
            if (h > 0) h--;
        }
    }
    
    return height;
}

# Pythonå®ç°
def build_height(s, sa):
    n = len(s)
    rank = [0] * n
    height = [0] * n
    
    # æ„å»ºrankæ•°ç»„
    for i, pos in enumerate(sa):
        rank[pos] = i
    
    # è®¡ç®—heightæ•°ç»„
    h = 0
    for i in range(n):
        if rank[i] > 0:
            j = sa[rank[i] - 1]
            while i + h < n and j + h < n and s[i + h] == s[j + h]:
                h += 1
            height[rank[i]] = h
            if h > 0:
                h -= 1
    
    return height
```

#### â±ï¸ å¤æ‚åº¦åˆ†æ
- **åç¼€æ•°ç»„æ„å»º**ï¼šO(n log n)
- **Heightæ•°ç»„æ„å»º**ï¼šO(n)
- **ç©ºé—´å¤æ‚åº¦**ï¼šO(n)

---

## ğŸ”§ å­—ç¬¦ä¸²å“ˆå¸Œ

#### ğŸ“Œ åŸºæœ¬æ€æƒ³
é€šè¿‡å“ˆå¸Œå‡½æ•°å°†å­—ç¬¦ä¸²æ˜ å°„ä¸ºæ•´æ•°ï¼Œç”¨äºå¿«é€Ÿåˆ¤æ–­å­—ç¬¦ä¸²ç›¸ç­‰æ€§å’Œæ¯”è¾ƒå­—å…¸åºã€‚

#### ğŸ’» å­—ç¬¦ä¸²å“ˆå¸Œå®ç°

```cpp
class StringHash {
private:
    vector<long long> prefix, power;
    long long base, mod;
    
public:
    StringHash(const string& s, long long b = 911382629, long long m = 1e9+7) 
        : base(b), mod(m) {
        int n = s.length();
        prefix.resize(n + 1, 0);
        power.resize(n + 1, 1);
        
        for (int i = 0; i < n; i++) {
            prefix[i + 1] = (prefix[i] * base + s[i]) % mod;
            power[i + 1] = (power[i] * base) % mod;
        }
    }
    
    // è·å–å­ä¸²[l, r)çš„å“ˆå¸Œå€¼
    long long getHash(int l, int r) {
        return (prefix[r] - prefix[l] * power[r - l] % mod + mod) % mod;
    }
    
    // è·å–æ•´ä¸ªå­—ç¬¦ä¸²çš„å“ˆå¸Œå€¼
    long long getHash() {
        return getHash(0, prefix.size() - 1);
    }
};

# Pythonå®ç°
class StringHash:
    def __init__(self, s, base=911382629, mod=10**9+7):
        self.base = base
        self.mod = mod
        self.n = len(s)
        self.prefix = [0] * (self.n + 1)
        self.power = [1] * (self.n + 1)
        
        for i in range(self.n):
            self.prefix[i + 1] = (self.prefix[i] * base + ord(s[i])) % self.mod
            self.power[i + 1] = (self.power[i] * base) % self.mod
    
    def get_hash(self, l, r):
        return (self.prefix[r] - self.prefix[l] * self.power[r - l]) % self.mod
    
    def get_full_hash(self):
        return self.get_hash(0, self.n)
```

#### ğŸ’¡ åŒå“ˆå¸Œé˜²å†²çª

```cpp
class DoubleHash {
private:
    StringHash h1, h2;
    
public:
    DoubleHash(const string& s) 
        : h1(s, 911382629, 1000000007), 
          h2(s, 972663749, 1000000009) {}
    
    pair<long long, long long> getHash(int l, int r) {
        return {h1.getHash(l, r), h2.getHash(l, r)};
    }
};
```

---

## ğŸ“Š å­—ç¬¦ä¸²ç®—æ³•å¯¹æ¯”

| ç®—æ³• | é€‚ç”¨åœºæ™¯ | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | ä¼˜åŠ¿ | åŠ£åŠ¿ |
|------|----------|------------|------------|------|------|
| **KMP** | å•æ¨¡å¼åŒ¹é… | O(n+m) | O(m) | çº¿æ€§æ—¶é—´ | é¢„å¤„ç†å¼€é”€ |
| **Zå‡½æ•°** | å¤šå­—ç¬¦ä¸²å¤„ç† | O(n) | O(n) | ç®€å•é«˜æ•ˆ | åº”ç”¨åœºæ™¯æœ‰é™ |
| **å­—å…¸æ ‘** | å‰ç¼€æŸ¥è¯¢ | O(å­—ç¬¦ä¸²é•¿åº¦) | O(æ€»é•¿åº¦) | å‰ç¼€å…±äº« | ç©ºé—´æ¶ˆè€—å¤§ |
| **ACè‡ªåŠ¨æœº** | å¤šæ¨¡å¼åŒ¹é… | O(n+åŒ¹é…æ•°) | O(æ€»é•¿åº¦) | åŒæ—¶åŒ¹é…å¤šæ¨¡å¼ | æ„å»ºå¤æ‚ |
| **åç¼€æ•°ç»„** | å¤æ‚å­—ç¬¦ä¸²æ“ä½œ | O(n log n) | O(n) | åŠŸèƒ½å¼ºå¤§ | å®ç°å¤æ‚ |
| **å­—ç¬¦ä¸²å“ˆå¸Œ** | å¿«é€Ÿç›¸ç­‰åˆ¤æ–­ | O(1)æŸ¥è¯¢ | O(n) | æŸ¥è¯¢æå¿« | å†²çªé£é™© |

---

## ğŸ¯ å®æˆ˜åº”ç”¨æŠ€å·§

### 1. å­—ç¬¦ä¸²å‘¨æœŸæ€§æ£€æµ‹

```cpp
// æ£€æŸ¥å­—ç¬¦ä¸²æ˜¯å¦ç”±æŸä¸ªå­ä¸²é‡å¤æ„æˆ
bool isRepeated(const string& s) {
    vector<int> pi = prefix_function(s);
    int n = s.length();
    int period = n - pi[n - 1];
    return n % period == 0 && period != n;
}
```

### 2. æœ€å°è¡¨ç¤ºæ³•

```cpp
int minRepresentation(const string& s) {
    string ss = s + s;
    int n = s.length();
    int i = 0, j = 1, k = 0;
    
    while (i < n && j < n && k < n) {
        char a = ss[i + k], b = ss[j + k];
        if (a == b) {
            k++;
            continue;
        }
        if (a > b) {
            i = i + k + 1;
            if (i <= j) i = j + 1;
        } else {
            j = j + k + 1;
            if (j <= i) j = i + 1;
        }
        k = 0;
    }
    
    return min(i, j);
}
```

### 3. å›æ–‡æ£€æµ‹ï¼ˆManacherç®—æ³•ï¼‰

```cpp
class Manacher {
private:
    string s;
    vector<int> d1, d2;  // å¥‡æ•°é•¿åº¦å’Œå¶æ•°é•¿åº¦çš„å›æ–‡åŠå¾„
    
public:
    Manacher(const string& str) : s(str) {
        int n = s.length();
        d1.resize(n);
        d2.resize(n);
        
        // å¥‡æ•°é•¿åº¦å›æ–‡
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 1 : min(d1[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < n && s[i - k] == s[i + k]) k++;
            d1[i] = k--;
            if (i + k > r) {
                l = i - k;
                r = i + k;
            }
        }
        
        // å¶æ•°é•¿åº¦å›æ–‡
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : min(d2[l + r - i + 1], r - i + 1);
            while (0 <= i - k - 1 && i + k < n && s[i - k - 1] == s[i + k]) k++;
            d2[i] = k--;
            if (i + k > r) {
                l = i - k - 1;
                r = i + k;
            }
        }
    }
    
    bool isPalindrome(int l, int r) {
        int len = r - l + 1;
        if (len % 2 == 1) {
            int center = (l + r) / 2;
            return d1[center] >= len / 2 + 1;
        } else {
            int center = (l + r) / 2 + 1;
            return d2[center] >= len / 2;
        }
    }
};
```

---

## ğŸ’¡ å¸¸è§ä¼˜åŒ–æŠ€å·§

### 1. é¢„å¤„ç†ä¼˜åŒ–
- **å¤šæ¨¡å¼åŒ¹é…é¢„å¤„ç†**ï¼šä½¿ç”¨ACè‡ªåŠ¨æœºè€Œä¸æ˜¯å¤šæ¬¡KMP
- **å“ˆå¸Œé¢„è®¡ç®—**ï¼šæå‰è®¡ç®—å‰ç¼€å“ˆå¸Œå€¼
- **å­—ç¬¦é›†å‹ç¼©**ï¼šå°†å­—ç¬¦èŒƒå›´å‹ç¼©åˆ°è¾ƒå°å€¼

### 2. ç©ºé—´ä¼˜åŒ–
- **åŠ¨æ€Trie**ï¼šåªåˆ›å»ºå¿…è¦çš„èŠ‚ç‚¹
- **åç¼€æ•°ç»„å‹ç¼©å­˜å‚¨**ï¼šä½¿ç”¨intè€Œélong long
- **å“ˆå¸Œå†²çªå¤„ç†**ï¼šå¼€æ”¾å¯»å€æ³•æ¯”é“¾åœ°å€æ³•æ›´ç¼“å­˜å‹å¥½

### 3. å¸¸æ•°ä¼˜åŒ–
- **é¿å…é¢‘ç¹å‡½æ•°è°ƒç”¨**ï¼šå†…è”å…³é”®å‡½æ•°
- **ä½¿ç”¨ä½è¿ç®—**ï¼šæŸäº›æ“ä½œå¯ä»¥ç”¨ä½è¿ç®—åŠ é€Ÿ
- **å‡å°‘å†…å­˜è®¿é—®**ï¼šåˆç†ç»„ç»‡æ•°æ®ç»“æ„

---

## ğŸ“ æ ¸å¿ƒè¦ç‚¹é€Ÿè®°

1. KMPç®—æ³•é€šè¿‡å‰ç¼€å‡½æ•°é¿å…ä¸»ä¸²æŒ‡é’ˆå›æº¯ï¼Œå®ç°çº¿æ€§æ—¶é—´åŒ¹é…
2. å­—å…¸æ ‘é€‚åˆå‰ç¼€ç›¸å…³æ“ä½œï¼Œå¤©ç„¶æ”¯æŒå‰ç¼€åŒ¹é…
3. ACè‡ªåŠ¨æœºæ˜¯å¤šæ¨¡å¼åŒ¹é…çš„æ ‡å‡†è§£å†³æ–¹æ¡ˆ
4. åç¼€æ•°ç»„æ˜¯å­—ç¬¦ä¸²å¤„ç†çš„åŸºç¡€æ•°æ®ç»“æ„ï¼ŒåŠŸèƒ½å¼ºå¤§
5. å­—ç¬¦ä¸²å“ˆå¸Œæä¾›O(1)æ—¶é—´çš„ç›¸ç­‰åˆ¤æ–­ï¼Œä½†éœ€è¦æ³¨æ„å†²çª
6. ä¸åŒçš„å­—ç¬¦ä¸²ç®—æ³•é€‚ç”¨äºä¸åŒçš„åœºæ™¯ï¼Œéœ€è¦æ ¹æ®é—®é¢˜ç‰¹ç‚¹é€‰æ‹©

## ğŸ“š æ¨¡å—å†…è‡ªæµ‹é¢˜

### é—®é¢˜1
KMPç®—æ³•ä¸­ï¼Œå‰ç¼€å‡½æ•°Ï€[i]è¡¨ç¤ºä»€ä¹ˆï¼Ÿ
A. ä»¥iå¼€å¤´çš„æœ€é•¿å‰ç¼€é•¿åº¦  
B. å‰iä¸ªå­—ç¬¦ä¸­æœ€é•¿ç›¸ç­‰å‰åç¼€çš„é•¿åº¦  
C. ç¬¬iä¸ªå­—ç¬¦å‡ºç°çš„æ¬¡æ•°  
D. ä»¥iç»“å°¾çš„æœ€é•¿åç¼€é•¿åº¦

**è§£æ**ï¼šB. å‰ç¼€å‡½æ•°Ï€[i]è¡¨ç¤ºå­ä¸²s[0â€¦i]çš„æœ€é•¿ç›¸ç­‰çœŸå‰ç¼€ä¸çœŸåç¼€çš„é•¿åº¦ã€‚

### é—®é¢˜2
å­—å…¸æ ‘ç›¸æ¯”å“ˆå¸Œè¡¨çš„ä¸»è¦ä¼˜åŠ¿æ˜¯ï¼Ÿ
A. æ’å…¥å’ŒæŸ¥æ‰¾æ›´å¿«  
B. æ”¯æŒå‰ç¼€åŒ¹é…  
C. ç©ºé—´ä½¿ç”¨æ›´å°‘  
D. å®ç°æ›´ç®€å•

**è§£æ**ï¼šB. å­—å…¸æ ‘å¤©ç„¶æ”¯æŒå‰ç¼€åŒ¹é…æ“ä½œï¼Œè¿™æ˜¯å“ˆå¸Œè¡¨éš¾ä»¥é«˜æ•ˆå®ç°çš„åŠŸèƒ½ã€‚

### é—®é¢˜3
ACè‡ªåŠ¨æœºä¸»è¦ç”¨äºè§£å†³ä»€ä¹ˆé—®é¢˜ï¼Ÿ
A. å•ä¸ªæ¨¡å¼ä¸²åŒ¹é…  
B. å¤šä¸ªæ¨¡å¼ä¸²åŒæ—¶åŒ¹é…  
C. æœ€é•¿å…¬å…±å­ä¸²  
D. å­—ç¬¦ä¸²ç›¸ä¼¼åº¦è®¡ç®—

**è§£æ**ï¼šB. ACè‡ªåŠ¨æœºæ˜¯KMPç®—æ³•åœ¨å¤šæ¨¡å¼åŒ¹é…ä¸Šçš„æ‰©å±•ï¼Œèƒ½å¤ŸåŒæ—¶åœ¨æ–‡æœ¬ä¸­æœç´¢å¤šä¸ªæ¨¡å¼ä¸²ã€‚

### é—®é¢˜4
åç¼€æ•°ç»„çš„sa[i]è¡¨ç¤ºä»€ä¹ˆï¼Ÿ
A. æ’åä¸ºiçš„åç¼€ä½ç½®  
B. ç¬¬iä¸ªå­—ç¬¦çš„åç¼€æ’å  
C. ç¬¬iä¸ªå­—ç¬¦çš„ASCIIå€¼  
D. é•¿åº¦ä¸ºiçš„å­ä¸²æ•°é‡

**è§£æ**ï¼šA. sa[i]è¡¨ç¤ºå°†æ‰€æœ‰åç¼€æ’åºåç¬¬iå°çš„åç¼€çš„èµ·å§‹ä½ç½®ï¼Œä¹Ÿç§°ä¸ºåç¼€æ•°ç»„ã€‚

### é—®é¢˜5
å­—ç¬¦ä¸²å“ˆå¸Œçš„ä¸»è¦åº”ç”¨åœºæ™¯æ˜¯ï¼Ÿ
A. ç²¾ç¡®çš„å­—ç¬¦ä¸²ç›¸ç­‰åˆ¤æ–­  
B. å­—å…¸åºæ¯”è¾ƒ  
C. å¿«é€Ÿçš„ç›¸ç­‰æ€§æµ‹è¯•  
D. å­—ç¬¦ä¸²å‹ç¼©å­˜å‚¨

**è§£æ**ï¼šC. å­—ç¬¦ä¸²å“ˆå¸Œä¸»è¦ç”¨äºå¿«é€Ÿçš„ç›¸ç­‰æ€§æµ‹è¯•ï¼Œå°†å­—ç¬¦ä¸²æ¯”è¾ƒè½¬æ¢ä¸ºæ•´æ•°æ¯”è¾ƒï¼Œå¤§å¤§æé«˜é€Ÿåº¦ã€‚

---

*æœ¬ç¬”è®°åŸºäºOI-Wikiå­—ç¬¦ä¸²ç®—æ³•å†…å®¹æ•´ç†ï¼Œé€‚ç”¨äºç®—æ³•ç«èµ›å­¦ä¹ ä¸å¤ä¹ ã€‚*