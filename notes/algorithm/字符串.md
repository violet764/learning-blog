# 字符串算法模块

字符串算法是处理字符串数据的一类算法。常见的字符串问题包括模式匹配、字符串搜索、前缀/后缀处理、回文检测等。

## 字符串匹配算法

### KMP算法  

**基本思想**
KMP算法通过预处理模式串，构建失配函数，在匹配失败时利用已匹配的信息，避免主串指针回溯。

<KMPSearch />

**前缀函数定义**

给定长度为n的字符串s，前缀函数π是一个长度为n的数组：
- `π[i] = max{k: s[0…k−1] = s[i−(k−1)…i]}`
- - 特别的，`π[0] = 0`

**前缀函数实现**  
::: code-group
```cpp
// C++实现前缀函数
vector<int> prefix_function(string s) {
    int n = (int)s.length();
    vector<int> pi(n);
    for (int i = 1; i < n; i++) {
        int j = pi[i - 1];
        while (j > 0 && s[i] != s[j]) {
            j = pi[j - 1];
        }
        if (s[i] == s[j]) j++;
        pi[i] = j;
    }
    return pi;
}
```
```python
// Python实现
def prefix_function(s):
    n = len(s)
    pi = [0] * n
    for i in range(1, n):
        j = pi[i - 1]
        while j > 0 and s[i] != s[j]:
            j = pi[j - 1]
        if s[i] == s[j]:
            j += 1
        pi[i] = j
    return pi
```
:::
**KMP字符串匹配**
::: code-group
```cpp
// 使用KMP算法查找所有匹配位置
vector<int> find_occurrences(string text, string pattern) {
    string cur = pattern + '#' + text;
    int sz1 = text.size(), sz2 = pattern.size();
    vector<int> v;
    vector<int> lps = prefix_function(cur);
    
    for (int i = sz2 + 1; i <= sz1 + sz2; i++) {
        if (lps[i] == sz2) {
            v.push_back(i - 2 * sz2);  // 匹配位置
        }
    }
    return v;
}
```
```python
# Python实现
def find_occurrences(text, pattern):
    cur = pattern + '#' + text
    sz1, sz2 = len(text), len(pattern)
    v = []
    lps = prefix_function(cur)
    
    for i in range(sz2 + 1, sz1 + sz2 + 1):
        if lps[i] == sz2:
            v.append(i - 2 * sz2)  # 匹配位置
    
    return v
```
:::

**复杂度分析**
- **时间复杂度**：O(n+m)，其中n是主串长度，m是模式串长度
- **空间复杂度**：O(m)，存储前缀函数
---
### Z函数（扩展KMP）
对于字符串s，Z函数z[i]表示s和其后缀s[i...]的最长公共前缀长度，z[0]通常定义为0或字符串长度。

**Z函数实现**
::: code-group
```cpp
vector<int> z_function(string s) {
    int n = (int)s.length();
    vector<int> z(n);
    for (int i = 1, l = 0, r = 0; i < n; ++i) {
        if (i <= r)
            z[i] = min(r - i + 1, z[i - l]);
        while (i + z[i] < n && s[z[i]] == s[i + z[i]])
            ++z[i];
        if (i + z[i] - 1 > r)
            l = i, r = i + z[i] - 1;
    }
    return z;
}
```
```python
# Python实现
def z_function(s):
    n = len(s)
    z = [0] * n
    l = r = 0
    
    for i in range(1, n):
        if i <= r:
            z[i] = min(r - i + 1, z[i - l])
        while i + z[i] < n and s[z[i]] == s[i + z[i]]:
            z[i] += 1
        if i + z[i] - 1 > r:
            l, r = i, i + z[i] - 1
    
    return z
```
:::
**字符串匹配应用**
::: code-group
```cpp
vector<int> z_pattern_matching(string text, string pattern) {
    string combined = pattern + '$' + text;
    vector<int> z = z_function(combined);
    vector<int> result;
    
    for (int i = pattern.length() + 1; i < combined.length(); i++) {
        if (z[i] == pattern.length()) {
            result.push_back(i - pattern.length() - 1);
        }
    }
    
    return result;
}
```
:::

---

## 字典树（Trie）

**基本思想**
字典树，又称前缀树，是一种专门用于处理字符串的树形数据结构，能够高效地存储和查找字符串集合。

**存储原理**
- **路径存储**：每个边代表一个字符，从根到节点的路径构成字符串
- **前缀共享**：具有相同前缀的字符串共享路径上的节点
- **标记终止**：使用特殊标记表示字符串的结束位置

**基本实现**
::: code-group
```cpp
class Trie {
private:
    struct TrieNode {
        TrieNode* children[26];
        bool isEnd;
        
        TrieNode() : isEnd(false) {
            for (int i = 0; i < 26; i++) {
                children[i] = nullptr;
            }
        }
    };
    
    TrieNode* root;
    
public:
    Trie() {
        root = new TrieNode();
    }
    
    void insert(string word) {
        TrieNode* curr = root;
        for (char c : word) {
            int index = c - 'a';
            if (!curr->children[index]) {
                curr->children[index] = new TrieNode();
            }
            curr = curr->children[index];
        }
        curr->isEnd = true;
    }
    
    bool search(string word) {
        TrieNode* curr = root;
        for (char c : word) {
            int index = c - 'a';
            if (!curr->children[index]) {
                return false;
            }
            curr = curr->children[index];
        }
        return curr->isEnd;
    }
    
    bool startsWith(string prefix) {
        TrieNode* curr = root;
        for (char c : prefix) {
            int index = c - 'a';
            if (!curr->children[index]) {
                return false;
            }
            curr = curr->children[index];
        }
        return true;
    }
};
```
```python
# Python实现
class Trie:
    class TrieNode:
        def __init__(self):
            self.children = {}
            self.is_end = False
    
    def __init__(self):
        self.root = self.TrieNode()
    
    def insert(self, word):
        curr = self.root
        for c in word:
            if c not in curr.children:
                curr.children[c] = self.TrieNode()
            curr = curr.children[c]
        curr.is_end = True
    
    def search(self, word):
        curr = self.root
        for c in word:
            if c not in curr.children:
                return False
            curr = curr.children[c]
        return curr.is_end
    
    def starts_with(self, prefix):
        curr = self.root
        for c in prefix:
            if c not in curr.children:
                return False
            curr = curr.children[c]
        return True
```
:::

**复杂度分析**
| 操作 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| 插入 | O(m) | O(m) |
| 查找 | O(m) | - |
| 前缀查询 | O(m) | - |

*注：m为字符串长度*

---

## AC自动机

**基本思想**
AC自动机（Aho-Corasick算法）是KMP算法在多模式匹配上的扩展，使用Trie树构建自动机，实现多模式串的同时匹配。

**构建过程**
1. **构建Trie树**：将所有模式串插入Trie
2. **构建失配指针**：使用BFS构建失配函数
3. **输出指针**：标记可能的匹配结束位置

**AC自动机实现**
::: code-group
```cpp
class AhoCorasick {
private:
    struct Node {
        Node* children[26];
        Node* fail;
        vector<int> outputs;
        
        Node() {
            for (int i = 0; i < 26; i++) {
                children[i] = nullptr;
            }
            fail = nullptr;
        }
    };
    
    Node* root;
    
public:
    AhoCorasick() {
        root = new Node();
    }
    
    void insert(const string& pattern, int id) {
        Node* curr = root;
        for (char c : pattern) {
            int index = c - 'a';
            if (!curr->children[index]) {
                curr->children[index] = new Node();
            }
            curr = curr->children[index];
        }
        curr->outputs.push_back(id);
    }
    
    void build() {
        queue<Node*> q;
        
        // 第一层节点的失配指针指向根节点
        for (int i = 0; i < 26; i++) {
            if (root->children[i]) {
                root->children[i]->fail = root;
                q.push(root->children[i]);
            }
        }
        
        // BFS构建失配指针
        while (!q.empty()) {
            Node* curr = q.front();
            q.pop();
            
            for (int i = 0; i < 26; i++) {
                Node* child = curr->children[i];
                if (child) {
                    Node* fail = curr->fail;
                    
                    // 找到最长的可匹配后缀
                    while (fail && !fail->children[i]) {
                        fail = fail->fail;
                    }
                    
                    child->fail = fail ? fail->children[i] : root;
                    child->outputs.insert(child->outputs.end(),
                                       child->fail->outputs.begin(),
                                       child->fail->outputs.end());
                    q.push(child);
                }
            }
        }
    }
    
    vector<int> search(const string& text) {
        vector<int> result;
        Node* curr = root;
        
        for (char c : text) {
            int index = c - 'a';
            
            // 失配时跳转
            while (curr && !curr->children[index]) {
                curr = curr->fail;
            }
            
            curr = curr ? curr->children[index] : root;
            
            // 记录所有匹配的模式串
            for (int id : curr->outputs) {
                result.push_back(id);
            }
        }
        
        return result;
    }
};
```
```python
# Python实现
from collections import deque

class AhoCorasick:
    class Node:
        def __init__(self):
            self.children = {}
            self.fail = None
            self.outputs = []
    
    def __init__(self):
        self.root = self.Node()
    
    def insert(self, pattern, id):
        curr = self.root
        for c in pattern:
            if c not in curr.children:
                curr.children[c] = self.Node()
            curr = curr.children[c]
        curr.outputs.append(id)
    
    def build(self):
        q = deque()
        
        # 第一层节点的失配指针指向根节点
        for c, child in self.root.children.items():
            child.fail = self.root
            q.append(child)
        
        # BFS构建失配指针
        while q:
            curr = q.popleft()
            
            for c, child in curr.children.items():
                fail = curr.fail
                
                # 找到最长的可匹配后缀
                while fail and c not in fail.children:
                    fail = fail.fail
                
                child.fail = fail.children[c] if fail else self.root
                child.outputs.extend(child.fail.outputs)
                q.append(child)
    
    def search(self, text):
        result = []
        curr = self.root
        
        for c in text:
            # 失配时跳转
            while curr and c not in curr.children:
                curr = curr.fail
            
            curr = curr.children[c] if curr else self.root
            
            # 记录所有匹配的模式串
            result.extend(curr.outputs)
        
        return result
```
:::
**复杂度分析**
- **构建时间**：O(总模式串长度 * 字符集大小)
- **匹配时间**：O(文本长度 + 匹配数)
- **空间复杂度**：O(总模式串长度)

---

## 后缀数组

后缀数组是字符串所有后缀按字典序排序后，每个后缀的起始位置组成的数组。辅助的rank数组表示每个后缀的排名。

**后缀数组实现（O(n log n)倍增算法）**
::: code-group
```cpp
class SuffixArray {
private:
    string s;
    int n;
    vector<int> sa, rank, tmp;
    
public:
    SuffixArray(const string& str) : s(str), n(str.length()) {
        sa.resize(n);
        rank.resize(n);
        tmp.resize(n);
        
        // 初始排序：按单个字符
        for (int i = 0; i < n; i++) {
            sa[i] = i;
            rank[i] = s[i];
        }
        
        // 倍增
        for (int k = 1; k < n; k <<= 1) {
            auto cmp = [this, k](int i, int j) {
                if (rank[i] != rank[j]) {
                    return rank[i] < rank[j];
                }
                int ri = (i + k < n) ? rank[i + k] : -1;
                int rj = (j + k < n) ? rank[j + k] : -1;
                return ri < rj;
            };
            
            sort(sa.begin(), sa.end(), cmp);
            
            // 重新计算rank
            tmp[sa[0]] = 0;
            for (int i = 1; i < n; i++) {
                tmp[sa[i]] = tmp[sa[i-1]] + (cmp(sa[i-1], sa[i]) ? 1 : 0);
            }
            rank = tmp;
            
            if (rank[sa[n-1]] == n-1) break;  // 所有rank都不相同
        }
    }
    
    vector<int> getSA() { return sa; }
    vector<int> getRank() { return rank; }
};
```
```python
# Python实现
class SuffixArray:
    def __init__(self, s):
        self.s = s
        self.n = len(s)
        self.sa = list(range(self.n))
        self.rank = [ord(c) for c in s]
        self.tmp = [0] * self.n
        
        k = 1
        while k < self.n:
            self.sa.sort(key=lambda x: (
                self.rank[x], 
                self.rank[x + k] if x + k < self.n else -1
            ))
            
            self.tmp[self.sa[0]] = 0
            for i in range(1, self.n):
                prev, curr = self.sa[i-1], self.sa[i]
                self.tmp[curr] = self.tmp[prev] + (
                    (self.rank[prev], self.rank[prev + k] if prev + k < self.n else -1) <
                    (self.rank[curr], self.rank[curr + k] if curr + k < self.n else -1)
                )
            
            self.rank = self.tmp[:]
            if self.rank[self.sa[-1]] == self.n - 1:
                break
            k <<= 1
```
:::
**Height数组实现**
::: code-group
```cpp
vector<int> buildHeight(const string& s, const vector<int>& sa) {
    int n = s.length();
    vector<int> rank(n), height(n);
    
    // 构建rank数组
    for (int i = 0; i < n; i++) {
        rank[sa[i]] = i;
    }
    
    // 计算height数组
    int h = 0;
    for (int i = 0; i < n; i++) {
        if (rank[i] > 0) {
            int j = sa[rank[i] - 1];
            while (i + h < n && j + h < n && s[i + h] == s[j + h]) {
                h++;
            }
            height[rank[i]] = h;
            if (h > 0) h--;
        }
    }
    
    return height;
}
```
```python
# Python实现
def build_height(s, sa):
    n = len(s)
    rank = [0] * n
    height = [0] * n
    
    # 构建rank数组
    for i, pos in enumerate(sa):
        rank[pos] = i
    
    # 计算height数组
    h = 0
    for i in range(n):
        if rank[i] > 0:
            j = sa[rank[i] - 1]
            while i + h < n and j + h < n and s[i + h] == s[j + h]:
                h += 1
            height[rank[i]] = h
            if h > 0:
                h -= 1
    
    return height
```
:::
**复杂度分析**
- **后缀数组构建**：O(n log n)
- **Height数组构建**：O(n)
- **空间复杂度**：O(n)

---

## 字符串哈希

**基本思想**
通过哈希函数将字符串映射为整数，用于快速判断字符串相等性和比较字典序。

**字符串哈希实现**
::: code-group
```cpp
class StringHash {
private:
    vector<long long> prefix, power;
    long long base, mod;
    
public:
    StringHash(const string& s, long long b = 911382629, long long m = 1e9+7) 
        : base(b), mod(m) {
        int n = s.length();
        prefix.resize(n + 1, 0);
        power.resize(n + 1, 1);
        
        for (int i = 0; i < n; i++) {
            prefix[i + 1] = (prefix[i] * base + s[i]) % mod;
            power[i + 1] = (power[i] * base) % mod;
        }
    }
    
    // 获取子串[l, r)的哈希值
    long long getHash(int l, int r) {
        return (prefix[r] - prefix[l] * power[r - l] % mod + mod) % mod;
    }
    
    // 获取整个字符串的哈希值
    long long getHash() {
        return getHash(0, prefix.size() - 1);
    }
};
```
```python
# Python实现
class StringHash:
    def __init__(self, s, base=911382629, mod=10**9+7):
        self.base = base
        self.mod = mod
        self.n = len(s)
        self.prefix = [0] * (self.n + 1)
        self.power = [1] * (self.n + 1)
        
        for i in range(self.n):
            self.prefix[i + 1] = (self.prefix[i] * base + ord(s[i])) % self.mod
            self.power[i + 1] = (self.power[i] * base) % self.mod
    
    def get_hash(self, l, r):
        return (self.prefix[r] - self.prefix[l] * self.power[r - l]) % self.mod
    
    def get_full_hash(self):
        return self.get_hash(0, self.n)
```
:::

**双哈希防冲突**
::: code-group
```cpp
class DoubleHash {
private:
    StringHash h1, h2;
    
public:
    DoubleHash(const string& s) 
        : h1(s, 911382629, 1000000007), 
          h2(s, 972663749, 1000000009) {}
    
    pair<long long, long long> getHash(int l, int r) {
        return {h1.getHash(l, r), h2.getHash(l, r)};
    }
};
```
:::
---

## 字符串算法对比

| 算法 | 适用场景 | 时间复杂度 | 空间复杂度 | 优势 | 劣势 |
|------|----------|------------|------------|------|------|
| **KMP** | 单模式匹配 | O(n+m) | O(m) | 线性时间 | 预处理开销 |
| **Z函数** | 多字符串处理 | O(n) | O(n) | 简单高效 | 应用场景有限 |
| **字典树** | 前缀查询 | O(字符串长度) | O(总长度) | 前缀共享 | 空间消耗大 |
| **AC自动机** | 多模式匹配 | O(n+匹配数) | O(总长度) | 同时匹配多模式 | 构建复杂 |
| **后缀数组** | 复杂字符串操作 | O(n log n) | O(n) | 功能强大 | 实现复杂 |
| **字符串哈希** | 快速相等判断 | O(1)查询 | O(n) | 查询极快 | 冲突风险 |

---

## 实战应用技巧

**1. 字符串周期性检测**

```cpp
// 检查字符串是否由某个子串重复构成
bool isRepeated(const string& s) {
    vector<int> pi = prefix_function(s);
    int n = s.length();
    int period = n - pi[n - 1];
    return n % period == 0 && period != n;
}
```

**2. 最小表示法**

```cpp
int minRepresentation(const string& s) {
    string ss = s + s;
    int n = s.length();
    int i = 0, j = 1, k = 0;
    
    while (i < n && j < n && k < n) {
        char a = ss[i + k], b = ss[j + k];
        if (a == b) {
            k++;
            continue;
        }
        if (a > b) {
            i = i + k + 1;
            if (i <= j) i = j + 1;
        } else {
            j = j + k + 1;
            if (j <= i) j = i + 1;
        }
        k = 0;
    }
    
    return min(i, j);
}
```

**3. 回文检测（Manacher算法）**

```cpp
class Manacher {
private:
    string s;
    vector<int> d1, d2;  // 奇数长度和偶数长度的回文半径
    
public:
    Manacher(const string& str) : s(str) {
        int n = s.length();
        d1.resize(n);
        d2.resize(n);
        
        // 奇数长度回文
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 1 : min(d1[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < n && s[i - k] == s[i + k]) k++;
            d1[i] = k--;
            if (i + k > r) {
                l = i - k;
                r = i + k;
            }
        }
        
        // 偶数长度回文
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : min(d2[l + r - i + 1], r - i + 1);
            while (0 <= i - k - 1 && i + k < n && s[i - k - 1] == s[i + k]) k++;
            d2[i] = k--;
            if (i + k > r) {
                l = i - k - 1;
                r = i + k;
            }
        }
    }
    
    bool isPalindrome(int l, int r) {
        int len = r - l + 1;
        if (len % 2 == 1) {
            int center = (l + r) / 2;
            return d1[center] >= len / 2 + 1;
        } else {
            int center = (l + r) / 2 + 1;
            return d2[center] >= len / 2;
        }
    }
};
```

