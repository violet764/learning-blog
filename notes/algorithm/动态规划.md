# 动态规划算法详解

动态规划（Dynamic Programming，DP）是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。它将子问题的解存储起来，避免重复计算，从而提高算法效率。

**核心思想**  
动态规划的核心思想是**分治思想**和**记忆化**的结合：
- **分治**：将大问题分解为小问题
- **记忆化**：保存已解决的子问题的解，避免重复计算

**适用条件**  
动态规划适用于满足以下条件的问题：

**1. 最优子结构**
问题的最优解包含其子问题的最优解。即整体最优可以通过子问题最优来构造。

**2. 重叠子问题**
在递归求解过程中，相同的子问题会被多次计算。

**3. 无后效性**
未来状态只与当前状态有关，与如何到达当前状态无关。

**解题步骤**
1. **定义状态**：明确dp数组的含义
2. **确定状态转移方程**：找到状态之间的关系
3. **初始化边界条件**：确定最小子问题的解
4. **确定计算顺序**：确保计算时所需的状态已计算
5. **返回结果**：从dp数组中获取最终答案

## 背包问题

背包问题是动态规划的经典应用，主要研究在有限容量下如何选择物品以获得最大价值。

---

### 0-1背包

::: info 问题描述
有$n$个物品，每个物品重量为$w[i]$，价值为$v[i]$，背包容量为$W$。每个物品只能选择0次或1次，求能装入背包的最大价值。
:::
**原理分析**
0-1背包的核心思想是：对于每个物品，要么放入背包，要么不放入。
- **状态定义**：`dp[i][j]`表示前$i$个物品中，容量为$j$时的最大价值
- **状态转移**：
  - 不选第$i$个物品：`dp[i][j] = dp[i-1][j]`
  - 选第$i$个物品：`dp[i][j] = dp[i-1][j-w[i]] + v[i]`（需满足$j \geq w[i]$）


假设有3个物品：
- 物品1：重量2，价值3
- 物品2：重量3，价值4  
- 物品3：重量4，价值5  
背包容量W=5

**手动计算过程**：
```
容量: 0 1 2 3 4 5
物品0: 0 0 0 0 0 0
物品1: 0 0 3 3 3 3
物品2: 0 0 3 4 4 7
物品3: 0 0 3 4 5 7
最大价值：7（选择物品1和物品2）
```

**实现模板：**

::: code-group

```cpp [C++递归]
// 递归+记忆化实现
int knapsack_recursive(int i, int capacity, vector<int>& weights, vector<int>& values, vector<vector<int>>& memo) {
    if (i == 0 || capacity == 0) return 0;
    if (memo[i][capacity] != -1) return memo[i][capacity];
    
    // 不选当前物品
    int not_take = knapsack_recursive(i-1, capacity, weights, values, memo);
    
    // 选当前物品（如果容量足够）
    int take = 0;
    if (capacity >= weights[i-1]) {
        take = values[i-1] + knapsack_recursive(i-1, capacity - weights[i-1], weights, values, memo);
    }
    
    memo[i][capacity] = max(take, not_take);
    return memo[i][capacity];
}

int knapsack_01_recursive(vector<int>& weights, vector<int>& values, int W) {
    int n = weights.size();
    vector<vector<int>> memo(n+1, vector<int>(W+1, -1));
    return knapsack_recursive(n, W, weights, values, memo);
}
```
```python [Python递归]
#@cache python 的缓存装饰器直接实现记忆化
def knapsack_01_recursive(weights, values, W):
    """递归+记忆化实现"""
    n = len(weights)
    memo = {}
    
    def dfs(i, capacity):
        if i == 0 or capacity == 0:
            return 0
        if (i, capacity) in memo:
            return memo[(i, capacity)]
        
        # 不选当前物品
        not_take = dfs(i-1, capacity)
        
        # 选当前物品
        take = 0
        if capacity >= weights[i-1]:
            take = values[i-1] + dfs(i-1, capacity - weights[i-1])
        
        memo[(i, capacity)] = max(take, not_take)
        return memo[(i, capacity)]
    
    return dfs(n, W)
```

```cpp [C++二维数组]
// 二维数组动态规划
int knapsack_01_2d(vector<int>& weights, vector<int>& values, int W) {
    int n = weights.size();
    vector<vector<int>> dp(n+1, vector<int>(W+1, 0));
    
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j <= W; j++) {
            // 不选第i个物品
            dp[i][j] = dp[i-1][j];
            
            // 选第i个物品（如果容量足够）
            if (j >= weights[i-1]) {
                dp[i][j] = max(dp[i][j], dp[i-1][j-weights[i-1]] + values[i-1]);
            }
        }
    }
    
    return dp[n][W];
}
```
```python [Python二维数组]
def knapsack_01_2d(weights, values, W):
    """二维数组实现"""
    n = len(weights)
    dp = [[0] * (W+1) for _ in range(n+1)]
    
    for i in range(1, n+1):
        for j in range(W+1):
            dp[i][j] = dp[i-1][j]  # 不选第i个物品
            if j >= weights[i-1]:
                dp[i][j] = max(dp[i][j], dp[i-1][j-weights[i-1]] + values[i-1])
    
    return dp[n][W]
```

```cpp [C++空间优化]
// 一维数组空间优化（倒序遍历）
int knapsack_01_optimized(vector<int>& weights, vector<int>& values, int W) {
    int n = weights.size();
    vector<int> dp(W+1, 0);
    
    for (int i = 0; i < n; i++) {
        // 必须倒序遍历，避免重复选择
        for (int j = W; j >= weights[i]; j--) {
            dp[j] = max(dp[j], dp[j-weights[i]] + values[i]);
        }
    }
    
    return dp[W];
}
```

```python [Python空间优化]
def knapsack_01_optimized(weights, values, W):
    """空间优化实现"""
    n = len(weights)
    dp = [0] * (W+1)
    
    for i in range(n):
        # 倒序遍历避免重复选择
        for j in range(W, weights[i]-1, -1):
            dp[j] = max(dp[j], dp[j-weights[i]] + values[i])
    
    return dp[W]
```
:::

**复杂度分析**
- **时间复杂度**：$O(nW)$
- **空间复杂度**：
  - 递归：$O(nW)$（记忆化）
  - 二维数组：$O(nW)$
  - 空间优化：$O(W)$

---

### 完全背包

::: info 问题描述

有$n$种物品，每种物品重量为$w[i]$，价值为$v[i]$，每种物品有无限多个。背包容量为$W$，求能装入背包的最大价值。
:::

**原理分析**
完全背包与0-1背包的关键区别在于：每种物品可以选取多次。
- **状态定义**：`dp[j]`表示容量为$j$时的最大价值
- **状态转移**：对于每个物品，可以选取0次、1次、2次...直到容量限制
- **关键区别**：使用正序遍历，允许重复选择同一物品

假设有2种物品：
- 物品1：重量2，价值3
- 物品2：重量3，价值4
背包容量W=5

**手动计算过程**：
```
容量: 0 1 2 3 4 5
初始: 0 0 0 0 0 0
物品1: 0 0 3 3 6 6
物品2: 0 0 3 4 6 7
最大价值：7（选择1个物品1和1个物品2）
```

**实现模板**

::: code-group

```cpp [C++递归]
// 递归+记忆化实现
int complete_knapsack_recursive(int i, int capacity, vector<int>& weights, vector<int>& values, vector<vector<int>>& memo) {
    if (i == 0 || capacity == 0) return 0;
    if (memo[i][capacity] != -1) return memo[i][capacity];
    
    // 不选当前物品
    int not_take = complete_knapsack_recursive(i-1, capacity, weights, values, memo);
    
    // 选当前物品（可以选多次）
    int take = 0;
    if (capacity >= weights[i-1]) {
        take = values[i-1] + complete_knapsack_recursive(i, capacity - weights[i-1], weights, values, memo);
    }
    
    memo[i][capacity] = max(take, not_take);
    return memo[i][capacity];
}

int complete_knapsack_recursive(vector<int>& weights, vector<int>& values, int W) {
    int n = weights.size();
    vector<vector<int>> memo(n+1, vector<int>(W+1, -1));
    return complete_knapsack_recursive(n, W, weights, values, memo);
}
```
```python [Python递归]
def complete_knapsack_recursive(weights, values, W):
    """递归+记忆化实现"""
    n = len(weights)
    memo = {}
    
    def dfs(i, capacity):
        if i == 0 or capacity == 0:
            return 0
        if (i, capacity) in memo:
            return memo[(i, capacity)]
        
        # 不选当前物品
        not_take = dfs(i-1, capacity)
        
        # 选当前物品（可以选多次）
        take = 0
        if capacity >= weights[i-1]:
            take = values[i-1] + dfs(i, capacity - weights[i-1])
        
        memo[(i, capacity)] = max(take, not_take)
        return memo[(i, capacity)]
    
    return dfs(n, W)
```

```cpp [C++二维数组]
// 二维数组动态规划
int complete_knapsack_2d(vector<int>& weights, vector<int>& values, int W) {
    int n = weights.size();
    vector<vector<int>> dp(n+1, vector<int>(W+1, 0));
    
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j <= W; j++) {
            // 不选第i个物品
            dp[i][j] = dp[i-1][j];
            
            // 选第i个物品（可以选多次）
            if (j >= weights[i-1]) {
                dp[i][j] = max(dp[i][j], dp[i][j-weights[i-1]] + values[i-1]);
            }
        }
    }
    
    return dp[n][W];
}
```

```python [Python二维数组]
def complete_knapsack_2d(weights, values, W):
    """二维数组实现"""
    n = len(weights)
    dp = [[0] * (W+1) for _ in range(n+1)]
    
    for i in range(1, n+1):
        for j in range(W+1):
            dp[i][j] = dp[i-1][j]  # 不选第i个物品
            if j >= weights[i-1]:
                # 关键：使用dp[i][j-weights[i-1]]而不是dp[i-1][...]
                dp[i][j] = max(dp[i][j], dp[i][j-weights[i-1]] + values[i-1])
    
    return dp[n][W]
```

```cpp [C++空间优化]
// 一维数组空间优化（正序遍历）
int complete_knapsack_optimized(vector<int>& weights, vector<int>& values, int W) {
    int n = weights.size();
    vector<int> dp(W+1, 0);
    
    for (int i = 0; i < n; i++) {
        // 正序遍历，允许重复选择
        for (int j = weights[i]; j <= W; j++) {
            dp[j] = max(dp[j], dp[j-weights[i]] + values[i]);
        }
    }
    
    return dp[W];
}
```

```python [Python空间优化]

def complete_knapsack_optimized(weights, values, W):
    """空间优化实现"""
    n = len(weights)
    dp = [0] * (W+1)
    for i in range(n):
        # 正序遍历，允许重复选择
        for j in range(weights[i], W+1):
            dp[j] = max(dp[j], dp[j-weights[i]] + values[i])
    
    return dp[W]
```
:::

**复杂度分析**
- **时间复杂度**：$O(nW)$
- **空间复杂度**：$O(W)$（优化后）

---

### 多重背包

::: info 问题描述
有$n$种物品，每种物品重量为$w[i]$，价值为$v[i]$，数量限制为$cnt[i]$。背包容量为$W$，求能装入背包的最大价值。
:::

**原理分析**
多重背包是0-1背包和完全背包的中间状态：每种物品有数量限制，但可以选多个。
- **朴素解法**：将多重背包转化为0-1背包（每个物品拆分为多个0-1物品）
- **二进制优化**：使用二进制分组减少物品数量

假设有2种物品：
- 物品1：重量2，价值3，数量2
- 物品2：重量3，价值4，数量1
背包容量W=5

**手动计算过程**：
```
容量: 0 1 2 3 4 5
初始: 0 0 0 0 0 0
物品1: 0 0 3 3 6 6
物品2: 0 0 3 4 6 7
最大价值：7
```

**实现模板**

::: code-group

```cpp [C++实现]
// 朴素多重背包（直接转化为0-1背包）
int multiple_knapsack_naive(vector<int>& weights, vector<int>& values, vector<int>& counts, int W) {
    int n = weights.size();
    vector<int> dp(W+1, 0);
    
    for (int i = 0; i < n; i++) {
        for (int k = 1; k <= counts[i]; k++) {
            for (int j = W; j >= weights[i]; j--) {
                if (j >= k * weights[i]) {
                    dp[j] = max(dp[j], dp[j - k * weights[i]] + k * values[i]);
                }
            }
        }
    }
    
    return dp[W];
}
```
```python [Python实现]
def multiple_knapsack_naive(weights, values, counts, W):
    """朴素多重背包"""
    n = len(weights)
    dp = [0] * (W+1)
    
    for i in range(n):
        for k in range(1, counts[i]+1):
            for j in range(W, weights[i]-1, -1):
                if j >= k * weights[i]:
                    dp[j] = max(dp[j], dp[j - k * weights[i]] + k * values[i])
    
    return dp[W]
```


```cpp [C++二进制优化]
// 二进制分组优化
int multiple_knapsack_binary(vector<int>& weights, vector<int>& values, vector<int>& counts, int W) {
    vector<pair<int, int>> items; // (weight, value)
    
    // 二进制分组
    for (int i = 0; i < weights.size(); i++) {
        int cnt = counts[i];
        int k = 1;
        while (k <= cnt) {
            items.push_back({k * weights[i], k * values[i]});
            cnt -= k;
            k *= 2;
        }
        if (cnt > 0) {
            items.push_back({cnt * weights[i], cnt * values[i]});
        }
    }
    
    // 转化为0-1背包
    vector<int> dp(W+1, 0);
    for (auto& item : items) {
        for (int j = W; j >= item.first; j--) {
            dp[j] = max(dp[j], dp[j - item.first] + item.second);
        }
    }
    
    return dp[W];
}
```

```python [Python二进制优化]

def multiple_knapsack_binary(weights, values, counts, W):
    """二进制优化"""
    items = []
    
    # 二进制分组
    for i in range(len(weights)):
        cnt = counts[i]
        k = 1
        while k <= cnt:
            items.append((k * weights[i], k * values[i]))
            cnt -= k
            k *= 2
        if cnt > 0:
            items.append((cnt * weights[i], cnt * values[i]))
    
    # 转化为0-1背包
    dp = [0] * (W+1)
    for weight, value in items:
        for j in range(W, weight-1, -1):
            dp[j] = max(dp[j], dp[j - weight] + value)
    
    return dp[W]
```
:::


---

### 混合背包

::: info 问题描述
混合背包问题包含0-1背包、完全背包和多重背包的混合情况。每个物品可能有不同的选择限制。
:::
**原理分析**
根据每个物品的限制类型，采用不同的处理策略：
- **0-1背包**：倒序遍历
- **完全背包**：正序遍历  
- **多重背包**：二进制优化后按0-1背包处理

示例
假设有3种物品：
- 物品1：重量2，价值3（0-1背包）
- 物品2：重量3，价值4（完全背包）
- 物品3：重量4，价值5，数量2（多重背包）
背包容量W=8

**实现模板**

::: code-group

```cpp [C++实现]
int mixed_knapsack(vector<int>& weights, vector<int>& values, vector<int>& types, int W) {
    // types: 0-0-1背包, 1-完全背包, 2-多重背包（counts参数单独传递）
    vector<int> dp(W+1, 0);
    
    for (int i = 0; i < weights.size(); i++) {
        if (types[i] == 0) {  // 0-1背包
            for (int j = W; j >= weights[i]; j--) {
                dp[j] = max(dp[j], dp[j - weights[i]] + values[i]);
            }
        } else if (types[i] == 1) {  // 完全背包
            for (int j = weights[i]; j <= W; j++) {
                dp[j] = max(dp[j], dp[j - weights[i]] + values[i]);
            }
        }
        // 多重背包需要单独处理
    }
    
    return dp[W];
}
```

```python [Python实现]
def mixed_knapsack(weights, values, types, W, counts=None):
    """混合背包实现"""
    dp = [0] * (W+1)
    
    for i in range(len(weights)):
        if types[i] == 0:  # 0-1背包
            for j in range(W, weights[i]-1, -1):
                dp[j] = max(dp[j], dp[j - weights[i]] + values[i])
        elif types[i] == 1:  # 完全背包
            for j in range(weights[i], W+1):
                dp[j] = max(dp[j], dp[j - weights[i]] + values[i])
        elif types[i] == 2:  # 多重背包
            cnt = counts[i] if counts else 1
            # 二进制优化处理
            k = 1
            while k <= cnt:
                weight = k * weights[i]
                value = k * values[i]
                for j in range(W, weight-1, -1):
                    dp[j] = max(dp[j], dp[j - weight] + value)
                cnt -= k
                k *= 2
            if cnt > 0:
                weight = cnt * weights[i]
                value = cnt * values[i]
                for j in range(W, weight-1, -1):
                    dp[j] = max(dp[j], dp[j - weight] + value)
    
    return dp[W]
```
:::

---

### 二维费用背包

::: info 问题描述
物品有两种消耗（如重量和体积），背包有重量限制$W$和体积限制$V$，求在两种限制下的最大价值。
:::

**原理分析**
二维费用背包是0-1背包的扩展，状态定义增加一维：
- **状态定义**：`dp[i][j]`表示重量限制为$i$，体积限制为$j$时的最大价值
- **状态转移**：类似0-1背包，但需要同时满足两种限制

示例
假设有2个物品：
- 物品1：重量2，体积1，价值3
- 物品2：重量3，体积2，价值4
背包重量限制W=5，体积限制V=3

**实现模板**

::: code-group

```cpp [C++实现]
int two_dimensional_knapsack(vector<int>& weights, vector<int>& volumes, vector<int>& values, int W, int V) {
    int n = weights.size();
    vector<vector<int>> dp(W+1, vector<int>(V+1, 0));
    
    for (int k = 0; k < n; k++) {
        for (int i = W; i >= weights[k]; i--) {
            for (int j = V; j >= volumes[k]; j--) {
                dp[i][j] = max(dp[i][j], dp[i - weights[k]][j - volumes[k]] + values[k]);
            }
        }
    }
    
    return dp[W][V];
}
```

```python [Python实现]
def two_dimensional_knapsack(weights, volumes, values, W, V):
    """二维费用背包"""
    n = len(weights)
    dp = [[0] * (V+1) for _ in range(W+1)]
    
    for k in range(n):
        for i in range(W, weights[k]-1, -1):
            for j in range(V, volumes[k]-1, -1):
                dp[i][j] = max(dp[i][j], dp[i - weights[k]][j - volumes[k]] + values[k])
    
    return dp[W][V]
```
:::


---

## 区间DP

区间DP是指状态表示为区间[l, r]的动态规划，通常通过枚举区间端点和分割点来转移状态。

**基本模板**

区间DP通常按照区间长度递增的顺序进行动态规划：

::: code-group

```cpp [C++实现]
// 区间DP通用模板
for (int len = 1; len <= n; len++) {           // 枚举区间长度
    for (int l = 1; l + len - 1 <= n; l++) {   // 枚举区间起点
        int r = l + len - 1;                   // 区间终点
        if (len == 1) {
            dp[l][r] = initial_value;          // 初始化
            continue;
        }
        
        for (int k = l; k < r; k++) {          // 枚举分割点
            dp[l][r] = max/min(dp[l][r], dp[l][k] + dp[k+1][r] + cost(l, r, k));
        }
    }
}
```

```python [Python实现]
def interval_dp_template(n, cost_func):
    """区间DP通用模板"""
    dp = [[0] * (n+1) for _ in range(n+1)]
    
    for length in range(1, n+1):           # 枚举区间长度
        for l in range(1, n-length+2):     # 枚举区间起点
            r = l + length - 1             # 区间终点
            if length == 1:
                dp[l][r] = initial_value   # 初始化
                continue
            
            for k in range(l, r):          # 枚举分割点
                dp[l][r] = max(dp[l][r], dp[l][k] + dp[k+1][r] + cost_func(l, r, k))
    
    return dp[1][n]
```
:::

### 石子合并

::: info 问题描述
有一排石子，每堆石子有一定重量。每次只能合并相邻的两堆石子，合并的代价是两堆石子的重量之和。求将所有石子合并成一堆的最小总代价。
:::
**原理分析**
- **状态定义**：`dp[l][r]`表示合并区间[l, r]的石子的最小代价
- **状态转移**：枚举最后一次合并的分割点k，将区间分为[l, k]和[k+1, r]
- **代价计算**：合并代价是区间总重量（可以通过前缀和快速计算）

示例
假设有4堆石子：重量分别为[1, 3, 2, 4]

**手动计算过程**：
```
石子: 1, 3, 2, 4
前缀和: 0, 1, 4, 6, 10

合并顺序1（最优）：
1. 合并1+3=4（代价4）
2. 合并4+2=6（代价6） 
3. 合并6+4=10（代价10）
总代价：4+6+10=20

合并顺序2：
1. 合并2+4=6（代价6）
2. 合并3+6=9（代价9）
3. 合并1+9=10（代价10）
总代价：6+9+10=25
```

**实现模板:**

::: code-group

```cpp [C++实现]
int stone_merge(vector<int>& stones) {
    int n = stones.size();
    vector<int> prefix(n+1, 0);
    vector<vector<int>> dp(n+1, vector<int>(n+1, 0));
    
    // 计算前缀和
    for (int i = 1; i <= n; i++) {
        prefix[i] = prefix[i-1] + stones[i-1];
    }
    
    // 区间DP
    for (int len = 2; len <= n; len++) {
        for (int l = 1; l + len - 1 <= n; l++) {
            int r = l + len - 1;
            dp[l][r] = INT_MAX;
            int sum = prefix[r] - prefix[l-1];  // 区间和
            
            for (int k = l; k < r; k++) {
                dp[l][r] = min(dp[l][r], dp[l][k] + dp[k+1][r] + sum);
            }
        }
    }
    
    return dp[1][n];
}
```

```python [Python实现]
def stone_merge(stones):
    """石子合并问题"""
    n = len(stones)
    prefix = [0] * (n+1)
    dp = [[0] * (n+1) for _ in range(n+1)]
    
    # 计算前缀和
    for i in range(1, n+1):
        prefix[i] = prefix[i-1] + stones[i-1]
    
    # 区间DP
    for length in range(2, n+1):
        for l in range(1, n-length+2):
            r = l + length - 1
            dp[l][r] = float('inf')
            total = prefix[r] - prefix[l-1]
            
            for k in range(l, r):
                dp[l][r] = min(dp[l][r], dp[l][k] + dp[k+1][r] + total)
    
    return dp[1][n]
```
:::

---

## 树形DP

树形DP是在树结构上进行的动态规划，通常以节点为状态，考虑父子关系进行状态转移。

**基本模板**

树形DP通常使用深度优先搜索（DFS）进行状态转移：

::: code-group

```cpp [C++]
vector<vector<int>> tree;  // 邻接表表示的树
vector<int> dp;           // DP数组

void dfs(int u, int parent) {
    // 初始化当前节点的状态
    
    for (int v : tree[u]) {
        if (v == parent) continue;  // 跳过父节点
        
        dfs(v, u);  // 递归处理子节点
        
        // 根据子节点的状态更新当前节点的状态
        // dp[u] = combine(dp[u], dp[v])
    }
    
    // 处理当前节点的最终状态
}
```

```python [Python实现]
def tree_dp_template(tree, n):
    """树形DP通用模板"""
    dp = [0] * (n+1)
    
    def dfs(u, parent):
        # 初始化当前节点的状态
        
        for v in tree[u]:
            if v == parent:
                continue
            
            dfs(v, u)  # 递归处理子节点
            
            # 根据子节点的状态更新当前节点的状态
            # dp[u] = combine(dp[u], dp[v])
        
        # 处理当前节点的最终状态
    
    dfs(1, 0)  # 假设1为根节点
    return dp[1]
```
:::

### 树的独立集

::: info 问题描述
在树上选择一些节点，使得任意两个被选择的节点不相邻（没有边直接相连），求最大权值和。
:::

**原理分析**
- **状态定义**：
  - `dp[u][0]`：不选择节点u时，以u为根的子树的最大权值
  - `dp[u][1]`：选择节点u时，以u为根的子树的最大权值
- **状态转移**：
  - 不选u：u的每个子节点可选可不选，取最大值
  - 选u：u的每个子节点必须不选

示例:
假设有如下树结构（节点上的数字表示权重）：
```
    1(10)
   / \
 2(20) 3(30)
  |
 4(40)
```

**手动计算过程**：
- 节点4：dp[4][0]=0, dp[4][1]=40
- 节点2：dp[2][0]=max(0,40)=40, dp[2][1]=20+0=20
- 节点3：dp[3][0]=0, dp[3][1]=30
- 节点1：dp[1][0]=40+30=70, dp[1][1]=10+0+0=10
最大权值和：max(70,10)=70

**实现模板:**

::: code-group

```cpp [C++]
int tree_independent_set(vector<vector<int>>& tree, vector<int>& weights) {
    int n = tree.size() - 1;
    vector<vector<int>> dp(n+1, vector<int>(2, 0));
    
    function<void(int, int)> dfs = [&](int u, int parent) {
        dp[u][0] = 0;       // 不选u
        dp[u][1] = weights[u];  // 选u
        
        for (int v : tree[u]) {
            if (v == parent) continue;
            
            dfs(v, u);
            
            // u不选，v可选可不选
            dp[u][0] += max(dp[v][0], dp[v][1]);
            // u选，v不能选
            dp[u][1] += dp[v][0];
        }
    };
    
    dfs(1, 0);
    return max(dp[1][0], dp[1][1]);
}
```

```python [Python]
def tree_independent_set(tree, weights):
    """树的独立集问题"""
    n = len(tree) - 1
    dp = [[0, 0] for _ in range(n+1)]
    
    def dfs(u, parent):
        dp[u][0] = 0        # 不选u
        dp[u][1] = weights[u]  # 选u
        
        for v in tree[u]:
            if v == parent:
                continue
            
            dfs(v, parent)
            
            # u不选，v可选可不选
            dp[u][0] += max(dp[v][0], dp[v][1])
            # u选，v不能选
            dp[u][1] += dp[v][0]
    
    dfs(1, 0)
    return max(dp[1][0], dp[1][1])
```
:::

---

## 状态压缩DP

状态压缩DP将复杂的状态用二进制表示，适用于状态数量有限但转移复杂的情况。

### 旅行商问题

::: info 问题描述
给定n个城市和它们之间的距离，求从起点出发，经过所有城市恰好一次，最后回到起点的最短路径。
:::
**原理分析**
- **状态定义**：`dp[mask][i]`表示当前访问状态为mask（二进制位表示是否访问过对应城市），当前在城市i的最短路径
- **状态转移**：从未访问的城市中选择下一个城市j进行转移

示例:
假设有4个城市，距离矩阵为：
```
  0  1  2  3
0 0  2  9  10
1 1  0  6  4
2 15 7  0  8
3 6  3  12 0
```

**实现模板:**

::: code-group

```cpp [C++]
int traveling_salesman(vector<vector<int>>& dist) {
    int n = dist.size();
    vector<vector<int>> dp(1 << n, vector<int>(n, INT_MAX));
    
    // 初始化：从起点0出发
    dp[1][0] = 0;
    
    // 状态转移
    for (int mask = 1; mask < (1 << n); mask++) {
        for (int u = 0; u < n; u++) {
            if (!(mask & (1 << u))) continue;  // u不在当前状态中
            
            for (int v = 0; v < n; v++) {
                if (mask & (1 << v)) continue;  // v已经在当前状态中
                
                int next_mask = mask | (1 << v);
                dp[next_mask][v] = min(dp[next_mask][v], dp[mask][u] + dist[u][v]);
            }
        }
    }
    
    // 回到起点
    int answer = INT_MAX;
    for (int i = 1; i < n; i++) {
        answer = min(answer, dp[(1 << n) - 1][i] + dist[i][0]);
    }
    
    return answer;
}
```

```python [Python]
def traveling_salesman(dist):
    """旅行商问题"""
    n = len(dist)
    dp = [[float('inf')] * n for _ in range(1 << n)]
    
    # 初始化：从起点0出发
    dp[1][0] = 0
    
    # 状态转移
    for mask in range(1, 1 << n):
        for u in range(n):
            if not (mask & (1 << u)):  # u不在当前状态中
                continue
            
            for v in range(n):
                if mask & (1 << v):  # v已经在当前状态中
                    continue
                
                next_mask = mask | (1 << v)
                dp[next_mask][v] = min(dp[next_mask][v], dp[mask][u] + dist[u][v])
    
    # 回到起点
    answer = float('inf')
    for i in range(1, n):
        answer = min(answer, dp[(1 << n) - 1][i] + dist[i][0])
    
    return answer
```
:::

复杂度分析
- **时间复杂度**：$O(n^2 \cdot 2^n)$
- **空间复杂度**：$O(n \cdot 2^n)$

---

## 动态规划优化

### 单调队列优化

**适用场景**
形如 `dp[i] = max/min(dp[j] + value)` 的状态转移，其中j的范围与i线性相关。

**实现模板:**

::: code-group

```cpp [C++]
class MonotonicQueue {
private:
    deque<pair<int, int>> dq;  // (index, value)
    
public:
    void push(int idx, int val) {
        // 维护单调递减队列
        while (!dq.empty() && dq.back().second <= val) {
            dq.pop_back();
        }
        dq.push_back({idx, val});
    }
    
    void pop(int idx) {
        // 删除过期的元素
        while (!dq.empty() && dq.front().first <= idx) {
            dq.pop_front();
        }
    }
    
    int front() {
        return dq.front().second;
    }
};

// 使用单调队列优化DP
int monotonic_queue_dp(vector<int>& nums, int k) {
    int n = nums.size();
    vector<int> dp(n, 0);
    MonotonicQueue mq;
    
    for (int i = 0; i < n; i++) {
        if (i <= k) {
            dp[i] = nums[i];
        } else {
            dp[i] = mq.front() + nums[i];
        }
        
        mq.push(i, dp[i]);
        mq.pop(i - k);  // 移除窗口外的元素
    }
    
    return dp[n-1];
}
```

```python [Python]
from collections import deque

class MonotonicQueue:
    def __init__(self):
        self.dq = deque()
    
    def push(self, idx, val):
        # 维护单调递减队列
        while self.dq and self.dq[-1][1] <= val:
            self.dq.pop()
        self.dq.append((idx, val))
    
    def pop(self, idx):
        # 删除过期的元素
        while self.dq and self.dq[0][0] <= idx:
            self.dq.popleft()
    
    def front(self):
        return self.dq[0][1] if self.dq else 0

def monotonic_queue_dp(nums, k):
    """单调队列优化DP"""
    n = len(nums)
    dp = [0] * n
    mq = MonotonicQueue()
    
    for i in range(n):
        if i <= k:
            dp[i] = nums[i]
        else:
            dp[i] = mq.front() + nums[i]
        
        mq.push(i, dp[i])
        mq.pop(i - k)  # 移除窗口外的元素
    
    return dp[n-1]
```
:::

###  斜率优化

**适用场景**
形如 `dp[i] = min(dp[j] + a[i] * b[j] + c[i] + d[j])` 的状态转移。

**实现模板:**

::: code-group

```cpp [C++]
struct Line {
    long long m, b;  // y = m*x + b
    
    long long eval(long long x) {
        return m * x + b;
    }
};

class ConvexHull {
private:
    deque<Line> hull;
    
    // 判断三条线是否形成凸包
    bool isConvex(Line l1, Line l2, Line l3) {
        return (l3.b - l1.b) * (l1.m - l2.m) <= (l2.b - l1.b) * (l1.m - l3.m);
    }
    
public:
    void addLine(long long m, long long b) {
        Line newLine = {m, b};
        
        while (hull.size() >= 2 && isConvex(hull[hull.size()-2], hull.back(), newLine)) {
            hull.pop_back();
        }
        
        hull.push_back(newLine);
    }
    
    long long query(long long x) {
        while (hull.size() >= 2 && hull[0].eval(x) >= hull[1].eval(x)) {
            hull.pop_front();
        }
        
        return hull.front().eval(x);
    }
};
```

```python [Python]
class ConvexHull:
    def __init__(self):
        self.hull = []
    
    def is_convex(self, l1, l2, l3):
        # 判断三条线是否形成凸包
        return (l3[1] - l1[1]) * (l1[0] - l2[0]) <= (l2[1] - l1[1]) * (l1[0] - l3[0])
    
    def add_line(self, m, b):
        new_line = (m, b)
        
        while len(self.hull) >= 2 and self.is_convex(self.hull[-2], self.hull[-1], new_line):
            self.hull.pop()
        
        self.hull.append(new_line)
    
    def query(self, x):
        while len(self.hull) >= 2:
            val1 = self.hull[0][0] * x + self.hull[0][1]
            val2 = self.hull[1][0] * x + self.hull[1][1]
            if val1 >= val2:
                self.hull.pop(0)
            else:
                break
        
        return self.hull[0][0] * x + self.hull[0][1]
```
:::

