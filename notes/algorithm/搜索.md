# 搜索算法


## 核心定义

搜索，也就是对状态空间进行枚举，通过穷尽所有的可能来找到最优解，或者统计合法解的个数。搜索是高级算法的基础，但纯搜索通常效率较低，需要配合各种优化技巧。

## 深度优先搜索 (DFS)

DFS采用深度优先的策略，沿着一条路径尽可能深地搜索，直到无法继续前进时才回溯。

**搜索框架**

**递归实现模板**

```cpp
// C++递归DFS模板
void dfs(int state) {
    if (isGoal(state)) {           // 终止条件
        handleGoal();               // 处理目标状态
        return;
    }
    
    if (!isValid(state)) {         // 剪枝条件
        return;
    }
    
    for (int i = 0; i < optionsCount; i++) {
        if (canChoose(state, i)) {
            makeChoice(state, i);   // 做出选择
            dfs(newState);          // 递归搜索
            undoChoice(state, i);   // 撤销选择（回溯）
        }
    }
}
```

```python
# Python递归DFS模板
def dfs(state):
    if is_goal(state):              # 终止条件
        handle_goal()               # 处理目标状态
        return
    
    if not is_valid(state):         # 剪枝条件
        return
    
    for i in range(options_count):
        if can_choose(state, i):
            make_choice(state, i)   # 做出选择
            dfs(new_state)          # 递归搜索
            undo_choice(state, i)   # 撤销选择（回溯）
```

### 全排列

**实现代码**

```cpp
// Luogu P1706 全排列问题
#include <iomanip>
#include <iostream>
using namespace std;

int n;
bool vis[50];           // 访问标记数组
int a[50];              // 排列数组，按顺序储存当前搜索结果

void dfs(int step) {
    if (step == n + 1) {    // 边界条件：找到一个完整排列
        for (int i = 1; i <= n; i++) {
            cout << setw(5) << a[i];  // 保留5个场宽
        }
        cout << endl;
        return;
    }
    
    for (int i = 1; i <= n; i++) {
        if (!vis[i]) {       // 判断数字i是否在正在进行的全排列中
            vis[i] = true;    // 标记为已访问
            a[step] = i;      // 将数字i放入当前位置
            dfs(step + 1);    // 递归处理下一个位置
            vis[i] = false;   // 撤销标记（回溯）
        }
    }
}

int main() {
    cin >> n;
    dfs(1);                 // 从第一个位置开始搜索
    return 0;
}
```

```python
# Python实现
def dfs_permutation(step):
    if step == n + 1:       # 边界条件：找到一个完整排列
        for i in range(1, n + 1):
            print(f"{a[i]:5d}", end='')
        print()
        return
    
    for i in range(1, n + 1):
        if not vis[i]:      # 判断数字i是否在正在进行的全排列中
            vis[i] = True   # 标记为已访问
            a[step] = i     # 将数字i放入当前位置
            dfs_permutation(step + 1)  # 递归处理下一个位置
            vis[i] = False  # 撤销标记（回溯）

n = int(input())
vis = [False] * 50
a = [0] * 50
dfs_permutation(1)
```

### 数的分解

**实现代码**

```cpp
// 将正整数n分解为不超过m个正整数之和
int m, arr[103];  // arr 用于记录方案

void dfs(int n, int i, int a) {
    if (n == 0) {  // 找到一个分解方案
        for (int j = 1; j <= i - 1; ++j) 
            printf("%d ", arr[j]);
        printf("\n");
        return;
    }
    
    if (i <= m) {  // 还可以继续分解
        for (int j = a; j <= n; ++j) {  // 确保非递减顺序
            arr[i] = j;
            dfs(n - j, i + 1, j);       // 递归分解剩余部分
        }
    }
}

# Python实现
def dfs_number_decomposition(n, i, a):
    if n == 0:  # 找到一个分解方案
        for j in range(1, i):
            print(arr[j], end=' ')
        print()
        return
    
    if i <= m:  # 还可以继续分解
        for j in range(a, n + 1):  # 确保非递减顺序
            arr[i] = j
            dfs_number_decomposition(n - j, i + 1, j)

# 使用示例
m = 3
arr = [0] * 103
dfs_number_decomposition(5, 1, 1)  # 将5分解为最多3个数的和
```

---

## 广度优先搜索 (BFS)


BFS采用广度优先的策略，按层次进行搜索，逐层扩展节点直到找到目标。BFS特别适合求最短路径问题，因为它总是先找到距离起点最近的解。

**搜索框架**

**迭代实现模板**

```cpp
// C++ BFS模板
struct State {
    int data[10];  // 状态数据
    int step;      // 步数
};

void bfs(State start) {
    queue<State> q;
    unordered_map<string, bool> visited;  // 记录已访问状态
    
    q.push(start);
    visited[encode(start)] = true;
    
    while (!q.empty()) {
        State current = q.front();
        q.pop();
        
        if (isGoal(current)) {
            handleGoal(current);
            return;
        }
        
        for (int i = 0; i < optionsCount; i++) {
            State next = getNextState(current, i);
            string key = encode(next);
            
            if (!visited[key]) {
                visited[key] = true;
                next.step = current.step + 1;
                q.push(next);
            }
        }
    }
}
```

```python
# Python BFS模板
from collections import deque

def bfs(start):
    q = deque()
    visited = set()  # 记录已访问状态
    
    q.append(start)
    visited.add(encode(start))
    
    while q:
        current = q.popleft()
        
        if is_goal(current):
            handle_goal(current)
            return
        
        for i in range(options_count):
            next_state = get_next_state(current, i)
            key = encode(next_state)
            
            if key not in visited:
                visited.add(key)
                next_state['step'] = current['step'] + 1
                q.append(next_state)
```

### 迷宫最短路径

**实现代码**

```cpp
// 迷宫最短路径问题
struct Point {
    int x, y, step;
};

int dx[] = {-1, 1, 0, 0};  // 四个方向
int dy[] = {0, 0, -1, 1};

int bfsMaze(vector<vector<char>>& maze, Point start, Point end) {
    int n = maze.size();
    int m = maze[0].size();
    vector<vector<bool>> visited(n, vector<bool>(m, false));
    
    queue<Point> q;
    q.push(start);
    visited[start.x][start.y] = true;
    
    while (!q.empty()) {
        Point current = q.front();
        q.pop();
        
        if (current.x == end.x && current.y == end.y) {
            return current.step;  // 找到终点
        }
        
        for (int i = 0; i < 4; i++) {
            int nx = current.x + dx[i];
            int ny = current.y + dy[i];
            
            if (nx >= 0 && nx < n && ny >= 0 && ny < m && 
                !visited[nx][ny] && maze[nx][ny] != '#') {
                visited[nx][ny] = true;
                q.push({nx, ny, current.step + 1});
            }
        }
    }
    
    return -1;  // 无法到达
}
```
```python
# Python实现
from collections import deque

def bfs_maze(maze, start, end):
    n = len(maze)
    m = len(maze[0])
    visited = [[False] * m for _ in range(n)]
    dx = [-1, 1, 0, 0]  # 四个方向
    dy = [0, 0, -1, 1]
    
    q = deque()
    q.append((start[0], start[1], 0))  # x, y, step
    visited[start[0]][start[1]] = True
    
    while q:
        x, y, step = q.popleft()
        
        if (x, y) == end:
            return step  # 找到终点
        
        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]
            
            if (0 <= nx < n and 0 <= ny < m and 
                not visited[nx][ny] and maze[nx][ny] != '#'):
                visited[nx][ny] = True
                q.append((nx, ny, step + 1))
    
    return -1  # 无法到达
```

---

## 高级搜索技术

### 双向搜索 

**基本思想**
从起点和终点同时开始搜索，在中间相遇，有效减少搜索空间。

**实现代码**

```cpp
// 双向BFS模板
int bidirectionalBFS(State start, State end) {
    unordered_set<string> forward, backward;
    queue<State> qForward, qBackward;
    
    forward.insert(encode(start));
    backward.insert(encode(end));
    
    qForward.push(start);
    qBackward.push(end);
    
    int step = 0;
    
    while (!qForward.empty() && !qBackward.empty()) {
        // 选择较小的队列扩展
        if (qForward.size() > qBackward.size()) {
            swap(qForward, qBackward);
            swap(forward, backward);
        }
        
        int size = qForward.size();
        for (int i = 0; i < size; i++) {
            State current = qForward.front();
            qForward.pop();
            
            string key = encode(current);
            if (backward.count(key)) {  // 相遇
                return step;
            }
            
            for (int j = 0; j < optionsCount; j++) {
                State next = getNextState(current, j);
                string nextKey = encode(next);
                
                if (!forward.count(nextKey)) {
                    forward.insert(nextKey);
                    qForward.push(next);
                }
            }
        }
        step++;
    }
    
    return -1;  // 无法到达
}
```

```python

# Python实现
from collections import deque

def bidirectional_bfs(start, end):
    forward = set()
    backward = set()
    q_forward = deque()
    q_backward = deque()
    
    forward.add(encode(start))
    backward.add(end)
    
    q_forward.append(start)
    q_backward.append(end)
    
    step = 0
    
    while q_forward and q_backward:
        # 选择较小的队列扩展
        if len(q_forward) > len(q_backward):
            q_forward, q_backward = q_backward, q_forward
            forward, backward = backward, forward
        
        for _ in range(len(q_forward)):
            current = q_forward.popleft()
            key = encode(current)
            
            if key in backward:  # 相遇
                return step
            
            for j in range(options_count):
                next_state = get_next_state(current, j)
                next_key = encode(next_state)
                
                if next_key not in forward:
                    forward.add(next_key)
                    q_forward.append(next_state)
        
        step += 1
    
    return -1  # 无法到达
```

### 迭代加深搜索

**基本思想**
结合DFS和BFS的优点，逐渐增加搜索深度，避免深度过大导致的栈溢出。

**实现代码**

```cpp
// 迭代加深搜索模板
bool dfsLimited(State current, int depth, int limit) {
    if (depth > limit) return false;
    if (isGoal(current)) return true;
    
    for (int i = 0; i < optionsCount; i++) {
        if (canChoose(current, i)) {
            makeChoice(current, i);
            if (dfsLimited(current, depth + 1, limit)) {
                return true;
            }
            undoChoice(current, i);
        }
    }
    return false;
}

bool iterativeDeepeningSearch(State start) {
    for (int limit = 0; limit <= MAX_DEPTH; limit++) {
        if (dfsLimited(start, 0, limit)) {
            return true;
        }
    }
    return false;
}
```

```python

# Python实现
def dfs_limited(current, depth, limit):
    if depth > limit:
        return False
    if is_goal(current):
        return True
    
    for i in range(options_count):
        if can_choose(current, i):
            make_choice(current, i)
            if dfs_limited(current, depth + 1, limit):
                return True
            undo_choice(current, i)
    return False

def iterative_deepening_search(start):
    for limit in range(max_depth + 1):
        if dfs_limited(start, 0, limit):
            return True
    return False
```

### A* 算法

**基本思想**
在BFS基础上加入启发函数，优先探索更有可能通向目标的状态。

**实现代码**

```cpp
struct AStarState {
    State data;
    int g;  // 从起点到当前状态的实际代价
    int h;  // 从当前状态到终点的估计代价
    int f;  // f = g + h
    
    bool operator<(const AStarState& other) const {
        return f > other.f;  // 优先队列取最小值
    }
};

int aStarSearch(State start, State end) {
    priority_queue<AStarState> pq;
    unordered_map<string, int> best_g;
    
    AStarState startState = {start, 0, heuristic(start, end), 0};
    startState.f = startState.g + startState.h;
    
    pq.push(startState);
    best_g[encode(start)] = 0;
    
    while (!pq.empty()) {
        AStarState current = pq.top();
        pq.pop();
        
        if (isGoal(current.data)) {
            return current.g;
        }
        
        for (int i = 0; i < optionsCount; i++) {
            State next = getNextState(current.data, i);
            int new_g = current.g + cost(current.data, next);
            
            string key = encode(next);
            if (!best_g.count(key) || new_g < best_g[key]) {
                best_g[key] = new_g;
                AStarState next_state = {next, new_g, heuristic(next, end), 0};
                next_state.f = next_state.g + next_state.h;
                pq.push(next_state);
            }
        }
    }
    
    return -1;
}
```

```python
# Python实现
import heapq

def a_star_search(start, end):
    pq = []
    best_g = {}
    
    start_state = (0, heuristic(start, end), start)  # f, h, data
    heapq.heappush(pq, start_state)
    best_g[encode(start)] = 0
    
    while pq:
        f, h, current_data = heapq.heappop(pq)
        g = f - h
        
        if is_goal(current_data):
            return g
        
        for i in range(options_count):
            next_data = get_next_state(current_data, i)
            new_g = g + cost(current_data, next_data)
            
            key = encode(next_data)
            if key not in best_g or new_g < best_g[key]:
                best_g[key] = new_g
                next_h = heuristic(next_data, end)
                next_f = new_g + next_h
                heapq.heappush(pq, (next_f, next_h, next_data))
    
    return -1
```

---

## 搜索优化技巧

### 剪枝策略

**可行性剪枝**
```cpp
bool canReachGoal(State current, int stepsRemaining) {
    int minDistance = estimateMinDistance(current, goal);
    return minDistance <= stepsRemaining;
}
```

**最优性剪枝**
```cpp
if (currentCost + estimateMinDistance(current, goal) >= bestSolution) {
    return;  // 即使找到最优解也不会比当前更好
}
```

**对称剪枝**
```cpp
if (isSymmetrical(current, visited)) {
    return;  // 避免重复搜索对称状态
}
```

### 记忆化搜索

**实现示例***

```cpp
unordered_map<string, int> memo;

int memoizedSearch(State current) {
    string key = encode(current);
    if (memo.count(key)) {
        return memo[key];
    }
    
    if (isGoal(current)) {
        return memo[key] = 0;
    }
    
    int result = INF;
    for (int i = 0; i < optionsCount; i++) {
        if (canChoose(current, i)) {
            State next = getNextState(current, i);
            result = min(result, 1 + memoizedSearch(next));
        }
    }
    
    return memo[key] = result;
}
``
```python
# Python实现
memo = {}

def memoized_search(current):
    key = encode(current)
    if key in memo:
        return memo[key]
    
    if is_goal(current):
        memo[key] = 0
        return 0
    
    result = float('inf')
    for i in range(options_count):
        if can_choose(current, i):
            next_state = get_next_state(current, i)
            result = min(result, 1 + memoized_search(next_state))
    
    memo[key] = result
    return result
```

---

## 搜索算法对比

| 算法 | 适用场景 | 时间复杂度 | 空间复杂度 | 最优性 | 实现难度 |
|------|----------|------------|------------|--------|----------|
| **DFS** | 需要所有解或特定深度解 | O(b^d) | O(d) | 不保证 | 简单 |
| **BFS** | 最短路径问题 | O(b^d) | O(b^d) | 保证 | 简单 |
| **双向BFS** | 对称的最短路径 | O(b^(d/2)) | O(b^(d/2)) | 保证 | 中等 |
| **IDS** | 深度限制或避免栈溢出 | O(b^d) | O(d) | 保证 | 中等 |
| **A\*** | 有启发函数的路径寻找 | 依赖于启发函数 | 依赖于启发函数 | 保证 | 复杂 |

*注：b为分支因子，d为解的深度*
