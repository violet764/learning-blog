# 算法应用与优化


## 时间复杂度分析

```cpp
// 1. 单层循环 - O(n)
void linearLoop(int n) {
    for (int i = 0; i < n; i++) {
        // O(1) 操作
    }
}

// 2. 嵌套循环 - O(n²)
void nestedLoop(int n) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            // O(1) 操作
        }
    }
}

// 3. 对数循环 - O(log n)
void logarithmicLoop(int n) {
    for (int i = 1; i < n; i *= 2) {
        // O(1) 操作
    }
}

// 4. 二分查找 - O(log n)
int binarySearch(const vector<int>& arr, int target) {
    int left = 0, right = arr.size() - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] == target) return mid;
        else if (arr[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    return -1;
}

# Python实现
def linear_loop(n):
    for i in range(n):
        pass  # O(1) 操作

def nested_loop(n):
    for i in range(n):
        for j in range(n):
            pass  # O(1) 操作

def logarithmic_loop(n):
    i = 1
    while i < n:
        i *= 2
        pass  # O(1) 操作

def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
```


## 空间复杂度分析

```cpp
// 1. 原地操作 - O(1) 空间
void reverseArray(vector<int>& arr) {
    int left = 0, right = arr.size() - 1;
    while (left < right) {
        swap(arr[left], arr[right]);
        left++;
        right--;
    }
}

// 2. 递归深度分析 - O(log n) 空间
int binarySearchSpace(const vector<int>& arr, int left, int right, int target) {
    if (left > right) return -1;
    int mid = left + (right - left) / 2;
    if (arr[mid] == target) return mid;
    else if (arr[mid] < target) 
        return binarySearchSpace(arr, mid + 1, right, target);
    else 
        return binarySearchSpace(arr, left, mid - 1, target);
}

// 3. 动态数组 - O(n) 空间
vector<int> copyArray(const vector<int>& arr) {
    vector<int> result(arr.size());  // O(n) 额外空间
    for (int i = 0; i < arr.size(); i++) {
        result[i] = arr[i];
    }
    return result;
}

# Python实现
def reverse_array(arr):
    left, right = 0, len(arr) - 1
    while left < right:
        arr[left], arr[right] = arr[right], arr[left]
        left += 1
        right -= 1

def binary_search_space(arr, left, right, target):
    if left > right:
        return -1
    mid = left + (right - left) // 2
    if arr[mid] == target:
        return mid
    elif arr[mid] < target:
        return binary_search_space(arr, mid + 1, right, target)
    else:
        return binary_search_space(arr, left, mid - 1, target)

def copy_array(arr):
    result = [0] * len(arr)  # O(n) 额外空间
    for i in range(len(arr)):
        result[i] = arr[i]
    return result
```



## 数据结构效率对比

| 数据结构 | 插入 | 删除 | 查找 | 修改 | 适用场景 |
|----------|------|------|------|------|----------|
| **数组** | O(n) | O(n) | O(1) | O(1) | 随机访问密集 |
| **链表** | O(1) | O(1) | O(n) | O(n) | 插入删除频繁 |
| **栈** | O(1) | O(1) | O(n) | - | LIFO操作 |
| **队列** | O(1) | O(1) | O(n) | - | FIFO操作 |
| **哈希表** | O(1) | O(1) | O(1) | O(1) | 快速查找 |
| **平衡树** | O(log n) | O(log n) | O(log n) | O(log n) | 动态有序 |
| **线段树** | O(log n) | O(log n) | O(log n) | O(log n) | 区间操作 |
| **树状数组** | O(log n) | O(log n) | O(log n) | O(log n) | 前缀操作 |
| **并查集** | - | - | α(n) | α(n) | 集合操作 |

---


## 排序算法

**定义与分类**
排序是将一组数据按照特定顺序进行排列的过程，是算法中的基础操作。根据数据结构特性，选择合适的排序算法能够显著提高效率。

### 排序算法实现

```cpp
// 1. 插入排序 - 适合小数组或基本有序数组
void insertionSort(vector<int>& arr) {
    for (int i = 1; i < arr.size(); i++) {
        int key = arr[i];
        int j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}

// 2. 快速排序 - 平均性能最好
void quickSort(vector<int>& arr, int left, int right) {
    if (left < right) {
        int pivot = partition(arr, left, right);
        quickSort(arr, left, pivot - 1);
        quickSort(arr, pivot + 1, right);
    }
}

int partition(vector<int>& arr, int left, int right) {
    int pivot = arr[right];
    int i = left - 1;
    for (int j = left; j < right; j++) {
        if (arr[j] <= pivot) {
            i++;
            swap(arr[i], arr[j]);
        }
    }
    swap(arr[i + 1], arr[right]);
    return i + 1;
}

// 3. 归并排序 - 稳定排序，适合链表
void mergeSort(vector<int>& arr, int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);
        merge(arr, left, mid, right);
    }
}

void merge(vector<int>& arr, int left, int mid, int right) {
    vector<int> temp(right - left + 1);
    int i = left, j = mid + 1, k = 0;
    
    while (i <= mid && j <= right) {
        if (arr[i] <= arr[j]) {
            temp[k++] = arr[i++];
        } else {
            temp[k++] = arr[j++];
        }
    }
    
    while (i <= mid) temp[k++] = arr[i++];
    while (j <= right) temp[k++] = arr[j++];
    
    for (i = left, k = 0; i <= right; i++, k++) {
        arr[i] = temp[k];
    }
}

// 4. 堆排序 - 原地排序，适合数组
void heapSort(vector<int>& arr) {
    int n = arr.size();
    
    // 构建最大堆
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }
    
    // 逐个提取元素
    for (int i = n - 1; i > 0; i--) {
        swap(arr[0], arr[i]);
        heapify(arr, i, 0);
    }
}

void heapify(vector<int>& arr, int n, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;
    
    if (left < n && arr[left] > arr[largest])
        largest = left;
    
    if (right < n && arr[right] > arr[largest])
        largest = right;
    
    if (largest != i) {
        swap(arr[i], arr[largest]);
        heapify(arr, n, largest);
    }
}

# Python实现
def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key

def quick_sort(arr, left, right):
    if left < right:
        pivot = partition(arr, left, right)
        quick_sort(arr, left, pivot - 1)
        quick_sort(arr, pivot + 1, right)

def partition(arr, left, right):
    pivot = arr[right]
    i = left - 1
    for j in range(left, right):
        if arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    arr[i + 1], arr[right] = arr[right], arr[i + 1]
    return i + 1

def merge_sort(arr, left, right):
    if left < right:
        mid = left + (right - left) // 2
        merge_sort(arr, left, mid)
        merge_sort(arr, mid + 1, right)
        merge(arr, left, mid, right)

def merge(arr, left, mid, right):
    temp = [0] * (right - left + 1)
    i, j, k = left, mid + 1, 0
    
    while i <= mid and j <= right:
        if arr[i] <= arr[j]:
            temp[k] = arr[i]
            i += 1
        else:
            temp[k] = arr[j]
            j += 1
        k += 1
    
    while i <= mid:
        temp[k] = arr[i]
        i += 1
        k += 1
    
    while j <= right:
        temp[k] = arr[j]
        j += 1
        k += 1
    
    for i in range(left, right + 1):
        arr[i] = temp[i - left]

def heap_sort(arr):
    n = len(arr)
    
    # 构建最大堆
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)
    
    # 逐个提取元素
    for i in range(n - 1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]
        heapify(arr, i, 0)

def heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2
    
    if left < n and arr[left] > arr[largest]:
        largest = left
    
    if right < n and arr[right] > arr[largest]:
        largest = right
    
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)
```

**排序算法复杂度对比**

| 算法 | 平均时间 | 最坏时间 | 空间复杂度 | 稳定性 | 适用场景 |
|------|----------|----------|------------|--------|----------|
| 插入排序 | O(n²) | O(n²) | O(1) | 稳定 | 小数组/基本有序 |
| 快速排序 | O(n log n) | O(n²) | O(log n) | 不稳定 | 通用场景 |
| 归并排序 | O(n log n) | O(n log n) | O(n) | 稳定 | 链表/稳定需求 |
| 堆排序 | O(n log n) | O(n log n) | O(1) | 不稳定 | 原地排序 |

---


## 二叉树遍历

```cpp
// 二叉树节点定义
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// 前序遍历 - 递归
void preorderTraversal(TreeNode* root, vector<int>& result) {
    if (root) {
        result.push_back(root->val);
        preorderTraversal(root->left, result);
        preorderTraversal(root->right, result);
    }
}

// 中序遍历 - 递归
void inorderTraversal(TreeNode* root, vector<int>& result) {
    if (root) {
        inorderTraversal(root->left, result);
        result.push_back(root->val);
        inorderTraversal(root->right, result);
    }
}

// 后序遍历 - 递归
void postorderTraversal(TreeNode* root, vector<int>& result) {
    if (root) {
        postorderTraversal(root->left, result);
        postorderTraversal(root->right, result);
        result.push_back(root->val);
    }
}

// 层序遍历 - 使用队列
void levelOrderTraversal(TreeNode* root, vector<vector<int>>& result) {
    if (!root) return;
    
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        int levelSize = q.size();
        vector<int> currentLevel;
        
        for (int i = 0; i < levelSize; i++) {
            TreeNode* node = q.front();
            q.pop();
            currentLevel.push_back(node->val);
            
            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
        
        result.push_back(currentLevel);
    }
}

# Python实现
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def preorder_traversal(root):
    if not root:
        return []
    return [root.val] + preorder_traversal(root.left) + preorder_traversal(root.right)

def inorder_traversal(root):
    if not root:
        return []
    return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right)

def postorder_traversal(root):
    if not root:
        return []
    return postorder_traversal(root.left) + postorder_traversal(root.right) + [root.val]

def level_order_traversal(root):
    if not root:
        return []
    
    from collections import deque
    q = deque([root])
    result = []
    
    while q:
        level_size = len(q)
        current_level = []
        
        for _ in range(level_size):
            node = q.popleft()
            current_level.append(node.val)
            
            if node.left:
                q.append(node.left)
            if node.right:
                q.append(node.right)
        
        result.append(current_level)
    
    return result
```

---

## 图结构相关算法


### Dijkstra算法

```cpp
vector<int> dijkstra(int n, int start, const vector<vector<pair<int, int>>>& graph) {
    vector<int> dist(n + 1, INT_MAX);
    vector<bool> visited(n + 1, false);
    dist[start] = 0;
    
    // 使用优先队列优化
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    pq.push({0, start});
    
    while (!pq.empty()) {
        int u = pq.top().second;
        int d = pq.top().first;
        pq.pop();
        
        if (visited[u]) continue;
        visited[u] = true;
        
        for (const auto& edge : graph[u]) {
            int v = edge.first;
            int weight = edge.second;
            
            if (!visited[v] && dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
                pq.push({dist[v], v});
            }
        }
    }
    
    return dist;
}

def dijkstra(n, start, graph):
    import heapq
    dist = [float('inf')] * (n + 1)
    dist[start] = 0
    visited = [False] * (n + 1)
    
    heap = [(0, start)]
    
    while heap:
        d, u = heapq.heappop(heap)
        
        if visited[u]:
            continue
        
        visited[u] = True
        
        for v, weight in graph[u]:
            if not visited[v] and dist[u] + weight < dist[v]:
                dist[v] = dist[u] + weight
                heapq.heappush(heap, (dist[v], v))
    
    return dist
```

---

## 字符串结构相关算法

### KMP算法

```cpp
vector<int> computeLPS(const string& pattern) {
    int n = pattern.length();
    vector<int> lps(n, 0);
    int len = 0, i = 1;
    
    while (i < n) {
        if (pattern[i] == pattern[len]) {
            len++;
            lps[i] = len;
            i++;
        } else {
            if (len != 0) {
                len = lps[len - 1];
            } else {
                lps[i] = 0;
                i++;
            }
        }
    }
    
    return lps;
}

vector<int> kmpSearch(const string& text, const string& pattern) {
    vector<int> lps = computeLPS(pattern);
    vector<int> result;
    int i = 0, j = 0;
    
    while (i < text.length()) {
        if (pattern[j] == text[i]) {
            i++;
            j++;
        }
        
        if (j == pattern.length()) {
            result.push_back(i - j);
            j = lps[j - 1];
        } else if (i < text.length() && pattern[j] != text[i]) {
            if (j != 0) {
                j = lps[j - 1];
            } else {
                i++;
            }
        }
    }
    
    return result;
}

def compute_lps(pattern):
    n = len(pattern)
    lps = [0] * n
    length = 0
    i = 1
    
    while i < n:
        if pattern[i] == pattern[length]:
            length += 1
            lps[i] = length
            i += 1
        else:
            if length != 0:
                length = lps[length - 1]
            else:
                lps[i] = 0
                i += 1
    
    return lps

def kmp_search(text, pattern):
    lps = compute_lps(pattern)
    result = []
    i = 0
    j = 0
    
    while i < len(text):
        if pattern[j] == text[i]:
            i += 1
            j += 1
        
        if j == len(pattern):
            result.append(i - j)
            j = lps[j - 1]
        elif i < len(text) and pattern[j] != text[i]:
            if j != 0:
                j = lps[j - 1]
            else:
                i += 1
    
    return result
```
