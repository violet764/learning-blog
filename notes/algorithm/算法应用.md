# 算法应用与优化


## ACM模式数据的读入

Python对于数据的读入：用 `input()` 读取每行，再解析（比如分割、转类型）。
C++对于数据的读入：用 `cin/scanf` 读取数值，或 `getline` 读取整行。
::: code-group
```python
# 读取一行输入（比如"1 2 3"），转成整数列表
nums = list(map(int, input().split()))

# 读取多行输入（比如多组测试用例）
while True:
    try:
        line = input().strip()
        if not line:
            break
        # 处理line
    except EOFError:
        break
```

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int n;
    cin >> n; // 读取整数
    
    vector<int> nums(n);
    for (int i = 0; i < n; ++i) {
        cin >> nums[i]; // 读取数组
    }
    
    // 处理数据后输出
    cout << nums[0] << endl;
    return 0;
}
```
:::

## 时间复杂度分析
时间复杂度表示算法执行时间随输入数据规模增长的变化趋势。它不是具体的执行时间，而是描述算法效率的量度。
::: code-group
```cpp
// 1. 单层循环 - O(n)
void linearLoop(int n) {
    for (int i = 0; i < n; i++) {
        // O(1) 操作
    }
}

// 2. 嵌套循环 - O(n²)
void nestedLoop(int n) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            // O(1) 操作
        }
    }
}

// 3. 对数循环 - O(log n)
void logarithmicLoop(int n) {
    for (int i = 1; i < n; i *= 2) {
        // O(1) 操作
    }
}

// 4. 二分查找 - O(log n)
int binarySearch(const vector<int>& arr, int target) {
    int left = 0, right = arr.size() - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] == target) return mid;
        else if (arr[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    return -1;
}
````
```python
def linear_loop(n):
    for i in range(n):
        pass  # O(1) 操作

def nested_loop(n):
    for i in range(n):
        for j in range(n):
            pass  # O(1) 操作

def logarithmic_loop(n):
    i = 1
    while i < n:
        i *= 2
        pass  # O(1) 操作

def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
```
:::

## 空间复杂度分析
空间复杂度表示算法在执行过程中需要的额外存储空间（不包括输入数据本身）随输入规模增长的变化趋势。
::: code-group
```cpp
// 1. 原地操作 - O(1) 空间
void reverseArray(vector<int>& arr) {
    int left = 0, right = arr.size() - 1;
    while (left < right) {
        swap(arr[left], arr[right]);
        left++;
        right--;
    }
}

// 2. 递归深度分析 - O(log n) 空间
int binarySearchSpace(const vector<int>& arr, int left, int right, int target) {
    if (left > right) return -1;
    int mid = left + (right - left) / 2;
    if (arr[mid] == target) return mid;
    else if (arr[mid] < target) 
        return binarySearchSpace(arr, mid + 1, right, target);
    else 
        return binarySearchSpace(arr, left, mid - 1, target);
}

// 3. 动态数组 - O(n) 空间
vector<int> copyArray(const vector<int>& arr) {
    vector<int> result(arr.size());  // O(n) 额外空间
    for (int i = 0; i < arr.size(); i++) {
        result[i] = arr[i];
    }
    return result;
}
```
```python
# Python实现
def reverse_array(arr):
    left, right = 0, len(arr) - 1
    while left < right:
        arr[left], arr[right] = arr[right], arr[left]
        left += 1
        right -= 1

def binary_search_space(arr, left, right, target):
    if left > right:
        return -1
    mid = left + (right - left) // 2
    if arr[mid] == target:
        return mid
    elif arr[mid] < target:
        return binary_search_space(arr, mid + 1, right, target)
    else:
        return binary_search_space(arr, left, mid - 1, target)

def copy_array(arr):
    result = [0] * len(arr)  # O(n) 额外空间
    for i in range(len(arr)):
        result[i] = arr[i]
    return result
```
:::



## 数据结构效率对比

| 数据结构 | 插入 | 删除 | 查找 | 修改 | 适用场景 |
|----------|------|------|------|------|----------|
| **数组** | O(n) | O(n) | O(1) | O(1) | 随机访问密集 |
| **链表** | O(1) | O(1) | O(n) | O(n) | 插入删除频繁 |
| **栈** | O(1) | O(1) | O(n) | - | LIFO操作 |
| **队列** | O(1) | O(1) | O(n) | - | FIFO操作 |
| **哈希表** | O(1) | O(1) | O(1) | O(1) | 快速查找 |
| **平衡树** | O(log n) | O(log n) | O(log n) | O(log n) | 动态有序 |
| **线段树** | O(log n) | O(log n) | O(log n) | O(log n) | 区间操作 |
| **树状数组** | O(log n) | O(log n) | O(log n) | O(log n) | 前缀操作 |
| **并查集** | - | - | α(n) | α(n) | 集合操作 |

---


## 排序算法

**定义与分类**
排序是将一组数据按照特定顺序进行排列的过程，是算法中的基础操作。根据数据结构特性，选择合适的排序算法能够显著提高效率。

### 选择排序

**核心思想**：每次从待排序数据中选择最小（或最大）的元素，放到已排序序列的末尾。

**操作步骤**：

1. 在未排序序列中找到最小元素
2. 将其与未排序序列的第一个元素交换
3. 将已排序序列长度增加1
4. 重复步骤1-3，直到所有元素排序完成

**时间复杂度**：O(n²)

**稳定性**：不稳定（可能改变相同元素的相对位置）

:::code-group
```python
def selection_sort(arr):
    """
    选择排序
    :param arr: 待排序数组
    :return: 排序后的数组
    """
    n = len(arr)
    # 遍历所有数组元素
    for i in range(n):
        # 假设当前位置是最小值的索引
        min_idx = i
        
        # 在剩余部分中寻找更小的元素
        for j in range(i + 1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        
        # 将找到的最小元素与当前位置交换
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    
    return arr
```
```cpp
#include <iostream>
#include <vector>
using namespace std;

void selectionSort(vector<int>& arr) {
    int n = arr.size();
    
    // 遍历所有数组元素
    for (int i = 0; i < n - 1; i++) {
        // 假设当前位置是最小值的索引
        int minIdx = i;
        
        // 在剩余部分中寻找更小的元素
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIdx]) {
                minIdx = j;
            }
        }
        
        // 将找到的最小元素与当前位置交换
        swap(arr[i], arr[minIdx]);
    }
}
```
:::
---

### 冒泡排序

**核心思想**：重复遍历数组，比较相邻元素，如果顺序错误就交换，直到没有需要交换的元素。

**操作步骤**：

1. 从第一个元素开始，比较相邻元素
2. 如果顺序错误（前 > 后），交换它们
3. 重复遍历，直到一次遍历中没有发生交换


**时间复杂度**：O(n²)

**稳定性**：稳定

:::code-group
```python
def bubble_sort(arr):
    """
    冒泡排序（优化版）
    :param arr: 待排序数组
    :return: 排序后的数组
    """
    n = len(arr)
    
    # 遍历所有数组元素
    for i in range(n):
        swapped = False  # 优化：记录是否发生交换
        
        # 最后i个元素已经有序
        for j in range(0, n - i - 1):
            # 如果当前元素大于下一个元素，交换
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                swapped = True
        
        # 如果这一轮没有发生交换，说明数组已有序
        if not swapped:
            break
    
    return arr
```

```cpp
#include <iostream>
#include <vector>
using namespace std;

void bubbleSort(vector<int>& arr) {
    int n = arr.size();
    bool swapped;
    
    for (int i = 0; i < n - 1; i++) {
        swapped = false;
        
        // 最后i个元素已经有序
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
                swapped = true;
            }
        }
        
        // 如果没有发生交换，提前结束
        if (!swapped) {
            break;
        }
    }
}
```
:::
---

### 插入排序

**核心思想**：将数组分为已排序和未排序两部分，每次从未排序部分取一个元素插入到已排序部分的正确位置。

**操作步骤**：

1. 第一个元素视为已排序
2. 取下一个元素，在已排序序列中从后向前扫描
3. 如果当前元素大于新元素，将当前元素后移一位
4. 找到合适位置后，插入新元素
5. 重复步骤2-4

**时间复杂度**：O(n²)

**稳定性**：稳定

:::code-group
```python
def insertion_sort(arr):
    """
    插入排序
    :param arr: 待排序数组
    :return: 排序后的数组
    """
    n = len(arr)
    
    # 从第二个元素开始
    for i in range(1, n):
        key = arr[i]  # 当前要插入的元素
        j = i - 1
        
        # 将比key大的元素向后移动
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        
        # 插入key到正确位置
        arr[j + 1] = key
    
    return arr
```
```python

def binary_insertion_sort(arr):
    """
    二分插入排序（优化版）
    :param arr: 待排序数组
    :return: 排序后的数组
    """
    n = len(arr)
    
    for i in range(1, n):
        key = arr[i]
        
        # 使用二分查找找到插入位置
        left, right = 0, i - 1
        while left <= right:
            mid = (left + right) // 2
            if key < arr[mid]:
                right = mid - 1
            else:
                left = mid + 1
        
        # 移动元素，为插入腾出空间
        for j in range(i - 1, left - 1, -1):
            arr[j + 1] = arr[j]
        
        # 插入元素
        arr[left] = key
    
    return arr
```
```cpp
#include <iostream>
#include <vector>
using namespace std;

void insertionSort(vector<int>& arr) {
    int n = arr.size();
    
    for (int i = 1; i < n; i++) {
        int key = arr[i];
        int j = i - 1;
        
        // 将比key大的元素向后移动
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        
        // 插入key到正确位置
        arr[j + 1] = key;
    }
}
```
```cpp
void binaryInsertionSort(vector<int>& arr) {
    int n = arr.size();
    
    for (int i = 1; i < n; i++) {
        int key = arr[i];
        
        // 二分查找插入位置
        int left = 0, right = i - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (key < arr[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        
        // 移动元素
        for (int j = i - 1; j >= left; j--) {
            arr[j + 1] = arr[j];
        }
        
        // 插入元素
        arr[left] = key;
    }
}
```
:::
---

### 希尔排序
**核心思想**：插入排序的改进版，通过将数组按间隔分组，分别进行插入排序，逐渐缩小间隔直至为1。

**操作步骤**：

1. 选择一个增量序列（如n/2, n/4, ..., 1）
2. 按当前增量将数组分组
3. 对每组进行插入排序
4. 减小增量，重复步骤2-3，直到增量为1

**增量序列选择**：

- 希尔原始序列：n/2, n/4, ..., 1
- Knuth序列：1, 4, 13, 40, ... (3^k - 1)/2
- Sedgewick序列：1, 5, 19, 41, ...

**时间复杂度**：O(n^1.3) ~ O(n^1.5)

**稳定性**：不稳定

:::code-group

```python
def shell_sort_original(arr):
    """
    希尔排序（原始实现，使用n/2序列）
    :param arr: 待排序数组
    :return: 排序后的数组
    """
    n = len(arr)
    
    # 初始间隔为n/2，逐步减半
    gap = n // 2
    
    while gap > 0:
        # 对每个间隔进行插入排序
        for i in range(gap, n):
            temp = arr[i]
            j = i
            
            while j >= gap and arr[j - gap] > temp:
                arr[j] = arr[j - gap]
                j -= gap
            
            arr[j] = temp
        
        gap //= 2
    
    return arr
```

```cpp
void shellSortOriginal(vector<int>& arr) {
    int n = arr.size();
    
    // 使用n/2序列
    for (int gap = n / 2; gap > 0; gap /= 2) {
        // 对每个间隔进行插入排序
        for (int i = gap; i < n; i++) {
            int temp = arr[i];
            int j = i;
            
            while (j >= gap && arr[j - gap] > temp) {
                arr[j] = arr[j - gap];
                j -= gap;
            }
            
            arr[j] = temp;
        }
    }
}
```
:::
---

### 快速排序
**核心思想**：分治法，选择一个基准元素，将数组分为两部分，左边都小于基准，右边都大于基准，然后递归排序。

**操作步骤**：

1. 选择基准元素（pivot）
2. 分区操作：将所有小于基准的元素移到左边，大于基准的移到右边
3. 递归排序左右两个子数组

**基准选择策略**：

- 选择第一个元素（简单但不适合已排序数组）
- 随机选择
- 选择中位数（三数取中）

**时间复杂度**：O(n log n)

**稳定性**：不稳定

:::code-group
```python
def quick_sort(arr):
    """
    快速排序（基础版）
    :param arr: 待排序数组
    :return: 排序后的数组
    """
    if len(arr) <= 1:
        return arr
    
    # 选择基准元素（这里选择最后一个元素）
    pivot = arr[-1]
    
    # 分区
    left = []
    right = []
    middle = []
    
    for num in arr:
        if num < pivot:
            left.append(num)
        elif num > pivot:
            right.append(num)
        else:
            middle.append(num)
    
    # 递归排序并合并
    return quick_sort(left) + middle + quick_sort(right)
```

```python
def quick_sort_iterative(arr):
    """
    快速排序（迭代版，避免递归栈溢出）
    :param arr: 待排序数组
    :return: 排序后的数组
    """
    stack = [(0, len(arr) - 1)]
    
    while stack:
        low, high = stack.pop()
        
        if low < high:
            pi = partition(arr, low, high)
            
            # 将子数组的边界压入栈中
            stack.append((low, pi - 1))
            stack.append((pi + 1, high))
    
    return arr
```
```cpp
#include <iostream>
#include <vector>
#include <stack>
#include <algorithm>
using namespace std;

// 分区函数（Hoare分区方案，效率更高）
int partitionHoare(vector<int>& arr, int low, int high) {
    // 三数取中法选择基准
    int mid = low + (high - low) / 2;
    
    // 确保arr[low] <= arr[mid] <= arr[high]
    if (arr[low] > arr[mid]) swap(arr[low], arr[mid]);
    if (arr[low] > arr[high]) swap(arr[low], arr[high]);
    if (arr[mid] > arr[high]) swap(arr[mid], arr[high]);
    
    // 将中位数作为基准
    int pivot = arr[mid];
    swap(arr[mid], arr[high - 1]);  // 将基准放到high-1位置
    
    int i = low - 1;
    int j = high;
    
    while (true) {
        do {
            i++;
        } while (arr[i] < pivot);
        
        do {
            j--;
        } while (arr[j] > pivot);
        
        if (i >= j) {
            break;
        }
        
        swap(arr[i], arr[j]);
    }
    
    swap(arr[i], arr[high - 1]);
    return i;
}

// 递归版快速排序
void quickSortRecursive(vector<int>& arr, int low, int high) {
    if (low < high) {
        int pi = partitionHoare(arr, low, high);
        quickSortRecursive(arr, low, pi - 1);
        quickSortRecursive(arr, pi + 1, high);
    }
}

// 迭代版快速排序
void quickSortIterative(vector<int>& arr) {
    int n = arr.size();
    stack<pair<int, int>> stk;
    stk.push({0, n - 1});
    
    while (!stk.empty()) {
        int low = stk.top().first;
        int high = stk.top().second;
        stk.pop();
        
        if (low < high) {
            int pi = partitionHoare(arr, low, high);
            
            // 将左右子数组的边界压入栈中
            if (pi - 1 > low) {
                stk.push({low, pi - 1});
            }
            if (pi + 1 < high) {
                stk.push({pi + 1, high});
            }
        }
    }
}

// 封装函数
void quickSort(vector<int>& arr) {
    if (arr.size() <= 1) return;
    quickSortRecursive(arr, 0, arr.size() - 1);
}
```
:::
---

### 归并排序
**核心思想**：分治法，将数组分成两半，分别排序，然后合并两个有序数组。

**操作步骤**：

1. 将数组递归地分成两半，直到每个子数组只有一个元素
2. 合并相邻的子数组，保持有序
3. 重复合并，直到整个数组有序

**时间复杂度**：O(n log n)  
**稳定性**：稳定

:::code-group
```python
def merge_sort(arr):
    """
    归并排序（递归版）
    :param arr: 待排序数组
    :return: 排序后的数组
    """
    if len(arr) <= 1:
        return arr
    
    # 分割数组
    mid = len(arr) // 2
    left_half = arr[:mid]
    right_half = arr[mid:]
    
    # 递归排序
    left_half = merge_sort(left_half)
    right_half = merge_sort(right_half)
    
    # 合并
    return merge(left_half, right_half)

def merge(left, right):
    """
    合并两个有序数组
    :param left: 左有序数组
    :param right: 右有序数组
    :return: 合并后的有序数组
    """
    result = []
    i = j = 0
    
    # 合并两个数组
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    # 添加剩余元素
    result.extend(left[i:])
    result.extend(right[j:])
    
    return result
```

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// 合并两个有序数组
void merge(vector<int>& arr, int left, int mid, int right, vector<int>& temp) {
    int i = left;
    int j = mid + 1;
    int k = left;
    
    // 合并两个有序部分
    while (i <= mid && j <= right) {
        if (arr[i] <= arr[j]) {
            temp[k++] = arr[i++];
        } else {
            temp[k++] = arr[j++];
        }
    }
    
    // 复制剩余元素
    while (i <= mid) {
        temp[k++] = arr[i++];
    }
    
    while (j <= right) {
        temp[k++] = arr[j++];
    }
    
    // 将临时数组复制回原数组
    for (int i = left; i <= right; i++) {
        arr[i] = temp[i];
    }
}

// 递归版归并排序
void mergeSortRecursive(vector<int>& arr, int left, int right, vector<int>& temp) {
    if (left < right) {
        int mid = left + (right - left) / 2;
        
        // 递归排序左右两部分
        mergeSortRecursive(arr, left, mid, temp);
        mergeSortRecursive(arr, mid + 1, right, temp);
        
        // 合并两个有序部分
        merge(arr, left, mid, right, temp);
    }
}

// 封装函数
void mergeSort(vector<int>& arr) {
    if (arr.size() <= 1) return;
    
    vector<int> temp(arr.size());
    mergeSortRecursive(arr, 0, arr.size() - 1, temp);
}
```
:::
---

### 堆排序
**核心思想**：利用堆这种数据结构，将数组构建成最大堆（或最小堆），然后不断取出堆顶元素。

**操作步骤**：

1. 将无序数组构建成最大堆
2. 将堆顶元素（最大值）与最后一个元素交换
3. 减少堆的大小，重新调整堆
4. 重复步骤2-3，直到堆大小为1

**时间复杂度**：O(n log n)

**稳定性**：不稳定

:::code-group
```python
def heap_sort(arr):
    """
    堆排序（使用最大堆）
    :param arr: 待排序数组
    :return: 排序后的数组
    """
    n = len(arr)
    
    # 构建最大堆
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)
    
    # 一个个从堆顶取出元素
    for i in range(n - 1, 0, -1):
        # 将当前最大值（堆顶）与末尾元素交换
        arr[0], arr[i] = arr[i], arr[0]
        
        # 重新调整堆
        heapify(arr, i, 0)
    
    return arr
```
```python
def heapify(arr, n, i):
    """
    调整堆，使以i为根的子树成为最大堆
    :param arr: 数组
    :param n: 堆的大小
    :param i: 当前根节点索引
    """
    largest = i  # 初始化最大值为根
    left = 2 * i + 1  # 左子节点
    right = 2 * i + 2  # 右子节点
    
    # 如果左子节点存在且大于根
    if left < n and arr[left] > arr[largest]:
        largest = left
    
    # 如果右子节点存在且大于当前最大值
    if right < n and arr[right] > arr[largest]:
        largest = right
    
    # 如果最大值不是根
    if largest != i:
        # 交换根与最大值
        arr[i], arr[largest] = arr[largest], arr[i]
        
        # 递归调整受影响的子树
        heapify(arr, n, largest)

```

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// 调整堆，使以i为根的子树成为最大堆
void heapify(vector<int>& arr, int n, int i) {
    int largest = i;        // 初始化最大值为根
    int left = 2 * i + 1;   // 左子节点
    int right = 2 * i + 2;  // 右子节点
    
    // 如果左子节点存在且大于根
    if (left < n && arr[left] > arr[largest]) {
        largest = left;
    }
    
    // 如果右子节点存在且大于当前最大值
    if (right < n && arr[right] > arr[largest]) {
        largest = right;
    }
    
    // 如果最大值不是根
    if (largest != i) {
        swap(arr[i], arr[largest]);
        
        // 递归调整受影响的子树
        heapify(arr, n, largest);
    }
}

// 堆排序
void heapSort(vector<int>& arr) {
    int n = arr.size();
    
    // 构建最大堆（从最后一个非叶子节点开始）
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }
    
    // 一个个从堆顶取出元素
    for (int i = n - 1; i > 0; i--) {
        // 将当前最大值（堆顶）与末尾元素交换
        swap(arr[0], arr[i]);
        
        // 重新调整堆
        heapify(arr, i, 0);
    }
}

// 使用C++ STL的优先队列实现堆排序（简化版）
vector<int> heapSortSTL(const vector<int>& arr) {
    // 构建最大堆
    vector<int> result = arr;
    make_heap(result.begin(), result.end());
    
    // 排序
    sort_heap(result.begin(), result.end());
    
    return result;
}
```
:::
---

### 桶排序
**核心思想**：将数据分到有限数量的桶里，每个桶再单独排序（可能使用其他排序算法），最后合并所有桶。

**操作步骤**：

1. 确定桶的数量和范围
2. 将元素分配到对应的桶中
3. 对每个桶内的元素进行排序
4. 按顺序合并所有桶

**时间复杂度**：平均情况：O(n + k)

**稳定性**：稳定（取决于桶内排序算法的稳定性）

:::code-group
```python
def bucket_sort(arr, bucket_size=10):
    """
    桶排序
    :param arr: 待排序数组（假设元素在[0,1)范围内）
    :param bucket_size: 桶的大小
    :return: 排序后的数组
    """
    if len(arr) == 0:
        return arr
    
    # 找到最大值和最小值
    min_val = min(arr)
    max_val = max(arr)
    
    # 计算桶的数量
    bucket_count = (max_val - min_val) // bucket_size + 1
    buckets = [[] for _ in range(int(bucket_count))]
    
    # 将元素分配到桶中
    for num in arr:
        index = int((num - min_val) // bucket_size)
        buckets[index].append(num)
    
    # 对每个桶进行排序（这里使用插入排序）
    result = []
    for bucket in buckets:
        if bucket:
            insertion_sort(bucket)  # 使用之前定义的插入排序
            result.extend(bucket)
    
    return result
```
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// 插入排序（用于桶内排序）
void insertionSortForBucket(vector<float>& arr) {
    int n = arr.size();
    for (int i = 1; i < n; i++) {
        float key = arr[i];
        int j = i - 1;
        
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}


// 桶排序（针对整数）
vector<int> bucketSortInt(vector<int>& arr, int bucketSize = 10) {
    if (arr.empty()) return arr;
    
    // 找到最大值和最小值
    int minVal = *min_element(arr.begin(), arr.end());
    int maxVal = *max_element(arr.begin(), arr.end());
    
    // 计算桶的数量
    int bucketCount = (maxVal - minVal) / bucketSize + 1;
    vector<vector<int>> buckets(bucketCount);
    
    // 将元素分配到桶中
    for (int num : arr) {
        int index = (num - minVal) / bucketSize;
        buckets[index].push_back(num);
    }
    
    // 对每个桶进行排序并合并
    vector<int> result;
    for (auto& bucket : buckets) {
        if (!bucket.empty()) {
            sort(bucket.begin(), bucket.end());  // 使用STL排序
            result.insert(result.end(), bucket.begin(), bucket.end());
        }
    }
    
    return result;
}
```
:::
---

### 计数排序
**核心思想**：统计每个元素出现的次数，然后根据统计信息将元素放到正确位置。

**操作步骤**：

1. 找出待排序数组中的最大值和最小值
2. 创建计数数组，统计每个元素出现的次数
3. 将计数数组转换为前缀和数组
4. 反向遍历原数组，根据计数数组将元素放到输出数组的正确位置

**时间复杂度**：O(n + k)，k为数据范围
**稳定性**：稳定

:::code-group
```python
def counting_sort(arr):
    """
    计数排序（基础版，适合非负整数）
    :param arr: 待排序数组（非负整数）
    :return: 排序后的数组
    """
    if len(arr) == 0:
        return arr
    
    # 找到最大值和最小值
    max_val = max(arr)
    min_val = min(arr)
    
    # 创建计数数组
    count_size = max_val - min_val + 1
    count = [0] * count_size
    
    # 统计每个元素出现的次数
    for num in arr:
        count[num - min_val] += 1
    
    # 重建排序后的数组
    result = []
    for i in range(count_size):
        result.extend([i + min_val] * count[i])
    
    return result
```


```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// 计数排序（基础版）
vector<int> countingSortBasic(const vector<int>& arr) {
    if (arr.empty()) return {};
    
    // 找到最大值和最小值
    int maxVal = *max_element(arr.begin(), arr.end());
    int minVal = *min_element(arr.begin(), arr.end());
    
    // 创建计数数组
    int range = maxVal - minVal + 1;
    vector<int> count(range, 0);
    
    // 统计每个元素出现的次数
    for (int num : arr) {
        count[num - minVal]++;
    }
    
    // 重建排序后的数组
    vector<int> result;
    for (int i = 0; i < range; i++) {
        for (int j = 0; j < count[i]; j++) {
            result.push_back(i + minVal);
        }
    }
    
    return result;
}

```
:::
---

### 基数排序
**核心思想**：按位排序，从最低有效位到最高有效位，每次使用稳定的排序算法（如计数排序）对一位进行排序。

**操作步骤**：

1. 找到数组中的最大数，确定最大位数
2. 从最低位开始，对每一位进行稳定排序
3. 重复步骤2，直到最高位

**时间复杂度**：O(d * (n + k))，d为最大位数，k为基数（通常为10）  
**稳定性**：稳定

:::code-group
```python
def counting_sort_for_radix(arr, exp):
    """
    用于基数排序的计数排序（按指定位排序）
    :param arr: 待排序数组
    :param exp: 当前位数（1, 10, 100, ...）
    :return: 按当前位排序后的数组
    """
    n = len(arr)
    output = [0] * n
    count = [0] * 10  # 0-9
    
    # 统计当前位上每个数字的出现次数
    for i in range(n):
        index = (arr[i] // exp) % 10
        count[index] += 1
    
    # 计算前缀和
    for i in range(1, 10):
        count[i] += count[i - 1]
    
    # 反向遍历，保证稳定性
    for i in range(n - 1, -1, -1):
        index = (arr[i] // exp) % 10
        output[count[index] - 1] = arr[i]
        count[index] -= 1
    
    return output


```
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;

// 用于基数排序的计数排序
void countingSortForRadix(vector<int>& arr, int exp) {
    int n = arr.size();
    vector<int> output(n);
    vector<int> count(10, 0);
    
    // 统计当前位上每个数字的出现次数
    for (int i = 0; i < n; i++) {
        int index = (arr[i] / exp) % 10;
        count[index]++;
    }
    
    // 计算前缀和
    for (int i = 1; i < 10; i++) {
        count[i] += count[i - 1];
    }
    
    // 反向遍历，保证稳定性
    for (int i = n - 1; i >= 0; i--) {
        int index = (arr[i] / exp) % 10;
        output[count[index] - 1] = arr[i];
        count[index]--;
    }
    
    // 复制回原数组
    arr = output;
}

```
:::
---

### 排序算法性能比较表

| 排序算法 | 最好情况 | 平均情况 | 最坏情况 | 空间复杂度 | 稳定性 | 适用场景 |
|---------|---------|---------|---------|-----------|--------|---------|
| 选择排序 | O(n²) | O(n²) | O(n²) | O(1) | 不稳定 | 小数据集，空间有限 |
| 冒泡排序 | O(n) | O(n²) | O(n²) | O(1) | 稳定 | 教学使用，几乎不用在实际中 |
| 插入排序 | O(n) | O(n²) | O(n²) | O(1) | 稳定 | 小数据集，基本有序的数据 |
| 希尔排序 | O(n log n) | O(n^1.3-1.5) | O(n²) | O(1) | 不稳定 | 中等大小数据集 |
| 快速排序 | O(n log n) | O(n log n) | O(n²) | O(log n) | 不稳定 | 通用排序，大数据集 |
| 归并排序 | O(n log n) | O(n log n) | O(n log n) | O(n) | 稳定 | 需要稳定排序，大数据集 |
| 堆排序 | O(n log n) | O(n log n) | O(n log n) | O(1) | 不稳定 | 空间有限的大数据集 |
| 桶排序 | O(n + k) | O(n + k) | O(n²) | O(n + k) | 稳定 | 均匀分布的数据 |
| 计数排序 | O(n + k) | O(n + k) | O(n + k) | O(n + k) | 稳定 | 小范围整数 |
| 基数排序 | O(d(n + k)) | O(d(n + k)) | O(d(n + k)) | O(n + k) | 稳定 | 多位数整数或字符串 |
---

## 二分搜索
二分搜索的核心前提：数据必须**有序**（单调递增或递减）

**基本思想:**  

1. 每次取中间元素与目标比较
2. 根据比较结果缩小搜索范围一半
3. 重复直到找到目标或范围为空

**时间复杂度：**O(log n)


:::code-group
```python
def binary_search(nums: list[int], target: int) -> int:
    """二分查找（双闭区间）"""
    # 初始化双闭区间 [0, n-1] ，即 i, j 分别指向数组首元素、尾元素
    i, j = 0, len(nums) - 1
    # 循环，当搜索区间为空时跳出（当 i > j 时为空）
    while i <= j:
        # 理论上 Python 的数字可以无限大（取决于内存大小），无须考虑大数越界问题
        m = (i + j) // 2  # 计算中点索引 m
        if nums[m] < target:
            i = m + 1  # 此情况说明 target 在区间 [m+1, j] 中
        elif nums[m] > target:
            j = m - 1  # 此情况说明 target 在区间 [i, m-1] 中
        else:
            return m  # 找到目标元素，返回其索引
    return -1  # 未找到目标元素，返回 -1
```
```python
def binary_search_lcro(nums: list[int], target: int) -> int:
    """二分查找（左闭右开区间）"""
    # 初始化左闭右开区间 [0, n) ，即 i, j 分别指向数组首元素、尾元素+1
    i, j = 0, len(nums)
    # 循环，当搜索区间为空时跳出（当 i = j 时为空）
    while i < j:
        m = (i + j) // 2  # 计算中点索引 m
        if nums[m] < target:
            i = m + 1  # 此情况说明 target 在区间 [m+1, j) 中
        elif nums[m] > target:
            j = m  # 此情况说明 target 在区间 [i, m) 中
        else:
            return m  # 找到目标元素，返回其索引
    return -1  # 未找到目标元素，返回 -1
```
```cpp
/* 二分查找（双闭区间） */
int binarySearch(vector<int> &nums, int target) {
    // 初始化双闭区间 [0, n-1] ，即 i, j 分别指向数组首元素、尾元素
    int i = 0, j = nums.size() - 1;
    // 循环，当搜索区间为空时跳出（当 i > j 时为空）
    while (i <= j) {
        int m = i + (j - i) / 2; // 计算中点索引 m
        if (nums[m] < target)    // 此情况说明 target 在区间 [m+1, j] 中
            i = m + 1;
        else if (nums[m] > target) // 此情况说明 target 在区间 [i, m-1] 中
            j = m - 1;
        else // 找到目标元素，返回其索引
            return m;
    }
    // 未找到目标元素，返回 -1
    return -1;
}
```
```cpp
/* 二分查找（左闭右开区间） */
int binarySearchLCRO(vector<int> &nums, int target) {
    // 初始化左闭右开区间 [0, n) ，即 i, j 分别指向数组首元素、尾元素+1
    int i = 0, j = nums.size();
    // 循环，当搜索区间为空时跳出（当 i = j 时为空）
    while (i < j) {
        int m = i + (j - i) / 2; // 计算中点索引 m
        if (nums[m] < target)    // 此情况说明 target 在区间 [m+1, j) 中
            i = m + 1;
        else if (nums[m] > target) // 此情况说明 target 在区间 [i, m) 中
            j = m;
        else // 找到目标元素，返回其索引
            return m;
    }
    // 未找到目标元素，返回 -1
    return -1;
}
```
:::

二分查找插入点： 

给定一个长度为 `n` 的有序数组 `nums` 和一个元素 `target` ，数组不存在重复元素。现将 `target`插入数组 `nums` 中，并保持其有序性。若数组中已存在元素 `target` ，则插入到其左方。请返回插入后 `target` 在数组中的索引.
:::code-group

```python
def binary_search_insertion(nums: list[int], target: int) -> int:
    """二分查找插入点（存在重复元素）"""
    i, j = 0, len(nums) - 1  # 初始化双闭区间 [0, n-1]
    while i <= j:
        m = (i + j) // 2  # 计算中点索引 m
        if nums[m] < target:
            i = m + 1  # target 在区间 [m+1, j] 中
        elif nums[m] > target:
            j = m - 1  # target 在区间 [i, m-1] 中
        else:
            j = m - 1  # 首个小于 target 的元素在区间 [i, m-1] 中
    # 返回插入点 i
    return i
```
```cpp
/* 二分查找插入点（存在重复元素） */
int binarySearchInsertion(vector<int> &nums, int target) {
    int i = 0, j = nums.size() - 1; // 初始化双闭区间 [0, n-1]
    while (i <= j) {
        int m = i + (j - i) / 2; // 计算中点索引 m
        if (nums[m] < target) {
            i = m + 1; // target 在区间 [m+1, j] 中
        } else if (nums[m] > target) {
            j = m - 1; // target 在区间 [i, m-1] 中
        } else {
            j = m - 1; // 首个小于 target 的元素在区间 [i, m-1] 中
        }
    }
    // 返回插入点 i
    return i;
}
```
:::










