# 算法应用与优化


## ACM模式数据的读入

Python对于数据的读入：用 `input()` 读取每行，再解析（比如分割、转类型）。
C++对于数据的读入：用 `cin/scanf` 读取数值，或 `getline` 读取整行。
::: code-group
```python
# 读取一行输入（比如"1 2 3"），转成整数列表
nums = list(map(int, input().split()))

# 读取多行输入（比如多组测试用例）
while True:
    try:
        line = input().strip()
        if not line:
            break
        # 处理line
    except EOFError:
        break
```

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int n;
    cin >> n; // 读取整数
    
    vector<int> nums(n);
    for (int i = 0; i < n; ++i) {
        cin >> nums[i]; // 读取数组
    }
    
    // 处理数据后输出
    cout << nums[0] << endl;
    return 0;
}
```
:::

## 时间复杂度分析
::: code-group
```cpp
// 1. 单层循环 - O(n)
void linearLoop(int n) {
    for (int i = 0; i < n; i++) {
        // O(1) 操作
    }
}

// 2. 嵌套循环 - O(n²)
void nestedLoop(int n) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            // O(1) 操作
        }
    }
}

// 3. 对数循环 - O(log n)
void logarithmicLoop(int n) {
    for (int i = 1; i < n; i *= 2) {
        // O(1) 操作
    }
}

// 4. 二分查找 - O(log n)
int binarySearch(const vector<int>& arr, int target) {
    int left = 0, right = arr.size() - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] == target) return mid;
        else if (arr[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    return -1;
}
````
```python
def linear_loop(n):
    for i in range(n):
        pass  # O(1) 操作

def nested_loop(n):
    for i in range(n):
        for j in range(n):
            pass  # O(1) 操作

def logarithmic_loop(n):
    i = 1
    while i < n:
        i *= 2
        pass  # O(1) 操作

def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
```
:::

## 空间复杂度分析
::: code-group
```cpp
// 1. 原地操作 - O(1) 空间
void reverseArray(vector<int>& arr) {
    int left = 0, right = arr.size() - 1;
    while (left < right) {
        swap(arr[left], arr[right]);
        left++;
        right--;
    }
}

// 2. 递归深度分析 - O(log n) 空间
int binarySearchSpace(const vector<int>& arr, int left, int right, int target) {
    if (left > right) return -1;
    int mid = left + (right - left) / 2;
    if (arr[mid] == target) return mid;
    else if (arr[mid] < target) 
        return binarySearchSpace(arr, mid + 1, right, target);
    else 
        return binarySearchSpace(arr, left, mid - 1, target);
}

// 3. 动态数组 - O(n) 空间
vector<int> copyArray(const vector<int>& arr) {
    vector<int> result(arr.size());  // O(n) 额外空间
    for (int i = 0; i < arr.size(); i++) {
        result[i] = arr[i];
    }
    return result;
}
```
```python
# Python实现
def reverse_array(arr):
    left, right = 0, len(arr) - 1
    while left < right:
        arr[left], arr[right] = arr[right], arr[left]
        left += 1
        right -= 1

def binary_search_space(arr, left, right, target):
    if left > right:
        return -1
    mid = left + (right - left) // 2
    if arr[mid] == target:
        return mid
    elif arr[mid] < target:
        return binary_search_space(arr, mid + 1, right, target)
    else:
        return binary_search_space(arr, left, mid - 1, target)

def copy_array(arr):
    result = [0] * len(arr)  # O(n) 额外空间
    for i in range(len(arr)):
        result[i] = arr[i]
    return result
```
:::



## 数据结构效率对比

| 数据结构 | 插入 | 删除 | 查找 | 修改 | 适用场景 |
|----------|------|------|------|------|----------|
| **数组** | O(n) | O(n) | O(1) | O(1) | 随机访问密集 |
| **链表** | O(1) | O(1) | O(n) | O(n) | 插入删除频繁 |
| **栈** | O(1) | O(1) | O(n) | - | LIFO操作 |
| **队列** | O(1) | O(1) | O(n) | - | FIFO操作 |
| **哈希表** | O(1) | O(1) | O(1) | O(1) | 快速查找 |
| **平衡树** | O(log n) | O(log n) | O(log n) | O(log n) | 动态有序 |
| **线段树** | O(log n) | O(log n) | O(log n) | O(log n) | 区间操作 |
| **树状数组** | O(log n) | O(log n) | O(log n) | O(log n) | 前缀操作 |
| **并查集** | - | - | α(n) | α(n) | 集合操作 |

---


## 排序算法

**定义与分类**
排序是将一组数据按照特定顺序进行排列的过程，是算法中的基础操作。根据数据结构特性，选择合适的排序算法能够显著提高效率。

### 排序算法实现
::: code-group
```cpp
// 1. 插入排序 - 适合小数组或基本有序数组
void insertionSort(vector<int>& arr) {
    for (int i = 1; i < arr.size(); i++) {
        int key = arr[i];
        int j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}

// 2. 快速排序 - 平均性能最好
void quickSort(vector<int>& arr, int left, int right) {
    if (left < right) {
        int pivot = partition(arr, left, right);
        quickSort(arr, left, pivot - 1);
        quickSort(arr, pivot + 1, right);
    }
}

int partition(vector<int>& arr, int left, int right) {
    int pivot = arr[right];
    int i = left - 1;
    for (int j = left; j < right; j++) {
        if (arr[j] <= pivot) {
            i++;
            swap(arr[i], arr[j]);
        }
    }
    swap(arr[i + 1], arr[right]);
    return i + 1;
}

// 3. 归并排序 - 稳定排序，适合链表
void mergeSort(vector<int>& arr, int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);
        merge(arr, left, mid, right);
    }
}

void merge(vector<int>& arr, int left, int mid, int right) {
    vector<int> temp(right - left + 1);
    int i = left, j = mid + 1, k = 0;
    
    while (i <= mid && j <= right) {
        if (arr[i] <= arr[j]) {
            temp[k++] = arr[i++];
        } else {
            temp[k++] = arr[j++];
        }
    }
    
    while (i <= mid) temp[k++] = arr[i++];
    while (j <= right) temp[k++] = arr[j++];
    
    for (i = left, k = 0; i <= right; i++, k++) {
        arr[i] = temp[k];
    }
}

// 4. 堆排序 - 原地排序，适合数组
void heapSort(vector<int>& arr) {
    int n = arr.size();
    
    // 构建最大堆
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }
    
    // 逐个提取元素
    for (int i = n - 1; i > 0; i--) {
        swap(arr[0], arr[i]);
        heapify(arr, i, 0);
    }
}

void heapify(vector<int>& arr, int n, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;
    
    if (left < n && arr[left] > arr[largest])
        largest = left;
    
    if (right < n && arr[right] > arr[largest])
        largest = right;
    
    if (largest != i) {
        swap(arr[i], arr[largest]);
        heapify(arr, n, largest);
    }
}
```

```python
# Python实现
def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key

def quick_sort(arr, left, right):
    if left < right:
        pivot = partition(arr, left, right)
        quick_sort(arr, left, pivot - 1)
        quick_sort(arr, pivot + 1, right)

def partition(arr, left, right):
    pivot = arr[right]
    i = left - 1
    for j in range(left, right):
        if arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    arr[i + 1], arr[right] = arr[right], arr[i + 1]
    return i + 1

def merge_sort(arr, left, right):
    if left < right:
        mid = left + (right - left) // 2
        merge_sort(arr, left, mid)
        merge_sort(arr, mid + 1, right)
        merge(arr, left, mid, right)

def merge(arr, left, mid, right):
    temp = [0] * (right - left + 1)
    i, j, k = left, mid + 1, 0
    
    while i <= mid and j <= right:
        if arr[i] <= arr[j]:
            temp[k] = arr[i]
            i += 1
        else:
            temp[k] = arr[j]
            j += 1
        k += 1
    
    while i <= mid:
        temp[k] = arr[i]
        i += 1
        k += 1
    
    while j <= right:
        temp[k] = arr[j]
        j += 1
        k += 1
    
    for i in range(left, right + 1):
        arr[i] = temp[i - left]

def heap_sort(arr):
    n = len(arr)
    
    # 构建最大堆
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)
    
    # 逐个提取元素
    for i in range(n - 1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]
        heapify(arr, i, 0)

def heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2
    
    if left < n and arr[left] > arr[largest]:
        largest = left
    
    if right < n and arr[right] > arr[largest]:
        largest = right
    
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)
```
:::

**排序算法复杂度对比**

| 算法 | 平均时间 | 最坏时间 | 空间复杂度 | 稳定性 | 适用场景 |
|------|----------|----------|------------|--------|----------|
| 插入排序 | O(n²) | O(n²) | O(1) | 稳定 | 小数组/基本有序 |
| 快速排序 | O(n log n) | O(n²) | O(log n) | 不稳定 | 通用场景 |
| 归并排序 | O(n log n) | O(n log n) | O(n) | 稳定 | 链表/稳定需求 |
| 堆排序 | O(n log n) | O(n log n) | O(1) | 不稳定 | 原地排序 |








