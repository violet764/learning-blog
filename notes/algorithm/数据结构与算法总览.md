# 数据结构与算法总览

**前置知识**：C++基础语法、程序设计基础

**后续关联模块**：算法应用与优化、扩展算法专题

## 📌 核心定义

**数据结构**是计算机中存储、组织数据的方式。更通俗地说，数据结构是计算机程序中用于组织、管理和存储数据的一种格式，它不仅是数据元素的集合，还包括数据元素之间的关系。

### 学习意义

- **提升程序效率**：选择合适的数据结构能够显著提高程序的运行效率
- **优化内存使用**：合理的数据结构可以减少内存占用，提高空间利用率
- **简化问题解决**：将复杂问题转化为适合特定数据结构的形式，简化解决方案
- **算法基础**：数据结构是算法的基础，许多高效算法依赖于特定的数据结构

---

## 📚 第一部分：数据结构基础总览

## 📊 数据结构全体系知识图谱

```
数据结构体系
├── 基础数据结构
│   ├── 线性结构
│   │   ├── 数组（静态存储）
│   │   ├── 链表（动态存储）
│   │   ├── 栈（后进先出）
│   │   └── 队列（先进先出）
│   └── 非线性基础结构
│       ├── 哈希表（键值映射）
│       └── 并查集（集合操作）
├── 高级数据结构
│   ├── 树形结构
│   │   ├── 二叉树
│   │   ├── 线段树（区间操作）
│   │   ├── 树状数组（前缀和）
│   │   ├── 平衡树（动态有序）
│   │   │   ├── Treap
│   │   │   ├── Splay树
│   │   │   └── 其他平衡树
│   │   ├── 字典树（字符串处理）
│   │   └── 堆（优先队列）
│   ├── 可持久化结构
│   │   ├── 可持久化线段树
│   │   ├── 可持久化字典树
│   │   └── 其他可持久化结构
│   └── 复合结构
│       ├── 树套树
│       ├── 分块结构
│       └── 动态开点结构
└── 特殊结构
    ├── vEB树（整数集合）
    ├── zkw线段树（非递归线段树）
    └── 压位Trie（空间优化）
```

### 模块间关联关系

| 模块 | 关联关系 | 说明 |
|------|----------|------|
| 基础数据结构 | → 高级数据结构 | 基础结构是构建高级结构的基础 |
| 基础数据结构 | → 算法模块 | 提供算法实现的底层支持 |
| 高级数据结构 | → 算法模块 | 支持更复杂高效的算法实现 |
| 效率分析 | → 所有模块 | 为所有结构选择和算法设计提供理论依据 |
| 实战技巧 | → 所有模块 | 提供实际应用中的经验和避坑指南 |

## 🛣️ 学习路径建议

### 第一阶段：基础入门
1. **数组与链表**：理解顺序存储和链式存储的区别
2. **栈与队列**：掌握LIFO和FIFO两种基本数据组织方式
3. **哈希表**：学习快速查找和键值映射的基本思想
4. **并查集**：理解集合操作的基本实现

### 第二阶段：进阶结构
1. **树形结构基础**：二叉树的基本概念和遍历方式
2. **树状数组**：简单高效的前缀和维护结构
3. **堆与优先队列**：掌握动态极值维护的基本方法
4. **字典树**：学习字符串的高效存储和查找

### 第三阶段：高级结构
1. **线段树**：区间操作的经典数据结构
2. **平衡树**：动态维护有序集合的高级结构
3. **可持久化数据结构**：历史版本维护技术
4. **树套树**：复合结构解决复杂问题

### 第四阶段：专题深化
1. **特殊优化结构**：zkw线段树、vEB树等高效变体
2. **分块思想**：平衡时间与空间复杂度的通用方法
3. **动态树**：处理动态连通性问题的高级结构
4. **字符串专用结构**：后缀结构、回文结构等

### 第五阶段：综合应用
1. **多结构组合**：根据问题特点组合使用多种数据结构
2. **优化技巧**：常数优化、内存优化等实用技巧
3. **实战训练**：通过典型题目巩固知识
4. **知识整合**：形成完整的数据结构与算法知识体系

---

## 📖 第二部分：基础数据结构详解

## 📊 线性数据结构

### 数组 (Array)

#### 📌 定义
数组是最基础的线性数据结构，它存储相同类型的元素，并在内存中连续分配空间。

#### 🔧 存储原理
- **连续存储**：所有元素在内存中连续存放
- **索引访问**：通过下标直接计算元素地址
- **固定大小**：创建时确定大小，运行时通常不可变

#### 💻 核心操作

```cpp
// 数组定义与初始化
int arr[100];                 // 静态数组
vector<int> vec;              // 动态数组

// 访问操作
int value = arr[index];       // O(1)
arr[index] = newValue;        // O(1)

// 容量操作
int size = sizeof(arr) / sizeof(arr[0]);  // O(1)
vec.push_back(x);             // 均摊O(1)
vec.size();                   // O(1)

// Python实现
arr = [0] * 100               # 静态数组
arr = []                      # 动态数组
value = arr[index]            # O(1)
arr.append(x)                 # 均摊O(1)
```

#### ⏱️ 复杂度分析
| 操作 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| 访问 | O(1) | - |
| 查找 | O(n) | - |
| 插入 | O(n) | - |
| 删除 | O(n) | O(n) |

#### 🎯 适用场景
- 需要频繁随机访问元素
- 元素数量相对稳定
- 对内存连续性有要求

---

### 链表 (Linked List)

#### 📌 定义
链表是一种通过指针连接的线性数据结构，元素在内存中可以不连续存储。

#### 🔧 存储原理
- **节点结构**：每个节点包含数据域和指针域
- **动态连接**：通过指针将各节点串联起来
- **灵活扩展**：可以动态插入和删除节点

#### 💻 核心操作

```cpp
// 链表节点定义
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

// 插入操作
void insert(ListNode* head, int val, int position) {
    ListNode* newNode = new ListNode(val);
    if (position == 0) {
        newNode->next = head;
        return newNode;
    }
    ListNode* current = head;
    for (int i = 0; i < position - 1 && current; i++) {
        current = current->next;
    }
    if (current) {
        newNode->next = current->next;
        current->next = newNode;
    }
}

// 删除操作
void remove(ListNode* head, int position) {
    if (position == 0 && head) {
        ListNode* temp = head;
        head = head->next;
        delete temp;
        return;
    }
    ListNode* current = head;
    for (int i = 0; i < position - 1 && current->next; i++) {
        current = current->next;
    }
    if (current->next) {
        ListNode* temp = current->next;
        current->next = temp->next;
        delete temp;
    }
}

# Python实现
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
```

#### ⏱️ 复杂度分析
| 操作 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| 访问 | O(n) | - |
| 查找 | O(n) | - |
| 插入 | O(1) | O(n) |
| 删除 | O(1) | O(n) |

#### 🎯 适用场景
- 需要频繁插入和删除操作
- 元素数量变化较大
- 不需要频繁随机访问

---

### 栈 (Stack)

#### 📌 定义
栈是一种后进先出(LIFO)的线性数据结构，只允许在一端进行插入和删除操作。

#### 🔧 存储原理
- **单端操作**：所有操作都在栈顶进行
- **压栈弹出**：push操作添加元素，pop操作移除元素
- **层次访问**：只能访问栈顶元素

#### 💻 核心操作

```cpp
// 使用数组实现栈
class ArrayStack {
private:
    vector<int> data;
    
public:
    void push(int x) {         // O(1)
        data.push_back(x);
    }
    
    int pop() {                // O(1)
        if (empty()) throw runtime_error("Stack is empty");
        int top = data.back();
        data.pop_back();
        return top;
    }
    
    int top() {                // O(1)
        if (empty()) throw runtime_error("Stack is empty");
        return data.back();
    }
    
    bool empty() {             // O(1)
        return data.empty();
    }
};

// STL栈使用
stack<int> st;
st.push(1);                    // 入栈
st.top();                      // 获取栈顶
st.pop();                      // 出栈
st.empty();                    // 判空

# Python实现
class Stack:
    def __init__(self):
        self.data = []
    
    def push(self, x):         # O(1)
        self.data.append(x)
    
    def pop(self):              # O(1)
        if not self.data:
            raise Exception("Stack is empty")
        return self.data.pop()
    
    def top(self):              # O(1)
        if not self.data:
            raise Exception("Stack is empty")
        return self.data[-1]
    
    def empty(self):            # O(1)
        return len(self.data) == 0
```

#### ⏱️ 复杂度分析
| 操作 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| push | O(1) | O(n) |
| pop | O(1) | - |
| top | O(1) | - |

#### 🎯 适用场景
- 函数调用栈
- 表达式求值
- 深度优先搜索(DFS)
- 括号匹配检查

---

### 队列 (Queue)

#### 📌 定义
队列是一种先进先出(FIFO)的线性数据结构，在队尾插入元素，在队头删除元素。

#### 🔧 存储原理
- **双端操作**：插入在队尾，删除在队头
- **顺序服务**：按照元素到达的顺序进行处理
- **环形缓冲**：常用循环数组实现提高效率

#### 💻 核心操作

```cpp
// 使用数组实现队列
class ArrayQueue {
private:
    vector<int> data;
    int front, rear;
    
public:
    ArrayQueue(int capacity) : front(0), rear(0) {
        data.resize(capacity);
    }
    
    void enqueue(int x) {       // O(1)
        data[rear] = x;
        rear = (rear + 1) % data.size();
    }
    
    int dequeue() {            // O(1)
        if (empty()) throw runtime_error("Queue is empty");
        int result = data[front];
        front = (front + 1) % data.size();
        return result;
    }
    
    bool empty() {             // O(1)
        return front == rear;
    }
};

// STL队列使用
queue<int> q;
q.push(1);                     // 入队
q.front();                     // 获取队头
q.pop();                       // 出队
q.empty();                     // 判空

# Python实现
from collections import deque

queue = deque()
queue.append(1)                # 入队
queue[0]                       # 队头元素
queue.popleft()                # 出队
len(queue) == 0                # 判空
```

#### ⏱️ 复杂度分析
| 操作 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| enqueue | O(1) | O(n) |
| dequeue | O(1) | - |
| front | O(1) | - |

#### 🎯 适用场景
- 广度优先搜索(BFS)
- 任务调度
- 缓冲区管理
- 层次遍历

---

## 🌐 非线性基础数据结构

### 哈希表 (Hash Table)

#### 📌 定义
哈希表是基于键值对的存储结构，通过哈希函数将键映射到存储位置，实现快速查找。

#### 🔧 存储原理
- **哈希映射**：使用哈希函数计算键的存储地址
- **冲突处理**：解决不同键映射到同一位置的问题
- **动态扩容**：当元素过多时自动扩展容量

#### 💻 核心操作

```cpp
// 哈希函数示例
int hashFunction(int key, int tableSize) {
    return key % tableSize;  // 简单取模哈希
}

// STL哈希表使用
unordered_map<string, int> hm;
hm["apple"] = 5;             // 插入/修改
int value = hm["apple"];     // 查找
hm.erase("apple");           // 删除
bool exists = hm.count("apple"); // 检查存在

unordered_set<int> hs;
hs.insert(5);                 // 插入
bool exists = hs.count(5);   // 检查存在

# Python实现
# 字典就是哈希表
hm = {}
hm["apple"] = 5              # 插入/修改
value = hm["apple"]          # 查找
del hm["apple"]              # 删除
"apple" in hm                # 检查存在

# 集合也是哈希表
hs = set()
hs.add(5)                    # 插入
5 in hs                      # 检查存在
```

#### ⏱️ 复杂度分析
| 操作 | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度 |
|------|----------------|----------------|------------|
| 插入 | O(1) | O(n) | O(n) |
| 删除 | O(1) | O(n) | - |
| 查找 | O(1) | O(n) | - |

#### 🎯 适用场景
- 需要快速查找、插入和删除
- 键值对存储需求
- 去重和计数问题
- 缓存实现

#### ⚠️ 易错点
- 哈希冲突可能导致性能退化
- 需要选择合适的哈希函数
- 哈希表遍历顺序不确定

---

### 并查集 (Disjoint Set Union)

#### 📌 定义
并查集是一种维护集合的数据结构，支持高效的集合合并和查找操作。

#### 🔧 存储原理
- **树形结构**：每个集合表示为一棵树
- **路径压缩**：查找时压缩路径减少高度
- **按秩合并**：合并时将小树合并到大树

#### 💻 核心操作

```cpp
class DSU {
private:
    vector<int> parent, rank;
    
public:
    DSU(int n) {
        parent.resize(n);
        rank.resize(n, 0);
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }
    
    int find(int x) {             // 查找根节点
        if (parent[x] != x) {
            parent[x] = find(parent[x]);  // 路径压缩
        }
        return parent[x];
    }
    
    void unite(int x, int y) {    // 合并两个集合
        x = find(x);
        y = find(y);
        if (x == y) return;
        
        // 按秩合并
        if (rank[x] < rank[y]) {
            parent[x] = y;
        } else {
            parent[y] = x;
            if (rank[x] == rank[y]) {
                rank[x]++;
            }
        }
    }
    
    bool same(int x, int y) {     // 判断是否同集合
        return find(x) == find(y);
    }
};

# Python实现
class DSU:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n
    
    def find(self, x):            # 查找根节点
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])  # 路径压缩
        return self.parent[x]
    
    def unite(self, x, y):        # 合并两个集合
        x, y = self.find(x), self.find(y)
        if x == y:
            return
        
        # 按秩合并
        if self.rank[x] < self.rank[y]:
            self.parent[x] = y
        else:
            self.parent[y] = x
            if self.rank[x] == self.rank[y]:
                self.rank[x] += 1
    
    def same(self, x, y):         # 判断是否同集合
        return self.find(x) == self.find(y)
```

#### ⏱️ 复杂度分析
| 操作 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| find | α(n) ≈ O(1) | O(n) |
| unite | α(n) ≈ O(1) | - |
| same | α(n) ≈ O(1) | - |

#### 🎯 适用场景
- 连通性问题
- 最小生成树算法
- 动态连通性检查
- 等价关系维护

---

## 📋 STL容器速查表

| 容器类型 | 底层结构 | 时间复杂度(访问) | 时间复杂度(插入) | 适用场景 |
|---------|---------|------------------|------------------|----------|
| vector | 动态数组 | O(1) | 均摊O(1) | 随机访问 |
| list | 双向链表 | O(n) | O(1) | 频繁插入删除 |
| deque | 双端队列 | O(1) | O(1) | 两端操作 |
| stack | 容器适配器 | - | O(1) | LIFO操作 |
| queue | 容器适配器 | - | O(1) | FIFO操作 |
| priority_queue | 堆 | - | O(log n) | 优先级处理 |
| set/map | 平衡树 | O(log n) | O(log n) | 有序集合 |
| unordered_set/map | 哈希表 | O(1) | O(1) | 快速查找 |

---

## 💡 基础数据结构实战技巧

### 1. 选择技巧
- **随机访问多** → 使用数组或vector
- **插入删除多** → 使用链表或list
- **后进先出** → 使用stack
- **先进先出** → 使用queue
- **快速查找** → 使用unordered_map/set
- **有序需求** → 使用map/set

### 2. 优化技巧
- **预分配空间**：使用vector::reserve()减少重新分配
- **移动语义**：C++11中使用move减少拷贝
- **缓存友好设计**：数组比链表更缓存友好
- **批量操作**：减少单元素操作次数

### 3. 常见陷阱
- **数组越界**：C++不检查数组边界
- **迭代器失效**：插入删除可能导致迭代器失效
- **内存泄漏**：链表节点记得手动释放
- **哈希冲突**：特殊构造可能导致大量冲突

---

## 📚 第三部分：高级数据结构详解

## 🌳 树形高级数据结构

### 线段树 (Segment Tree)

#### 📌 定义
线段树是算法竞赛中常用的用来维护区间信息的数据结构，可以在O(log N)时间复杂度内实现单点修改、区间修改、区间查询等操作。

#### 🔧 存储原理
- **堆式存储**：使用数组模拟完全二叉树结构
- **区间划分**：每个节点表示一个区间，父节点区间是子节点区间的并集
- **懒惰标记**：延迟区间修改操作，减少不必要计算

#### 💻 核心操作

```cpp
class SegmentTree {
private:
    vector<int> tree, lazy;  // 线段树数组和懒惰标记
    int n;
    
    void build(int node, int l, int r, const vector<int>& arr) {
        if (l == r) {
            tree[node] = arr[l];
            return;
        }
        int mid = (l + r) / 2;
        build(node * 2, l, mid, arr);
        build(node * 2 + 1, mid + 1, r, arr);
        tree[node] = tree[node * 2] + tree[node * 2 + 1];
    }
    
    void pushDown(int node, int l, int r) {
        if (lazy[node] != 0) {
            int mid = (l + r) / 2;
            tree[node * 2] += lazy[node] * (mid - l + 1);
            lazy[node * 2] += lazy[node];
            tree[node * 2 + 1] += lazy[node] * (r - mid);
            lazy[node * 2 + 1] += lazy[node];
            lazy[node] = 0;
        }
    }
    
    void update(int node, int l, int r, int ql, int qr, int val) {
        if (ql > r || qr < l) return;
        if (ql <= l && r <= qr) {
            tree[node] += val * (r - l + 1);
            lazy[node] += val;
            return;
        }
        pushDown(node, l, r);
        int mid = (l + r) / 2;
        update(node * 2, l, mid, ql, qr, val);
        update(node * 2 + 1, mid + 1, r, ql, qr, val);
        tree[node] = tree[node * 2] + tree[node * 2 + 1];
    }
    
    int query(int node, int l, int r, int ql, int qr) {
        if (ql > r || qr < l) return 0;
        if (ql <= l && r <= qr) return tree[node];
        pushDown(node, l, r);
        int mid = (l + r) / 2;
        return query(node * 2, l, mid, ql, qr) + 
               query(node * 2 + 1, mid + 1, r, ql, qr);
    }
    
public:
    SegmentTree(const vector<int>& arr) {
        n = arr.size() - 1;  // 假设arr[0]不使用，从1开始
        tree.resize(4 * n);
        lazy.resize(4 * n, 0);
        build(1, 1, n, arr);
    }
    
    void update(int l, int r, int val) {
        update(1, 1, n, l, r, val);
    }
    
    int query(int l, int r) {
        return query(1, 1, n, l, r);
    }
};

# Python实现
class SegmentTree:
    def __init__(self, arr):
        self.n = len(arr) - 1  # 假设arr[0]不使用
        self.tree = [0] * (4 * self.n)
        self.lazy = [0] * (4 * self.n)
        self.build(1, 1, self.n, arr)
    
    def build(self, node, l, r, arr):
        if l == r:
            self.tree[node] = arr[l]
            return
        mid = (l + r) // 2
        self.build(node * 2, l, mid, arr)
        self.build(node * 2 + 1, mid + 1, r, arr)
        self.tree[node] = self.tree[node * 2] + self.tree[node * 2 + 1]
    
    def push_down(self, node, l, r):
        if self.lazy[node] != 0:
            mid = (l + r) // 2
            self.tree[node * 2] += self.lazy[node] * (mid - l + 1)
            self.lazy[node * 2] += self.lazy[node]
            self.tree[node * 2 + 1] += self.lazy[node] * (r - mid)
            self.lazy[node * 2 + 1] += self.lazy[node]
            self.lazy[node] = 0
    
    def update(self, node, l, r, ql, qr, val):
        if ql > r or qr < l:
            return
        if ql <= l and r <= qr:
            self.tree[node] += val * (r - l + 1)
            self.lazy[node] += val
            return
        self.push_down(node, l, r)
        mid = (l + r) // 2
        self.update(node * 2, l, mid, ql, qr, val)
        self.update(node * 2 + 1, mid + 1, r, ql, qr, val)
        self.tree[node] = self.tree[node * 2] + self.tree[node * 2 + 1]
    
    def query(self, node, l, r, ql, qr):
        if ql > r or qr < l:
            return 0
        if ql <= l and r <= qr:
            return self.tree[node]
        self.push_down(node, l, r)
        mid = (l + r) // 2
        return self.query(node * 2, l, mid, ql, qr) + \
               self.query(node * 2 + 1, mid + 1, r, ql, qr)
```

#### ⏱️ 复杂度分析
| 操作 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| 建树 | O(n) | O(n) |
| 区间查询 | O(log n) | - |
| 区间修改 | O(log n) | - |

#### 🎯 适用场景
- 频繁的区间查询和修改操作
- 需要维护区间和、最大值、最小值等
- 区间最值操作与历史最值维护
- 离线算法中处理区间约束

---

### zkw线段树 (zkw Segment Tree)

#### 📌 定义
zkw线段树是一种非递归的线段树实现，由张昆伟提出，具有常数更小、实现简单的特点。

#### 🔧 存储原理
- **非递归实现**：使用迭代代替递归，减少函数调用开销
- **自底向上**：从叶子节点开始向上更新
- **完全二叉树**：利用完全二叉树的性质简化操作

#### 💻 核心操作

```cpp
class ZKWSegmentTree {
private:
    vector<int> tree;
    int M, n;
    
public:
    ZKWSegmentTree(int size) {
        n = size;
        M = 1;
        while (M < n + 2) M <<= 1;  // 计算合适的M值
        tree.assign(2 * M, 0);
    }
    
    void build(const vector<int>& arr) {
        // 建树：从叶子节点开始
        for (int i = 1; i <= n; i++) {
            tree[M + i] = arr[i];
        }
        // 向上更新
        for (int i = M - 1; i; i--) {
            tree[i] = tree[i << 1] + tree[i << 1 | 1];
        }
    }
    
    void update(int pos, int value) {
        // 修改：从叶子节点开始向上更新
        for (tree[pos += M] = value; pos > 1; pos >>= 1) {
            tree[pos >> 1] = tree[pos] + tree[pos ^ 1];
        }
    }
    
    int query(int l, int r) {
        // 查询：非递归实现
        int ans = 0;
        for (l += M, r += M + 1; l < r; l >>= 1, r >>= 1) {
            if (l & 1) ans += tree[l++];
            if (r & 1) ans += tree[--r];
        }
        return ans;
    }
};

# Python实现
class ZKWSegmentTree:
    def __init__(self, size):
        self.n = size
        self.M = 1
        while self.M < size + 2:
            self.M <<= 1
        self.tree = [0] * (2 * self.M)
    
    def build(self, arr):
        # 建树：从叶子节点开始
        for i in range(1, self.n + 1):
            self.tree[self.M + i] = arr[i]
        # 向上更新
        for i in range(self.M - 1, 0, -1):
            self.tree[i] = self.tree[i << 1] + self.tree[i << 1 | 1]
    
    def update(self, pos, value):
        # 修改：从叶子节点开始向上更新
        pos += self.M
        self.tree[pos] = value
        while pos > 1:
            pos >>= 1
            self.tree[pos] = self.tree[pos << 1] + self.tree[pos << 1 | 1]
    
    def query(self, l, r):
        # 查询：非递归实现
        ans = 0
        l += self.M
        r += self.M + 1
        while l < r:
            if l & 1:
                ans += self.tree[l]
                l += 1
            if r & 1:
                r -= 1
                ans += self.tree[r]
            l >>= 1
            r >>= 1
        return ans
```

#### ⏱️ 复杂度分析
| 操作 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| 建树 | O(n) | O(n) |
| 单点修改 | O(log n) | - |
| 区间查询 | O(log n) | - |

#### 💡 优势与普通线段树对比

| 特性 | 普通线段树 | zkw线段树 |
|------|------------|-----------|
| 实现方式 | 递归 | 非递归 |
| 常数大小 | 较大 | 较小 |
| 代码复杂度 | 较复杂 | 较简单 |
| 递归深度 | 可能栈溢出 | 无此问题 |
| 适用场景 | 复杂的线段树操作 | 简单的线段树操作 |

---

### 平衡树 (Balanced Trees)

#### 📌 定义
平衡树是一类自平衡的二叉搜索树，通过旋转等操作确保树的高度保持在O(log n)，从而保证各种操作的高效性。

#### 🔧 存储原理
- **二叉搜索性质**：左子树节点小于根节点，右子树节点大于根节点
- **平衡维护**：通过旋转或其他操作保持树的平衡
- **高度控制**：确保树的高度不超过O(log n)

### Treap (树堆)

#### 💻 核心操作

```cpp
class Treap {
private:
    struct Node {
        int key, priority;
        Node *left, *right;
        Node(int k) : key(k), priority(rand()), left(nullptr), right(nullptr) {}
    };
    
    Node* root;
    
    // 右旋
    Node* rotateRight(Node* y) {
        Node* x = y->left;
        y->left = x->right;
        x->right = y;
        return x;
    }
    
    // 左旋
    Node* rotateLeft(Node* x) {
        Node* y = x->right;
        x->right = y->left;
        y->left = x;
        return y;
    }
    
    // 插入
    Node* insert(Node* node, int key) {
        if (!node) return new Node(key);
        
        if (key < node->key) {
            node->left = insert(node->left, key);
            if (node->left->priority > node->priority)
                node = rotateRight(node);
        } else {
            node->right = insert(node->right, key);
            if (node->right->priority > node->priority)
                node = rotateLeft(node);
        }
        return node;
    }
    
    // 删除
    Node* remove(Node* node, int key) {
        if (!node) return nullptr;
        
        if (key < node->key) {
            node->left = remove(node->left, key);
        } else if (key > node->key) {
            node->right = remove(node->right, key);
        } else {
            // 找到要删除的节点
            if (!node->left) return node->right;
            if (!node->right) return node->left;
            
            // 有两个子节点，旋转优先级较高的子节点
            if (node->left->priority > node->right->priority) {
                node = rotateRight(node);
                node->right = remove(node->right, key);
            } else {
                node = rotateLeft(node);
                node->left = remove(node->left, key);
            }
        }
        return node;
    }
    
    // 查找
    bool search(Node* node, int key) {
        if (!node) return false;
        if (key == node->key) return true;
        return key < node->key ? search(node->left, key) : search(node->right, key);
    }
    
public:
    Treap() : root(nullptr) {}
    
    void insert(int key) {
        root = insert(root, key);
    }
    
    void remove(int key) {
        root = remove(root, key);
    }
    
    bool search(int key) {
        return search(root, key);
    }
};
```

#### ⏱️ 复杂度分析
| 操作 | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度 |
|------|----------------|----------------|------------|
| 插入 | O(log n) | O(n) | O(n) |
| 删除 | O(log n) | O(n) | - |
| 查找 | O(log n) | O(n) | - |

---

### 字典树 (Trie)

#### 📌 定义
字典树，又称前缀树，是一种专门用于处理字符串的树形数据结构，能够高效地存储和查找字符串集合。

#### 🔧 存储原理
- **路径存储**：每个边代表一个字符，从根到节点的路径构成字符串
- **前缀共享**：具有相同前缀的字符串共享路径上的节点
- **标记终止**：使用特殊标记表示字符串的结束位置

#### 💻 核心操作

```cpp
class Trie {
private:
    struct TrieNode {
        TrieNode* children[26];
        bool isEnd;
        TrieNode() : isEnd(false) {
            for (int i = 0; i < 26; i++) {
                children[i] = nullptr;
            }
        }
    };
    
    TrieNode* root;
    
public:
    Trie() {
        root = new TrieNode();
    }
    
    void insert(string word) {
        TrieNode* curr = root;
        for (char c : word) {
            int index = c - 'a';
            if (!curr->children[index]) {
                curr->children[index] = new TrieNode();
            }
            curr = curr->children[index];
        }
        curr->isEnd = true;
    }
    
    bool search(string word) {
        TrieNode* curr = root;
        for (char c : word) {
            int index = c - 'a';
            if (!curr->children[index]) {
                return false;
            }
            curr = curr->children[index];
        }
        return curr->isEnd;
    }
    
    bool startsWith(string prefix) {
        TrieNode* curr = root;
        for (char c : prefix) {
            int index = c - 'a';
            if (!curr->children[index]) {
                return false;
            }
            curr = curr->children[index];
        }
        return true;
    }
    
    // 压位Trie优化：使用位压缩减少空间
    class CompressedTrie {
    private:
        struct Node {
            int children[4];  // 使用int存储位图
            bool isEnd;
            Node() : isEnd(false) {
                for (int i = 0; i < 4; i++) {
                    children[i] = -1;
                }
            }
        };
        
        vector<Node> nodes;
        int root;
        
        int getCharIndex(char c) {
            if ('a' <= c && c <= 'z') return 0;
            if ('A' <= c && c <= 'Z') return 1;
            if ('0' <= c && c <= '9') return 2;
            return 3;
        }
        
    public:
        CompressedTrie() {
            nodes.emplace_back();
            root = 0;
        }
        
        void insert(string word) {
            int curr = root;
            for (char c : word) {
                int idx = getCharIndex(c);
                if (nodes[curr].children[idx] == -1) {
                    nodes[curr].children[idx] = nodes.size();
                    nodes.emplace_back();
                }
                curr = nodes[curr].children[idx];
            }
            nodes[curr].isEnd = true;
        }
    };
};

# Python实现
class Trie:
    class TrieNode:
        def __init__(self):
            self.children = {}
            self.is_end = False
    
    def __init__(self):
        self.root = self.TrieNode()
    
    def insert(self, word):
        curr = self.root
        for c in word:
            if c not in curr.children:
                curr.children[c] = self.TrieNode()
            curr = curr.children[c]
        curr.is_end = True
    
    def search(self, word):
        curr = self.root
        for c in word:
            if c not in curr.children:
                return False
            curr = curr.children[c]
        return curr.is_end
    
    def starts_with(self, prefix):
        curr = self.root
        for c in prefix:
            if c not in curr.children:
                return False
            curr = curr.children[c]
        return True
```

#### ⏱️ 复杂度分析
| 操作 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| 插入 | O(m) | O(m) |
| 查找 | O(m) | - |
| 前缀查询 | O(m) | - |

*注：m为字符串长度*

---

## 🔥 可持久化数据结构

### 可持久化线段树

#### 📌 定义
可持久化线段树能够保存历史版本，支持对历史版本的查询，通过共享不变部分来节省空间。

#### 🔧 存储原理
- **版本管理**：每个操作生成新版本，旧版本保留
- **节点共享**：未修改的节点在多个版本间共享
- **动态创建**：只创建被修改的节点及其路径上的节点

#### 💻 核心操作

```cpp
class PersistentSegmentTree {
private:
    struct Node {
        int value;
        Node *left, *right;
        Node(int v = 0, Node* l = nullptr, Node* r = nullptr) 
            : value(v), left(l), right(r) {}
    };
    
    vector<Node*> versions;  // 存储各个版本的根节点
    int n;
    
    Node* build(int l, int r) {
        if (l == r) return new Node(0);
        int mid = (l + r) / 2;
        return new Node(0, build(l, mid), build(mid + 1, r));
    }
    
    Node* update(Node* node, int l, int r, int pos, int val) {
        if (!node) node = new Node();
        if (l == r) {
            return new Node(node->value + val);
        }
        
        int mid = (l + r) / 2;
        Node* newNode = new Node();
        
        if (pos <= mid) {
            newNode->left = update(node->left, l, mid, pos, val);
            newNode->right = node->right;
        } else {
            newNode->left = node->left;
            newNode->right = update(node->right, mid + 1, r, pos, val);
        }
        
        newNode->value = (newNode->left ? newNode->left->value : 0) + 
                         (newNode->right ? newNode->right->value : 0);
        return newNode;
    }
    
    int query(Node* node, int l, int r, int ql, int qr) {
        if (!node || ql > r || qr < l) return 0;
        if (ql <= l && r <= qr) return node->value;
        
        int mid = (l + r) / 2;
        return query(node->left, l, mid, ql, qr) + 
               query(node->right, mid + 1, r, ql, qr);
    }
    
public:
    PersistentSegmentTree(int n) : n(n) {
        versions.push_back(build(1, n));  // 初始版本
    }
    
    void update(int version, int pos, int val) {
        Node* newRoot = update(versions[version], 1, n, pos, val);
        versions.push_back(newRoot);
    }
    
    int query(int version, int l, int r) {
        return query(versions[version], 1, n, l, r);
    }
    
    int getVersionCount() {
        return versions.size() - 1;
    }
};
```

#### ⏱️ 复杂度分析
| 操作 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| 版本更新 | O(log n) | O(log n) |
| 历史查询 | O(log n) | - |
| 总空间消耗 | - | O(n + m log n) |

*注：m为操作次数*

#### 🎯 适用场景
- 需要查询历史状态的场景
- 离线算法中的应用
- 函数式编程中的数据结构
- 区间第k小问题

---

## 🎯 高级结构对比

| 结构类型 | 典型应用 | 时间复杂度 | 优势 | 劣势 |
|----------|----------|------------|------|------|
| 普通线段树 | 区间操作 | O(log n) | 递归直观 | 常数较大 |
| zkw线段树 | 简单区间操作 | O(log n) | 常数小 | 功能有限 |
| Treap | 动态有序集合 | O(log n) | 随机平衡 | 概率算法 |
| Splay树 | 频繁访问局部性 | 均摊O(log n) | 自适应 | 最坏O(n) |
| 可持久化线段树 | 历史版本 | O(log n) | 保留历史 | 空间较大 |
| 字典树 | 字符串处理 | O(m) | 前缀优化 | 空间消耗大 |

---

## 💡 高级数据结构实战技巧

### 1. 线段树变体选择
- **普通区间操作** → 普通线段树
- **单点查询多** → zkw线段树  
- **历史版本需求** → 可持久化线段树
- **多重条件查询** → 树套树

### 2. 平衡树选择
- **随机数据** → Treap（实现简单）
- **局部性强** → Splay（自适应优化）
- **确定性要求** → Scapegoat（确定性平衡）
- **序列操作** → Rope/Splay

### 3. 空间优化技巧
- **动态开点** → 按需创建节点
- **标记永久化** → 减少标记下放
- **位压缩** → 优化字典树空间
- **节点复用** → 可持久化中的共享

### 4. 常见陷阱
- **边界处理**：线段树的左右边界易错
- **懒惰标记**：忘记下放导致错误
- **递归深度**：大数据量可能栈溢出
- **内存管理**：动态创建节点需释放

---

## 📊 数据结构分类与特点总结

| 分类 | 典型结构 | 时间复杂度特点 | 适用场景 |
|------|----------|----------------|----------|
| 线性结构 | 数组、链表、栈、队列 | 访问O(1)或O(n) | 顺序数据处理 |
| 树形结构 | 二叉树、线段树、平衡树 | 通常O(log n) | 层次关系数据 |
| 哈希结构 | 哈希表 | 平均O(1) | 快速查找场景 |
| 复合结构 | 树套树、可持久化结构 | 通常O(log²n) | 复杂查询需求 |

---

## 🏆 竞赛中的应用价值

### 常考知识点
- **基础结构**：栈、队列、并查集（几乎每场比赛都有）
- **树形结构**：线段树、树状数组、平衡树（高频考点）
- **哈希应用**：字符串哈希、状态压缩（实用技巧）
- **高级结构**：可持久化线段树、树套树（难题常见）

### 提分策略
1. **熟练掌握基础**：确保基础结构不丢分
2. **重点突破高级**：线段树和平衡树是提分关键
3. **积累特殊技巧**：掌握一些优化结构解决特定问题
4. **培养结构思维**：学会分析问题并选择合适的数据结构

---

## 📝 核心要点速记

1. 数据结构是数据元素及其关系的集合，直接影响算法效率
2. 基础结构是高级结构的基础，必须扎实掌握
3. 不同数据结构各有优劣，选择时需考虑具体问题特点
4. 时间复杂度和空间复杂度是衡量数据结构效率的重要指标
5. 竞赛中常用的是高效查询、修改和区间操作的数据结构
6. 高级结构的实现复杂，但往往能解决基础结构无法处理的问题

---

## 📚 模块内自测题

### 问题1
下列哪种数据结构适合频繁的随机访问操作？
A. 链表  
B. 栈  
C. 数组  
D. 队列

**解析**：C. 数组支持O(1)时间的随机访问，而链表、栈、队列都需要O(n)时间访问任意元素。

### 问题2
对于需要动态维护有序集合且支持频繁插入删除的场景，最适合的数据结构是？
A. 普通数组  
B. 哈希表  
C. 平衡树  
D. 栈

**解析**：C. 平衡树能够在O(log n)时间内完成插入、删除和查找操作，同时维护元素的有序性。

### 问题3
zkw线段树相比普通线段树的主要优势是？
A. 支持更多操作  
B. 常数更小、实现简单  
C. 空间复杂度更低  
D. 支持更复杂的标记下放

**解析**：B. zkw线段树使用非递归实现，常数更小，代码实现相对简单，但功能上不如普通线段树全面。

### 问题4
可持久化数据结构的主要应用场景是？
A. 提高时间复杂度  
B. 保存历史版本状态  
C. 减少空间复杂度  
D. 简化代码实现

**解析**：B. 可持久化数据结构的主要特点是能够保存和查询历史版本状态，虽然通常会增加空间复杂度。

### 问题5
字典树（Trie）相比哈希表在字符串处理中的主要优势是？
A. 时间复杂度更低  
B. 支持前缀匹配查询  
C. 空间复杂度更低  
D. 支持更多的字符类型

**解析**：B. 字典树天然支持前缀匹配查询，这是哈希表难以高效实现的功能。

---

*本笔记基于OI-Wiki数据结构与算法专区内容整理，适用于算法竞赛学习与复习。*