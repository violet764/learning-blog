# 数据结构与算法

**数据结构**是计算机中存储、组织数据的方式。更通俗地说，数据结构是计算机程序中用于组织、管理和存储数据的一种格式，它不仅是数据元素的集合，还包括数据元素之间的关系。

---

***数据结构全体系知识图谱***

```
数据结构体系
├── 基础数据结构
│   ├── 线性结构
│   │   ├── 数组（静态存储）
│   │   ├── 链表（动态存储）
│   │   ├── 栈（后进先出）
│   │   └── 队列（先进先出）
│   └── 非线性基础结构
│       ├── 哈希表（键值映射）
│       └── 并查集（集合操作）
├── 高级数据结构
│   ├── 树形结构
│   │   ├── 二叉树
│   │   ├── 线段树（区间操作）
│   │   ├── 树状数组（前缀和）
│   │   ├── 平衡树（动态有序）
│   │   │   ├── Treap
│   │   │   ├── Splay树
│   │   │   └── 其他平衡树
│   │   ├── 字典树（字符串处理）
│   │   └── 堆（优先队列）
│   ├── 可持久化结构
│   │   ├── 可持久化线段树
│   │   ├── 可持久化字典树
│   │   └── 其他可持久化结构
│   └── 复合结构
│       ├── 树套树
│       ├── 分块结构
│       └── 动态开点结构
└── 特殊结构
    ├── vEB树（整数集合）
    ├── zkw线段树（非递归线段树）
    └── 压位Trie（空间优化）
```

---

## 基础数据结构

### 数组 (Array)

**定义**
数组是最基础的线性数据结构，它存储相同类型的元素，并在内存中连续分配空间。

**存储原理**
- **连续存储**：所有元素在内存中连续存放
- **索引访问**：通过下标直接计算元素地址
- **固定大小**：创建时确定大小，运行时通常不可变

**核心操作**
::: code-group
```cpp
// 数组定义与初始化
int arr[100];                 // 静态数组
vector<int> vec;              // 动态数组

// 访问操作
int value = arr[index];       // O(1)
arr[index] = newValue;        // O(1)

// 容量操作
int size = sizeof(arr) / sizeof(arr[0]);  // O(1)
vec.push_back(x);             // 均摊O(1)
vec.size();                   // O(1)
```
```python
arr = [0] * 100               # 静态数组
arr = []                      # 动态数组
value = arr[index]            # O(1)
arr.append(x)                 # 均摊O(1)
```
:::

**复杂度分析**
| 操作 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| 访问 | O(1) | - |
| 查找 | O(n) | - |
| 插入 | O(n) | - |
| 删除 | O(n) | O(n) |

**适用场景**
- 需要频繁随机访问元素
- 元素数量相对稳定
- 对内存连续性有要求

---

### 链表 (Linked List)

**定义**
链表是一种通过指针连接的线性数据结构，元素在内存中可以不连续存储。

**存储原理**
- **节点结构**：每个节点包含数据域和指针域
- **动态连接**：通过指针将各节点串联起来
- **灵活扩展**：可以动态插入和删除节点

**核心操作**
::: code-group
```cpp
// 链表节点定义
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

// 插入操作
void insert(ListNode* head, int val, int position) {
    ListNode* newNode = new ListNode(val);
    if (position == 0) {
        newNode->next = head;
        return newNode;
    }
    ListNode* current = head;
    for (int i = 0; i < position - 1 && current; i++) {
        current = current->next;
    }
    if (current) {
        newNode->next = current->next;
        current->next = newNode;
    }
}

// 删除操作
void remove(ListNode* head, int position) {
    if (position == 0 && head) {
        ListNode* temp = head;
        head = head->next;
        delete temp;
        return;
    }
    ListNode* current = head;
    for (int i = 0; i < position - 1 && current->next; i++) {
        current = current->next;
    }
    if (current->next) {
        ListNode* temp = current->next;
        current->next = temp->next;
        delete temp;
    }
}
```

```python
# Python实现
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
```
:::
**复杂度分析**
| 操作 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| 访问 | O(n) | - |
| 查找 | O(n) | - |
| 插入 | O(1) | O(n) |
| 删除 | O(1) | O(n) |

**适用场景**
- 需要频繁插入和删除操作
- 元素数量变化较大
- 不需要频繁随机访问

---

### 栈 (Stack)

**定义**
栈是一种后进先出(LIFO)的线性数据结构，只允许在一端进行插入和删除操作。

**存储原理**
- **单端操作**：所有操作都在栈顶进行
- **压栈弹出**：`push`操作添加元素，`pop`操作移除元素
- **层次访问**：只能访问栈顶元素

**核心操作**
::: code-group
```cpp
// 使用数组实现栈
class ArrayStack {
private:
    vector<int> data;

public:
    void push(int x) {         // O(1)
        data.push_back(x);
    }

    int pop() {                // O(1)
        if (empty()) throw runtime_error("Stack is empty");
        int top = data.back();
        data.pop_back();
        return top;
    }

    int top() {                // O(1)
        if (empty()) throw runtime_error("Stack is empty");
        return data.back();
    }

    bool empty() {             // O(1)
        return data.empty();
    }
};

// STL栈使用
stack<int> st;
st.push(1);                    // 入栈
st.top();                      // 获取栈顶
st.pop();                      // 出栈
st.empty();                    // 判空
```

```python
# Python实现
class Stack:
    def __init__(self):
        self.data = []

    def push(self, x):         # O(1)
        self.data.append(x)

    def pop(self):              # O(1)
        if not self.data:
            raise Exception("Stack is empty")
        return self.data.pop()

    def top(self):              # O(1)
        if not self.data:
            raise Exception("Stack is empty")
        return self.data[-1]

    def empty(self):            # O(1)
        return len(self.data) == 0
```
:::
**复杂度分析**
| 操作 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| push | O(1) | O(n) |
| pop | O(1) | - |
| top | O(1) | - |

**适用场景**
- 函数调用栈
- 表达式求值
- 深度优先搜索(DFS)
- 括号匹配检查

---

### 队列 (Queue)

**定义**
队列是一种先进先出(FIFO)的线性数据结构，在队尾插入元素，在队头删除元素。

**存储原理**
- **双端操作**：插入在队尾，删除在队头
- **顺序服务**：按照元素到达的顺序进行处理
- **环形缓冲**：常用循环数组实现提高效率

**核心操作**
::: code-group
```cpp
// 使用数组实现队列
class ArrayQueue {
private:
    vector<int> data;
    int front, rear;

public:
    ArrayQueue(int capacity) : front(0), rear(0) {
        data.resize(capacity);
    }

    void enqueue(int x) {       // O(1)
        data[rear] = x;
        rear = (rear + 1) % data.size();
    }

    int dequeue() {            // O(1)
        if (empty()) throw runtime_error("Queue is empty");
        int result = data[front];
        front = (front + 1) % data.size();
        return result;
    }

    bool empty() {             // O(1)
        return front == rear;
    }
};

// STL队列使用
queue<int> q;
q.push(1);                     // 入队
q.front();                     // 获取队头
q.pop();                       // 出队
q.empty();                     // 判空
```

```python

# Python实现
from collections import deque

queue = deque()
queue.append(1)                # 入队
queue[0]                       # 队头元素
queue.popleft()                # 出队
len(queue) == 0                # 判空
```
:::
**复杂度分析**
| 操作 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| enqueue | O(1) | O(n) |
| dequeue | O(1) | - |
| front | O(1) | - |

**适用场景**
- 广度优先搜索(BFS)
- 任务调度
- 缓冲区管理
- 层次遍历

---

### 哈希表（HashMap）

**定义**
哈希表是基于键值对的存储结构，通过哈希函数将键映射到存储位置，实现o(1)快速查找。

**存储原理**
- **哈希映射**：使用哈希函数计算键的存储地址
- **冲突处理**：解决不同键映射到同一位置的问题
- **动态扩容**：当元素过多时自动扩展容量

**核心操作**
::: code-group
```cpp
// 哈希函数示例
int hashFunction(int key, int tableSize) {
    return key % tableSize;  // 简单取模哈希
}

// STL哈希表使用
unordered_map<string, int> hm;
hm["apple"] = 5;             // 插入/修改
int value = hm["apple"];     // 查找
hm.erase("apple");           // 删除
bool exists = hm.count("apple"); // 检查存在

unordered_set<int> hs;
hs.insert(5);                 // 插入
bool exists = hs.count(5);   // 检查存在
```

```python
# Python实现
# 字典就是哈希表
hm = {}
hm["apple"] = 5              # 插入/修改
value = hm["apple"]          # 查找
del hm["apple"]              # 删除
"apple" in hm                # 检查存在

# 集合也是哈希表
hs = set()
hs.add(5)                    # 插入
5 in hs                      # 检查存在
```
:::
**复杂度分析**
| 操作 | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度 |
|------|----------------|----------------|------------|
| 插入 | O(1) | O(n) | O(n) |
| 删除 | O(1) | O(n) | - |
| 查找 | O(1) | O(n) | - |

**适用场景**
- 需要快速查找、插入和删除
- 键值对存储需求
- 去重和计数问题
- 缓存实现

::: info
- 哈希冲突可能导致性能退化
- 需要选择合适的哈希函数
- 哈希表遍历顺序不确定
:::

---

### 并查集 （Union Set）

**定义**
并查集是一种维护集合的数据结构，支持高效的集合合并和查找操作。

**存储原理**
- **树形结构**：每个集合表示为一棵树
- **路径压缩**：查找时压缩路径减少高度
- **按秩合并**：合并时将小树合并到大树

**核心操作**
::: code-group
```cpp
#include <iostream>
#include <vector>
#include <unordered_map>
#include <algorithm>
using namespace std;

class UnionFind {
private:
    vector<int> parent;  // 父节点数组
    vector<int> rank;    // 秩（树的高度）
    vector<int> size;    // 集合大小
    int count;           // 连通分量数量
    
public:
    // 构造函数
    UnionFind(int n) {
        count = n;
        parent.resize(n);
        rank.resize(n, 0);
        size.resize(n, 1);
        
        // 初始化，每个节点的父节点是自己
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }
    
    // 查找根节点（带路径压缩）
    int find(int x) {
        // 递归版（简洁）
        if (parent[x] != x) {
            parent[x] = find(parent[x]);  // 路径压缩
        }
        return parent[x];
        
        // 迭代版（防止栈溢出）
        // int root = x;
        // while (parent[root] != root) {
        //     root = parent[root];
        // }
        // // 路径压缩
        // while (parent[x] != root) {
        //     int temp = parent[x];
        //     parent[x] = root;
        //     x = temp;
        // }
        // return root;
    }
    
    // 合并两个集合
    bool unionSets(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        
        // 如果已经在同一个集合，直接返回
        if (rootX == rootY) {
            return false;
        }
        
        // 按秩合并
        if (rank[rootX] < rank[rootY]) {
            parent[rootX] = rootY;
            size[rootY] += size[rootX];
        } else if (rank[rootX] > rank[rootY]) {
            parent[rootY] = rootX;
            size[rootX] += size[rootY];
        } else {
            // 秩相等时，任意合并，并增加秩
            parent[rootY] = rootX;
            size[rootX] += size[rootY];
            rank[rootX] += 1;
        }
        
        count--;  // 连通分量减少
        return true;
    }
    
    // 检查两个元素是否连通
    bool connected(int x, int y) {
        return find(x) == find(y);
    }
    
    // 获取连通分量数量
    int getCount() const {
        return count;
    }
    
    // 获取元素所在集合的大小
    int getSize(int x) {
        int root = find(x);
        return size[root];
    }
    
    // 获取所有连通分量
    unordered_map<int, vector<int>> getSets() {
        unordered_map<int, vector<int>> sets;
        for (int i = 0; i < parent.size(); i++) {
            int root = find(i);
            sets[root].push_back(i);
        }
        return sets;
    }
    
    // 打印状态（调试用）
    void printStatus() {
        cout << "索引: ";
        for (int i = 0; i < parent.size(); i++) {
            cout << i << " ";
        }
        cout << endl;
        
        cout << "父节点: ";
        for (int p : parent) {
            cout << p << " ";
        }
        cout << endl;
        
        cout << "秩: ";
        for (int r : rank) {
            cout << r << " ";
        }
        cout << endl;
        
        cout << "集合大小: ";
        for (int s : size) {
            cout << s << " ";
        }
        cout << endl;
        
        cout << "连通分量数量: " << count << endl;
        
        auto sets = getSets();
        cout << "连通分量:" << endl;
        for (const auto& entry : sets) {
            cout << "  集合" << entry.first << ": ";
            for (int elem : entry.second) {
                cout << elem << " ";
            }
            cout << endl;
        }
    }
};

// 测试函数
void testUnionFind() {
    cout << "=== 并查集基本用法 ===" << endl;
    
    // 1. 初始化
    UnionFind uf(10);
    cout << "初始化状态:" << endl;
    uf.printStatus();
    cout << endl;
    
    // 2. 合并操作
    vector<pair<int, int>> operations = {
        {0, 1}, {2, 3}, {4, 5}, {6, 7}, {8, 9},
        {1, 2}, {3, 4}, {5, 6}, {7, 8}
    };
    
    cout << "合并操作:" << endl;
    for (int i = 0; i < operations.size(); i++) {
        int x = operations[i].first;
        int y = operations[i].second;
        uf.unionSets(x, y);
        cout << "  合并 " << x << " 和 " << y 
             << " 后，连通分量: " << uf.getCount() << endl;
    }
    
    cout << "\n最终状态:" << endl;
    uf.printStatus();
    
    // 3. 连通性测试
    cout << "\n=== 连通性测试 ===" << endl;
    vector<pair<int, int>> testPairs = {
        {0, 4}, {1, 7}, {2, 9}, {3, 8}, {0, 9}
    };
    
    for (const auto& p : testPairs) {
        int x = p.first;
        int y = p.second;
        cout << "  " << x << " 和 " << y << " 是否连通: " 
             << (uf.connected(x, y) ? "是" : "否") << endl;
    }
    
    // 4. 集合大小测试
    cout << "\n=== 集合大小测试 ===" << endl;
    for (int i = 0; i < 5; i++) {
        cout << "  元素 " << i << " 所在集合大小: " << uf.getSize(i) << endl;
    }
}

int main() {
    // 运行测试
    testUnionFind();
    return 0;
}

```
```python
class UnionFind:
    """并查集实现（带路径压缩和按秩合并）"""
    
    def __init__(self, n):
        """
        初始化并查集
        :param n: 元素数量，元素编号为 0 到 n-1
        """
        self.parent = list(range(n))  # 父节点数组，初始时每个节点的父节点是自己
        self.rank = [0] * n           # 秩（树的高度），用于按秩合并
        self.count = n                # 连通分量数量
        self.size = [1] * n           # 每个集合的大小
    
    def find(self, x):
        """
        查找元素x的根节点（带路径压缩）
        时间复杂度：近似O(1)（阿克曼函数的反函数）
        """
        # 方法1：递归版（更简洁）
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])  # 路径压缩
        return self.parent[x]
        
        # 方法2：迭代版（防止递归深度过大）
        # root = x
        # # 先找到根节点
        # while self.parent[root] != root:
        #     root = self.parent[root]
        # # 路径压缩
        # while self.parent[x] != root:
        #     temp = self.parent[x]
        #     self.parent[x] = root
        #     x = temp
        # return root
    
    def union(self, x, y):
        """
        合并元素x和y所在的集合
        时间复杂度：近似O(1)
        """
        root_x = self.find(x)
        root_y = self.find(y)
        
        # 如果已经在同一个集合，直接返回
        if root_x == root_y:
            return False
        
        # 按秩合并：将小树合并到大树
        if self.rank[root_x] < self.rank[root_y]:
            self.parent[root_x] = root_y
            self.size[root_y] += self.size[root_x]
        elif self.rank[root_x] > self.rank[root_y]:
            self.parent[root_y] = root_x
            self.size[root_x] += self.size[root_y]
        else:
            # 秩相等时，任意合并，并增加秩
            self.parent[root_y] = root_x
            self.size[root_x] += self.size[root_y]
            self.rank[root_x] += 1
        
        self.count -= 1  # 连通分量减少
        return True
    
    def connected(self, x, y):
        """
        检查元素x和y是否在同一个集合中
        """
        return self.find(x) == self.find(y)
    
    def get_count(self):
        """
        获取连通分量的数量
        """
        return self.count
    
    def get_size(self, x):
        """
        获取元素x所在集合的大小
        """
        root = self.find(x)
        return self.size[root]
    
    def get_sets(self):
        """
        获取所有连通分量
        返回：字典，key为根节点，value为集合中的元素列表
        """
        sets = {}
        for i in range(len(self.parent)):
            root = self.find(i)
            if root not in sets:
                sets[root] = []
            sets[root].append(i)
        return sets
    
    def print_status(self):
        """
        打印当前并查集状态（用于调试）
        """
        print("索引:", list(range(len(self.parent))))
        print("父节点:", self.parent)
        print("秩:", self.rank)
        print("集合大小:", self.size)
        print("连通分量数量:", self.count)
        
        sets = self.get_sets()
        print("连通分量:")
        for root, elements in sets.items():
            print(f"  集合{root}: {elements}")


# 使用示例和测试
if __name__ == "__main__":
    print("=== 并查集基本用法 ===")
    
    # 1. 初始化并查集（10个元素）
    uf = UnionFind(10)
    print("初始化状态:")
    uf.print_status()
    print()
    
    # 2. 进行一些合并操作
    operations = [(0, 1), (2, 3), (4, 5), (6, 7), (8, 9),
                  (1, 2), (3, 4), (5, 6), (7, 8)]
    
    print("合并操作:")
    for i, (x, y) in enumerate(operations):
        uf.union(x, y)
        print(f"  合并 {x} 和 {y} 后，连通分量: {uf.get_count()}")
    
    print("\n最终状态:")
    uf.print_status()
    
    # 3. 测试连通性
    print("\n=== 连通性测试 ===")
    test_pairs = [(0, 4), (1, 7), (2, 9), (3, 8), (0, 9)]
    for x, y in test_pairs:
        print(f"  {x} 和 {y} 是否连通: {uf.connected(x, y)}")
    
    # 4. 测试集合大小
    print("\n=== 集合大小测试 ===")
    for i in range(5):
        print(f"  元素 {i} 所在集合大小: {uf.get_size(i)}")
    
    # 5. 实际应用示例：朋友圈问题
    print("\n=== 实际应用：朋友圈问题 ===")
    print("假设有10个人（0-9），朋友关系如下:")
    friendships = [(0, 1), (1, 2), (3, 4), (4, 5), (6, 7), (7, 8), (8, 9)]
    
    uf_friends = UnionFind(10)
    for a, b in friendships:
        uf_friends.union(a, b)
    
    print(f"朋友圈数量: {uf_friends.get_count()}")
    circles = uf_friends.get_sets()
    print("每个朋友圈的成员:")
    for i, (root, members) in enumerate(circles.items()):
        print(f"  朋友圈{i+1}: {members}")



```
:::

**实际应用：** 

::: code-group
```cpp
// 实际应用：朋友圈问题
void friendCirclesExample() {
    cout << "\n=== 实际应用：朋友圈问题 ===" << endl;
    
    int n = 10;  // 10个人
    vector<pair<int, int>> friendships = {
        {0, 1}, {1, 2}, {3, 4}, {4, 5}, {6, 7}, {7, 8}, {8, 9}
    };
    
    UnionFind uf(n);
    for (const auto& f : friendships) {
        uf.unionSets(f.first, f.second);
    }
    
    cout << "朋友关系:" << endl;
    for (const auto& f : friendships) {
        cout << "  " << f.first << " 和 " << f.second << " 是朋友" << endl;
    }
    
    cout << "\n朋友圈数量: " << uf.getCount() << endl;
    
    auto circles = uf.getSets();
    cout << "每个朋友圈的成员:" << endl;
    int circleNum = 1;
    for (const auto& entry : circles) {
        cout << "  朋友圈" << circleNum++ << ": ";
        for (int member : entry.second) {
            cout << member << " ";
        }
        cout << endl;
    }
}

// 实际应用：岛屿数量问题
int numIslands(vector<vector<char>>& grid) {
    if (grid.empty()) return 0;
    
    int rows = grid.size();
    int cols = grid[0].size();
    
    UnionFind uf(rows * cols);
    int waterCount = 0;
    
    // 方向：右和下
    vector<pair<int, int>> directions = {{0, 1}, {1, 0}};
    
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            if (grid[i][j] == '1') {
                int index = i * cols + j;
                
                // 检查相邻的陆地
                for (const auto& dir : directions) {
                    int ni = i + dir.first;
                    int nj = j + dir.second;
                    
                    if (ni >= 0 && ni < rows && nj >= 0 && nj < cols && grid[ni][nj] == '1') {
                        int neighborIndex = ni * cols + nj;
                        uf.unionSets(index, neighborIndex);
                    }
                }
            } else {
                waterCount++;
            }
        }
    }
    
    return uf.getCount() - waterCount;
}

void islandsExample() {
    cout << "\n=== 岛屿数量问题 ===" << endl;
    
    vector<vector<char>> grid = {
        {'1', '1', '0', '0', '0'},
        {'1', '1', '0', '0', '0'},
        {'0', '0', '1', '0', '0'},
        {'0', '0', '0', '1', '1'}
    };
    
    cout << "网格:" << endl;
    for (const auto& row : grid) {
        cout << "  ";
        for (char cell : row) {
            cout << cell << " ";
        }
        cout << endl;
    }
    
    int islands = numIslands(grid);
    cout << "岛屿数量: " << islands << endl;
}

int main() {
    // 运行测试
    friendCirclesExample();
    islandsExample();
    
    return 0;
}
```

```python
# 高级应用：解决实际问题
def num_islands(grid):
    """
    LeetCode 200：岛屿数量（使用并查集）
    """
    if not grid:
        return 0
    
    rows, cols = len(grid), len(grid[0])
    uf = UnionFind(rows * cols)
    
    # 方向：右和下（避免重复）
    directions = [(0, 1), (1, 0)]
    
    water_count = 0  # 水域数量
    
    for i in range(rows):
        for j in range(cols):
            if grid[i][j] == '1':  # 陆地
                index = i * cols + j
                # 检查右侧和下方的相邻陆地
                for dx, dy in directions:
                    ni, nj = i + dx, j + dy
                    if 0 <= ni < rows and 0 <= nj < cols and grid[ni][nj] == '1':
                        neighbor_index = ni * cols + nj
                        uf.union(index, neighbor_index)
            else:
                water_count += 1
    
    # 岛屿数量 = 连通分量数量 - 水域数量
    return uf.get_count() - water_count


# 测试岛屿数量问题
print("\n=== 岛屿数量问题 ===")
grid = [
    ['1', '1', '0', '0', '0'],
    ['1', '1', '0', '0', '0'],
    ['0', '0', '1', '0', '0'],
    ['0', '0', '0', '1', '1']
]

print("网格:")
for row in grid:
    print(" ", row)

islands = num_islands(grid)
print(f"岛屿数量: {islands}")
```


:::

**复杂度分析**

| 操作 | 普通实现 | 带路径压缩和按秩合并
|-------|----------|------------------|
| 初始化 | O(n) | O(n) |
| 查找 | O(n) | O(α(n))（近似常数） |
| 合并 | O(n) | O(α(n))（近似常数） |

α(n)：阿克曼函数的反函数，增长极慢，对于任何实际n，α(n) < 5

**适用场景**
- 连通性问题
- 最小生成树算法
- 动态连通性检查
- 等价关系维护

---

### STL容器速查表

| 容器类型 | 底层结构 | 时间复杂度(访问) | 时间复杂度(插入) | 适用场景 |
|---------|---------|------------------|------------------|----------|
| vector | 动态数组 | O(1) | 均摊O(1) | 随机访问 |
| list | 双向链表 | O(n) | O(1) | 频繁插入删除 |
| deque | 双端队列 | O(1) | O(1) | 两端操作 |
| stack | 容器适配器 | - | O(1) | LIFO操作 |
| queue | 容器适配器 | - | O(1) | FIFO操作 |
| priority_queue | 堆 | - | O(log n) | 优先级处理 |
| set/map | 平衡树 | O(log n) | O(log n) | 有序集合 |
| unordered_set/map | 哈希表 | O(1) | O(1) | 快速查找 |

---

## 高级数据结构


### 树 (Tree)

**定义**
树是一种非线性的数据结构，它是由n（n≥0）个有限节点组成一个具有层次关系的集合。每个节点都可能有零个或多个子节点，没有父节点的节点称为根节点。

**存储原理**
- **层次结构**：数据元素之间存在着一对多的层次关系
- **根节点**：唯一没有前驱节点的节点
- **叶节点**：没有后继节点的节点
- **父子关系**：除了根节点外，每个节点都有且仅有一个父节点

**核心操作**
::: code-group

```cpp
// 二叉树节点定义
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// 前序遍历 - 递归
void preorderTraversal(TreeNode* root, vector<int>& result) {
    if (root) {
        result.push_back(root->val);
        preorderTraversal(root->left, result);
        preorderTraversal(root->right, result);
    }
}

// 中序遍历 - 递归
void inorderTraversal(TreeNode* root, vector<int>& result) {
    if (root) {
        inorderTraversal(root->left, result);
        result.push_back(root->val);
        inorderTraversal(root->right, result);
    }
}

// 后序遍历 - 递归
void postorderTraversal(TreeNode* root, vector<int>& result) {
    if (root) {
        postorderTraversal(root->left, result);
        postorderTraversal(root->right, result);
        result.push_back(root->val);
    }
}

// 层序遍历 - 使用队列
void levelOrderTraversal(TreeNode* root, vector<vector<int>>& result) {
    if (!root) return;
    
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        int levelSize = q.size();
        vector<int> currentLevel;
        
        for (int i = 0; i < levelSize; i++) {
            TreeNode* node = q.front();
            q.pop();
            currentLevel.push_back(node->val);
            
            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
        
        result.push_back(currentLevel);
    }
}
```
```python
# 二叉树节点定义
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
# 前序遍历 - 递归
def preorder_traversal(root):
    if not root:
        return []
    return [root.val] + preorder_traversal(root.left) + preorder_traversal(root.right)
# 中序遍历 - 递归
def inorder_traversal(root):
    if not root:
        return []
    return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right)
# 后序遍历 - 递归
def postorder_traversal(root):
    if not root:
        return []
    return postorder_traversal(root.left) + postorder_traversal(root.right) + [root.val]
# 层序遍历 - 使用队列
def level_order_traversal(root):
    if not root:
        return []
    
    from collections import deque
    q = deque([root])
    result = []
    
    while q:
        level_size = len(q)
        current_level = []
        
        for _ in range(level_size):
            node = q.popleft()
            current_level.append(node.val)
            
            if node.left:
                q.append(node.left)
            if node.right:
                q.append(node.right)
        
        result.append(current_level)
    
    return result
```
:::
**复杂度分析**
| 操作 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| 遍历 | O(n) | O(h) |
| 查找 | O(h) | - |
| 插入 | O(h) | - |
| 删除 | O(h) | - |

*注：h为树的高度，平衡树h=log n*

**适用场景**
- 表示具有层级关系的数据
- 文件系统目录结构
- 组织架构图
- 表达式解析
- 决策树算法

---

### 堆 (Heap)

**定义**
堆是一种特殊的完全二叉树，其中每个节点的值都大于等于（最大堆）或小于等于（最小堆）其子节点的值。

**存储原理**
- **完全二叉树**：除最后一层外，其他层都被完全填满，最后一层从左到右填充
- **数组存储**：使用数组实现，对于索引为i的节点，其左子节点为2i+1，右子节点为2i+2
- **堆性质**：父节点与子节点满足特定的大小关系

**核心操作**
::: code-group
```cpp
class Heap {
private:
    vector<int> heap;

    // 上浮操作
    void heapifyUp(int index) {
        while (index > 0) {
            int parent = (index - 1) / 2;
            if (heap[parent] >= heap[index]) break;
            swap(heap[parent], heap[index]);
            index = parent;
        }
    }

    // 下沉操作
    void heapifyDown(int index) {
        int size = heap.size();
        while (true) {
            int largest = index;
            int left = 2 * index + 1;
            int right = 2 * index + 2;

            if (left < size && heap[left] > heap[largest])
                largest = left;
            if (right < size && heap[right] > heap[largest])
                largest = right;

            if (largest == index) break;
            swap(heap[index], heap[largest]);
            index = largest;
        }
    }

public:
    void push(int value) {
        heap.push_back(value);
        heapifyUp(heap.size() - 1);
    }

    void pop() {
        if (heap.empty()) return;
        heap[0] = heap.back();
        heap.pop_back();
        heapifyDown(0);
    }

    int top() {
        return heap.empty() ? -1 : heap[0];
    }

    bool empty() {
        return heap.empty();
    }
};

// STL堆使用
priority_queue<int> maxHeap;        // 最大堆
priority_queue<int, vector<int>, greater<int>> minHeap;  // 最小堆
maxHeap.push(3);                    // 插入元素
int top = maxHeap.top();            // 获取堆顶
maxHeap.pop();                      // 弹出堆顶
```

```python
# Python实现
import heapq

# Python的heapq模块实现最小堆
heap = []
heapq.heappush(heap, 3)             # 插入元素
top = heap[0]                       # 获取堆顶
heapq.heappop(heap)                 # 弹出堆顶

# 实现最大堆的方法
max_heap = []
heapq.heappush(max_heap, -3)        # 插入负值
top = -max_heap[0]                  # 获取堆顶（取反）
heapq.heappop(max_heap)             # 弹出堆顶（取反）
```
:::
**复杂度分析**
| 操作 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| 插入 | O(log n) | O(1) |
| 删除 | O(log n) | O(1) |
| 查找极值 | O(1) | - |

**适用场景**
- 优先队列实现
- 堆排序算法
- Top K问题
- Dijkstra算法
- 哈夫曼编码

---

### 图 (Graph)

**定义**
图是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为G(V,E)，其中G表示图，V是图中顶点的集合，E是图中边的集合。

**存储原理**
- **邻接矩阵**：使用二维数组表示顶点间的关系
- **邻接表**：使用链表或动态数组存储每个顶点的邻居
- **边集数组**：使用数组存储所有的边

**核心操作**
::: code-group
```cpp
// 邻接表表示图
class Graph {
private:
    int vertices;
    vector<vector<int>> adjList;

public:
    Graph(int v) : vertices(v) {
        adjList.resize(v);
    }

    void addEdge(int u, int v) {
        adjList[u].push_back(v);
        adjList[v].push_back(u);  // 无向图
    }

    // 深度优先搜索
    void dfs(int start, vector<bool>& visited) {
        visited[start] = true;
        cout << start << " ";

        for (int neighbor : adjList[start]) {
            if (!visited[neighbor]) {
                dfs(neighbor, visited);
            }
        }
    }

    // 广度优先搜索
    void bfs(int start) {
        vector<bool> visited(vertices, false);
        queue<int> q;

        visited[start] = true;
        q.push(start);

        while (!q.empty()) {
            int node = q.front();
            q.pop();
            cout << node << " ";

            for (int neighbor : adjList[node]) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    q.push(neighbor);
                }
            }
        }
    }
};

// STL图使用
vector<vector<int>> graph(100);     // 创建邻接表
graph[0].push_back(1);              // 添加边
graph[1].push_back(0);              // 无向图
```

```python
# Python实现
from collections import defaultdict, deque

class Graph:
    def __init__(self):
        self.graph = defaultdict(list)

    def add_edge(self, u, v):
        self.graph[u].append(v)
        self.graph[v].append(u)  # 无向图

    # 深度优先搜索
    def dfs(self, start, visited=None):
        if visited is None:
            visited = set()
        visited.add(start)
        print(start, end=" ")

        for neighbor in self.graph[start]:
            if neighbor not in visited:
                self.dfs(neighbor, visited)

    # 广度优先搜索
    def bfs(self, start):
        visited = set()
        queue = deque([start])
        visited.add(start)

        while queue:
            node = queue.popleft()
            print(node, end=" ")

            for neighbor in self.graph[node]:
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append(neighbor)


# 使用字典表示图
graph = defaultdict(list)
graph[0].append(1)
graph[1].append(0)
```
:::

#### Dijkstra算法
::: code-group
```cpp
vector<int> dijkstra(int n, int start, const vector<vector<pair<int, int>>>& graph) {
    vector<int> dist(n + 1, INT_MAX);
    vector<bool> visited(n + 1, false);
    dist[start] = 0;
    
    // 使用优先队列优化
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    pq.push({0, start});
    
    while (!pq.empty()) {
        int u = pq.top().second;
        int d = pq.top().first;
        pq.pop();
        
        if (visited[u]) continue;
        visited[u] = true;
        
        for (const auto& edge : graph[u]) {
            int v = edge.first;
            int weight = edge.second;
            
            if (!visited[v] && dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
                pq.push({dist[v], v});
            }
        }
    }
    
    return dist;
}
```


```python
def dijkstra(n, start, graph):
    import heapq
    dist = [float('inf')] * (n + 1)
    dist[start] = 0
    visited = [False] * (n + 1)
    
    heap = [(0, start)]
    
    while heap:
        d, u = heapq.heappop(heap)
        
        if visited[u]:
            continue
        
        visited[u] = True
        
        for v, weight in graph[u]:
            if not visited[v] and dist[u] + weight < dist[v]:
                dist[v] = dist[u] + weight
                heapq.heappush(heap, (dist[v], v))
    
    return dist
```
:::

**复杂度分析**
| 操作 | 邻接表 | 邻接矩阵 |
|------|--------|----------|
| 存储空间 | O(V+E) | O(V²) |
| 添加边 | O(1) | O(1) |
| 检查边 | O(degree) | O(1) |
| 遍历邻居 | O(degree) | O(V) |

**适用场景**
- 社交网络关系
- 路径规划导航
- 网络拓扑结构
- 任务依赖关系
- 推荐系统

::: info
- 邻接表适合稀疏图（边较少）
- 邻接矩阵适合稠密图（边较多）
- 图算法通常需要visited数组避免重复访问
:::

---





### 位集（Bitset）

**核心思想**：集合可以用二进制表示，二进制从低到高第i位为1表示i在集合中

**转换公式**：$( f(S) = \sum_{i∈S} 2^i )$

**示例**：
- 集合$\{0,2,3\}$ → $2^0$ + $2^2$ + $2^3$ = $13$ → 二进制$1101_2$

**Bitset表示规则**：
- 用n位二进制数表示集合
- 若元素 $(a_i)$ 在集合中，第$i$位为1；否则为0  

**示例表示**：
```Plain Text
集合  A = {0, 2, 3, 5}  
Bitset表示（8位）：00101101  
0 0 1 0 1 1 0 1
↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑
7 6 5 4 3 2 1 0

解释：
- 位置0: 1 → 元素0在集合中
- 位置1: 0 → 元素1不在集合中
- 位置2: 1 → 元素2在集合中
- 位置3: 1 → 元素3在集合中
- 位置4: 0 → 元素4不在集合中
- 位置5: 1 → 元素5在集合中
- 位置6: 0 → 元素6不在集合中
- 位置7: 0 → 元素7不在集合中
```

**集合与集合的运算**

| 术语       | 集合       | 位运算       | 集合示例                     | 位运算示例                 |
|------------|------------|--------------|------------------------------|----------------------------|
| 交集       | $A \cap B$ | $a \& b$     | $\{0,2,3\} \cap \{0,1,2\} = \{0,2\}$ | $1101 \& 0111 = 0101$      |
| 并集       | $A \cup B$ | $a \mid b$   | $\{0,2,3\} \cup \{0,1,2\} = \{0,1,2,3\}$ | $1101 \mid 0111 = 1111$    |
| 对称差     | $A \Delta B$ | $a \oplus b$ | $\{0,2,3\} \Delta \{0,1,2\} = \{1,3\}$ | $1101 \oplus 0111 = 1010$  |
| 差         | $A \setminus B$ | $a \& \sim b$ | $\{0,2,3\} \setminus \{1,2\} = \{0,3\}$ | $1101 \& 1001 = 1001$      |
| 差（子集） | $A \setminus B, B \subseteq A$ | $a \oplus b$ | $\{0,2,3\} \setminus \{0,2\} = \{3\}$ | $1101 \oplus 0101 = 1000$  |
| 包含于     | $A \subseteq B$ | $a \& b = a$<br>$a \mid b = b$ | $\{0,2\} \subseteq \{0,2,3\}$ | $0101 \& 1101 = 0101$<br>$0101 \mid 1101 = 1101$ |

**集合与元素的运算**

| 术语                     | 集合                     | 位运算                     | 集合示例                     | 位运算示例                     |
|--------------------------|--------------------------|----------------------------|------------------------------|--------------------------------|
| 空集                     | $\varnothing$            | $0$                        |                              |                                |
| 单元素集合               | $\{i\}$                  | $1 << i$                   | $\{2\}$                      | $1 << 2$                       |
| 全集                     | $U = \{0,1,2,\dots,n-1\}$ | $(1 << n) - 1$             | $\{0,1,2,3\}$                | $(1 << 4) - 1$                 |
| 补集                     | $\complement_U S = U \setminus S$ | $((1 << n) - 1) \oplus s$ | $U=\{0,1,2,3\}\\\complement_U \{1,2\}=\{0,3\}$ | $1111 \oplus 0110 = 1001$      |
| 属于                     | $i \in S$                | $(s >> i) \& 1 = 1$        | $2 \in \{0,2,3\}$            | $(1101 >> 2) \& 1 = 1$         |
| 不属于                   | $i \notin S$             | $(s >> i) \& 1 = 0$        | $1 \notin \{0,2,3\}$         | $(1101 >> 1) \& 1 = 0$         |
| 添加元素                 | $S \cup \{i\}$           | $s \mid (1 << i)$          | $\{0,3\} \cup \{2\}$         | $1001 \mid (1 << 2)$           |
| 删除元素                 | $S \setminus \{i\}$      | $s \& \sim (1 << i)$       | $\{0,2,3\} \setminus \{2\}$  | $1101 \& \sim (1 << 2)$        |
| 删除元素（一定在集合中） | $S \setminus \{i\}, i \in S$ | $s \oplus (1 << i)$       | $\{0,2,3\} \setminus \{2\}$  | $1101 \oplus (1 << 2)$         |


**具体操作实现**

**遍历集合**
```python
设元素范围从 0 到 n−1，枚举范围中的元素 i，判断 i 是否在集合 s 中。
for i in range(n):
    if (s >> i) & 1:  # i 在 s 中
        # 处理 i 的逻辑
```
**枚举所有集合**
```python
设元素范围从 0 到 n−1，从空集 ∅ 枚举到全集 U：
for s in range(1 << n):
    # 处理 s 的逻辑
```

**成员检查（Contains）**
```python
def contains(self, element):
    # 检查第element位是否为1
    return (self.bits >> element) & 1 == 1

# 示例：
# 集合A: 00101101
# 检查元素3: (00101101 >> 3) & 1 = 1 → True
# 检查元素4: (00101101 >> 4) & 1 = 0 → False
```

**添加元素（Add）**
```python
def add(self, element):
    # 将第element位设为1
    self.bits |= (1 << element)

# 示例：
# 初始：00101101（包含{0,2,3,5}）
# 添加元素4：00101101 | 00010000 = 00111101
# 结果：00111101（现在包含{0,2,3,4,5}）
```

**移除元素（Remove）**
```python
def remove(self, element):
    # 将第element位设为0
    self.bits &= ~(1 << element)

# 示例：
# 初始：00111101（包含{0,2,3,4,5}）
# 移除元素3：00111101 & 11110111 = 00110101
# 结果：00110101（现在包含{0,2,4,5}）
```

**清空集合（Clear）**
```python
def clear(self):
    self.bits = 0  # 所有位设为0
```

**并集（Union）**
```python
def union(self, other):
    # 按位或运算
    return Bitset(self.bits | other.bits)

# 示例：
# A = {0,2,3,5} → 00101101
# B = {1,3,4,6} → 01011010
# A ∪ B = {0,1,2,3,4,5,6} → 01111111
# 计算：00101101 | 01011010 = 01111111
```

**交集（Intersection）**
```python
def intersection(self, other):
    # 按位与运算
    return Bitset(self.bits & other.bits)

# 示例：
# A = {0,2,3,5} → 00101101
# B = {1,3,4,6} → 01011010
# A ∩ B = {3} → 00001000
# 计算：00101101 & 01011010 = 00001000
```

**差集（Difference）**
```python
def difference(self, other):
    # A & (~B)
    return Bitset(self.bits & ~other.bits)

# 示例：
# A = {0,2,3,5} → 00101101
# B = {1,3,4,6} → 01011010
# A - B = {0,2,5} → 00100101
# 计算：00101101 & 10100101 = 00100101
```

**对称差（Symmetric Difference）**
```python
def symmetric_difference(self, other):
    # 按位异或运算
    return Bitset(self.bits ^ other.bits)

# 示例：
# A = {0,2,3,5} → 00101101
# B = {1,3,4,6} → 01011010
# A Δ B = {0,1,2,4,5,6} → 01110111
# 计算：00101101 ^ 01011010 = 01110111
```


### 线段树 (Segment Tree)

**核心思想**：把数组划分成多个小区间，预处理并存储这些区间信息，实现快速区间查询和更新。

**直观比喻**
想象你要管理一家公司的月度销售额：
原始数据：1月-12月的销售额数组
你想快速回答："第一季度（1-3月）总销售额是多少？"
也经常需要更新某个月的销售额

线段树的做法：

1. 把1-12月分成更小的区间
2. 提前计算好每个区间的总和并存储
3. 查询时，只需组合几个预先计算好的区间结果
   
```text
原始数组：[1, 3, 5, 7, 9, 11]
索引：     0  1  2  3  4  5

构建的线段树（存储区间和）：
                      [0-5]: 36
                     /       \
             [0-2]: 9        [3-5]: 27
            /      \         /      \
      [0-1]: 4   [2-2]:5  [3-4]:16  [5-5]:11
     /     \
[0-0]:1 [1-1]:3
```

**关键特点**  
**二叉树结构**：每个节点代表一个区间  
**存储聚合信息**：区间和、最大值、最小值等  

**时间复杂度**：  
1. 构建：O(n)
2. 区间查询：O(log n)
3. 单点更新：O(log n)
4. 区间更新（带懒标记）：O(log n)

**核心操作**
::: code-group
```cpp
#include <iostream>
#include <vector>
#include <cmath>
#include <climits>
using namespace std;

class SegmentTree {
private:
    vector<int> tree;      // 线段树数组
    vector<int> lazy;      // 懒标记数组
    vector<int> data;      // 原始数据（可选）
    int n;                 // 原始数据大小
    
    // 构建线段树
    void build(int node, int left, int right) {
        if (left == right) {
            tree[node] = data[left];
            return;
        }
        
        int mid = (left + right) / 2;
        int leftChild = 2 * node + 1;
        int rightChild = 2 * node + 2;
        
        build(leftChild, left, mid);
        build(rightChild, mid + 1, right);
        
        tree[node] = tree[leftChild] + tree[rightChild];
    }
    
    // 区间查询
    int query(int node, int left, int right, int ql, int qr) {
        // 当前区间完全在查询区间内
        if (ql <= left && right <= qr) {
            return tree[node];
        }
        
        // 当前区间与查询区间无交集
        if (right < ql || left > qr) {
            return 0;
        }
        
        // 部分重叠，递归查询
        int mid = (left + right) / 2;
        int leftChild = 2 * node + 1;
        int rightChild = 2 * node + 2;
        
        int leftSum = query(leftChild, left, mid, ql, qr);
        int rightSum = query(rightChild, mid + 1, right, ql, qr);
        
        return leftSum + rightSum;
    }
    
    // 单点更新
    void updatePoint(int node, int left, int right, int index, int value) {
        if (left == right) {
            tree[node] = value;
            return;
        }
        
        int mid = (left + right) / 2;
        int leftChild = 2 * node + 1;
        int rightChild = 2 * node + 2;
        
        if (index <= mid) {
            updatePoint(leftChild, left, mid, index, value);
        } else {
            updatePoint(rightChild, mid + 1, right, index, value);
        }
        
        tree[node] = tree[leftChild] + tree[rightChild];
    }
    
    // 带懒标记的区间更新
    void updateRangeLazy(int node, int left, int right, int ul, int ur, int value) {
        int leftChild = 2 * node + 1;
        int rightChild = 2 * node + 2;
        
        // 下推懒标记
        if (lazy[node] != 0) {
            tree[node] += lazy[node] * (right - left + 1);
            if (left != right) {
                lazy[leftChild] += lazy[node];
                lazy[rightChild] += lazy[node];
            }
            lazy[node] = 0;
        }
        
        // 当前区间完全在更新区间外
        if (right < ul || left > ur) {
            return;
        }
        
        // 当前区间完全在更新区间内
        if (ul <= left && right <= ur) {
            tree[node] += value * (right - left + 1);
            if (left != right) {
                lazy[leftChild] += value;
                lazy[rightChild] += value;
            }
            return;
        }
        
        // 部分重叠，递归更新
        int mid = (left + right) / 2;
        updateRangeLazy(leftChild, left, mid, ul, ur, value);
        updateRangeLazy(rightChild, mid + 1, right, ul, ur, value);
        
        tree[node] = tree[leftChild] + tree[rightChild];
    }
    
    // 带懒标记的区间查询
    int queryRangeLazy(int node, int left, int right, int ql, int qr) {
        int leftChild = 2 * node + 1;
        int rightChild = 2 * node + 2;
        
        // 下推懒标记
        if (lazy[node] != 0) {
            tree[node] += lazy[node] * (right - left + 1);
            if (left != right) {
                lazy[leftChild] += lazy[node];
                lazy[rightChild] += lazy[node];
            }
            lazy[node] = 0;
        }
        
        // 当前区间完全在查询区间内
        if (ql <= left && right <= qr) {
            return tree[node];
        }
        
        // 当前区间与查询区间无交集
        if (right < ql || left > qr) {
            return 0;
        }
        
        // 部分重叠，递归查询
        int mid = (left + right) / 2;
        int leftSum = queryRangeLazy(leftChild, left, mid, ql, qr);
        int rightSum = queryRangeLazy(rightChild, mid + 1, right, ql, qr);
        
        return leftSum + rightSum;
    }
    
public:
    // 构造函数
    SegmentTree(const vector<int>& nums) {
        data = nums;
        n = nums.size();
        tree.resize(4 * n);
        lazy.resize(4 * n, 0);
        build(0, 0, n - 1);
    }
    
    // 区间查询接口
    int rangeQuery(int left, int right) {
        if (left < 0 || right >= n || left > right) {
            throw out_of_range("查询区间非法");
        }
        return query(0, 0, n - 1, left, right);
    }
    
    // 单点更新接口
    void pointUpdate(int index, int value) {
        if (index < 0 || index >= n) {
            throw out_of_range("索引越界");
        }
        updatePoint(0, 0, n - 1, index, value);
    }
    
    // 区间更新接口（带懒标记）
    void rangeUpdate(int left, int right, int value) {
        if (left < 0 || right >= n || left > right) {
            throw out_of_range("更新区间非法");
        }
        updateRangeLazy(0, 0, n - 1, left, right, value);
    }
    
    // 带懒标记的区间查询接口
    int rangeQueryLazy(int left, int right) {
        if (left < 0 || right >= n || left > right) {
            throw out_of_range("查询区间非法");
        }
        return queryRangeLazy(0, 0, n - 1, left, right);
    }
    
    // 打印线段树（调试用）
    void printTree() {
        cout << "线段树数组: ";
        for (int i = 0; i < tree.size(); i++) {
            cout << tree[i] << " ";
        }
        cout << endl;
    }
    
    // 获取原始数组当前状态（考虑懒标记）
    vector<int> getCurrentArray() {
        vector<int> result(n);
        for (int i = 0; i < n; i++) {
            result[i] = rangeQueryLazy(i, i);
        }
        return result;
    }
};

// 使用示例
int main() {
    cout << "=== 线段树示例程序 ===" << endl;
    
    // 1. 创建线段树
    vector<int> arr = {1, 3, 5, 7, 9, 11};
    SegmentTree segTree(arr);
    
    cout << "\n原始数组: ";
    for (int num : arr) cout << num << " ";
    cout << endl;
    
    // 2. 区间查询测试
    cout << "\n--- 区间查询测试 ---" << endl;
    cout << "查询[0,2]的和: " << segTree.rangeQuery(0, 2) << endl;  // 9
    cout << "查询[2,4]的和: " << segTree.rangeQuery(2, 4) << endl;  // 21
    cout << "查询[1,3]的和: " << segTree.rangeQuery(1, 3) << endl;  // 15
    
    // 3. 单点更新测试
    cout << "\n--- 单点更新测试 ---" << endl;
    segTree.pointUpdate(2, 10);
    cout << "将索引2的值从5改为10" << endl;
    cout << "更新后查询[0,2]的和: " << segTree.rangeQuery(0, 2) << endl;  // 14
    
    // 4. 区间更新测试（带懒标记）
    cout << "\n--- 区间更新测试（带懒标记） ---" << endl;
    SegmentTree segTreeLazy(arr);  // 重新创建
    
    cout << "更新前数组: ";
    vector<int> before = segTreeLazy.getCurrentArray();
    for (int num : before) cout << num << " ";
    cout << endl;
    
    // 将索引1-4的值都加5
    segTreeLazy.rangeUpdate(1, 4, 5);
    
    cout << "将区间[1,4]的值都增加5" << endl;
    
    cout << "更新后数组: ";
    vector<int> after = segTreeLazy.getCurrentArray();
    for (int num : after) cout << num << " ";
    cout << endl;
    
    cout << "更新后查询[1,4]的和: " << segTreeLazy.rangeQueryLazy(1, 4) << endl;
    
    // 5. 动态查询示例
    cout << "\n--- 动态操作示例 ---" << endl;
    SegmentTree dynamicTree({2, 4, 6, 8, 10});
    
    cout << "初始数组: ";
    for (int num : dynamicTree.getCurrentArray()) cout << num << " ";
    cout << endl;
    
    cout << "[0,3]的和: " << dynamicTree.rangeQuery(0, 3) << endl;
    
    dynamicTree.pointUpdate(1, 10);
    cout << "更新索引1为10后，[0,3]的和: " << dynamicTree.rangeQuery(0, 3) << endl;
    
    dynamicTree.rangeUpdate(2, 4, 3);
    cout << "区间[2,4]增加3后，[0,4]的和: " << dynamicTree.rangeQueryLazy(0, 4) << endl;
    
    return 0;
}
```
```python
class SegmentTree:
    """线段树实现（区间和查询）"""
    
    def __init__(self, data):
        """
        初始化线段树
        :param data: 原始数据数组
        """
        self.n = len(data)
        self.data = data
        self.tree = [0] * (4 * self.n)  # 4倍空间保证足够
        self.lazy = [0] * (4 * self.n)  # 懒标记数组（用于区间更新）
        self._build(0, 0, self.n - 1)
    
    def _build(self, node, left, right):
        """构建线段树"""
        if left == right:
            # 叶子节点，存储原始数据
            self.tree[node] = self.data[left]
            return
        
        mid = (left + right) // 2
        left_child = 2 * node + 1
        right_child = 2 * node + 2
        
        # 递归构建左右子树
        self._build(left_child, left, mid)
        self._build(right_child, mid + 1, right)
        
        # 当前节点存储左右子树的和
        self.tree[node] = self.tree[left_child] + self.tree[right_child]
    
    def query(self, ql, qr):
        """
        查询区间[ql, qr]的和
        """
        return self._query(0, 0, self.n - 1, ql, qr)
    
    def _query(self, node, left, right, ql, qr):
        """递归查询实现"""
        # 1. 如果当前区间完全在查询区间内，直接返回
        if ql <= left and right <= qr:
            return self.tree[node]
        
        # 2. 如果当前区间与查询区间没有交集，返回0
        if right < ql or left > qr:
            return 0
        
        # 3. 部分重叠，递归查询左右子树
        mid = (left + right) // 2
        left_child = 2 * node + 1
        right_child = 2 * node + 2
        
        left_sum = self._query(left_child, left, mid, ql, qr)
        right_sum = self._query(right_child, mid + 1, right, ql, qr)
        
        return left_sum + right_sum
    
    def update_point(self, index, value):
        """
        单点更新：将index位置的值更新为value
        """
        self._update_point(0, 0, self.n - 1, index, value)
    
    def _update_point(self, node, left, right, index, value):
        """递归单点更新实现"""
        if left == right:
            # 找到目标叶子节点
            self.tree[node] = value
            return
        
        mid = (left + right) // 2
        left_child = 2 * node + 1
        right_child = 2 * node + 2
        
        if index <= mid:
            # 目标在左子树
            self._update_point(left_child, left, mid, index, value)
        else:
            # 目标在右子树
            self._update_point(right_child, mid + 1, right, index, value)
        
        # 更新当前节点的值
        self.tree[node] = self.tree[left_child] + self.tree[right_child]
    
    def update_range(self, ul, ur, value):
        """
        区间更新：将区间[ul, ur]的所有值增加value
        使用懒标记优化
        """
        self._update_range(0, 0, self.n - 1, ul, ur, value)
    
    def _update_range(self, node, left, right, ul, ur, value):
        """带懒标记的区间更新实现"""
        left_child = 2 * node + 1
        right_child = 2 * node + 2
        
        # 1. 下推懒标记
        if self.lazy[node] != 0:
            self.tree[node] += self.lazy[node] * (right - left + 1)
            if left != right:  # 非叶子节点
                self.lazy[left_child] += self.lazy[node]
                self.lazy[right_child] += self.lazy[node]
            self.lazy[node] = 0
        
        # 2. 如果当前区间完全在更新区间外，直接返回
        if right < ul or left > ur:
            return
        
        # 3. 如果当前区间完全在更新区间内，更新并设置懒标记
        if ul <= left and right <= ur:
            self.tree[node] += value * (right - left + 1)
            if left != right:  # 非叶子节点
                self.lazy[left_child] += value
                self.lazy[right_child] += value
            return
        
        # 4. 部分重叠，递归更新左右子树
        mid = (left + right) // 2
        self._update_range(left_child, left, mid, ul, ur, value)
        self._update_range(right_child, mid + 1, right, ul, ur, value)
        
        # 5. 更新当前节点
        self.tree[node] = self.tree[left_child] + self.tree[right_child]
    
    def query_range_lazy(self, ql, qr):
        """带懒标记的区间查询"""
        return self._query_range_lazy(0, 0, self.n - 1, ql, qr)
    
    def _query_range_lazy(self, node, left, right, ql, qr):
        """带懒标记的查询实现"""
        left_child = 2 * node + 1
        right_child = 2 * node + 2
        
        # 1. 下推懒标记
        if self.lazy[node] != 0:
            self.tree[node] += self.lazy[node] * (right - left + 1)
            if left != right:  # 非叶子节点
                self.lazy[left_child] += self.lazy[node]
                self.lazy[right_child] += self.lazy[node]
            self.lazy[node] = 0
        
        # 2. 如果当前区间完全在查询区间内，直接返回
        if ql <= left and right <= qr:
            return self.tree[node]
        
        # 3. 如果当前区间与查询区间没有交集，返回0
        if right < ql or left > qr:
            return 0
        
        # 4. 部分重叠，递归查询
        mid = (left + right) // 2
        left_sum = self._query_range_lazy(left_child, left, mid, ql, qr)
        right_sum = self._query_range_lazy(right_child, mid + 1, right, ql, qr)
        
        return left_sum + right_sum


# 使用示例
if __name__ == "__main__":
    # 创建线段树
    arr = [1, 3, 5, 7, 9, 11]
    seg_tree = SegmentTree(arr)
    
    print("原始数组:", arr)
    print("线段树结构（简化）:", seg_tree.tree[:15])
    
    # 区间查询测试
    print("\n--- 区间查询测试 ---")
    print("查询[0,2]的和:", seg_tree.query(0, 2))  # 1+3+5=9
    print("查询[2,4]的和:", seg_tree.query(2, 4))  # 5+7+9=21
    print("查询[1,3]的和:", seg_tree.query(1, 3))  # 3+5+7=15
    
    # 单点更新测试
    print("\n--- 单点更新测试 ---")
    seg_tree.update_point(2, 10)  # 将索引2的值从5改为10
    print("更新后查询[0,2]的和:", seg_tree.query(0, 2))  # 1+3+10=14
    
    # 区间更新测试（带懒标记）
    print("\n--- 区间更新测试 ---")
    seg_tree2 = SegmentTree([1, 3, 5, 7, 9, 11])
    seg_tree2.update_range(1, 4, 5)  # 索引1-4的值都加5
    print("区间更新后数组（懒标记实现）:")
    for i in range(6):
        print(f"索引{i}: {seg_tree2.query(i, i)}", end="  ")
    print()
    print("更新后查询[1,4]的和:", seg_tree2.query_range_lazy(1, 4))
```
:::


**适用场景**
- 频繁的区间查询和修改操作
- 需要维护区间和、最大值、最小值等
- 区间最值操作与历史最值维护
- 离线算法中处理区间约束

---



### 平衡树 (Balanced Tree)

**定义**
平衡树是一类自平衡的二叉搜索树，通过旋转等操作确保树的高度保持在O(log n)，从而保证各种操作的高效性。

**存储原理**
- **二叉搜索性质**：左子树节点小于根节点，右子树节点大于根节点
- **平衡维护**：通过旋转或其他操作保持树的平衡
- **高度控制**：确保树的高度不超过O(log n)

###  树堆(Treap)

**核心操作**
::: code-group
```cpp
class Treap {
private:
    struct Node {
        int key, priority;
        Node *left, *right;
        Node(int k) : key(k), priority(rand()), left(nullptr), right(nullptr) {}
    };

    Node* root;

    // 右旋
    Node* rotateRight(Node* y) {
        Node* x = y->left;
        y->left = x->right;
        x->right = y;
        return x;
    }

    // 左旋
    Node* rotateLeft(Node* x) {
        Node* y = x->right;
        x->right = y->left;
        y->left = x;
        return y;
    }

    // 插入
    Node* insert(Node* node, int key) {
        if (!node) return new Node(key);

        if (key < node->key) {
            node->left = insert(node->left, key);
            if (node->left->priority > node->priority)
                node = rotateRight(node);
        } else {
            node->right = insert(node->right, key);
            if (node->right->priority > node->priority)
                node = rotateLeft(node);
        }
        return node;
    }

    // 删除
    Node* remove(Node* node, int key) {
        if (!node) return nullptr;

        if (key < node->key) {
            node->left = remove(node->left, key);
        } else if (key > node->key) {
            node->right = remove(node->right, key);
        } else {
            // 找到要删除的节点
            if (!node->left) return node->right;
            if (!node->right) return node->left;

            // 有两个子节点，旋转优先级较高的子节点
            if (node->left->priority > node->right->priority) {
                node = rotateRight(node);
                node->right = remove(node->right, key);
            } else {
                node = rotateLeft(node);
                node->left = remove(node->left, key);
            }
        }
        return node;
    }

    // 查找
    bool search(Node* node, int key) {
        if (!node) return false;
        if (key == node->key) return true;
        return key < node->key ? search(node->left, key) : search(node->right, key);
    }

public:
    Treap() : root(nullptr) {}

    void insert(int key) {
        root = insert(root, key);
    }

    void remove(int key) {
        root = remove(root, key);
    }

    bool search(int key) {
        return search(root, key);
    }
};
```
::: 
**复杂度分析**
| 操作 | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度 |
|------|----------------|----------------|------------|
| 插入 | O(log n) | O(n) | O(n) |
| 删除 | O(log n) | O(n) | - |
| 查找 | O(log n) | O(n) | - |

---

### 字典树 (Trie)

**定义**
想象一下你在字典里查单词：
- 先找第一个字母，比如"apple"先找'a'
- 然后在'a'的部分找第二个字母'p'
- 接着在'ap'的部分找第三个字母'p'...

字典树就是这种思想的实现：  
1. **树结构**：每个节点代表一个字母
2. **路径即单词**：从根节点到某个节点的路径组成一个单词
3. **共享前缀**：多个单词共享相同前缀时，它们共享路径
4. **结束标记**：节点标记是否为单词结尾

简单例子：插入"cat", "car", "dog":
```text
    根(root)
    /    \
   c      d
  /        \
 a          o
/ \          \
t* r*         g*
```

**核心操作**
::: code-group
```cpp
#include <iostream>
#include <unordered_map>
#include <memory>
#include <string>
#include <vector>

using namespace std;

class TrieNode {
public:
    unordered_map<char, shared_ptr<TrieNode>> children;
    bool is_end;
    
    TrieNode() : is_end(false) {}
};

class Trie {
private:
    shared_ptr<TrieNode> root;
    
public:
    Trie() : root(make_shared<TrieNode>()) {}
    
    // 插入单词
    void insert(const string& word) {
        auto node = root;
        for (char ch : word) {
            if (node->children.find(ch) == node->children.end()) {
                node->children[ch] = make_shared<TrieNode>();
            }
            node = node->children[ch];
        }
        node->is_end = true;
    }
    
    // 搜索完整单词
    bool search(const string& word) {
        auto node = root;
        for (char ch : word) {
            if (node->children.find(ch) == node->children.end()) {
                return false;
            }
            node = node->children[ch];
        }
        return node->is_end;
    }
    
    // 检查前缀
    bool startsWith(const string& prefix) {
        auto node = root;
        for (char ch : prefix) {
            if (node->children.find(ch) == node->children.end()) {
                return false;
            }
            node = node->children[ch];
        }
        return true;
    }
    
    // 删除单词
    bool remove(const string& word) {
        vector<pair<shared_ptr<TrieNode>, char>> path;
        auto node = root;
        
        // 1. 找到单词节点
        for (char ch : word) {
            if (node->children.find(ch) == node->children.end()) {
                return false;
            }
            path.emplace_back(node, ch);
            node = node->children[ch];
        }
        
        if (!node->is_end) {
            return false;  // 单词不存在
        }
        
        // 2. 标记为非单词结尾
        node->is_end = false;
        
        // 3. 删除无用节点
        if (node->children.empty()) {
            for (auto it = path.rbegin(); it != path.rend(); ++it) {
                auto& [parent, ch] = *it;
                parent->children.erase(ch);
                if (!parent->children.empty() || parent->is_end) {
                    break;
                }
            }
        }
        
        return true;
    }
    
    // 打印所有单词（辅助函数）
    void printAllWords() {
        vector<string> words;
        collectWords(root, "", words);
        cout << "Trie中所有单词: ";
        for (const auto& word : words) {
            cout << word << " ";
        }
        cout << endl;
    }
    
private:
    void collectWords(shared_ptr<TrieNode> node, string prefix, vector<string>& result) {
        if (node->is_end) {
            result.push_back(prefix);
        }
        for (const auto& [ch, child] : node->children) {
            collectWords(child, prefix + ch, result);
        }
    }
};

// 使用示例
int main() {
    Trie trie;
    
    // 插入单词
    vector<string> words = {"apple", "app", "banana", "bat", "ball"};
    for (const auto& word : words) {
        trie.insert(word);
    }
    
    // 测试
    cout << boolalpha;  // 让bool输出为true/false
    cout << "搜索 'app': " << trie.search("app") << endl;      // true
    cout << "搜索 'ap': " << trie.search("ap") << endl;        // false
    
    cout << "前缀 'ap': " << trie.startsWith("ap") << endl;    // true
    cout << "前缀 'ba': " << trie.startsWith("ba") << endl;    // true
    cout << "前缀 'ca': " << trie.startsWith("ca") << endl;    // false
    
    // 删除测试
    trie.remove("app");
    cout << "删除后搜索 'app': " << trie.search("app") << endl;  // false
    cout << "搜索 'apple': " << trie.search("apple") << endl;    // true
    
    // 打印所有单词
    trie.printAllWords();
    
    return 0;
}
```
```python
# Python实现
class TrieNode:
    def __init__(self):
        self.children = {}  # 存储子节点：字符->节点
        self.is_end = False  # 标记是否为单词结尾

class Trie:
    def __init__(self):
        self.root = TrieNode()
    
    def insert(self, word: str) -> None:
        """插入单词"""
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end = True
    
    def search(self, word: str) -> bool:
        """搜索完整单词"""
        node = self.root
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
        return node.is_end
    
    def startsWith(self, prefix: str) -> bool:
        """检查是否有以prefix开头的单词"""
        node = self.root
        for char in prefix:
            if char not in node.children:
                return False
            node = node.children[char]
        return True
    
    def delete(self, word: str) -> bool:
        """删除单词（简化版）"""
        node = self.root
        path = []  # 记录路径
        
        # 1. 找到单词节点
        for char in word:
            if char not in node.children:
                return False
            path.append((node, char))
            node = node.children[char]
        
        if not node.is_end:
            return False  # 单词不存在
        
        # 2. 标记为非单词结尾
        node.is_end = False
        
        # 3. 删除无用节点（如果节点没有子节点且不是其他单词的结尾）
        if not node.children:
            for parent, char in reversed(path):
                del parent.children[char]
                if parent.children or parent.is_end:
                    break
        
        return True


# 使用示例
if __name__ == "__main__":
    trie = Trie()
    
    # 插入单词
    words = ["apple", "app", "banana", "bat", "ball"]
    for word in words:
        trie.insert(word)
    
    # 测试搜索
    print("搜索 'app':", trie.search("app"))      # True
    print("搜索 'ap':", trie.search("ap"))        # False
    
    # 测试前缀
    print("前缀 'ap':", trie.startsWith("ap"))    # True
    print("前缀 'ba':", trie.startsWith("ba"))    # True
    print("前缀 'ca':", trie.startsWith("ca"))    # False
    
    # 删除测试
    trie.delete("app")
    print("删除后搜索 'app':", trie.search("app"))  # False
    print("搜索 'apple':", trie.search("apple"))    # True（app还在）
```
::: 


**时间复杂度** ：插入/搜索/删除：O(L)，L是单词长度，与字典中单词数量无关！  
**空间复杂度** ：最坏情况：O(N×L)，N是单词数，L是平均长度，但共享前缀能节省空间。  

---


### 可持久化线段树

**定义**
可持久化线段树能够保存历史版本，支持对历史版本的查询，通过共享不变部分来节省空间。

**存储原理**
- **版本管理**：每个操作生成新版本，旧版本保留
- **节点共享**：未修改的节点在多个版本间共享
- **动态创建**：只创建被修改的节点及其路径上的节点

**核心操作**
::: code-group
```cpp
class PersistentSegmentTree {
private:
    struct Node {
        int value;
        Node *left, *right;
        Node(int v = 0, Node* l = nullptr, Node* r = nullptr)
            : value(v), left(l), right(r) {}
    };

    vector<Node*> versions;  // 存储各个版本的根节点
    int n;

    Node* build(int l, int r) {
        if (l == r) return new Node(0);
        int mid = (l + r) / 2;
        return new Node(0, build(l, mid), build(mid + 1, r));
    }

    Node* update(Node* node, int l, int r, int pos, int val) {
        if (!node) node = new Node();
        if (l == r) {
            return new Node(node->value + val);
        }

        int mid = (l + r) / 2;
        Node* newNode = new Node();

        if (pos <= mid) {
            newNode->left = update(node->left, l, mid, pos, val);
            newNode->right = node->right;
        } else {
            newNode->left = node->left;
            newNode->right = update(node->right, mid + 1, r, pos, val);
        }

        newNode->value = (newNode->left ? newNode->left->value : 0) +
                         (newNode->right ? newNode->right->value : 0);
        return newNode;
    }

    int query(Node* node, int l, int r, int ql, int qr) {
        if (!node || ql > r || qr < l) return 0;
        if (ql <= l && r <= qr) return node->value;

        int mid = (l + r) / 2;
        return query(node->left, l, mid, ql, qr) +
               query(node->right, mid + 1, r, ql, qr);
    }

public:
    PersistentSegmentTree(int n) : n(n) {
        versions.push_back(build(1, n));  // 初始版本
    }

    void update(int version, int pos, int val) {
        Node* newRoot = update(versions[version], 1, n, pos, val);
        versions.push_back(newRoot);
    }

    int query(int version, int l, int r) {
        return query(versions[version], 1, n, l, r);
    }

    int getVersionCount() {
        return versions.size() - 1;
    }
};
```
:::
**复杂度分析**
| 操作 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| 版本更新 | O(log n) | O(log n) |
| 历史查询 | O(log n) | - |
| 总空间消耗 | - | O(n + m log n) |

*注：m为操作次数*

**适用场景**
- 需要查询历史状态的场景
- 离线算法中的应用
- 函数式编程中的数据结构
- 区间第k小问题
