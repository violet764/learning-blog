# 数据结构与算法总览

**数据结构**是计算机中存储、组织数据的方式。更通俗地说，数据结构是计算机程序中用于组织、管理和存储数据的一种格式，它不仅是数据元素的集合，还包括数据元素之间的关系。

---

***数据结构全体系知识图谱***

```
数据结构体系
├── 基础数据结构
│   ├── 线性结构
│   │   ├── 数组（静态存储）
│   │   ├── 链表（动态存储）
│   │   ├── 栈（后进先出）
│   │   └── 队列（先进先出）
│   └── 非线性基础结构
│       ├── 哈希表（键值映射）
│       └── 并查集（集合操作）
├── 高级数据结构
│   ├── 树形结构
│   │   ├── 二叉树
│   │   ├── 线段树（区间操作）
│   │   ├── 树状数组（前缀和）
│   │   ├── 平衡树（动态有序）
│   │   │   ├── Treap
│   │   │   ├── Splay树
│   │   │   └── 其他平衡树
│   │   ├── 字典树（字符串处理）
│   │   └── 堆（优先队列）
│   ├── 可持久化结构
│   │   ├── 可持久化线段树
│   │   ├── 可持久化字典树
│   │   └── 其他可持久化结构
│   └── 复合结构
│       ├── 树套树
│       ├── 分块结构
│       └── 动态开点结构
└── 特殊结构
    ├── vEB树（整数集合）
    ├── zkw线段树（非递归线段树）
    └── 压位Trie（空间优化）
```

---

## 基础数据结构

### 数组 (Array)

**定义**
数组是最基础的线性数据结构，它存储相同类型的元素，并在内存中连续分配空间。

**存储原理**
- **连续存储**：所有元素在内存中连续存放
- **索引访问**：通过下标直接计算元素地址
- **固定大小**：创建时确定大小，运行时通常不可变

**核心操作**

```cpp
// 数组定义与初始化
int arr[100];                 // 静态数组
vector<int> vec;              // 动态数组

// 访问操作
int value = arr[index];       // O(1)
arr[index] = newValue;        // O(1)

// 容量操作
int size = sizeof(arr) / sizeof(arr[0]);  // O(1)
vec.push_back(x);             // 均摊O(1)
vec.size();                   // O(1)

// Python实现
arr = [0] * 100               # 静态数组
arr = []                      # 动态数组
value = arr[index]            # O(1)
arr.append(x)                 # 均摊O(1)
```

**复杂度分析**
| 操作 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| 访问 | O(1) | - |
| 查找 | O(n) | - |
| 插入 | O(n) | - |
| 删除 | O(n) | O(n) |

**适用场景**
- 需要频繁随机访问元素
- 元素数量相对稳定
- 对内存连续性有要求

---

### 链表 (Linked List)

**定义**
链表是一种通过指针连接的线性数据结构，元素在内存中可以不连续存储。

**存储原理**
- **节点结构**：每个节点包含数据域和指针域
- **动态连接**：通过指针将各节点串联起来
- **灵活扩展**：可以动态插入和删除节点

**核心操作**

```cpp
// 链表节点定义
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

// 插入操作
void insert(ListNode* head, int val, int position) {
    ListNode* newNode = new ListNode(val);
    if (position == 0) {
        newNode->next = head;
        return newNode;
    }
    ListNode* current = head;
    for (int i = 0; i < position - 1 && current; i++) {
        current = current->next;
    }
    if (current) {
        newNode->next = current->next;
        current->next = newNode;
    }
}

// 删除操作
void remove(ListNode* head, int position) {
    if (position == 0 && head) {
        ListNode* temp = head;
        head = head->next;
        delete temp;
        return;
    }
    ListNode* current = head;
    for (int i = 0; i < position - 1 && current->next; i++) {
        current = current->next;
    }
    if (current->next) {
        ListNode* temp = current->next;
        current->next = temp->next;
        delete temp;
    }
}
```

```python
# Python实现
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
```

**复杂度分析**
| 操作 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| 访问 | O(n) | - |
| 查找 | O(n) | - |
| 插入 | O(1) | O(n) |
| 删除 | O(1) | O(n) |

**适用场景**
- 需要频繁插入和删除操作
- 元素数量变化较大
- 不需要频繁随机访问

---

### 栈 (Stack)

**定义**
栈是一种后进先出(LIFO)的线性数据结构，只允许在一端进行插入和删除操作。

**存储原理**
- **单端操作**：所有操作都在栈顶进行
- **压栈弹出**：`push`操作添加元素，`pop`操作移除元素
- **层次访问**：只能访问栈顶元素

**核心操作**

```cpp
// 使用数组实现栈
class ArrayStack {
private:
    vector<int> data;

public:
    void push(int x) {         // O(1)
        data.push_back(x);
    }

    int pop() {                // O(1)
        if (empty()) throw runtime_error("Stack is empty");
        int top = data.back();
        data.pop_back();
        return top;
    }

    int top() {                // O(1)
        if (empty()) throw runtime_error("Stack is empty");
        return data.back();
    }

    bool empty() {             // O(1)
        return data.empty();
    }
};

// STL栈使用
stack<int> st;
st.push(1);                    // 入栈
st.top();                      // 获取栈顶
st.pop();                      // 出栈
st.empty();                    // 判空
```

```python
# Python实现
class Stack:
    def __init__(self):
        self.data = []

    def push(self, x):         # O(1)
        self.data.append(x)

    def pop(self):              # O(1)
        if not self.data:
            raise Exception("Stack is empty")
        return self.data.pop()

    def top(self):              # O(1)
        if not self.data:
            raise Exception("Stack is empty")
        return self.data[-1]

    def empty(self):            # O(1)
        return len(self.data) == 0
```

**复杂度分析**
| 操作 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| push | O(1) | O(n) |
| pop | O(1) | - |
| top | O(1) | - |

**适用场景**
- 函数调用栈
- 表达式求值
- 深度优先搜索(DFS)
- 括号匹配检查

---

### 队列 (Queue)

**定义**
队列是一种先进先出(FIFO)的线性数据结构，在队尾插入元素，在队头删除元素。

**存储原理**
- **双端操作**：插入在队尾，删除在队头
- **顺序服务**：按照元素到达的顺序进行处理
- **环形缓冲**：常用循环数组实现提高效率

**核心操作**

```cpp
// 使用数组实现队列
class ArrayQueue {
private:
    vector<int> data;
    int front, rear;

public:
    ArrayQueue(int capacity) : front(0), rear(0) {
        data.resize(capacity);
    }

    void enqueue(int x) {       // O(1)
        data[rear] = x;
        rear = (rear + 1) % data.size();
    }

    int dequeue() {            // O(1)
        if (empty()) throw runtime_error("Queue is empty");
        int result = data[front];
        front = (front + 1) % data.size();
        return result;
    }

    bool empty() {             // O(1)
        return front == rear;
    }
};

// STL队列使用
queue<int> q;
q.push(1);                     // 入队
q.front();                     // 获取队头
q.pop();                       // 出队
q.empty();                     // 判空
```

```python

# Python实现
from collections import deque

queue = deque()
queue.append(1)                # 入队
queue[0]                       # 队头元素
queue.popleft()                # 出队
len(queue) == 0                # 判空
```

**复杂度分析**
| 操作 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| enqueue | O(1) | O(n) |
| dequeue | O(1) | - |
| front | O(1) | - |

**适用场景**
- 广度优先搜索(BFS)
- 任务调度
- 缓冲区管理
- 层次遍历

---

### 哈希表（HashMap）

**定义**
哈希表是基于键值对的存储结构，通过哈希函数将键映射到存储位置，实现o(1)快速查找。

**存储原理**
- **哈希映射**：使用哈希函数计算键的存储地址
- **冲突处理**：解决不同键映射到同一位置的问题
- **动态扩容**：当元素过多时自动扩展容量

**核心操作**

```cpp
// 哈希函数示例
int hashFunction(int key, int tableSize) {
    return key % tableSize;  // 简单取模哈希
}

// STL哈希表使用
unordered_map<string, int> hm;
hm["apple"] = 5;             // 插入/修改
int value = hm["apple"];     // 查找
hm.erase("apple");           // 删除
bool exists = hm.count("apple"); // 检查存在

unordered_set<int> hs;
hs.insert(5);                 // 插入
bool exists = hs.count(5);   // 检查存在
```

```python
# Python实现
# 字典就是哈希表
hm = {}
hm["apple"] = 5              # 插入/修改
value = hm["apple"]          # 查找
del hm["apple"]              # 删除
"apple" in hm                # 检查存在

# 集合也是哈希表
hs = set()
hs.add(5)                    # 插入
5 in hs                      # 检查存在
```

**复杂度分析**
| 操作 | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度 |
|------|----------------|----------------|------------|
| 插入 | O(1) | O(n) | O(n) |
| 删除 | O(1) | O(n) | - |
| 查找 | O(1) | O(n) | - |

**适用场景**
- 需要快速查找、插入和删除
- 键值对存储需求
- 去重和计数问题
- 缓存实现

::: info
- 哈希冲突可能导致性能退化
- 需要选择合适的哈希函数
- 哈希表遍历顺序不确定
:::

---

### 并查集 

**定义**
并查集是一种维护集合的数据结构，支持高效的集合合并和查找操作。

**存储原理**
- **树形结构**：每个集合表示为一棵树
- **路径压缩**：查找时压缩路径减少高度
- **按秩合并**：合并时将小树合并到大树

**核心操作**

```cpp
class DSU {
private:
    vector<int> parent, rank;

public:
    DSU(int n) {
        parent.resize(n);
        rank.resize(n, 0);
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }

    int find(int x) {             // 查找根节点
        if (parent[x] != x) {
            parent[x] = find(parent[x]);  // 路径压缩
        }
        return parent[x];
    }

    void unite(int x, int y) {    // 合并两个集合
        x = find(x);
        y = find(y);
        if (x == y) return;

        // 按秩合并
        if (rank[x] < rank[y]) {
            parent[x] = y;
        } else {
            parent[y] = x;
            if (rank[x] == rank[y]) {
                rank[x]++;
            }
        }
    }

    bool same(int x, int y) {     // 判断是否同集合
        return find(x) == find(y);
    }
};
```
```python
# Python实现
class DSU:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n

    def find(self, x):            # 查找根节点
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])  # 路径压缩
        return self.parent[x]

    def unite(self, x, y):        # 合并两个集合
        x, y = self.find(x), self.find(y)
        if x == y:
            return

        # 按秩合并
        if self.rank[x] < self.rank[y]:
            self.parent[x] = y
        else:
            self.parent[y] = x
            if self.rank[x] == self.rank[y]:
                self.rank[x] += 1

    def same(self, x, y):         # 判断是否同集合
        return self.find(x) == self.find(y)
```

**复杂度分析**
| 操作 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| find | α(n) ≈ O(1) | O(n) |
| unite | α(n) ≈ O(1) | - |
| same | α(n) ≈ O(1) | - |

**适用场景**
- 连通性问题
- 最小生成树算法
- 动态连通性检查
- 等价关系维护

---

### STL容器速查表

| 容器类型 | 底层结构 | 时间复杂度(访问) | 时间复杂度(插入) | 适用场景 |
|---------|---------|------------------|------------------|----------|
| vector | 动态数组 | O(1) | 均摊O(1) | 随机访问 |
| list | 双向链表 | O(n) | O(1) | 频繁插入删除 |
| deque | 双端队列 | O(1) | O(1) | 两端操作 |
| stack | 容器适配器 | - | O(1) | LIFO操作 |
| queue | 容器适配器 | - | O(1) | FIFO操作 |
| priority_queue | 堆 | - | O(log n) | 优先级处理 |
| set/map | 平衡树 | O(log n) | O(log n) | 有序集合 |
| unordered_set/map | 哈希表 | O(1) | O(1) | 快速查找 |

---

## 高级数据结构


### 树 (Tree)

**定义**
树是一种非线性的数据结构，它是由n（n≥0）个有限节点组成一个具有层次关系的集合。每个节点都可能有零个或多个子节点，没有父节点的节点称为根节点。

**存储原理**
- **层次结构**：数据元素之间存在着一对多的层次关系
- **根节点**：唯一没有前驱节点的节点
- **叶节点**：没有后继节点的节点
- **父子关系**：除了根节点外，每个节点都有且仅有一个父节点

**核心操作**

```cpp
// 二叉树节点定义
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// 二叉树遍历
// 前序遍历
void preorder(TreeNode* root) {
    if (!root) return;
    cout << root->val << " ";  // 访问根节点
    preorder(root->left);      // 遍历左子树
    preorder(root->right);     // 遍历右子树
}

// 中序遍历
void inorder(TreeNode* root) {
    if (!root) return;
    inorder(root->left);       // 遍历左子树
    cout << root->val << " ";  // 访问根节点
    inorder(root->right);      // 遍历右子树
}

// 后序遍历
void postorder(TreeNode* root) {
    if (!root) return;
    postorder(root->left);     // 遍历左子树
    postorder(root->right);    // 遍历右子树
    cout << root->val << " ";  // 访问根节点
}
```

```python
# Python实现
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

# 二叉树遍历
def preorder(root):
    if not root:
        return
    print(root.val, end=" ")  # 访问根节点
    preorder(root.left)       # 遍历左子树
    preorder(root.right)      # 遍历右子树

def inorder(root):
    if not root:
        return
    inorder(root.left)        # 遍历左子树
    print(root.val, end=" ")  # 访问根节点
    inorder(root.right)       # 遍历右子树

def postorder(root):
    if not root:
        return
    postorder(root.left)      # 遍历左子树
    postorder(root.right)     # 遍历右子树
    print(root.val, end=" ")  # 访问根节点
```

**复杂度分析**
| 操作 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| 遍历 | O(n) | O(h) |
| 查找 | O(h) | - |
| 插入 | O(h) | - |
| 删除 | O(h) | - |

*注：h为树的高度，平衡树h=log n*

**适用场景**
- 表示具有层级关系的数据
- 文件系统目录结构
- 组织架构图
- 表达式解析
- 决策树算法

---

### 堆 (Heap)

**定义**
堆是一种特殊的完全二叉树，其中每个节点的值都大于等于（最大堆）或小于等于（最小堆）其子节点的值。

**存储原理**
- **完全二叉树**：除最后一层外，其他层都被完全填满，最后一层从左到右填充
- **数组存储**：使用数组实现，对于索引为i的节点，其左子节点为2i+1，右子节点为2i+2
- **堆性质**：父节点与子节点满足特定的大小关系

**核心操作**

```cpp
class Heap {
private:
    vector<int> heap;

    // 上浮操作
    void heapifyUp(int index) {
        while (index > 0) {
            int parent = (index - 1) / 2;
            if (heap[parent] >= heap[index]) break;
            swap(heap[parent], heap[index]);
            index = parent;
        }
    }

    // 下沉操作
    void heapifyDown(int index) {
        int size = heap.size();
        while (true) {
            int largest = index;
            int left = 2 * index + 1;
            int right = 2 * index + 2;

            if (left < size && heap[left] > heap[largest])
                largest = left;
            if (right < size && heap[right] > heap[largest])
                largest = right;

            if (largest == index) break;
            swap(heap[index], heap[largest]);
            index = largest;
        }
    }

public:
    void push(int value) {
        heap.push_back(value);
        heapifyUp(heap.size() - 1);
    }

    void pop() {
        if (heap.empty()) return;
        heap[0] = heap.back();
        heap.pop_back();
        heapifyDown(0);
    }

    int top() {
        return heap.empty() ? -1 : heap[0];
    }

    bool empty() {
        return heap.empty();
    }
};

// STL堆使用
priority_queue<int> maxHeap;        // 最大堆
priority_queue<int, vector<int>, greater<int>> minHeap;  // 最小堆
maxHeap.push(3);                    // 插入元素
int top = maxHeap.top();            // 获取堆顶
maxHeap.pop();                      // 弹出堆顶
```

```python
# Python实现
import heapq

# Python的heapq模块实现最小堆
heap = []
heapq.heappush(heap, 3)             # 插入元素
top = heap[0]                       # 获取堆顶
heapq.heappop(heap)                 # 弹出堆顶

# 实现最大堆的方法
max_heap = []
heapq.heappush(max_heap, -3)        # 插入负值
top = -max_heap[0]                  # 获取堆顶（取反）
heapq.heappop(max_heap)             # 弹出堆顶（取反）
```

**复杂度分析**
| 操作 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| 插入 | O(log n) | O(1) |
| 删除 | O(log n) | O(1) |
| 查找极值 | O(1) | - |

**适用场景**
- 优先队列实现
- 堆排序算法
- Top K问题
- Dijkstra算法
- 哈夫曼编码

---

### 图 (Graph)

**定义**
图是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为G(V,E)，其中G表示图，V是图中顶点的集合，E是图中边的集合。

**存储原理**
- **邻接矩阵**：使用二维数组表示顶点间的关系
- **邻接表**：使用链表或动态数组存储每个顶点的邻居
- **边集数组**：使用数组存储所有的边

**核心操作**

```cpp
// 邻接表表示图
class Graph {
private:
    int vertices;
    vector<vector<int>> adjList;

public:
    Graph(int v) : vertices(v) {
        adjList.resize(v);
    }

    void addEdge(int u, int v) {
        adjList[u].push_back(v);
        adjList[v].push_back(u);  // 无向图
    }

    // 深度优先搜索
    void dfs(int start, vector<bool>& visited) {
        visited[start] = true;
        cout << start << " ";

        for (int neighbor : adjList[start]) {
            if (!visited[neighbor]) {
                dfs(neighbor, visited);
            }
        }
    }

    // 广度优先搜索
    void bfs(int start) {
        vector<bool> visited(vertices, false);
        queue<int> q;

        visited[start] = true;
        q.push(start);

        while (!q.empty()) {
            int node = q.front();
            q.pop();
            cout << node << " ";

            for (int neighbor : adjList[node]) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    q.push(neighbor);
                }
            }
        }
    }
};

// STL图使用
vector<vector<int>> graph(100);     // 创建邻接表
graph[0].push_back(1);              // 添加边
graph[1].push_back(0);              // 无向图
```

```python
# Python实现
from collections import defaultdict, deque

class Graph:
    def __init__(self):
        self.graph = defaultdict(list)

    def add_edge(self, u, v):
        self.graph[u].append(v)
        self.graph[v].append(u)  # 无向图

    # 深度优先搜索
    def dfs(self, start, visited=None):
        if visited is None:
            visited = set()
        visited.add(start)
        print(start, end=" ")

        for neighbor in self.graph[start]:
            if neighbor not in visited:
                self.dfs(neighbor, visited)

    # 广度优先搜索
    def bfs(self, start):
        visited = set()
        queue = deque([start])
        visited.add(start)

        while queue:
            node = queue.popleft()
            print(node, end=" ")

            for neighbor in self.graph[node]:
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append(neighbor)

# 使用字典表示图
graph = defaultdict(list)
graph[0].append(1)
graph[1].append(0)
```

**复杂度分析**
| 操作 | 邻接表 | 邻接矩阵 |
|------|--------|----------|
| 存储空间 | O(V+E) | O(V²) |
| 添加边 | O(1) | O(1) |
| 检查边 | O(degree) | O(1) |
| 遍历邻居 | O(degree) | O(V) |

**适用场景**
- 社交网络关系
- 路径规划导航
- 网络拓扑结构
- 任务依赖关系
- 推荐系统

::: info
- 邻接表适合稀疏图（边较少）
- 邻接矩阵适合稠密图（边较多）
- 图算法通常需要visited数组避免重复访问
:::

---


### 线段树 

**定义**
线段树是算法竞赛中常用的用来维护区间信息的数据结构，可以在O(log N)时间复杂度内实现单点修改、区间修改、区间查询等操作。

**存储原理**
- **堆式存储**：使用数组模拟完全二叉树结构
- **区间划分**：每个节点表示一个区间，父节点区间是子节点区间的并集
- **懒惰标记**：延迟区间修改操作，减少不必要计算

**核心操作**

```cpp
class SegmentTree {
private:
    vector<int> tree, lazy;  // 线段树数组和懒惰标记
    int n;

    void build(int node, int l, int r, const vector<int>& arr) {
        if (l == r) {
            tree[node] = arr[l];
            return;
        }
        int mid = (l + r) / 2;
        build(node * 2, l, mid, arr);
        build(node * 2 + 1, mid + 1, r, arr);
        tree[node] = tree[node * 2] + tree[node * 2 + 1];
    }

    void pushDown(int node, int l, int r) {
        if (lazy[node] != 0) {
            int mid = (l + r) / 2;
            tree[node * 2] += lazy[node] * (mid - l + 1);
            lazy[node * 2] += lazy[node];
            tree[node * 2 + 1] += lazy[node] * (r - mid);
            lazy[node * 2 + 1] += lazy[node];
            lazy[node] = 0;
        }
    }

    void update(int node, int l, int r, int ql, int qr, int val) {
        if (ql > r || qr < l) return;
        if (ql <= l && r <= qr) {
            tree[node] += val * (r - l + 1);
            lazy[node] += val;
            return;
        }
        pushDown(node, l, r);
        int mid = (l + r) / 2;
        update(node * 2, l, mid, ql, qr, val);
        update(node * 2 + 1, mid + 1, r, ql, qr, val);
        tree[node] = tree[node * 2] + tree[node * 2 + 1];
    }

    int query(int node, int l, int r, int ql, int qr) {
        if (ql > r || qr < l) return 0;
        if (ql <= l && r <= qr) return tree[node];
        pushDown(node, l, r);
        int mid = (l + r) / 2;
        return query(node * 2, l, mid, ql, qr) +
               query(node * 2 + 1, mid + 1, r, ql, qr);
    }

public:
    SegmentTree(const vector<int>& arr) {
        n = arr.size() - 1;  // 假设arr[0]不使用，从1开始
        tree.resize(4 * n);
        lazy.resize(4 * n, 0);
        build(1, 1, n, arr);
    }

    void update(int l, int r, int val) {
        update(1, 1, n, l, r, val);
    }

    int query(int l, int r) {
        return query(1, 1, n, l, r);
    }
};
```
```python
# Python实现
class SegmentTree:
    def __init__(self, arr):
        self.n = len(arr) - 1  # 假设arr[0]不使用
        self.tree = [0] * (4 * self.n)
        self.lazy = [0] * (4 * self.n)
        self.build(1, 1, self.n, arr)

    def build(self, node, l, r, arr):
        if l == r:
            self.tree[node] = arr[l]
            return
        mid = (l + r) // 2
        self.build(node * 2, l, mid, arr)
        self.build(node * 2 + 1, mid + 1, r, arr)
        self.tree[node] = self.tree[node * 2] + self.tree[node * 2 + 1]

    def push_down(self, node, l, r):
        if self.lazy[node] != 0:
            mid = (l + r) // 2
            self.tree[node * 2] += self.lazy[node] * (mid - l + 1)
            self.lazy[node * 2] += self.lazy[node]
            self.tree[node * 2 + 1] += self.lazy[node] * (r - mid)
            self.lazy[node * 2 + 1] += self.lazy[node]
            self.lazy[node] = 0

    def update(self, node, l, r, ql, qr, val):
        if ql > r or qr < l:
            return
        if ql <= l and r <= qr:
            self.tree[node] += val * (r - l + 1)
            self.lazy[node] += val
            return
        self.push_down(node, l, r)
        mid = (l + r) // 2
        self.update(node * 2, l, mid, ql, qr, val)
        self.update(node * 2 + 1, mid + 1, r, ql, qr, val)
        self.tree[node] = self.tree[node * 2] + self.tree[node * 2 + 1]

    def query(self, node, l, r, ql, qr):
        if ql > r or qr < l:
            return 0
        if ql <= l and r <= qr:
            return self.tree[node]
        self.push_down(node, l, r)
        mid = (l + r) // 2
        return self.query(node * 2, l, mid, ql, qr) + \
               self.query(node * 2 + 1, mid + 1, r, ql, qr)
```

**复杂度分析**
| 操作 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| 建树 | O(n) | O(n) |
| 区间查询 | O(log n) | - |
| 区间修改 | O(log n) | - |

**适用场景**
- 频繁的区间查询和修改操作
- 需要维护区间和、最大值、最小值等
- 区间最值操作与历史最值维护
- 离线算法中处理区间约束

---

### zkw线段树 

**定义**
zkw线段树是一种非递归的线段树实现，由张昆伟提出，具有常数更小、实现简单的特点。

**存储原理**
- **非递归实现**：使用迭代代替递归，减少函数调用开销
- **自底向上**：从叶子节点开始向上更新
- **完全二叉树**：利用完全二叉树的性质简化操作

**核心操作**

```cpp
class ZKWSegmentTree {
private:
    vector<int> tree;
    int M, n;

public:
    ZKWSegmentTree(int size) {
        n = size;
        M = 1;
        while (M < n + 2) M <<= 1;  // 计算合适的M值
        tree.assign(2 * M, 0);
    }

    void build(const vector<int>& arr) {
        // 建树：从叶子节点开始
        for (int i = 1; i <= n; i++) {
            tree[M + i] = arr[i];
        }
        // 向上更新
        for (int i = M - 1; i; i--) {
            tree[i] = tree[i << 1] + tree[i << 1 | 1];
        }
    }

    void update(int pos, int value) {
        // 修改：从叶子节点开始向上更新
        for (tree[pos += M] = value; pos > 1; pos >>= 1) {
            tree[pos >> 1] = tree[pos] + tree[pos ^ 1];
        }
    }

    int query(int l, int r) {
        // 查询：非递归实现
        int ans = 0;
        for (l += M, r += M + 1; l < r; l >>= 1, r >>= 1) {
            if (l & 1) ans += tree[l++];
            if (r & 1) ans += tree[--r];
        }
        return ans;
    }
};
```
```python
# Python实现
class ZKWSegmentTree:
    def __init__(self, size):
        self.n = size
        self.M = 1
        while self.M < size + 2:
            self.M <<= 1
        self.tree = [0] * (2 * self.M)

    def build(self, arr):
        # 建树：从叶子节点开始
        for i in range(1, self.n + 1):
            self.tree[self.M + i] = arr[i]
        # 向上更新
        for i in range(self.M - 1, 0, -1):
            self.tree[i] = self.tree[i << 1] + self.tree[i << 1 | 1]

    def update(self, pos, value):
        # 修改：从叶子节点开始向上更新
        pos += self.M
        self.tree[pos] = value
        while pos > 1:
            pos >>= 1
            self.tree[pos] = self.tree[pos << 1] + self.tree[pos << 1 | 1]

    def query(self, l, r):
        # 查询：非递归实现
        ans = 0
        l += self.M
        r += self.M + 1
        while l < r:
            if l & 1:
                ans += self.tree[l]
                l += 1
            if r & 1:
                r -= 1
                ans += self.tree[r]
            l >>= 1
            r >>= 1
        return ans
```

**复杂度分析**
| 操作 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| 建树 | O(n) | O(n) |
| 单点修改 | O(log n) | - |
| 区间查询 | O(log n) | - |

**优势与普通线段树对比**

| 特性 | 普通线段树 | zkw线段树 |
|------|------------|-----------|
| 实现方式 | 递归 | 非递归 |
| 常数大小 | 较大 | 较小 |
| 代码复杂度 | 较复杂 | 较简单 |
| 递归深度 | 可能栈溢出 | 无此问题 |
| 适用场景 | 复杂的线段树操作 | 简单的线段树操作 |

---

### 平衡树

**定义**
平衡树是一类自平衡的二叉搜索树，通过旋转等操作确保树的高度保持在O(log n)，从而保证各种操作的高效性。

**存储原理**
- **二叉搜索性质**：左子树节点小于根节点，右子树节点大于根节点
- **平衡维护**：通过旋转或其他操作保持树的平衡
- **高度控制**：确保树的高度不超过O(log n)

### Treap (树堆)

**核心操作**

```cpp
class Treap {
private:
    struct Node {
        int key, priority;
        Node *left, *right;
        Node(int k) : key(k), priority(rand()), left(nullptr), right(nullptr) {}
    };

    Node* root;

    // 右旋
    Node* rotateRight(Node* y) {
        Node* x = y->left;
        y->left = x->right;
        x->right = y;
        return x;
    }

    // 左旋
    Node* rotateLeft(Node* x) {
        Node* y = x->right;
        x->right = y->left;
        y->left = x;
        return y;
    }

    // 插入
    Node* insert(Node* node, int key) {
        if (!node) return new Node(key);

        if (key < node->key) {
            node->left = insert(node->left, key);
            if (node->left->priority > node->priority)
                node = rotateRight(node);
        } else {
            node->right = insert(node->right, key);
            if (node->right->priority > node->priority)
                node = rotateLeft(node);
        }
        return node;
    }

    // 删除
    Node* remove(Node* node, int key) {
        if (!node) return nullptr;

        if (key < node->key) {
            node->left = remove(node->left, key);
        } else if (key > node->key) {
            node->right = remove(node->right, key);
        } else {
            // 找到要删除的节点
            if (!node->left) return node->right;
            if (!node->right) return node->left;

            // 有两个子节点，旋转优先级较高的子节点
            if (node->left->priority > node->right->priority) {
                node = rotateRight(node);
                node->right = remove(node->right, key);
            } else {
                node = rotateLeft(node);
                node->left = remove(node->left, key);
            }
        }
        return node;
    }

    // 查找
    bool search(Node* node, int key) {
        if (!node) return false;
        if (key == node->key) return true;
        return key < node->key ? search(node->left, key) : search(node->right, key);
    }

public:
    Treap() : root(nullptr) {}

    void insert(int key) {
        root = insert(root, key);
    }

    void remove(int key) {
        root = remove(root, key);
    }

    bool search(int key) {
        return search(root, key);
    }
};
```

**复杂度分析**
| 操作 | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度 |
|------|----------------|----------------|------------|
| 插入 | O(log n) | O(n) | O(n) |
| 删除 | O(log n) | O(n) | - |
| 查找 | O(log n) | O(n) | - |

---

### 字典树 (Trie)

**定义**
字典树，又称前缀树，是一种专门用于处理字符串的树形数据结构，能够高效地存储和查找字符串集合。

**存储原理**
- **路径存储**：每个边代表一个字符，从根到节点的路径构成字符串
- **前缀共享**：具有相同前缀的字符串共享路径上的节点
- **标记终止**：使用特殊标记表示字符串的结束位置

**核心操作**

```cpp
class Trie {
private:
    struct TrieNode {
        TrieNode* children[26];
        bool isEnd;
        TrieNode() : isEnd(false) {
            for (int i = 0; i < 26; i++) {
                children[i] = nullptr;
            }
        }
    };

    TrieNode* root;

public:
    Trie() {
        root = new TrieNode();
    }

    void insert(string word) {
        TrieNode* curr = root;
        for (char c : word) {
            int index = c - 'a';
            if (!curr->children[index]) {
                curr->children[index] = new TrieNode();
            }
            curr = curr->children[index];
        }
        curr->isEnd = true;
    }

    bool search(string word) {
        TrieNode* curr = root;
        for (char c : word) {
            int index = c - 'a';
            if (!curr->children[index]) {
                return false;
            }
            curr = curr->children[index];
        }
        return curr->isEnd;
    }

    bool startsWith(string prefix) {
        TrieNode* curr = root;
        for (char c : prefix) {
            int index = c - 'a';
            if (!curr->children[index]) {
                return false;
            }
            curr = curr->children[index];
        }
        return true;
    }

    // 压位Trie优化：使用位压缩减少空间
    class CompressedTrie {
    private:
        struct Node {
            int children[4];  // 使用int存储位图
            bool isEnd;
            Node() : isEnd(false) {
                for (int i = 0; i < 4; i++) {
                    children[i] = -1;
                }
            }
        };

        vector<Node> nodes;
        int root;

        int getCharIndex(char c) {
            if ('a' <= c && c <= 'z') return 0;
            if ('A' <= c && c <= 'Z') return 1;
            if ('0' <= c && c <= '9') return 2;
            return 3;
        }

    public:
        CompressedTrie() {
            nodes.emplace_back();
            root = 0;
        }

        void insert(string word) {
            int curr = root;
            for (char c : word) {
                int idx = getCharIndex(c);
                if (nodes[curr].children[idx] == -1) {
                    nodes[curr].children[idx] = nodes.size();
                    nodes.emplace_back();
                }
                curr = nodes[curr].children[idx];
            }
            nodes[curr].isEnd = true;
        }
    };
};
```
```python
# Python实现
class Trie:
    class TrieNode:
        def __init__(self):
            self.children = {}
            self.is_end = False

    def __init__(self):
        self.root = self.TrieNode()

    def insert(self, word):
        curr = self.root
        for c in word:
            if c not in curr.children:
                curr.children[c] = self.TrieNode()
            curr = curr.children[c]
        curr.is_end = True

    def search(self, word):
        curr = self.root
        for c in word:
            if c not in curr.children:
                return False
            curr = curr.children[c]
        return curr.is_end

    def starts_with(self, prefix):
        curr = self.root
        for c in prefix:
            if c not in curr.children:
                return False
            curr = curr.children[c]
        return True
```

**复杂度分析**
| 操作 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| 插入 | O(m) | O(m) |
| 查找 | O(m) | - |
| 前缀查询 | O(m) | - |

*注：m为字符串长度*

---


### 可持久化线段树

**定义**
可持久化线段树能够保存历史版本，支持对历史版本的查询，通过共享不变部分来节省空间。

**存储原理**
- **版本管理**：每个操作生成新版本，旧版本保留
- **节点共享**：未修改的节点在多个版本间共享
- **动态创建**：只创建被修改的节点及其路径上的节点

**核心操作**

```cpp
class PersistentSegmentTree {
private:
    struct Node {
        int value;
        Node *left, *right;
        Node(int v = 0, Node* l = nullptr, Node* r = nullptr)
            : value(v), left(l), right(r) {}
    };

    vector<Node*> versions;  // 存储各个版本的根节点
    int n;

    Node* build(int l, int r) {
        if (l == r) return new Node(0);
        int mid = (l + r) / 2;
        return new Node(0, build(l, mid), build(mid + 1, r));
    }

    Node* update(Node* node, int l, int r, int pos, int val) {
        if (!node) node = new Node();
        if (l == r) {
            return new Node(node->value + val);
        }

        int mid = (l + r) / 2;
        Node* newNode = new Node();

        if (pos <= mid) {
            newNode->left = update(node->left, l, mid, pos, val);
            newNode->right = node->right;
        } else {
            newNode->left = node->left;
            newNode->right = update(node->right, mid + 1, r, pos, val);
        }

        newNode->value = (newNode->left ? newNode->left->value : 0) +
                         (newNode->right ? newNode->right->value : 0);
        return newNode;
    }

    int query(Node* node, int l, int r, int ql, int qr) {
        if (!node || ql > r || qr < l) return 0;
        if (ql <= l && r <= qr) return node->value;

        int mid = (l + r) / 2;
        return query(node->left, l, mid, ql, qr) +
               query(node->right, mid + 1, r, ql, qr);
    }

public:
    PersistentSegmentTree(int n) : n(n) {
        versions.push_back(build(1, n));  // 初始版本
    }

    void update(int version, int pos, int val) {
        Node* newRoot = update(versions[version], 1, n, pos, val);
        versions.push_back(newRoot);
    }

    int query(int version, int l, int r) {
        return query(versions[version], 1, n, l, r);
    }

    int getVersionCount() {
        return versions.size() - 1;
    }
};
```

**复杂度分析**
| 操作 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| 版本更新 | O(log n) | O(log n) |
| 历史查询 | O(log n) | - |
| 总空间消耗 | - | O(n + m log n) |

*注：m为操作次数*

**适用场景**
- 需要查询历史状态的场景
- 离线算法中的应用
- 函数式编程中的数据结构
- 区间第k小问题
