## 高级数据结构


### 树 (Tree)

**定义**
树是一种非线性的数据结构，它是由n（n≥0）个有限节点组成一个具有层次关系的集合。每个节点都可能有零个或多个子节点，没有父节点的节点称为根节点。

**存储原理**
- **层次结构**：数据元素之间存在着一对多的层次关系
- **根节点**：唯一没有前驱节点的节点
- **叶节点**：没有后继节点的节点
- **父子关系**：除了根节点外，每个节点都有且仅有一个父节点

**核心操作**
::: code-group

```cpp
// 二叉树节点定义
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// 前序遍历 - 递归
void preorderTraversal(TreeNode* root, vector<int>& result) {
    if (root) {
        result.push_back(root->val);
        preorderTraversal(root->left, result);
        preorderTraversal(root->right, result);
    }
}

// 中序遍历 - 递归
void inorderTraversal(TreeNode* root, vector<int>& result) {
    if (root) {
        inorderTraversal(root->left, result);
        result.push_back(root->val);
        inorderTraversal(root->right, result);
    }
}

// 后序遍历 - 递归
void postorderTraversal(TreeNode* root, vector<int>& result) {
    if (root) {
        postorderTraversal(root->left, result);
        postorderTraversal(root->right, result);
        result.push_back(root->val);
    }
}

// 层序遍历 - 使用队列
void levelOrderTraversal(TreeNode* root, vector<vector<int>>& result) {
    if (!root) return;
    
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        int levelSize = q.size();
        vector<int> currentLevel;
        
        for (int i = 0; i < levelSize; i++) {
            TreeNode* node = q.front();
            q.pop();
            currentLevel.push_back(node->val);
            
            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
        
        result.push_back(currentLevel);
    }
}
```
```python
# 二叉树节点定义
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
# 前序遍历 - 递归
def preorder_traversal(root):
    if not root:
        return []
    return [root.val] + preorder_traversal(root.left) + preorder_traversal(root.right)
# 中序遍历 - 递归
def inorder_traversal(root):
    if not root:
        return []
    return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right)
# 后序遍历 - 递归
def postorder_traversal(root):
    if not root:
        return []
    return postorder_traversal(root.left) + postorder_traversal(root.right) + [root.val]
# 层序遍历 - 使用队列
def level_order_traversal(root):
    if not root:
        return []
    
    from collections import deque
    q = deque([root])
    result = []
    
    while q:
        level_size = len(q)
        current_level = []
        
        for _ in range(level_size):
            node = q.popleft()
            current_level.append(node.val)
            
            if node.left:
                q.append(node.left)
            if node.right:
                q.append(node.right)
        
        result.append(current_level)
    
    return result
```
:::
**复杂度分析**
| 操作 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| 遍历 | O(n) | O(h) |
| 查找 | O(h) | - |
| 插入 | O(h) | - |
| 删除 | O(h) | - |

*注：h为树的高度，平衡树h=log n*

**适用场景**
- 表示具有层级关系的数据
- 文件系统目录结构
- 组织架构图
- 表达式解析
- 决策树算法

---

### 堆 (Heap)

**定义**
堆是一种特殊的完全二叉树，其中每个节点的值都大于等于（最大堆）或小于等于（最小堆）其子节点的值。

**存储原理**
- **完全二叉树**：除最后一层外，其他层都被完全填满，最后一层从左到右填充
- **数组存储**：使用数组实现，对于索引为i的节点，其左子节点为2i+1，右子节点为2i+2
- **堆性质**：父节点与子节点满足特定的大小关系

**核心操作**
::: code-group
```cpp
class Heap {
private:
    vector<int> heap;

    // 上浮操作
    void heapifyUp(int index) {
        while (index > 0) {
            int parent = (index - 1) / 2;
            if (heap[parent] >= heap[index]) break;
            swap(heap[parent], heap[index]);
            index = parent;
        }
    }

    // 下沉操作
    void heapifyDown(int index) {
        int size = heap.size();
        while (true) {
            int largest = index;
            int left = 2 * index + 1;
            int right = 2 * index + 2;

            if (left < size && heap[left] > heap[largest])
                largest = left;
            if (right < size && heap[right] > heap[largest])
                largest = right;

            if (largest == index) break;
            swap(heap[index], heap[largest]);
            index = largest;
        }
    }

public:
    void push(int value) {
        heap.push_back(value);
        heapifyUp(heap.size() - 1);
    }

    void pop() {
        if (heap.empty()) return;
        heap[0] = heap.back();
        heap.pop_back();
        heapifyDown(0);
    }

    int top() {
        return heap.empty() ? -1 : heap[0];
    }

    bool empty() {
        return heap.empty();
    }
};

// STL堆使用
priority_queue<int> maxHeap;        // 最大堆
priority_queue<int, vector<int>, greater<int>> minHeap;  // 最小堆
maxHeap.push(3);                    // 插入元素
int top = maxHeap.top();            // 获取堆顶
maxHeap.pop();                      // 弹出堆顶
```

```python
# Python实现
import heapq

# Python的heapq模块实现最小堆
heap = []
heapq.heappush(heap, 3)             # 插入元素
top = heap[0]                       # 获取堆顶
heapq.heappop(heap)                 # 弹出堆顶

# 实现最大堆的方法
max_heap = []
heapq.heappush(max_heap, -3)        # 插入负值
top = -max_heap[0]                  # 获取堆顶（取反）
heapq.heappop(max_heap)             # 弹出堆顶（取反）
```
:::
**复杂度分析**
| 操作 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| 插入 | O(log n) | O(1) |
| 删除 | O(log n) | O(1) |
| 查找极值 | O(1) | - |

**适用场景**
- 优先队列实现
- 堆排序算法
- Top K问题
- Dijkstra算法
- 哈夫曼编码

---

### 图 (Graph)

**定义**
图是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为G(V,E)，其中G表示图，V是图中顶点的集合，E是图中边的集合。

**存储原理**
- **邻接矩阵**：使用二维数组表示顶点间的关系
- **邻接表**：使用链表或动态数组存储每个顶点的邻居
- **边集数组**：使用数组存储所有的边

**核心操作**
::: code-group
```cpp
// 邻接表表示图
class Graph {
private:
    int vertices;
    vector<vector<int>> adjList;

public:
    Graph(int v) : vertices(v) {
        adjList.resize(v);
    }

    void addEdge(int u, int v) {
        adjList[u].push_back(v);
        adjList[v].push_back(u);  // 无向图
    }

    // 深度优先搜索
    void dfs(int start, vector<bool>& visited) {
        visited[start] = true;
        cout << start << " ";

        for (int neighbor : adjList[start]) {
            if (!visited[neighbor]) {
                dfs(neighbor, visited);
            }
        }
    }

    // 广度优先搜索
    void bfs(int start) {
        vector<bool> visited(vertices, false);
        queue<int> q;

        visited[start] = true;
        q.push(start);

        while (!q.empty()) {
            int node = q.front();
            q.pop();
            cout << node << " ";

            for (int neighbor : adjList[node]) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    q.push(neighbor);
                }
            }
        }
    }
};

// STL图使用
vector<vector<int>> graph(100);     // 创建邻接表
graph[0].push_back(1);              // 添加边
graph[1].push_back(0);              // 无向图
```

```python
# Python实现
from collections import defaultdict, deque

class Graph:
    def __init__(self):
        self.graph = defaultdict(list)

    def add_edge(self, u, v):
        self.graph[u].append(v)
        self.graph[v].append(u)  # 无向图

    # 深度优先搜索
    def dfs(self, start, visited=None):
        if visited is None:
            visited = set()
        visited.add(start)
        print(start, end=" ")

        for neighbor in self.graph[start]:
            if neighbor not in visited:
                self.dfs(neighbor, visited)

    # 广度优先搜索
    def bfs(self, start):
        visited = set()
        queue = deque([start])
        visited.add(start)

        while queue:
            node = queue.popleft()
            print(node, end=" ")

            for neighbor in self.graph[node]:
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append(neighbor)


# 使用字典表示图
graph = defaultdict(list)
graph[0].append(1)
graph[1].append(0)
```
:::

#### Dijkstra算法
::: code-group
```cpp
vector<int> dijkstra(int n, int start, const vector<vector<pair<int, int>>>& graph) {
    vector<int> dist(n + 1, INT_MAX);
    vector<bool> visited(n + 1, false);
    dist[start] = 0;
    
    // 使用优先队列优化
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    pq.push({0, start});
    
    while (!pq.empty()) {
        int u = pq.top().second;
        int d = pq.top().first;
        pq.pop();
        
        if (visited[u]) continue;
        visited[u] = true;
        
        for (const auto& edge : graph[u]) {
            int v = edge.first;
            int weight = edge.second;
            
            if (!visited[v] && dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
                pq.push({dist[v], v});
            }
        }
    }
    
    return dist;
}
```


```python
def dijkstra(n, start, graph):
    import heapq
    dist = [float('inf')] * (n + 1)
    dist[start] = 0
    visited = [False] * (n + 1)
    
    heap = [(0, start)]
    
    while heap:
        d, u = heapq.heappop(heap)
        
        if visited[u]:
            continue
        
        visited[u] = True
        
        for v, weight in graph[u]:
            if not visited[v] and dist[u] + weight < dist[v]:
                dist[v] = dist[u] + weight
                heapq.heappush(heap, (dist[v], v))
    
    return dist
```
:::

**复杂度分析**
| 操作 | 邻接表 | 邻接矩阵 |
|------|--------|----------|
| 存储空间 | O(V+E) | O(V²) |
| 添加边 | O(1) | O(1) |
| 检查边 | O(degree) | O(1) |
| 遍历邻居 | O(degree) | O(V) |

**适用场景**
- 社交网络关系
- 路径规划导航
- 网络拓扑结构
- 任务依赖关系
- 推荐系统

::: info
- 邻接表适合稀疏图（边较少）
- 邻接矩阵适合稠密图（边较多）
- 图算法通常需要visited数组避免重复访问
:::

---





### 位集（Bitset）

**核心思想**：集合可以用二进制表示，二进制从低到高第i位为1表示i在集合中

**转换公式**：$( f(S) = \sum_{i∈S} 2^i )$

**示例**：
- 集合$\{0,2,3\}$ → $2^0$ + $2^2$ + $2^3$ = $13$ → 二进制$1101_2$

**Bitset表示规则**：
- 用n位二进制数表示集合
- 若元素 $(a_i)$ 在集合中，第$i$位为1；否则为0  

**示例表示**：
```Plain Text
集合  A = {0, 2, 3, 5}  
Bitset表示（8位）：00101101  
0 0 1 0 1 1 0 1
↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑
7 6 5 4 3 2 1 0

解释：
- 位置0: 1 → 元素0在集合中
- 位置1: 0 → 元素1不在集合中
- 位置2: 1 → 元素2在集合中
- 位置3: 1 → 元素3在集合中
- 位置4: 0 → 元素4不在集合中
- 位置5: 1 → 元素5在集合中
- 位置6: 0 → 元素6不在集合中
- 位置7: 0 → 元素7不在集合中
```

**集合与集合的运算**

| 术语       | 集合       | 位运算       | 集合示例                     | 位运算示例                 |
|------------|------------|--------------|------------------------------|----------------------------|
| 交集       | $A \cap B$ | $a \& b$     | $\{0,2,3\} \cap \{0,1,2\} = \{0,2\}$ | $1101 \& 0111 = 0101$      |
| 并集       | $A \cup B$ | $a \mid b$   | $\{0,2,3\} \cup \{0,1,2\} = \{0,1,2,3\}$ | $1101 \mid 0111 = 1111$    |
| 对称差     | $A \Delta B$ | $a \oplus b$ | $\{0,2,3\} \Delta \{0,1,2\} = \{1,3\}$ | $1101 \oplus 0111 = 1010$  |
| 差         | $A \setminus B$ | $a \& \sim b$ | $\{0,2,3\} \setminus \{1,2\} = \{0,3\}$ | $1101 \& 1001 = 1001$      |
| 差（子集） | $A \setminus B, B \subseteq A$ | $a \oplus b$ | $\{0,2,3\} \setminus \{0,2\} = \{3\}$ | $1101 \oplus 0101 = 1000$  |
| 包含于     | $A \subseteq B$ | $a \& b = a$<br>$a \mid b = b$ | $\{0,2\} \subseteq \{0,2,3\}$ | $0101 \& 1101 = 0101$<br>$0101 \mid 1101 = 1101$ |

**集合与元素的运算**

| 术语                     | 集合                     | 位运算                     | 集合示例                     | 位运算示例                     |
|--------------------------|--------------------------|----------------------------|------------------------------|--------------------------------|
| 空集                     | $\varnothing$            | $0$                        |                              |                                |
| 单元素集合               | $\{i\}$                  | $1 << i$                   | $\{2\}$                      | $1 << 2$                       |
| 全集                     | $U = \{0,1,2,\dots,n-1\}$ | $(1 << n) - 1$             | $\{0,1,2,3\}$                | $(1 << 4) - 1$                 |
| 补集                     | $\complement_U S = U \setminus S$ | $((1 << n) - 1) \oplus s$ | $U=\{0,1,2,3\}\\\complement_U \{1,2\}=\{0,3\}$ | $1111 \oplus 0110 = 1001$      |
| 属于                     | $i \in S$                | $(s >> i) \& 1 = 1$        | $2 \in \{0,2,3\}$            | $(1101 >> 2) \& 1 = 1$         |
| 不属于                   | $i \notin S$             | $(s >> i) \& 1 = 0$        | $1 \notin \{0,2,3\}$         | $(1101 >> 1) \& 1 = 0$         |
| 添加元素                 | $S \cup \{i\}$           | $s \mid (1 << i)$          | $\{0,3\} \cup \{2\}$         | $1001 \mid (1 << 2)$           |
| 删除元素                 | $S \setminus \{i\}$      | $s \& \sim (1 << i)$       | $\{0,2,3\} \setminus \{2\}$  | $1101 \& \sim (1 << 2)$        |
| 删除元素（一定在集合中） | $S \setminus \{i\}, i \in S$ | $s \oplus (1 << i)$       | $\{0,2,3\} \setminus \{2\}$  | $1101 \oplus (1 << 2)$         |


**具体操作实现**

**遍历集合**
```python
# 设元素范围从 0 到 n−1，枚举范围中的元素 i，判断 i 是否在集合 s 中。
for i in range(n):
    if (s >> i) & 1:  # i 在 s 中
        # 处理 i 的逻辑
```
**枚举所有集合**

```python
# 设元素范围从 0 到 n−1，从空集 ∅ 枚举到全集 U：
for s in range(1 << n):
    # 处理 s 的逻辑
```

**成员检查（Contains）**
```python
def contains(self, element):
    # 检查第element位是否为1
    return (self.bits >> element) & 1 == 1

# 示例：
# 集合A: 00101101
# 检查元素3: (00101101 >> 3) & 1 = 1 → True
# 检查元素4: (00101101 >> 4) & 1 = 0 → False
```

**添加元素（Add）**
```python
def add(self, element):
    # 将第element位设为1
    self.bits |= (1 << element)

# 示例：
# 初始：00101101（包含{0,2,3,5}）
# 添加元素4：00101101 | 00010000 = 00111101
# 结果：00111101（现在包含{0,2,3,4,5}）
```

**移除元素（Remove）**
```python
def remove(self, element):
    # 将第element位设为0
    self.bits &= ~(1 << element)

# 示例：
# 初始：00111101（包含{0,2,3,4,5}）
# 移除元素3：00111101 & 11110111 = 00110101
# 结果：00110101（现在包含{0,2,4,5}）
```

**清空集合（Clear）**
```python
def clear(self):
    self.bits = 0  # 所有位设为0
```

**并集（Union）**
```python
def union(self, other):
    # 按位或运算
    return Bitset(self.bits | other.bits)

# 示例：
# A = {0,2,3,5} → 00101101
# B = {1,3,4,6} → 01011010
# A ∪ B = {0,1,2,3,4,5,6} → 01111111
# 计算：00101101 | 01011010 = 01111111
```

**交集（Intersection）**
```python
def intersection(self, other):
    # 按位与运算
    return Bitset(self.bits & other.bits)

# 示例：
# A = {0,2,3,5} → 00101101
# B = {1,3,4,6} → 01011010
# A ∩ B = {3} → 00001000
# 计算：00101101 & 01011010 = 00001000
```

**差集（Difference）**
```python
def difference(self, other):
    # A & (~B)
    return Bitset(self.bits & ~other.bits)

# 示例：
# A = {0,2,3,5} → 00101101
# B = {1,3,4,6} → 01011010
# A - B = {0,2,5} → 00100101
# 计算：00101101 & 10100101 = 00100101
```

**对称差（Symmetric Difference）**
```python
def symmetric_difference(self, other):
    # 按位异或运算
    return Bitset(self.bits ^ other.bits)

# 示例：
# A = {0,2,3,5} → 00101101
# B = {1,3,4,6} → 01011010
# A Δ B = {0,1,2,4,5,6} → 01110111
# 计算：00101101 ^ 01011010 = 01110111
```


### 线段树 (Segment Tree)

**核心思想**：把数组划分成多个小区间，预处理并存储这些区间信息，实现快速区间查询和更新。

**直观比喻**
想象你要管理一家公司的月度销售额：
原始数据：1月-12月的销售额数组
你想快速回答："第一季度（1-3月）总销售额是多少？"
也经常需要更新某个月的销售额

线段树的做法：

1. 把1-12月分成更小的区间
2. 提前计算好每个区间的总和并存储
3. 查询时，只需组合几个预先计算好的区间结果
   
```text
原始数组：[1, 3, 5, 7, 9, 11]
索引：     0  1  2  3  4  5

构建的线段树（存储区间和）：
                      [0-5]: 36
                     /       \
             [0-2]: 9        [3-5]: 27
            /      \         /      \
      [0-1]: 4   [2-2]:5  [3-4]:16  [5-5]:11
     /     \
[0-0]:1 [1-1]:3
```

**关键特点**  
**二叉树结构**：每个节点代表一个区间  
**存储聚合信息**：区间和、最大值、最小值等  

**时间复杂度**：  
1. 构建：O(n)
2. 区间查询：O(log n)
3. 单点更新：O(log n)
4. 区间更新（带懒标记）：O(log n)

**核心操作**
::: code-group
```cpp
#include <iostream>
#include <vector>
#include <cmath>
#include <climits>
using namespace std;

class SegmentTree {
private:
    vector<int> tree;      // 线段树数组
    vector<int> lazy;      // 懒标记数组
    vector<int> data;      // 原始数据（可选）
    int n;                 // 原始数据大小
    
    // 构建线段树
    void build(int node, int left, int right) {
        if (left == right) {
            tree[node] = data[left];
            return;
        }
        
        int mid = (left + right) / 2;
        int leftChild = 2 * node + 1;
        int rightChild = 2 * node + 2;
        
        build(leftChild, left, mid);
        build(rightChild, mid + 1, right);
        
        tree[node] = tree[leftChild] + tree[rightChild];
    }
    
    // 区间查询
    int query(int node, int left, int right, int ql, int qr) {
        // 当前区间完全在查询区间内
        if (ql <= left && right <= qr) {
            return tree[node];
        }
        
        // 当前区间与查询区间无交集
        if (right < ql || left > qr) {
            return 0;
        }
        
        // 部分重叠，递归查询
        int mid = (left + right) / 2;
        int leftChild = 2 * node + 1;
        int rightChild = 2 * node + 2;
        
        int leftSum = query(leftChild, left, mid, ql, qr);
        int rightSum = query(rightChild, mid + 1, right, ql, qr);
        
        return leftSum + rightSum;
    }
    
    // 单点更新
    void updatePoint(int node, int left, int right, int index, int value) {
        if (left == right) {
            tree[node] = value;
            return;
        }
        
        int mid = (left + right) / 2;
        int leftChild = 2 * node + 1;
        int rightChild = 2 * node + 2;
        
        if (index <= mid) {
            updatePoint(leftChild, left, mid, index, value);
        } else {
            updatePoint(rightChild, mid + 1, right, index, value);
        }
        
        tree[node] = tree[leftChild] + tree[rightChild];
    }
    
    // 带懒标记的区间更新
    void updateRangeLazy(int node, int left, int right, int ul, int ur, int value) {
        int leftChild = 2 * node + 1;
        int rightChild = 2 * node + 2;
        
        // 下推懒标记
        if (lazy[node] != 0) {
            tree[node] += lazy[node] * (right - left + 1);
            if (left != right) {
                lazy[leftChild] += lazy[node];
                lazy[rightChild] += lazy[node];
            }
            lazy[node] = 0;
        }
        
        // 当前区间完全在更新区间外
        if (right < ul || left > ur) {
            return;
        }
        
        // 当前区间完全在更新区间内
        if (ul <= left && right <= ur) {
            tree[node] += value * (right - left + 1);
            if (left != right) {
                lazy[leftChild] += value;
                lazy[rightChild] += value;
            }
            return;
        }
        
        // 部分重叠，递归更新
        int mid = (left + right) / 2;
        updateRangeLazy(leftChild, left, mid, ul, ur, value);
        updateRangeLazy(rightChild, mid + 1, right, ul, ur, value);
        
        tree[node] = tree[leftChild] + tree[rightChild];
    }
    
    // 带懒标记的区间查询
    int queryRangeLazy(int node, int left, int right, int ql, int qr) {
        int leftChild = 2 * node + 1;
        int rightChild = 2 * node + 2;
        
        // 下推懒标记
        if (lazy[node] != 0) {
            tree[node] += lazy[node] * (right - left + 1);
            if (left != right) {
                lazy[leftChild] += lazy[node];
                lazy[rightChild] += lazy[node];
            }
            lazy[node] = 0;
        }
        
        // 当前区间完全在查询区间内
        if (ql <= left && right <= qr) {
            return tree[node];
        }
        
        // 当前区间与查询区间无交集
        if (right < ql || left > qr) {
            return 0;
        }
        
        // 部分重叠，递归查询
        int mid = (left + right) / 2;
        int leftSum = queryRangeLazy(leftChild, left, mid, ql, qr);
        int rightSum = queryRangeLazy(rightChild, mid + 1, right, ql, qr);
        
        return leftSum + rightSum;
    }
    
public:
    // 构造函数
    SegmentTree(const vector<int>& nums) {
        data = nums;
        n = nums.size();
        tree.resize(4 * n);
        lazy.resize(4 * n, 0);
        build(0, 0, n - 1);
    }
    
    // 区间查询接口
    int rangeQuery(int left, int right) {
        if (left < 0 || right >= n || left > right) {
            throw out_of_range("查询区间非法");
        }
        return query(0, 0, n - 1, left, right);
    }
    
    // 单点更新接口
    void pointUpdate(int index, int value) {
        if (index < 0 || index >= n) {
            throw out_of_range("索引越界");
        }
        updatePoint(0, 0, n - 1, index, value);
    }
    
    // 区间更新接口（带懒标记）
    void rangeUpdate(int left, int right, int value) {
        if (left < 0 || right >= n || left > right) {
            throw out_of_range("更新区间非法");
        }
        updateRangeLazy(0, 0, n - 1, left, right, value);
    }
    
    // 带懒标记的区间查询接口
    int rangeQueryLazy(int left, int right) {
        if (left < 0 || right >= n || left > right) {
            throw out_of_range("查询区间非法");
        }
        return queryRangeLazy(0, 0, n - 1, left, right);
    }
    
    // 打印线段树（调试用）
    void printTree() {
        cout << "线段树数组: ";
        for (int i = 0; i < tree.size(); i++) {
            cout << tree[i] << " ";
        }
        cout << endl;
    }
    
    // 获取原始数组当前状态（考虑懒标记）
    vector<int> getCurrentArray() {
        vector<int> result(n);
        for (int i = 0; i < n; i++) {
            result[i] = rangeQueryLazy(i, i);
        }
        return result;
    }
};

// 使用示例
int main() {
    cout << "=== 线段树示例程序 ===" << endl;
    
    // 1. 创建线段树
    vector<int> arr = {1, 3, 5, 7, 9, 11};
    SegmentTree segTree(arr);
    
    cout << "\n原始数组: ";
    for (int num : arr) cout << num << " ";
    cout << endl;
    
    // 2. 区间查询测试
    cout << "\n--- 区间查询测试 ---" << endl;
    cout << "查询[0,2]的和: " << segTree.rangeQuery(0, 2) << endl;  // 9
    cout << "查询[2,4]的和: " << segTree.rangeQuery(2, 4) << endl;  // 21
    cout << "查询[1,3]的和: " << segTree.rangeQuery(1, 3) << endl;  // 15
    
    // 3. 单点更新测试
    cout << "\n--- 单点更新测试 ---" << endl;
    segTree.pointUpdate(2, 10);
    cout << "将索引2的值从5改为10" << endl;
    cout << "更新后查询[0,2]的和: " << segTree.rangeQuery(0, 2) << endl;  // 14
    
    // 4. 区间更新测试（带懒标记）
    cout << "\n--- 区间更新测试（带懒标记） ---" << endl;
    SegmentTree segTreeLazy(arr);  // 重新创建
    
    cout << "更新前数组: ";
    vector<int> before = segTreeLazy.getCurrentArray();
    for (int num : before) cout << num << " ";
    cout << endl;
    
    // 将索引1-4的值都加5
    segTreeLazy.rangeUpdate(1, 4, 5);
    
    cout << "将区间[1,4]的值都增加5" << endl;
    
    cout << "更新后数组: ";
    vector<int> after = segTreeLazy.getCurrentArray();
    for (int num : after) cout << num << " ";
    cout << endl;
    
    cout << "更新后查询[1,4]的和: " << segTreeLazy.rangeQueryLazy(1, 4) << endl;
    
    // 5. 动态查询示例
    cout << "\n--- 动态操作示例 ---" << endl;
    SegmentTree dynamicTree({2, 4, 6, 8, 10});
    
    cout << "初始数组: ";
    for (int num : dynamicTree.getCurrentArray()) cout << num << " ";
    cout << endl;
    
    cout << "[0,3]的和: " << dynamicTree.rangeQuery(0, 3) << endl;
    
    dynamicTree.pointUpdate(1, 10);
    cout << "更新索引1为10后，[0,3]的和: " << dynamicTree.rangeQuery(0, 3) << endl;
    
    dynamicTree.rangeUpdate(2, 4, 3);
    cout << "区间[2,4]增加3后，[0,4]的和: " << dynamicTree.rangeQueryLazy(0, 4) << endl;
    
    return 0;
}
```
```python
class SegmentTree:
    """线段树实现（区间和查询）"""
    
    def __init__(self, data):
        """
        初始化线段树
        :param data: 原始数据数组
        """
        self.n = len(data)
        self.data = data
        self.tree = [0] * (4 * self.n)  # 4倍空间保证足够
        self.lazy = [0] * (4 * self.n)  # 懒标记数组（用于区间更新）
        self._build(0, 0, self.n - 1)
    
    def _build(self, node, left, right):
        """构建线段树"""
        if left == right:
            # 叶子节点，存储原始数据
            self.tree[node] = self.data[left]
            return
        
        mid = (left + right) // 2
        left_child = 2 * node + 1
        right_child = 2 * node + 2
        
        # 递归构建左右子树
        self._build(left_child, left, mid)
        self._build(right_child, mid + 1, right)
        
        # 当前节点存储左右子树的和
        self.tree[node] = self.tree[left_child] + self.tree[right_child]
    
    def query(self, ql, qr):
        """
        查询区间[ql, qr]的和
        """
        return self._query(0, 0, self.n - 1, ql, qr)
    
    def _query(self, node, left, right, ql, qr):
        """递归查询实现"""
        # 1. 如果当前区间完全在查询区间内，直接返回
        if ql <= left and right <= qr:
            return self.tree[node]
        
        # 2. 如果当前区间与查询区间没有交集，返回0
        if right < ql or left > qr:
            return 0
        
        # 3. 部分重叠，递归查询左右子树
        mid = (left + right) // 2
        left_child = 2 * node + 1
        right_child = 2 * node + 2
        
        left_sum = self._query(left_child, left, mid, ql, qr)
        right_sum = self._query(right_child, mid + 1, right, ql, qr)
        
        return left_sum + right_sum
    
    def update_point(self, index, value):
        """
        单点更新：将index位置的值更新为value
        """
        self._update_point(0, 0, self.n - 1, index, value)
    
    def _update_point(self, node, left, right, index, value):
        """递归单点更新实现"""
        if left == right:
            # 找到目标叶子节点
            self.tree[node] = value
            return
        
        mid = (left + right) // 2
        left_child = 2 * node + 1
        right_child = 2 * node + 2
        
        if index <= mid:
            # 目标在左子树
            self._update_point(left_child, left, mid, index, value)
        else:
            # 目标在右子树
            self._update_point(right_child, mid + 1, right, index, value)
        
        # 更新当前节点的值
        self.tree[node] = self.tree[left_child] + self.tree[right_child]
    
    def update_range(self, ul, ur, value):
        """
        区间更新：将区间[ul, ur]的所有值增加value
        使用懒标记优化
        """
        self._update_range(0, 0, self.n - 1, ul, ur, value)
    
    def _update_range(self, node, left, right, ul, ur, value):
        """带懒标记的区间更新实现"""
        left_child = 2 * node + 1
        right_child = 2 * node + 2
        
        # 1. 下推懒标记
        if self.lazy[node] != 0:
            self.tree[node] += self.lazy[node] * (right - left + 1)
            if left != right:  # 非叶子节点
                self.lazy[left_child] += self.lazy[node]
                self.lazy[right_child] += self.lazy[node]
            self.lazy[node] = 0
        
        # 2. 如果当前区间完全在更新区间外，直接返回
        if right < ul or left > ur:
            return
        
        # 3. 如果当前区间完全在更新区间内，更新并设置懒标记
        if ul <= left and right <= ur:
            self.tree[node] += value * (right - left + 1)
            if left != right:  # 非叶子节点
                self.lazy[left_child] += value
                self.lazy[right_child] += value
            return
        
        # 4. 部分重叠，递归更新左右子树
        mid = (left + right) // 2
        self._update_range(left_child, left, mid, ul, ur, value)
        self._update_range(right_child, mid + 1, right, ul, ur, value)
        
        # 5. 更新当前节点
        self.tree[node] = self.tree[left_child] + self.tree[right_child]
    
    def query_range_lazy(self, ql, qr):
        """带懒标记的区间查询"""
        return self._query_range_lazy(0, 0, self.n - 1, ql, qr)
    
    def _query_range_lazy(self, node, left, right, ql, qr):
        """带懒标记的查询实现"""
        left_child = 2 * node + 1
        right_child = 2 * node + 2
        
        # 1. 下推懒标记
        if self.lazy[node] != 0:
            self.tree[node] += self.lazy[node] * (right - left + 1)
            if left != right:  # 非叶子节点
                self.lazy[left_child] += self.lazy[node]
                self.lazy[right_child] += self.lazy[node]
            self.lazy[node] = 0
        
        # 2. 如果当前区间完全在查询区间内，直接返回
        if ql <= left and right <= qr:
            return self.tree[node]
        
        # 3. 如果当前区间与查询区间没有交集，返回0
        if right < ql or left > qr:
            return 0
        
        # 4. 部分重叠，递归查询
        mid = (left + right) // 2
        left_sum = self._query_range_lazy(left_child, left, mid, ql, qr)
        right_sum = self._query_range_lazy(right_child, mid + 1, right, ql, qr)
        
        return left_sum + right_sum


# 使用示例
if __name__ == "__main__":
    # 创建线段树
    arr = [1, 3, 5, 7, 9, 11]
    seg_tree = SegmentTree(arr)
    
    print("原始数组:", arr)
    print("线段树结构（简化）:", seg_tree.tree[:15])
    
    # 区间查询测试
    print("\n--- 区间查询测试 ---")
    print("查询[0,2]的和:", seg_tree.query(0, 2))  # 1+3+5=9
    print("查询[2,4]的和:", seg_tree.query(2, 4))  # 5+7+9=21
    print("查询[1,3]的和:", seg_tree.query(1, 3))  # 3+5+7=15
    
    # 单点更新测试
    print("\n--- 单点更新测试 ---")
    seg_tree.update_point(2, 10)  # 将索引2的值从5改为10
    print("更新后查询[0,2]的和:", seg_tree.query(0, 2))  # 1+3+10=14
    
    # 区间更新测试（带懒标记）
    print("\n--- 区间更新测试 ---")
    seg_tree2 = SegmentTree([1, 3, 5, 7, 9, 11])
    seg_tree2.update_range(1, 4, 5)  # 索引1-4的值都加5
    print("区间更新后数组（懒标记实现）:")
    for i in range(6):
        print(f"索引{i}: {seg_tree2.query(i, i)}", end="  ")
    print()
    print("更新后查询[1,4]的和:", seg_tree2.query_range_lazy(1, 4))
```
:::


**适用场景**
- 频繁的区间查询和修改操作
- 需要维护区间和、最大值、最小值等
- 区间最值操作与历史最值维护
- 离线算法中处理区间约束

---



### 平衡树 (Balanced Tree)

**定义**
平衡树是一类自平衡的二叉搜索树，通过旋转等操作确保树的高度保持在O(log n)，从而保证各种操作的高效性。

**存储原理**
- **二叉搜索性质**：左子树节点小于根节点，右子树节点大于根节点
- **平衡维护**：通过旋转或其他操作保持树的平衡
- **高度控制**：确保树的高度不超过O(log n)

###  树堆(Treap)

**核心操作**
::: code-group
```cpp
class Treap {
private:
    struct Node {
        int key, priority;
        Node *left, *right;
        Node(int k) : key(k), priority(rand()), left(nullptr), right(nullptr) {}
    };

    Node* root;

    // 右旋
    Node* rotateRight(Node* y) {
        Node* x = y->left;
        y->left = x->right;
        x->right = y;
        return x;
    }

    // 左旋
    Node* rotateLeft(Node* x) {
        Node* y = x->right;
        x->right = y->left;
        y->left = x;
        return y;
    }

    // 插入
    Node* insert(Node* node, int key) {
        if (!node) return new Node(key);

        if (key < node->key) {
            node->left = insert(node->left, key);
            if (node->left->priority > node->priority)
                node = rotateRight(node);
        } else {
            node->right = insert(node->right, key);
            if (node->right->priority > node->priority)
                node = rotateLeft(node);
        }
        return node;
    }

    // 删除
    Node* remove(Node* node, int key) {
        if (!node) return nullptr;

        if (key < node->key) {
            node->left = remove(node->left, key);
        } else if (key > node->key) {
            node->right = remove(node->right, key);
        } else {
            // 找到要删除的节点
            if (!node->left) return node->right;
            if (!node->right) return node->left;

            // 有两个子节点，旋转优先级较高的子节点
            if (node->left->priority > node->right->priority) {
                node = rotateRight(node);
                node->right = remove(node->right, key);
            } else {
                node = rotateLeft(node);
                node->left = remove(node->left, key);
            }
        }
        return node;
    }

    // 查找
    bool search(Node* node, int key) {
        if (!node) return false;
        if (key == node->key) return true;
        return key < node->key ? search(node->left, key) : search(node->right, key);
    }

public:
    Treap() : root(nullptr) {}

    void insert(int key) {
        root = insert(root, key);
    }

    void remove(int key) {
        root = remove(root, key);
    }

    bool search(int key) {
        return search(root, key);
    }
};
```
::: 
**复杂度分析**
| 操作 | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度 |
|------|----------------|----------------|------------|
| 插入 | O(log n) | O(n) | O(n) |
| 删除 | O(log n) | O(n) | - |
| 查找 | O(log n) | O(n) | - |

---

### 字典树 (Trie)

**定义**
想象一下你在字典里查单词：
- 先找第一个字母，比如"apple"先找'a'
- 然后在'a'的部分找第二个字母'p'
- 接着在'ap'的部分找第三个字母'p'...

字典树就是这种思想的实现：  
1. **树结构**：每个节点代表一个字母
2. **路径即单词**：从根节点到某个节点的路径组成一个单词
3. **共享前缀**：多个单词共享相同前缀时，它们共享路径
4. **结束标记**：节点标记是否为单词结尾

简单例子：插入"cat", "car", "dog":
```text
    根(root)
    /    \
   c      d
  /        \
 a          o
/ \          \
t* r*         g*
```

**核心操作**
::: code-group
```cpp
#include <iostream>
#include <unordered_map>
#include <memory>
#include <string>
#include <vector>

using namespace std;

class TrieNode {
public:
    unordered_map<char, shared_ptr<TrieNode>> children;
    bool is_end;
    
    TrieNode() : is_end(false) {}
};

class Trie {
private:
    shared_ptr<TrieNode> root;
    
public:
    Trie() : root(make_shared<TrieNode>()) {}
    
    // 插入单词
    void insert(const string& word) {
        auto node = root;
        for (char ch : word) {
            if (node->children.find(ch) == node->children.end()) {
                node->children[ch] = make_shared<TrieNode>();
            }
            node = node->children[ch];
        }
        node->is_end = true;
    }
    
    // 搜索完整单词
    bool search(const string& word) {
        auto node = root;
        for (char ch : word) {
            if (node->children.find(ch) == node->children.end()) {
                return false;
            }
            node = node->children[ch];
        }
        return node->is_end;
    }
    
    // 检查前缀
    bool startsWith(const string& prefix) {
        auto node = root;
        for (char ch : prefix) {
            if (node->children.find(ch) == node->children.end()) {
                return false;
            }
            node = node->children[ch];
        }
        return true;
    }
    
    // 删除单词
    bool remove(const string& word) {
        vector<pair<shared_ptr<TrieNode>, char>> path;
        auto node = root;
        
        // 1. 找到单词节点
        for (char ch : word) {
            if (node->children.find(ch) == node->children.end()) {
                return false;
            }
            path.emplace_back(node, ch);
            node = node->children[ch];
        }
        
        if (!node->is_end) {
            return false;  // 单词不存在
        }
        
        // 2. 标记为非单词结尾
        node->is_end = false;
        
        // 3. 删除无用节点
        if (node->children.empty()) {
            for (auto it = path.rbegin(); it != path.rend(); ++it) {
                auto& [parent, ch] = *it;
                parent->children.erase(ch);
                if (!parent->children.empty() || parent->is_end) {
                    break;
                }
            }
        }
        
        return true;
    }
    
    // 打印所有单词（辅助函数）
    void printAllWords() {
        vector<string> words;
        collectWords(root, "", words);
        cout << "Trie中所有单词: ";
        for (const auto& word : words) {
            cout << word << " ";
        }
        cout << endl;
    }
    
private:
    void collectWords(shared_ptr<TrieNode> node, string prefix, vector<string>& result) {
        if (node->is_end) {
            result.push_back(prefix);
        }
        for (const auto& [ch, child] : node->children) {
            collectWords(child, prefix + ch, result);
        }
    }
};

// 使用示例
int main() {
    Trie trie;
    
    // 插入单词
    vector<string> words = {"apple", "app", "banana", "bat", "ball"};
    for (const auto& word : words) {
        trie.insert(word);
    }
    
    // 测试
    cout << boolalpha;  // 让bool输出为true/false
    cout << "搜索 'app': " << trie.search("app") << endl;      // true
    cout << "搜索 'ap': " << trie.search("ap") << endl;        // false
    
    cout << "前缀 'ap': " << trie.startsWith("ap") << endl;    // true
    cout << "前缀 'ba': " << trie.startsWith("ba") << endl;    // true
    cout << "前缀 'ca': " << trie.startsWith("ca") << endl;    // false
    
    // 删除测试
    trie.remove("app");
    cout << "删除后搜索 'app': " << trie.search("app") << endl;  // false
    cout << "搜索 'apple': " << trie.search("apple") << endl;    // true
    
    // 打印所有单词
    trie.printAllWords();
    
    return 0;
}
```
```python
# Python实现
class TrieNode:
    def __init__(self):
        self.children = {}  # 存储子节点：字符->节点
        self.is_end = False  # 标记是否为单词结尾

class Trie:
    def __init__(self):
        self.root = TrieNode()
    
    def insert(self, word: str) -> None:
        """插入单词"""
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end = True
    
    def search(self, word: str) -> bool:
        """搜索完整单词"""
        node = self.root
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
        return node.is_end
    
    def startsWith(self, prefix: str) -> bool:
        """检查是否有以prefix开头的单词"""
        node = self.root
        for char in prefix:
            if char not in node.children:
                return False
            node = node.children[char]
        return True
    
    def delete(self, word: str) -> bool:
        """删除单词（简化版）"""
        node = self.root
        path = []  # 记录路径
        
        # 1. 找到单词节点
        for char in word:
            if char not in node.children:
                return False
            path.append((node, char))
            node = node.children[char]
        
        if not node.is_end:
            return False  # 单词不存在
        
        # 2. 标记为非单词结尾
        node.is_end = False
        
        # 3. 删除无用节点（如果节点没有子节点且不是其他单词的结尾）
        if not node.children:
            for parent, char in reversed(path):
                del parent.children[char]
                if parent.children or parent.is_end:
                    break
        
        return True


# 使用示例
if __name__ == "__main__":
    trie = Trie()
    
    # 插入单词
    words = ["apple", "app", "banana", "bat", "ball"]
    for word in words:
        trie.insert(word)
    
    # 测试搜索
    print("搜索 'app':", trie.search("app"))      # True
    print("搜索 'ap':", trie.search("ap"))        # False
    
    # 测试前缀
    print("前缀 'ap':", trie.startsWith("ap"))    # True
    print("前缀 'ba':", trie.startsWith("ba"))    # True
    print("前缀 'ca':", trie.startsWith("ca"))    # False
    
    # 删除测试
    trie.delete("app")
    print("删除后搜索 'app':", trie.search("app"))  # False
    print("搜索 'apple':", trie.search("apple"))    # True（app还在）
```
::: 


**时间复杂度** ：插入/搜索/删除：O(L)，L是单词长度，与字典中单词数量无关！  
**空间复杂度** ：最坏情况：O(N×L)，N是单词数，L是平均长度，但共享前缀能节省空间。  

---


### 可持久化线段树

**定义**
可持久化线段树能够保存历史版本，支持对历史版本的查询，通过共享不变部分来节省空间。

**存储原理**
- **版本管理**：每个操作生成新版本，旧版本保留
- **节点共享**：未修改的节点在多个版本间共享
- **动态创建**：只创建被修改的节点及其路径上的节点

**核心操作**
::: code-group
```cpp
class PersistentSegmentTree {
private:
    struct Node {
        int value;
        Node *left, *right;
        Node(int v = 0, Node* l = nullptr, Node* r = nullptr)
            : value(v), left(l), right(r) {}
    };

    vector<Node*> versions;  // 存储各个版本的根节点
    int n;

    Node* build(int l, int r) {
        if (l == r) return new Node(0);
        int mid = (l + r) / 2;
        return new Node(0, build(l, mid), build(mid + 1, r));
    }

    Node* update(Node* node, int l, int r, int pos, int val) {
        if (!node) node = new Node();
        if (l == r) {
            return new Node(node->value + val);
        }

        int mid = (l + r) / 2;
        Node* newNode = new Node();

        if (pos <= mid) {
            newNode->left = update(node->left, l, mid, pos, val);
            newNode->right = node->right;
        } else {
            newNode->left = node->left;
            newNode->right = update(node->right, mid + 1, r, pos, val);
        }

        newNode->value = (newNode->left ? newNode->left->value : 0) +
                         (newNode->right ? newNode->right->value : 0);
        return newNode;
    }

    int query(Node* node, int l, int r, int ql, int qr) {
        if (!node || ql > r || qr < l) return 0;
        if (ql <= l && r <= qr) return node->value;

        int mid = (l + r) / 2;
        return query(node->left, l, mid, ql, qr) +
               query(node->right, mid + 1, r, ql, qr);
    }

public:
    PersistentSegmentTree(int n) : n(n) {
        versions.push_back(build(1, n));  // 初始版本
    }

    void update(int version, int pos, int val) {
        Node* newRoot = update(versions[version], 1, n, pos, val);
        versions.push_back(newRoot);
    }

    int query(int version, int l, int r) {
        return query(versions[version], 1, n, l, r);
    }

    int getVersionCount() {
        return versions.size() - 1;
    }
};
```
:::
**复杂度分析**
| 操作 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| 版本更新 | O(log n) | O(log n) |
| 历史查询 | O(log n) | - |
| 总空间消耗 | - | O(n + m log n) |

*注：m为操作次数*

**适用场景**
- 需要查询历史状态的场景
- 离线算法中的应用
- 函数式编程中的数据结构
- 区间第k小问题
