# æœç´¢ç®—æ³•æ¨¡å—

**å‰ç½®çŸ¥è¯†**ï¼šæ•°æ®ç»“æ„åŸºç¡€æ€»è§ˆã€åŸºç¡€æ•°æ®ç»“æ„ã€æ ˆä¸é˜Ÿåˆ—

**åç»­å…³è”æ¨¡å—**ï¼šåŠ¨æ€è§„åˆ’æ¨¡å—ã€å­—ç¬¦ä¸²ç®—æ³•æ¨¡å—

## ğŸ“Œ æ ¸å¿ƒå®šä¹‰

æœç´¢ï¼Œä¹Ÿå°±æ˜¯å¯¹çŠ¶æ€ç©ºé—´è¿›è¡Œæšä¸¾ï¼Œé€šè¿‡ç©·å°½æ‰€æœ‰çš„å¯èƒ½æ¥æ‰¾åˆ°æœ€ä¼˜è§£ï¼Œæˆ–è€…ç»Ÿè®¡åˆæ³•è§£çš„ä¸ªæ•°ã€‚åœ¨OIä¸­ï¼Œæœç´¢æ˜¯é«˜çº§ç®—æ³•çš„åŸºç¡€ï¼Œä½†çº¯æœç´¢é€šå¸¸åªèƒ½è·å¾—éƒ¨åˆ†åˆ†ï¼Œéœ€è¦é…åˆå„ç§ä¼˜åŒ–æŠ€å·§ã€‚

## ğŸŒ³ æ·±åº¦ä¼˜å…ˆæœç´¢ (DFS)

### ğŸ“Œ åŸºæœ¬æ€æƒ³

DFSé‡‡ç”¨æ·±åº¦ä¼˜å…ˆçš„ç­–ç•¥ï¼Œæ²¿ç€ä¸€æ¡è·¯å¾„å°½å¯èƒ½æ·±åœ°æœç´¢ï¼Œç›´åˆ°æ— æ³•ç»§ç»­å‰è¿›æ—¶æ‰å›æº¯ã€‚åœ¨ç®—æ³•ç«èµ›ä¸­ï¼ŒDFSé€šå¸¸æŒ‡åˆ©ç”¨é€’å½’å‡½æ•°å®ç°æš´åŠ›æšä¸¾çš„ç®—æ³•ã€‚

### ğŸ”§ æœç´¢æ¡†æ¶

#### ğŸ’» é€’å½’å®ç°æ¨¡æ¿

```cpp
// C++é€’å½’DFSæ¨¡æ¿
void dfs(int state) {
    if (isGoal(state)) {           // ç»ˆæ­¢æ¡ä»¶
        handleGoal();               // å¤„ç†ç›®æ ‡çŠ¶æ€
        return;
    }
    
    if (!isValid(state)) {         // å‰ªææ¡ä»¶
        return;
    }
    
    for (int i = 0; i < optionsCount; i++) {
        if (canChoose(state, i)) {
            makeChoice(state, i);   // åšå‡ºé€‰æ‹©
            dfs(newState);          // é€’å½’æœç´¢
            undoChoice(state, i);   // æ’¤é”€é€‰æ‹©ï¼ˆå›æº¯ï¼‰
        }
    }
}

# Pythoné€’å½’DFSæ¨¡æ¿
def dfs(state):
    if is_goal(state):              # ç»ˆæ­¢æ¡ä»¶
        handle_goal()               # å¤„ç†ç›®æ ‡çŠ¶æ€
        return
    
    if not is_valid(state):         # å‰ªææ¡ä»¶
        return
    
    for i in range(options_count):
        if can_choose(state, i):
            make_choice(state, i)   # åšå‡ºé€‰æ‹©
            dfs(new_state)          # é€’å½’æœç´¢
            undo_choice(state, i)   # æ’¤é”€é€‰æ‹©ï¼ˆå›æº¯ï¼‰
```

### ğŸ¯ å…¨æ’åˆ—é—®é¢˜ç¤ºä¾‹

#### ğŸ’» å®ç°ä»£ç 

```cpp
// Luogu P1706 å…¨æ’åˆ—é—®é¢˜
#include <iomanip>
#include <iostream>
using namespace std;

int n;
bool vis[50];           // è®¿é—®æ ‡è®°æ•°ç»„
int a[50];              // æ’åˆ—æ•°ç»„ï¼ŒæŒ‰é¡ºåºå‚¨å­˜å½“å‰æœç´¢ç»“æœ

void dfs(int step) {
    if (step == n + 1) {    // è¾¹ç•Œæ¡ä»¶ï¼šæ‰¾åˆ°ä¸€ä¸ªå®Œæ•´æ’åˆ—
        for (int i = 1; i <= n; i++) {
            cout << setw(5) << a[i];  // ä¿ç•™5ä¸ªåœºå®½
        }
        cout << endl;
        return;
    }
    
    for (int i = 1; i <= n; i++) {
        if (!vis[i]) {       // åˆ¤æ–­æ•°å­—iæ˜¯å¦åœ¨æ­£åœ¨è¿›è¡Œçš„å…¨æ’åˆ—ä¸­
            vis[i] = true;    // æ ‡è®°ä¸ºå·²è®¿é—®
            a[step] = i;      // å°†æ•°å­—iæ”¾å…¥å½“å‰ä½ç½®
            dfs(step + 1);    // é€’å½’å¤„ç†ä¸‹ä¸€ä¸ªä½ç½®
            vis[i] = false;   // æ’¤é”€æ ‡è®°ï¼ˆå›æº¯ï¼‰
        }
    }
}

int main() {
    cin >> n;
    dfs(1);                 // ä»ç¬¬ä¸€ä¸ªä½ç½®å¼€å§‹æœç´¢
    return 0;
}

# Pythonå®ç°
def dfs_permutation(step):
    if step == n + 1:       # è¾¹ç•Œæ¡ä»¶ï¼šæ‰¾åˆ°ä¸€ä¸ªå®Œæ•´æ’åˆ—
        for i in range(1, n + 1):
            print(f"{a[i]:5d}", end='')
        print()
        return
    
    for i in range(1, n + 1):
        if not vis[i]:      # åˆ¤æ–­æ•°å­—iæ˜¯å¦åœ¨æ­£åœ¨è¿›è¡Œçš„å…¨æ’åˆ—ä¸­
            vis[i] = True   # æ ‡è®°ä¸ºå·²è®¿é—®
            a[step] = i     # å°†æ•°å­—iæ”¾å…¥å½“å‰ä½ç½®
            dfs_permutation(step + 1)  # é€’å½’å¤„ç†ä¸‹ä¸€ä¸ªä½ç½®
            vis[i] = False  # æ’¤é”€æ ‡è®°ï¼ˆå›æº¯ï¼‰

n = int(input())
vis = [False] * 50
a = [0] * 50
dfs_permutation(1)
```

### ğŸ¯ æ•°çš„åˆ†è§£é—®é¢˜ç¤ºä¾‹

#### ğŸ’» å®ç°ä»£ç 

```cpp
// å°†æ­£æ•´æ•°nåˆ†è§£ä¸ºä¸è¶…è¿‡mä¸ªæ­£æ•´æ•°ä¹‹å’Œ
int m, arr[103];  // arr ç”¨äºè®°å½•æ–¹æ¡ˆ

void dfs(int n, int i, int a) {
    if (n == 0) {  // æ‰¾åˆ°ä¸€ä¸ªåˆ†è§£æ–¹æ¡ˆ
        for (int j = 1; j <= i - 1; ++j) 
            printf("%d ", arr[j]);
        printf("\n");
        return;
    }
    
    if (i <= m) {  // è¿˜å¯ä»¥ç»§ç»­åˆ†è§£
        for (int j = a; j <= n; ++j) {  // ç¡®ä¿éé€’å‡é¡ºåº
            arr[i] = j;
            dfs(n - j, i + 1, j);       // é€’å½’åˆ†è§£å‰©ä½™éƒ¨åˆ†
        }
    }
}

# Pythonå®ç°
def dfs_number_decomposition(n, i, a):
    if n == 0:  # æ‰¾åˆ°ä¸€ä¸ªåˆ†è§£æ–¹æ¡ˆ
        for j in range(1, i):
            print(arr[j], end=' ')
        print()
        return
    
    if i <= m:  # è¿˜å¯ä»¥ç»§ç»­åˆ†è§£
        for j in range(a, n + 1):  # ç¡®ä¿éé€’å‡é¡ºåº
            arr[i] = j
            dfs_number_decomposition(n - j, i + 1, j)

# ä½¿ç”¨ç¤ºä¾‹
m = 3
arr = [0] * 103
dfs_number_decomposition(5, 1, 1)  # å°†5åˆ†è§£ä¸ºæœ€å¤š3ä¸ªæ•°çš„å’Œ
```

---

## ğŸŒ å¹¿åº¦ä¼˜å…ˆæœç´¢ (BFS)

### ğŸ“Œ åŸºæœ¬æ€æƒ³

BFSé‡‡ç”¨å¹¿åº¦ä¼˜å…ˆçš„ç­–ç•¥ï¼ŒæŒ‰å±‚æ¬¡è¿›è¡Œæœç´¢ï¼Œé€å±‚æ‰©å±•èŠ‚ç‚¹ç›´åˆ°æ‰¾åˆ°ç›®æ ‡ã€‚BFSç‰¹åˆ«é€‚åˆæ±‚æœ€çŸ­è·¯å¾„é—®é¢˜ï¼Œå› ä¸ºå®ƒæ€»æ˜¯å…ˆæ‰¾åˆ°è·ç¦»èµ·ç‚¹æœ€è¿‘çš„è§£ã€‚

### ğŸ”§ æœç´¢æ¡†æ¶

#### ğŸ’» è¿­ä»£å®ç°æ¨¡æ¿

```cpp
// C++ BFSæ¨¡æ¿
struct State {
    int data[10];  // çŠ¶æ€æ•°æ®
    int step;      // æ­¥æ•°
};

void bfs(State start) {
    queue<State> q;
    unordered_map<string, bool> visited;  // è®°å½•å·²è®¿é—®çŠ¶æ€
    
    q.push(start);
    visited[encode(start)] = true;
    
    while (!q.empty()) {
        State current = q.front();
        q.pop();
        
        if (isGoal(current)) {
            handleGoal(current);
            return;
        }
        
        for (int i = 0; i < optionsCount; i++) {
            State next = getNextState(current, i);
            string key = encode(next);
            
            if (!visited[key]) {
                visited[key] = true;
                next.step = current.step + 1;
                q.push(next);
            }
        }
    }
}

# Python BFSæ¨¡æ¿
from collections import deque

def bfs(start):
    q = deque()
    visited = set()  # è®°å½•å·²è®¿é—®çŠ¶æ€
    
    q.append(start)
    visited.add(encode(start))
    
    while q:
        current = q.popleft()
        
        if is_goal(current):
            handle_goal(current)
            return
        
        for i in range(options_count):
            next_state = get_next_state(current, i)
            key = encode(next_state)
            
            if key not in visited:
                visited.add(key)
                next_state['step'] = current['step'] + 1
                q.append(next_state)
```

### ğŸ¯ è¿·å®«æœ€çŸ­è·¯å¾„é—®é¢˜

#### ğŸ’» å®ç°ä»£ç 

```cpp
// è¿·å®«æœ€çŸ­è·¯å¾„é—®é¢˜
struct Point {
    int x, y, step;
};

int dx[] = {-1, 1, 0, 0};  // å››ä¸ªæ–¹å‘
int dy[] = {0, 0, -1, 1};

int bfsMaze(vector<vector<char>>& maze, Point start, Point end) {
    int n = maze.size();
    int m = maze[0].size();
    vector<vector<bool>> visited(n, vector<bool>(m, false));
    
    queue<Point> q;
    q.push(start);
    visited[start.x][start.y] = true;
    
    while (!q.empty()) {
        Point current = q.front();
        q.pop();
        
        if (current.x == end.x && current.y == end.y) {
            return current.step;  // æ‰¾åˆ°ç»ˆç‚¹
        }
        
        for (int i = 0; i < 4; i++) {
            int nx = current.x + dx[i];
            int ny = current.y + dy[i];
            
            if (nx >= 0 && nx < n && ny >= 0 && ny < m && 
                !visited[nx][ny] && maze[nx][ny] != '#') {
                visited[nx][ny] = true;
                q.push({nx, ny, current.step + 1});
            }
        }
    }
    
    return -1;  // æ— æ³•åˆ°è¾¾
}

# Pythonå®ç°
from collections import deque

def bfs_maze(maze, start, end):
    n = len(maze)
    m = len(maze[0])
    visited = [[False] * m for _ in range(n)]
    dx = [-1, 1, 0, 0]  # å››ä¸ªæ–¹å‘
    dy = [0, 0, -1, 1]
    
    q = deque()
    q.append((start[0], start[1], 0))  # x, y, step
    visited[start[0]][start[1]] = True
    
    while q:
        x, y, step = q.popleft()
        
        if (x, y) == end:
            return step  # æ‰¾åˆ°ç»ˆç‚¹
        
        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]
            
            if (0 <= nx < n and 0 <= ny < m and 
                not visited[nx][ny] and maze[nx][ny] != '#'):
                visited[nx][ny] = True
                q.append((nx, ny, step + 1))
    
    return -1  # æ— æ³•åˆ°è¾¾
```

---

## ğŸ” é«˜çº§æœç´¢æŠ€æœ¯

### åŒå‘æœç´¢ (Bidirectional Search)

#### ğŸ“Œ åŸºæœ¬æ€æƒ³
ä»èµ·ç‚¹å’Œç»ˆç‚¹åŒæ—¶å¼€å§‹æœç´¢ï¼Œåœ¨ä¸­é—´ç›¸é‡ï¼Œæœ‰æ•ˆå‡å°‘æœç´¢ç©ºé—´ã€‚

#### ğŸ’» å®ç°ä»£ç 

```cpp
// åŒå‘BFSæ¨¡æ¿
int bidirectionalBFS(State start, State end) {
    unordered_set<string> forward, backward;
    queue<State> qForward, qBackward;
    
    forward.insert(encode(start));
    backward.insert(encode(end));
    
    qForward.push(start);
    qBackward.push(end);
    
    int step = 0;
    
    while (!qForward.empty() && !qBackward.empty()) {
        // é€‰æ‹©è¾ƒå°çš„é˜Ÿåˆ—æ‰©å±•
        if (qForward.size() > qBackward.size()) {
            swap(qForward, qBackward);
            swap(forward, backward);
        }
        
        int size = qForward.size();
        for (int i = 0; i < size; i++) {
            State current = qForward.front();
            qForward.pop();
            
            string key = encode(current);
            if (backward.count(key)) {  // ç›¸é‡
                return step;
            }
            
            for (int j = 0; j < optionsCount; j++) {
                State next = getNextState(current, j);
                string nextKey = encode(next);
                
                if (!forward.count(nextKey)) {
                    forward.insert(nextKey);
                    qForward.push(next);
                }
            }
        }
        step++;
    }
    
    return -1;  // æ— æ³•åˆ°è¾¾
}

# Pythonå®ç°
from collections import deque

def bidirectional_bfs(start, end):
    forward = set()
    backward = set()
    q_forward = deque()
    q_backward = deque()
    
    forward.add(encode(start))
    backward.add(end)
    
    q_forward.append(start)
    q_backward.append(end)
    
    step = 0
    
    while q_forward and q_backward:
        # é€‰æ‹©è¾ƒå°çš„é˜Ÿåˆ—æ‰©å±•
        if len(q_forward) > len(q_backward):
            q_forward, q_backward = q_backward, q_forward
            forward, backward = backward, forward
        
        for _ in range(len(q_forward)):
            current = q_forward.popleft()
            key = encode(current)
            
            if key in backward:  # ç›¸é‡
                return step
            
            for j in range(options_count):
                next_state = get_next_state(current, j)
                next_key = encode(next_state)
                
                if next_key not in forward:
                    forward.add(next_key)
                    q_forward.append(next_state)
        
        step += 1
    
    return -1  # æ— æ³•åˆ°è¾¾
```

### è¿­ä»£åŠ æ·±æœç´¢ (IDS)

#### ğŸ“Œ åŸºæœ¬æ€æƒ³
ç»“åˆDFSå’ŒBFSçš„ä¼˜ç‚¹ï¼Œé€æ¸å¢åŠ æœç´¢æ·±åº¦ï¼Œé¿å…æ·±åº¦è¿‡å¤§å¯¼è‡´çš„æ ˆæº¢å‡ºã€‚

#### ğŸ’» å®ç°ä»£ç 

```cpp
// è¿­ä»£åŠ æ·±æœç´¢æ¨¡æ¿
bool dfsLimited(State current, int depth, int limit) {
    if (depth > limit) return false;
    if (isGoal(current)) return true;
    
    for (int i = 0; i < optionsCount; i++) {
        if (canChoose(current, i)) {
            makeChoice(current, i);
            if (dfsLimited(current, depth + 1, limit)) {
                return true;
            }
            undoChoice(current, i);
        }
    }
    return false;
}

bool iterativeDeepeningSearch(State start) {
    for (int limit = 0; limit <= MAX_DEPTH; limit++) {
        if (dfsLimited(start, 0, limit)) {
            return true;
        }
    }
    return false;
}

# Pythonå®ç°
def dfs_limited(current, depth, limit):
    if depth > limit:
        return False
    if is_goal(current):
        return True
    
    for i in range(options_count):
        if can_choose(current, i):
            make_choice(current, i)
            if dfs_limited(current, depth + 1, limit):
                return True
            undo_choice(current, i)
    return False

def iterative_deepening_search(start):
    for limit in range(max_depth + 1):
        if dfs_limited(start, 0, limit):
            return True
    return False
```

### A* ç®—æ³•

#### ğŸ“Œ åŸºæœ¬æ€æƒ³
åœ¨BFSåŸºç¡€ä¸ŠåŠ å…¥å¯å‘å‡½æ•°ï¼Œä¼˜å…ˆæ¢ç´¢æ›´æœ‰å¯èƒ½é€šå‘ç›®æ ‡çš„çŠ¶æ€ã€‚

#### ğŸ’» å®ç°ä»£ç 

```cpp
struct AStarState {
    State data;
    int g;  // ä»èµ·ç‚¹åˆ°å½“å‰çŠ¶æ€çš„å®é™…ä»£ä»·
    int h;  // ä»å½“å‰çŠ¶æ€åˆ°ç»ˆç‚¹çš„ä¼°è®¡ä»£ä»·
    int f;  // f = g + h
    
    bool operator<(const AStarState& other) const {
        return f > other.f;  // ä¼˜å…ˆé˜Ÿåˆ—å–æœ€å°å€¼
    }
};

int aStarSearch(State start, State end) {
    priority_queue<AStarState> pq;
    unordered_map<string, int> best_g;
    
    AStarState startState = {start, 0, heuristic(start, end), 0};
    startState.f = startState.g + startState.h;
    
    pq.push(startState);
    best_g[encode(start)] = 0;
    
    while (!pq.empty()) {
        AStarState current = pq.top();
        pq.pop();
        
        if (isGoal(current.data)) {
            return current.g;
        }
        
        for (int i = 0; i < optionsCount; i++) {
            State next = getNextState(current.data, i);
            int new_g = current.g + cost(current.data, next);
            
            string key = encode(next);
            if (!best_g.count(key) || new_g < best_g[key]) {
                best_g[key] = new_g;
                AStarState next_state = {next, new_g, heuristic(next, end), 0};
                next_state.f = next_state.g + next_state.h;
                pq.push(next_state);
            }
        }
    }
    
    return -1;
}

# Pythonå®ç°
import heapq

def a_star_search(start, end):
    pq = []
    best_g = {}
    
    start_state = (0, heuristic(start, end), start)  # f, h, data
    heapq.heappush(pq, start_state)
    best_g[encode(start)] = 0
    
    while pq:
        f, h, current_data = heapq.heappop(pq)
        g = f - h
        
        if is_goal(current_data):
            return g
        
        for i in range(options_count):
            next_data = get_next_state(current_data, i)
            new_g = g + cost(current_data, next_data)
            
            key = encode(next_data)
            if key not in best_g or new_g < best_g[key]:
                best_g[key] = new_g
                next_h = heuristic(next_data, end)
                next_f = new_g + next_h
                heapq.heappush(pq, (next_f, next_h, next_data))
    
    return -1
```

---

## ğŸ’¡ æœç´¢ä¼˜åŒ–æŠ€å·§

### å‰ªæç­–ç•¥

#### ğŸ¯ å¯è¡Œæ€§å‰ªæ
```cpp
bool canReachGoal(State current, int stepsRemaining) {
    int minDistance = estimateMinDistance(current, goal);
    return minDistance <= stepsRemaining;
}
```

#### ğŸ¯ æœ€ä¼˜æ€§å‰ªæ
```cpp
if (currentCost + estimateMinDistance(current, goal) >= bestSolution) {
    return;  // å³ä½¿æ‰¾åˆ°æœ€ä¼˜è§£ä¹Ÿä¸ä¼šæ¯”å½“å‰æ›´å¥½
}
```

#### ğŸ¯ å¯¹ç§°å‰ªæ
```cpp
if (isSymmetrical(current, visited)) {
    return;  // é¿å…é‡å¤æœç´¢å¯¹ç§°çŠ¶æ€
}
```

### è®°å¿†åŒ–æœç´¢

#### ğŸ’» å®ç°ç¤ºä¾‹

```cpp
unordered_map<string, int> memo;

int memoizedSearch(State current) {
    string key = encode(current);
    if (memo.count(key)) {
        return memo[key];
    }
    
    if (isGoal(current)) {
        return memo[key] = 0;
    }
    
    int result = INF;
    for (int i = 0; i < optionsCount; i++) {
        if (canChoose(current, i)) {
            State next = getNextState(current, i);
            result = min(result, 1 + memoizedSearch(next));
        }
    }
    
    return memo[key] = result;
}

# Pythonå®ç°
memo = {}

def memoized_search(current):
    key = encode(current)
    if key in memo:
        return memo[key]
    
    if is_goal(current):
        memo[key] = 0
        return 0
    
    result = float('inf')
    for i in range(options_count):
        if can_choose(current, i):
            next_state = get_next_state(current, i)
            result = min(result, 1 + memoized_search(next_state))
    
    memo[key] = result
    return result
```

---

## ğŸ“Š æœç´¢ç®—æ³•å¯¹æ¯”

| ç®—æ³• | é€‚ç”¨åœºæ™¯ | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | æœ€ä¼˜æ€§ | å®ç°éš¾åº¦ |
|------|----------|------------|------------|--------|----------|
| **DFS** | éœ€è¦æ‰€æœ‰è§£æˆ–ç‰¹å®šæ·±åº¦è§£ | O(b^d) | O(d) | ä¸ä¿è¯ | ç®€å• |
| **BFS** | æœ€çŸ­è·¯å¾„é—®é¢˜ | O(b^d) | O(b^d) | ä¿è¯ | ç®€å• |
| **åŒå‘BFS** | å¯¹ç§°çš„æœ€çŸ­è·¯å¾„ | O(b^(d/2)) | O(b^(d/2)) | ä¿è¯ | ä¸­ç­‰ |
| **IDS** | æ·±åº¦é™åˆ¶æˆ–é¿å…æ ˆæº¢å‡º | O(b^d) | O(d) | ä¿è¯ | ä¸­ç­‰ |
| **A\*** | æœ‰å¯å‘å‡½æ•°çš„è·¯å¾„å¯»æ‰¾ | ä¾èµ–äºå¯å‘å‡½æ•° | ä¾èµ–äºå¯å‘å‡½æ•° | ä¿è¯ | å¤æ‚ |

*æ³¨ï¼šbä¸ºåˆ†æ”¯å› å­ï¼Œdä¸ºè§£çš„æ·±åº¦*

---

## ğŸ“ æ ¸å¿ƒè¦ç‚¹é€Ÿè®°

1. DFSé€‚åˆæ±‚æ‰€æœ‰è§£æˆ–ç‰¹å®šæ·±åº¦çš„è§£ï¼ŒBFSé€‚åˆæœ€çŸ­è·¯å¾„
2. æœç´¢çš„å…³é”®åœ¨äºçŠ¶æ€è¡¨ç¤ºå’Œè½¬ç§»çš„è®¾è®¡
3. å‰ªææ˜¯æœç´¢ä¼˜åŒ–çš„æ ¸å¿ƒï¼Œè¦è®¾è®¡æœ‰æ•ˆçš„å‰ªææ¡ä»¶
4. åŒå‘æœç´¢å¯ä»¥å°†æŒ‡æ•°çº§å¤æ‚åº¦é™ä½åˆ°åŠæŒ‡æ•°çº§
5. A*ç®—æ³•çš„æ•ˆæœä¸¥é‡ä¾èµ–äºå¯å‘å‡½æ•°çš„è´¨é‡
6. è®°å¿†åŒ–å¯ä»¥é¿å…é‡å¤è®¡ç®—ï¼Œå°†æŒ‡æ•°æ—¶é—´é™ä¸ºå¤šé¡¹å¼æ—¶é—´

## ğŸ“š æ¨¡å—å†…è‡ªæµ‹é¢˜

### é—®é¢˜1
ä»¥ä¸‹å“ªç§æƒ…å†µæœ€é€‚åˆä½¿ç”¨BFSè€Œä¸æ˜¯DFSï¼Ÿ
A. éœ€è¦æ‰¾åˆ°æ‰€æœ‰å¯èƒ½çš„è§£  
B. éœ€è¦æ‰¾åˆ°æœ€çŸ­è·¯å¾„  
C. éœ€è¦æ·±åº¦ä¼˜å…ˆéå†  
D. è§£çš„æ·±åº¦éå¸¸å¤§

**è§£æ**ï¼šB. BFSæŒ‰å±‚æ¬¡æœç´¢ï¼Œæ€»æ˜¯å…ˆæ‰¾åˆ°è·ç¦»èµ·ç‚¹æœ€è¿‘çš„è§£ï¼Œå› æ­¤æœ€é€‚åˆæ±‚è§£æœ€çŸ­è·¯å¾„é—®é¢˜ã€‚

### é—®é¢˜2
åœ¨æœç´¢ç®—æ³•ä¸­ï¼Œå‰ªæçš„ä¸»è¦ç›®çš„æ˜¯ï¼Ÿ
A. å¢åŠ è§£çš„å‡†ç¡®æ€§  
B. å‡å°‘æœç´¢ç©ºé—´ï¼Œæé«˜æ•ˆç‡  
C. æ”¹å˜æœç´¢çš„é¡ºåº  
D. ä¿è¯æ‰¾åˆ°æœ€ä¼˜è§£

**è§£æ**ï¼šB. å‰ªæçš„ä¸»è¦ç›®çš„æ˜¯é€šè¿‡æå‰æ’é™¤ä¸å¯èƒ½äº§ç”Ÿæœ€ä¼˜è§£çš„åˆ†æ”¯ï¼Œå‡å°‘æœç´¢ç©ºé—´ï¼Œæé«˜ç®—æ³•æ•ˆç‡ã€‚

### é—®é¢˜3
A*ç®—æ³•ç›¸æ¯”BFSçš„ä¸»è¦ä¼˜åŠ¿æ˜¯ï¼Ÿ
A. ä¿è¯æ‰¾åˆ°æœ€çŸ­è·¯å¾„  
B. ä½¿ç”¨å¯å‘å‡½æ•°æŒ‡å¯¼æœç´¢æ–¹å‘  
C. å®ç°æ›´ç®€å•  
D. å†…å­˜ä½¿ç”¨æ›´å°‘

**è§£æ**ï¼šB. A*ç®—æ³•çš„æ ¸å¿ƒä¼˜åŠ¿æ˜¯ä½¿ç”¨å¯å‘å‡½æ•°æŒ‡å¯¼æœç´¢æ–¹å‘ï¼Œä¼˜å…ˆæ¢ç´¢æ›´æœ‰å¯èƒ½é€šå‘ç›®æ ‡çš„è·¯å¾„ã€‚

### é—®é¢˜4
åŒå‘æœç´¢çš„ä¸»è¦ä¼˜åŒ–åŸç†æ˜¯ï¼Ÿ
A. åŒæ—¶ä»èµ·ç‚¹å’Œå¤šä¸ªæ–¹å‘æœç´¢  
B. ä»èµ·ç‚¹å’Œç»ˆç‚¹åŒæ—¶æœç´¢ï¼Œåœ¨ä¸­é—´ç›¸é‡  
C. ä½¿ç”¨å¤šä¸ªå¯å‘å‡½æ•°æŒ‡å¯¼æœç´¢  
D. éšæœºé€‰æ‹©æœç´¢æ–¹å‘

**è§£æ**ï¼šB. åŒå‘æœç´¢çš„æ ¸å¿ƒæ€æƒ³æ˜¯ä»èµ·ç‚¹å’Œç»ˆç‚¹åŒæ—¶å¼€å§‹æœç´¢ï¼Œåœ¨ä¸­é—´ç›¸é‡ï¼Œå°†æœç´¢æ·±åº¦ä»då‡åŠåˆ°d/2ã€‚

### é—®é¢˜5
åœ¨æ·±åº¦å¾ˆå¤§çš„æœç´¢é—®é¢˜ä¸­ï¼Œä¸ºäº†é¿å…æ ˆæº¢å‡ºï¼Œåº”è¯¥ä½¿ç”¨ï¼Ÿ
A. é€’å½’DFS  
B. è¿­ä»£åŠ æ·±æœç´¢  
C. çº¯é€’å½’å®ç°  
D. æ·±åº¦ä¼˜å…ˆåˆ°åº•

**è§£æ**ï¼šB. è¿­ä»£åŠ æ·±æœç´¢ç»“åˆäº†DFSå’ŒBFSçš„ä¼˜ç‚¹ï¼Œé€æ¸å¢åŠ æ·±åº¦é™åˆ¶ï¼Œå¯ä»¥æœ‰æ•ˆé¿å…é€’å½’æ·±åº¦è¿‡å¤§å¯¼è‡´çš„æ ˆæº¢å‡ºé—®é¢˜ã€‚

---

*æœ¬ç¬”è®°åŸºäºOI-Wikiæœç´¢ç®—æ³•å†…å®¹æ•´ç†ï¼Œé€‚ç”¨äºç®—æ³•ç«èµ›å­¦ä¹ ä¸å¤ä¹ ã€‚*